// Bun Snapshot v1, https://goo.gl/fbAQLP

exports[`Examples ConstantProductAMM Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 0 1 1000 4 10000000000 2 3
bytecblock 0x 0x61 0x62 0x67 0x70 0x72

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// examples/amm/amm.algo.ts:20
	// this.governor.value = this.txn.sender
	bytec 3 //  "g"
	txn Sender
	app_global_put
	retsub

// doCreatePoolToken(aAsset: AssetID, bAsset: AssetID): AssetID
doCreatePoolToken:
	proto 2 1

	// examples/amm/amm.algo.ts:26
	// return sendAssetCreation({
	//       configAssetName: 'DPT-' + aAsset.unitName + '-' + bAsset.unitName,
	//       configAssetUnitName: 'dpt',
	//       configAssetTotal: TOTAL_SUPPLY,
	//       configAssetDecimals: 3,
	//       configAssetManager: this.app.address,
	//       configAssetReserve: this.app.address,
	//     });
	itxn_begin
	intc 6 //  acfg
	itxn_field TypeEnum

	// examples/amm/amm.algo.ts:27
	// configAssetName: 'DPT-' + aAsset.unitName + '-' + bAsset.unitName
	pushbytes 0x4450542d // "DPT-"
	frame_dig -1 // aAsset: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	pushbytes 0x2d // "-"
	concat
	frame_dig -2 // bAsset: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	itxn_field ConfigAssetName

	// examples/amm/amm.algo.ts:28
	// configAssetUnitName: 'dpt'
	pushbytes 0x647074 // "dpt"
	itxn_field ConfigAssetUnitName

	// examples/amm/amm.algo.ts:29
	// configAssetTotal: TOTAL_SUPPLY
	intc 4 // 10000000000
	itxn_field ConfigAssetTotal

	// examples/amm/amm.algo.ts:30
	// configAssetDecimals: 3
	intc 6 // 3
	itxn_field ConfigAssetDecimals

	// examples/amm/amm.algo.ts:31
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// examples/amm/amm.algo.ts:32
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	retsub

// doAxfer(receiver: Address, asset: AssetID, amount: uint64): void
doAxfer:
	proto 3 0

	// examples/amm/amm.algo.ts:37
	// sendAssetTransfer({
	//       assetReceiver: receiver,
	//       xferAsset: asset,
	//       assetAmount: amount,
	//     })
	itxn_begin
	intc 3 //  axfer
	itxn_field TypeEnum

	// examples/amm/amm.algo.ts:38
	// assetReceiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field AssetReceiver

	// examples/amm/amm.algo.ts:39
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// examples/amm/amm.algo.ts:40
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// doOptIn(asset: AssetID): void
doOptIn:
	proto 1 0

	// examples/amm/amm.algo.ts:45
	// this.doAxfer(this.app.address, asset, 0)
	intc 0 // 0
	frame_dig -1 // asset: AssetID
	global CurrentApplicationAddress
	callsub doAxfer
	retsub

// tokensToMintIntial(aAmount: uint64, bAmount: uint64): uint64
tokensToMintIntial:
	proto 2 1

	// examples/amm/amm.algo.ts:49
	// return sqrt(aAmount * bAmount);
	frame_dig -1 // aAmount: uint64
	frame_dig -2 // bAmount: uint64
	*
	sqrt
	retsub

// tokensToMint(issued: uint64, aSupply: uint64, bSupply: uint64, aAmount: uint64, bAmount: uint64): uint64
tokensToMint:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// examples/amm/amm.algo.ts:53
	// aRatio = wideRatio([aAmount, SCALE], [aSupply])
	frame_dig -4 // aAmount: uint64
	intc 2 // 1000
	mulw
	intc 0 // 0
	frame_dig -2 // aSupply: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 0 // aRatio: uint64

	// examples/amm/amm.algo.ts:54
	// bRatio = wideRatio([bAmount, SCALE], [bSupply])
	frame_dig -5 // bAmount: uint64
	intc 2 // 1000
	mulw
	intc 0 // 0
	frame_dig -3 // bSupply: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 1 // bRatio: uint64

	// examples/amm/amm.algo.ts:56
	// ratio = aRatio < bRatio ? aRatio : bRatio
	frame_dig 0 // aRatio: uint64
	frame_dig 1 // bRatio: uint64
	<
	bz *ternary0_false
	frame_dig 0 // aRatio: uint64
	b *ternary0_end

*ternary0_false:
	frame_dig 1 // bRatio: uint64

*ternary0_end:
	frame_bury 2 // ratio: uint64

	// examples/amm/amm.algo.ts:58
	// return wideRatio([ratio, issued], [SCALE]);
	frame_dig 2 // ratio: uint64
	frame_dig -1 // issued: uint64
	mulw
	intc 0 // 0
	intc 2 // 1000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// computeRatio(): uint64
computeRatio:
	proto 0 1

	// examples/amm/amm.algo.ts:62
	// return wideRatio(
	//       [this.app.address.assetBalance(this.assetA.value), SCALE],
	//       [this.app.address.assetBalance(this.assetB.value)]
	//     );
	global CurrentApplicationAddress
	bytec 1 //  "a"
	app_global_get
	asset_holding_get AssetBalance
	pop
	intc 2 // 1000
	mulw
	intc 0 // 0
	global CurrentApplicationAddress
	bytec 2 //  "b"
	app_global_get
	asset_holding_get AssetBalance
	pop
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// tokensToBurn(issued: uint64, supply: uint64, amount: uint64): uint64
tokensToBurn:
	proto 3 1

	// examples/amm/amm.algo.ts:69
	// return wideRatio([supply, amount], [issued]);
	frame_dig -2 // supply: uint64
	frame_dig -3 // amount: uint64
	mulw
	intc 0 // 0
	frame_dig -1 // issued: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// tokensToSwap(inAmount: uint64, inSupply: uint64, outSupply: uint64): uint64
tokensToSwap:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/amm/amm.algo.ts:73
	// factor = SCALE - FEE
	pushint 995
	frame_bury 0 // factor: uint64

	// examples/amm/amm.algo.ts:74
	// return wideRatio([inAmount, factor, outSupply], [inSupply * SCALE + inAmount * factor]);
	frame_dig -1 // inAmount: uint64
	frame_dig 0 // factor: uint64
	mulw
	frame_dig -3 // outSupply: uint64
	uncover 2
	dig 1
	*
	cover 2
	mulw
	cover 2
	+
	swap
	intc 0 // 0
	frame_dig -2 // inSupply: uint64
	intc 2 // 1000
	*
	frame_dig -1 // inAmount: uint64
	frame_dig 0 // factor: uint64
	*
	+
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert

	// set the subroutine return value
	frame_bury 0
	retsub

// set_governor(address)void
*abi_route_set_governor:
	// governor: address
	txna ApplicationArgs 1
	dup
	len
	pushint 32
	==

	// argument 0 (governor) for set_governor must be a address
	assert

	// execute set_governor(address)void
	callsub set_governor
	intc 1 // 1
	return

// set_governor(governor: Address): void
set_governor:
	proto 1 0

	// examples/amm/amm.algo.ts:78
	// verifyAppCallTxn(this.txn, { sender: this.governor.value })
	// verify sender
	txn Sender
	bytec 3 //  "g"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.governor.value"}
	assert

	// examples/amm/amm.algo.ts:79
	// this.governor.value = governor
	bytec 3 //  "g"
	frame_dig -1 // governor: Address
	app_global_put
	retsub

// bootstrap(pay,uint64,uint64)uint64
*abi_route_bootstrap:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// bAsset: uint64
	txna ApplicationArgs 2
	btoi

	// aAsset: uint64
	txna ApplicationArgs 1
	btoi

	// seed: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 2 (seed) for bootstrap must be a pay transaction
	assert

	// execute bootstrap(pay,uint64,uint64)uint64
	callsub bootstrap
	itob
	concat
	log
	intc 1 // 1
	return

// bootstrap(seed: PayTxn, aAsset: AssetID, bAsset: AssetID): AssetID
bootstrap:
	proto 3 1

	// examples/amm/amm.algo.ts:83
	// verifyAppCallTxn(this.txn, { sender: this.governor.value })
	// verify sender
	txn Sender
	bytec 3 //  "g"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.governor.value"}
	assert

	// examples/amm/amm.algo.ts:85
	// assert(globals.groupSize === 2)
	global GroupSize
	intc 5 // 2
	==
	assert

	// examples/amm/amm.algo.ts:87
	// verifyPayTxn(seed, { receiver: this.app.address, amount: { greaterThanEqualTo: 300_000 } })
	// verify receiver
	frame_dig -1 // seed: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"seed","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // seed: PayTxn
	gtxns Amount
	pushint 300_000
	>=

	// transaction verification failed: {"txn":"seed","field":"amount","condition":"greaterThanEqualTo","expected":">=300_000"}
	assert

	// examples/amm/amm.algo.ts:88
	// assert(aAsset < bAsset)
	frame_dig -2 // aAsset: AssetID
	frame_dig -3 // bAsset: AssetID
	<
	assert

	// examples/amm/amm.algo.ts:90
	// this.assetA.value = aAsset
	bytec 1 //  "a"
	frame_dig -2 // aAsset: AssetID
	app_global_put

	// examples/amm/amm.algo.ts:91
	// this.assetB.value = bAsset
	bytec 2 //  "b"
	frame_dig -3 // bAsset: AssetID
	app_global_put

	// examples/amm/amm.algo.ts:92
	// this.poolToken.value = this.doCreatePoolToken(aAsset, bAsset)
	bytec 4 //  "p"
	frame_dig -3 // bAsset: AssetID
	frame_dig -2 // aAsset: AssetID
	callsub doCreatePoolToken
	app_global_put

	// examples/amm/amm.algo.ts:94
	// this.doOptIn(aAsset)
	frame_dig -2 // aAsset: AssetID
	callsub doOptIn

	// examples/amm/amm.algo.ts:95
	// this.doOptIn(bAsset)
	frame_dig -3 // bAsset: AssetID
	callsub doOptIn

	// examples/amm/amm.algo.ts:97
	// return this.poolToken.value;
	bytec 4 //  "p"
	app_global_get
	retsub

// mint(axfer,axfer,uint64,uint64,uint64)void
*abi_route_mint:
	// bAsset: uint64
	txna ApplicationArgs 3
	btoi

	// aAsset: uint64
	txna ApplicationArgs 2
	btoi

	// poolAsset: uint64
	txna ApplicationArgs 1
	btoi

	// bXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 3 (bXfer) for mint must be a axfer transaction
	assert

	// aXfer: axfer
	txn GroupIndex
	intc 5 // 2
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 4 (aXfer) for mint must be a axfer transaction
	assert

	// execute mint(axfer,axfer,uint64,uint64,uint64)void
	callsub mint
	intc 1 // 1
	return

// mint(aXfer: AssetTransferTxn, bXfer: AssetTransferTxn, poolAsset: AssetID, aAsset: AssetID, bAsset: AssetID): void
mint:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// well formed mint
	// examples/amm/amm.algo.ts:102
	// assert(aAsset === this.assetA.value)
	frame_dig -4 // aAsset: AssetID
	bytec 1 //  "a"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:103
	// assert(bAsset === this.assetB.value)
	frame_dig -5 // bAsset: AssetID
	bytec 2 //  "b"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:104
	// assert(poolAsset === this.poolToken.value)
	frame_dig -3 // poolAsset: AssetID
	bytec 4 //  "p"
	app_global_get
	==
	assert

	// valid asset A axfer
	// examples/amm/amm.algo.ts:107
	// verifyAssetTransferTxn(aXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: aAsset,
	//     })
	// verify sender
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"aXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"aXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"aXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -4 // aAsset: AssetID
	==

	// transaction verification failed: {"txn":"aXfer","field":"xferAsset","expected":"aAsset"}
	assert

	// valid asset B axfer
	// examples/amm/amm.algo.ts:115
	// verifyAssetTransferTxn(bXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: bAsset,
	//     })
	// verify sender
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"bXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetAmount
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"bXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"bXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -5 // bAsset: AssetID
	==

	// transaction verification failed: {"txn":"bXfer","field":"xferAsset","expected":"bAsset"}
	assert

	// *if0_condition
	// examples/amm/amm.algo.ts:123
	// this.app.address.assetBalance(aAsset) === aXfer.assetAmount &&
	//       this.app.address.assetBalance(bAsset) === bXfer.assetAmount
	global CurrentApplicationAddress
	frame_dig -4 // aAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	==
	dup
	bz *skip_and0
	global CurrentApplicationAddress
	frame_dig -5 // bAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	==
	&&

*skip_and0:
	bz *if0_else

	// *if0_consequent
	// examples/amm/amm.algo.ts:126
	// this.tokensToMintIntial(aXfer.assetAmount, bXfer.assetAmount)
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	callsub tokensToMintIntial
	b *if0_end

*if0_else:
	// examples/amm/amm.algo.ts:128
	// toMint = this.tokensToMint(
	//         TOTAL_SUPPLY - this.app.address.assetBalance(poolAsset),
	//         this.app.address.assetBalance(aAsset) - aXfer.assetAmount,
	//         this.app.address.assetBalance(bAsset) - bXfer.assetAmount,
	//         aXfer.assetAmount,
	//         bXfer.assetAmount
	//       )
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -5 // bAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	global CurrentApplicationAddress
	frame_dig -4 // aAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	intc 4 // 10000000000
	global CurrentApplicationAddress
	frame_dig -3 // poolAsset: AssetID
	asset_holding_get AssetBalance
	pop
	-
	callsub tokensToMint
	frame_bury 0 // toMint: uint64

	// examples/amm/amm.algo.ts:136
	// assert(toMint > 0)
	frame_dig 0 // toMint: uint64
	intc 0 // 0
	>
	assert

	// examples/amm/amm.algo.ts:138
	// this.doAxfer(this.txn.sender, poolAsset, toMint)
	frame_dig 0 // toMint: uint64
	frame_dig -3 // poolAsset: AssetID
	txn Sender
	callsub doAxfer

*if0_end:
	retsub

// burn(axfer,uint64,uint64,uint64)void
*abi_route_burn:
	// bAsset: uint64
	txna ApplicationArgs 3
	btoi

	// aAsset: uint64
	txna ApplicationArgs 2
	btoi

	// poolAsset: uint64
	txna ApplicationArgs 1
	btoi

	// poolXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 3 (poolXfer) for burn must be a axfer transaction
	assert

	// execute burn(axfer,uint64,uint64,uint64)void
	callsub burn
	intc 1 // 1
	return

// burn(poolXfer: AssetTransferTxn, poolAsset: AssetID, aAsset: AssetID, bAsset: AssetID): void
burn:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// well formed burn
	// examples/amm/amm.algo.ts:144
	// assert(poolAsset === this.poolToken.value)
	frame_dig -2 // poolAsset: AssetID
	bytec 4 //  "p"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:145
	// assert(aAsset === this.assetA.value)
	frame_dig -3 // aAsset: AssetID
	bytec 1 //  "a"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:146
	// assert(bAsset === this.assetB.value)
	frame_dig -4 // bAsset: AssetID
	bytec 2 //  "b"
	app_global_get
	==
	assert

	// valid pool axfer
	// examples/amm/amm.algo.ts:149
	// verifyAssetTransferTxn(poolXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: poolAsset,
	//     })
	// verify sender
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"poolXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetAmount
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"poolXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"poolXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // poolAsset: AssetID
	==

	// transaction verification failed: {"txn":"poolXfer","field":"xferAsset","expected":"poolAsset"}
	assert

	// examples/amm/amm.algo.ts:156
	// issued = TOTAL_SUPPLY - (this.app.address.assetBalance(poolAsset) - poolXfer.assetAmount)
	intc 4 // 10000000000
	global CurrentApplicationAddress
	frame_dig -2 // poolAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	-
	frame_bury 0 // issued: uint64

	// examples/amm/amm.algo.ts:158
	// aAmt = this.tokensToBurn(issued, this.app.address.assetBalance(aAsset), poolXfer.assetAmount)
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -3 // aAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig 0 // issued: uint64
	callsub tokensToBurn
	frame_bury 1 // aAmt: uint64

	// examples/amm/amm.algo.ts:160
	// bAmt = this.tokensToBurn(issued, this.app.address.assetBalance(bAsset), poolXfer.assetAmount)
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -4 // bAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig 0 // issued: uint64
	callsub tokensToBurn
	frame_bury 2 // bAmt: uint64

	// examples/amm/amm.algo.ts:162
	// this.doAxfer(this.txn.sender, aAsset, aAmt)
	frame_dig 1 // aAmt: uint64
	frame_dig -3 // aAsset: AssetID
	txn Sender
	callsub doAxfer

	// examples/amm/amm.algo.ts:163
	// this.doAxfer(this.txn.sender, bAsset, bAmt)
	frame_dig 2 // bAmt: uint64
	frame_dig -4 // bAsset: AssetID
	txn Sender
	callsub doAxfer

	// examples/amm/amm.algo.ts:165
	// this.ratio.value = this.computeRatio()
	bytec 5 //  "r"
	callsub computeRatio
	app_global_put
	retsub

// swap(axfer,uint64,uint64)void
*abi_route_swap:
	// bAsset: uint64
	txna ApplicationArgs 2
	btoi

	// aAsset: uint64
	txna ApplicationArgs 1
	btoi

	// swapXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 3 //  axfer
	==

	// argument 2 (swapXfer) for swap must be a axfer transaction
	assert

	// execute swap(axfer,uint64,uint64)void
	callsub swap
	intc 1 // 1
	return

// swap(swapXfer: AssetTransferTxn, aAsset: AssetID, bAsset: AssetID): void
swap:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// well formed swap
	// examples/amm/amm.algo.ts:170
	// assert(aAsset === this.assetA.value)
	frame_dig -2 // aAsset: AssetID
	bytec 1 //  "a"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:171
	// assert(bAsset === this.assetB.value)
	frame_dig -3 // bAsset: AssetID
	bytec 2 //  "b"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:173
	// verifyAssetTransferTxn(swapXfer, {
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       sender: this.txn.sender,
	//       xferAsset: { includedIn: [aAsset, bAsset] },
	//     })
	// verify assetAmount
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	intc 0 // 0
	>

	// transaction verification failed: {"txn":"swapXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"swapXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"swapXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify xferAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // aAsset: AssetID
	==
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // bAsset: AssetID
	==
	||

	// transaction verification failed: {"txn":{"txnText":"swapXfer"},"field":"xferAsset","condition":"includedIn","expected":"[aAsset, bAsset]"}
	assert

	// examples/amm/amm.algo.ts:180
	// outId = swapXfer.xferAsset === aAsset ? aAsset : bAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // aAsset: AssetID
	==
	bz *ternary1_false
	frame_dig -2 // aAsset: AssetID
	b *ternary1_end

*ternary1_false:
	frame_dig -3 // bAsset: AssetID

*ternary1_end:
	frame_bury 0 // outId: uint64

	// examples/amm/amm.algo.ts:182
	// inId = swapXfer.xferAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_bury 1 // inId: uint64

	// examples/amm/amm.algo.ts:184
	// toSwap = this.tokensToSwap(
	//       swapXfer.assetAmount,
	//       this.app.address.assetBalance(inId) - swapXfer.assetAmount,
	//       this.app.address.assetBalance(outId)
	//     )
	global CurrentApplicationAddress
	frame_dig 0 // outId: uint64
	asset_holding_get AssetBalance
	pop
	global CurrentApplicationAddress
	frame_dig 1 // inId: uint64
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	callsub tokensToSwap
	frame_bury 2 // toSwap: uint64

	// examples/amm/amm.algo.ts:190
	// assert(toSwap > 0)
	frame_dig 2 // toSwap: uint64
	intc 0 // 0
	>
	assert

	// examples/amm/amm.algo.ts:192
	// this.doAxfer(this.txn.sender, outId, toSwap)
	frame_dig 2 // toSwap: uint64
	frame_dig 0 // outId: uint64
	txn Sender
	callsub doAxfer

	// examples/amm/amm.algo.ts:194
	// this.ratio.value = this.computeRatio()
	bytec 5 //  "r"
	callsub computeRatio
	app_global_put
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xddc4cb4a // method "set_governor(address)void"
	pushbytes 0x25e6c376 // method "bootstrap(pay,uint64,uint64)uint64"
	pushbytes 0x10045c79 // method "mint(axfer,axfer,uint64,uint64,uint64)void"
	pushbytes 0x028e37c1 // method "burn(axfer,uint64,uint64,uint64)void"
	pushbytes 0x632aaed8 // method "swap(axfer,uint64,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_set_governor *abi_route_bootstrap *abi_route_mint *abi_route_burn *abi_route_swap

	// this contract does not implement the given ABI method for call NoOp
	err"
`;

exports[`Examples ConstantProductAMM Artifacts Maintains program size 1`] = `1086`;

exports[`Examples ConstantProductAMM Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "governor",
          "type": "address",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "set_governor",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "seed",
          "type": "pay",
        },
        {
          "desc": undefined,
          "name": "aAsset",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "bAsset",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "bootstrap",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "uint64",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "aXfer",
          "type": "axfer",
        },
        {
          "desc": undefined,
          "name": "bXfer",
          "type": "axfer",
        },
        {
          "desc": undefined,
          "name": "poolAsset",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "aAsset",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "bAsset",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "mint",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "poolXfer",
          "type": "axfer",
        },
        {
          "desc": undefined,
          "name": "poolAsset",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "aAsset",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "bAsset",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "burn",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "swapXfer",
          "type": "axfer",
        },
        {
          "desc": undefined,
          "name": "aAsset",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "bAsset",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "swap",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "ConstantProductAMM",
}
`;

exports[`Examples ConstantProductAMM Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "governor",
            "type": "address",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "set_governor",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "seed",
            "type": "pay",
          },
          {
            "desc": undefined,
            "name": "aAsset",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "bAsset",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "bootstrap",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "uint64",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "aXfer",
            "type": "axfer",
          },
          {
            "desc": undefined,
            "name": "bXfer",
            "type": "axfer",
          },
          {
            "desc": undefined,
            "name": "poolAsset",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "aAsset",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "bAsset",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "mint",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "poolXfer",
            "type": "axfer",
          },
          {
            "desc": undefined,
            "name": "poolAsset",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "aAsset",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "bAsset",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "burn",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "swapXfer",
            "type": "axfer",
          },
          {
            "desc": undefined,
            "name": "aAsset",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "bAsset",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "swap",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "ConstantProductAMM",
  },
  "hints": {
    "bootstrap(pay,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "burn(axfer,uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "mint(axfer,axfer,uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "set_governor(address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "swap(axfer,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {
        "assetA": {
          "key": "a",
          "type": "uint64",
        },
        "assetB": {
          "key": "b",
          "type": "uint64",
        },
        "governor": {
          "key": "g",
          "type": "bytes",
        },
        "poolToken": {
          "key": "p",
          "type": "uint64",
        },
        "ratio": {
          "key": "r",
          "type": "uint64",
        },
      },
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAwIDEgMTAwMCA0IDEwMDAwMDAwMDAwIDIgMwpieXRlY2Jsb2NrIDB4IDB4NjEgMHg2MiAweDY3IDB4NzAgMHg3MgoKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCnB1c2hpbnQgNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggKmNhbGxfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKmNyZWF0ZV9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRAoKKk5PVF9JTVBMRU1FTlRFRDoKCS8vIFRoZSByZXF1ZXN0ZWQgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIGNvbnRyYWN0LiBBcmUgeW91IHVzaW5nIHRoZSBjb3JyZWN0IE9uQ29tcGxldGU/IERpZCB5b3Ugc2V0IHlvdXIgYXBwIElEPwoJZXJyCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uOgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoJY2FsbHN1YiBjcmVhdGVBcHBsaWNhdGlvbgoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gY3JlYXRlQXBwbGljYXRpb24oKTogdm9pZApjcmVhdGVBcHBsaWNhdGlvbjoKCXByb3RvIDAgMAoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czoyMAoJLy8gdGhpcy5nb3Zlcm5vci52YWx1ZSA9IHRoaXMudHhuLnNlbmRlcgoJYnl0ZWMgMyAvLyAgImciCgl0eG4gU2VuZGVyCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBkb0NyZWF0ZVBvb2xUb2tlbihhQXNzZXQ6IEFzc2V0SUQsIGJBc3NldDogQXNzZXRJRCk6IEFzc2V0SUQKZG9DcmVhdGVQb29sVG9rZW46Cglwcm90byAyIDEKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MjYKCS8vIHJldHVybiBzZW5kQXNzZXRDcmVhdGlvbih7CgkvLyAgICAgICBjb25maWdBc3NldE5hbWU6ICdEUFQtJyArIGFBc3NldC51bml0TmFtZSArICctJyArIGJBc3NldC51bml0TmFtZSwKCS8vICAgICAgIGNvbmZpZ0Fzc2V0VW5pdE5hbWU6ICdkcHQnLAoJLy8gICAgICAgY29uZmlnQXNzZXRUb3RhbDogVE9UQUxfU1VQUExZLAoJLy8gICAgICAgY29uZmlnQXNzZXREZWNpbWFsczogMywKCS8vICAgICAgIGNvbmZpZ0Fzc2V0TWFuYWdlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIGNvbmZpZ0Fzc2V0UmVzZXJ2ZTogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICB9KTsKCWl0eG5fYmVnaW4KCWludGMgNiAvLyAgYWNmZwoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czoyNwoJLy8gY29uZmlnQXNzZXROYW1lOiAnRFBULScgKyBhQXNzZXQudW5pdE5hbWUgKyAnLScgKyBiQXNzZXQudW5pdE5hbWUKCXB1c2hieXRlcyAweDQ0NTA1NDJkIC8vICJEUFQtIgoJZnJhbWVfZGlnIC0xIC8vIGFBc3NldDogQXNzZXRJRAoJYXNzZXRfcGFyYW1zX2dldCBBc3NldFVuaXROYW1lCglwb3AKCWNvbmNhdAoJcHVzaGJ5dGVzIDB4MmQgLy8gIi0iCgljb25jYXQKCWZyYW1lX2RpZyAtMiAvLyBiQXNzZXQ6IEFzc2V0SUQKCWFzc2V0X3BhcmFtc19nZXQgQXNzZXRVbml0TmFtZQoJcG9wCgljb25jYXQKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXROYW1lCgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjI4CgkvLyBjb25maWdBc3NldFVuaXROYW1lOiAnZHB0JwoJcHVzaGJ5dGVzIDB4NjQ3MDc0IC8vICJkcHQiCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MjkKCS8vIGNvbmZpZ0Fzc2V0VG90YWw6IFRPVEFMX1NVUFBMWQoJaW50YyA0IC8vIDEwMDAwMDAwMDAwCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VG90YWwKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MzAKCS8vIGNvbmZpZ0Fzc2V0RGVjaW1hbHM6IDMKCWludGMgNiAvLyAzCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVjaW1hbHMKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MzEKCS8vIGNvbmZpZ0Fzc2V0TWFuYWdlcjogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRNYW5hZ2VyCgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjMyCgkvLyBjb25maWdBc3NldFJlc2VydmU6IHRoaXMuYXBwLmFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0UmVzZXJ2ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gQ3JlYXRlZEFzc2V0SUQKCXJldHN1YgoKLy8gZG9BeGZlcihyZWNlaXZlcjogQWRkcmVzcywgYXNzZXQ6IEFzc2V0SUQsIGFtb3VudDogdWludDY0KTogdm9pZApkb0F4ZmVyOgoJcHJvdG8gMyAwCgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjM3CgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiByZWNlaXZlciwKCS8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCgkvLyAgICAgICBhc3NldEFtb3VudDogYW1vdW50LAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDMgLy8gIGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjM4CgkvLyBhc3NldFJlY2VpdmVyOiByZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIHJlY2VpdmVyOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MzkKCS8vIHhmZXJBc3NldDogYXNzZXQKCWZyYW1lX2RpZyAtMiAvLyBhc3NldDogQXNzZXRJRAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6NDAKCS8vIGFzc2V0QW1vdW50OiBhbW91bnQKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKLy8gZG9PcHRJbihhc3NldDogQXNzZXRJRCk6IHZvaWQKZG9PcHRJbjoKCXByb3RvIDEgMAoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czo0NQoJLy8gdGhpcy5kb0F4ZmVyKHRoaXMuYXBwLmFkZHJlc3MsIGFzc2V0LCAwKQoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAtMSAvLyBhc3NldDogQXNzZXRJRAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWNhbGxzdWIgZG9BeGZlcgoJcmV0c3ViCgovLyB0b2tlbnNUb01pbnRJbnRpYWwoYUFtb3VudDogdWludDY0LCBiQW1vdW50OiB1aW50NjQpOiB1aW50NjQKdG9rZW5zVG9NaW50SW50aWFsOgoJcHJvdG8gMiAxCgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjQ5CgkvLyByZXR1cm4gc3FydChhQW1vdW50ICogYkFtb3VudCk7CglmcmFtZV9kaWcgLTEgLy8gYUFtb3VudDogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gYkFtb3VudDogdWludDY0CgkqCglzcXJ0CglyZXRzdWIKCi8vIHRva2Vuc1RvTWludChpc3N1ZWQ6IHVpbnQ2NCwgYVN1cHBseTogdWludDY0LCBiU3VwcGx5OiB1aW50NjQsIGFBbW91bnQ6IHVpbnQ2NCwgYkFtb3VudDogdWludDY0KTogdWludDY0CnRva2Vuc1RvTWludDoKCXByb3RvIDUgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXBuIDIKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6NTMKCS8vIGFSYXRpbyA9IHdpZGVSYXRpbyhbYUFtb3VudCwgU0NBTEVdLCBbYVN1cHBseV0pCglmcmFtZV9kaWcgLTQgLy8gYUFtb3VudDogdWludDY0CglpbnRjIDIgLy8gMTAwMAoJbXVsdwoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAtMiAvLyBhU3VwcGx5OiB1aW50NjQKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CglmcmFtZV9idXJ5IDAgLy8gYVJhdGlvOiB1aW50NjQKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6NTQKCS8vIGJSYXRpbyA9IHdpZGVSYXRpbyhbYkFtb3VudCwgU0NBTEVdLCBbYlN1cHBseV0pCglmcmFtZV9kaWcgLTUgLy8gYkFtb3VudDogdWludDY0CglpbnRjIDIgLy8gMTAwMAoJbXVsdwoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAtMyAvLyBiU3VwcGx5OiB1aW50NjQKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CglmcmFtZV9idXJ5IDEgLy8gYlJhdGlvOiB1aW50NjQKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6NTYKCS8vIHJhdGlvID0gYVJhdGlvIDwgYlJhdGlvID8gYVJhdGlvIDogYlJhdGlvCglmcmFtZV9kaWcgMCAvLyBhUmF0aW86IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gYlJhdGlvOiB1aW50NjQKCTwKCWJ6ICp0ZXJuYXJ5MF9mYWxzZQoJZnJhbWVfZGlnIDAgLy8gYVJhdGlvOiB1aW50NjQKCWIgKnRlcm5hcnkwX2VuZAoKKnRlcm5hcnkwX2ZhbHNlOgoJZnJhbWVfZGlnIDEgLy8gYlJhdGlvOiB1aW50NjQKCip0ZXJuYXJ5MF9lbmQ6CglmcmFtZV9idXJ5IDIgLy8gcmF0aW86IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czo1OAoJLy8gcmV0dXJuIHdpZGVSYXRpbyhbcmF0aW8sIGlzc3VlZF0sIFtTQ0FMRV0pOwoJZnJhbWVfZGlnIDIgLy8gcmF0aW86IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIGlzc3VlZDogdWludDY0CgltdWx3CglpbnRjIDAgLy8gMAoJaW50YyAyIC8vIDEwMDAKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMgoJcmV0c3ViCgovLyBjb21wdXRlUmF0aW8oKTogdWludDY0CmNvbXB1dGVSYXRpbzoKCXByb3RvIDAgMQoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czo2MgoJLy8gcmV0dXJuIHdpZGVSYXRpbygKCS8vICAgICAgIFt0aGlzLmFwcC5hZGRyZXNzLmFzc2V0QmFsYW5jZSh0aGlzLmFzc2V0QS52YWx1ZSksIFNDQUxFXSwKCS8vICAgICAgIFt0aGlzLmFwcC5hZGRyZXNzLmFzc2V0QmFsYW5jZSh0aGlzLmFzc2V0Qi52YWx1ZSldCgkvLyAgICAgKTsKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglieXRlYyAxIC8vICAiYSIKCWFwcF9nbG9iYWxfZ2V0Cglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJaW50YyAyIC8vIDEwMDAKCW11bHcKCWludGMgMCAvLyAwCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYnl0ZWMgMiAvLyAgImIiCglhcHBfZ2xvYmFsX2dldAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglwb3AKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CglyZXRzdWIKCi8vIHRva2Vuc1RvQnVybihpc3N1ZWQ6IHVpbnQ2NCwgc3VwcGx5OiB1aW50NjQsIGFtb3VudDogdWludDY0KTogdWludDY0CnRva2Vuc1RvQnVybjoKCXByb3RvIDMgMQoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czo2OQoJLy8gcmV0dXJuIHdpZGVSYXRpbyhbc3VwcGx5LCBhbW91bnRdLCBbaXNzdWVkXSk7CglmcmFtZV9kaWcgLTIgLy8gc3VwcGx5OiB1aW50NjQKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnQ6IHVpbnQ2NAoJbXVsdwoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAtMSAvLyBpc3N1ZWQ6IHVpbnQ2NAoJZGl2bW9kdwoJcG9wCglwb3AKCXN3YXAKCSEKCgkvLyB3aWRlUmF0aW8gZmFpbGVkCglhc3NlcnQKCXJldHN1YgoKLy8gdG9rZW5zVG9Td2FwKGluQW1vdW50OiB1aW50NjQsIGluU3VwcGx5OiB1aW50NjQsIG91dFN1cHBseTogdWludDY0KTogdWludDY0CnRva2Vuc1RvU3dhcDoKCXByb3RvIDMgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjczCgkvLyBmYWN0b3IgPSBTQ0FMRSAtIEZFRQoJcHVzaGludCA5OTUKCWZyYW1lX2J1cnkgMCAvLyBmYWN0b3I6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czo3NAoJLy8gcmV0dXJuIHdpZGVSYXRpbyhbaW5BbW91bnQsIGZhY3Rvciwgb3V0U3VwcGx5XSwgW2luU3VwcGx5ICogU0NBTEUgKyBpbkFtb3VudCAqIGZhY3Rvcl0pOwoJZnJhbWVfZGlnIC0xIC8vIGluQW1vdW50OiB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIGZhY3RvcjogdWludDY0CgltdWx3CglmcmFtZV9kaWcgLTMgLy8gb3V0U3VwcGx5OiB1aW50NjQKCXVuY292ZXIgMgoJZGlnIDEKCSoKCWNvdmVyIDIKCW11bHcKCWNvdmVyIDIKCSsKCXN3YXAKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgLTIgLy8gaW5TdXBwbHk6IHVpbnQ2NAoJaW50YyAyIC8vIDEwMDAKCSoKCWZyYW1lX2RpZyAtMSAvLyBpbkFtb3VudDogdWludDY0CglmcmFtZV9kaWcgMCAvLyBmYWN0b3I6IHVpbnQ2NAoJKgoJKwoJZGl2bW9kdwoJcG9wCglwb3AKCXN3YXAKCSEKCgkvLyB3aWRlUmF0aW8gZmFpbGVkCglhc3NlcnQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gc2V0X2dvdmVybm9yKGFkZHJlc3Mpdm9pZAoqYWJpX3JvdXRlX3NldF9nb3Zlcm5vcjoKCS8vIGdvdmVybm9yOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJcHVzaGludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChnb3Zlcm5vcikgZm9yIHNldF9nb3Zlcm5vciBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBzZXRfZ292ZXJub3IoYWRkcmVzcyl2b2lkCgljYWxsc3ViIHNldF9nb3Zlcm5vcgoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gc2V0X2dvdmVybm9yKGdvdmVybm9yOiBBZGRyZXNzKTogdm9pZApzZXRfZ292ZXJub3I6Cglwcm90byAxIDAKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6NzgKCS8vIHZlcmlmeUFwcENhbGxUeG4odGhpcy50eG4sIHsgc2VuZGVyOiB0aGlzLmdvdmVybm9yLnZhbHVlIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCgl0eG4gU2VuZGVyCglieXRlYyAzIC8vICAiZyIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoidGhpcy50eG4iLCJmaWVsZCI6InNlbmRlciIsImV4cGVjdGVkIjoidGhpcy5nb3Zlcm5vci52YWx1ZSJ9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6NzkKCS8vIHRoaXMuZ292ZXJub3IudmFsdWUgPSBnb3Zlcm5vcgoJYnl0ZWMgMyAvLyAgImciCglmcmFtZV9kaWcgLTEgLy8gZ292ZXJub3I6IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGJvb3RzdHJhcChwYXksdWludDY0LHVpbnQ2NCl1aW50NjQKKmFiaV9yb3V0ZV9ib290c3RyYXA6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCXB1c2hieXRlcyAweDE1MWY3Yzc1CgoJLy8gYkFzc2V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBhQXNzZXQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIHNlZWQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludGMgMSAvLyAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnRjIDEgLy8gIHBheQoJPT0KCgkvLyBhcmd1bWVudCAyIChzZWVkKSBmb3IgYm9vdHN0cmFwIG11c3QgYmUgYSBwYXkgdHJhbnNhY3Rpb24KCWFzc2VydAoKCS8vIGV4ZWN1dGUgYm9vdHN0cmFwKHBheSx1aW50NjQsdWludDY0KXVpbnQ2NAoJY2FsbHN1YiBib290c3RyYXAKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBib290c3RyYXAoc2VlZDogUGF5VHhuLCBhQXNzZXQ6IEFzc2V0SUQsIGJBc3NldDogQXNzZXRJRCk6IEFzc2V0SUQKYm9vdHN0cmFwOgoJcHJvdG8gMyAxCgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjgzCgkvLyB2ZXJpZnlBcHBDYWxsVHhuKHRoaXMudHhuLCB7IHNlbmRlcjogdGhpcy5nb3Zlcm5vci52YWx1ZSB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJdHhuIFNlbmRlcgoJYnl0ZWMgMyAvLyAgImciCglhcHBfZ2xvYmFsX2dldAoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InRoaXMudHhuIiwiZmllbGQiOiJzZW5kZXIiLCJleHBlY3RlZCI6InRoaXMuZ292ZXJub3IudmFsdWUifQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjg1CgkvLyBhc3NlcnQoZ2xvYmFscy5ncm91cFNpemUgPT09IDIpCglnbG9iYWwgR3JvdXBTaXplCglpbnRjIDUgLy8gMgoJPT0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czo4NwoJLy8gdmVyaWZ5UGF5VHhuKHNlZWQsIHsgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsIGFtb3VudDogeyBncmVhdGVyVGhhbkVxdWFsVG86IDMwMF8wMDAgfSB9KQoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gc2VlZDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJzZWVkIiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gc2VlZDogUGF5VHhuCglndHhucyBBbW91bnQKCXB1c2hpbnQgMzAwXzAwMAoJPj0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InNlZWQiLCJmaWVsZCI6ImFtb3VudCIsImNvbmRpdGlvbiI6ImdyZWF0ZXJUaGFuRXF1YWxUbyIsImV4cGVjdGVkIjoiPj0zMDBfMDAwIn0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czo4OAoJLy8gYXNzZXJ0KGFBc3NldCA8IGJBc3NldCkKCWZyYW1lX2RpZyAtMiAvLyBhQXNzZXQ6IEFzc2V0SUQKCWZyYW1lX2RpZyAtMyAvLyBiQXNzZXQ6IEFzc2V0SUQKCTwKCWFzc2VydAoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czo5MAoJLy8gdGhpcy5hc3NldEEudmFsdWUgPSBhQXNzZXQKCWJ5dGVjIDEgLy8gICJhIgoJZnJhbWVfZGlnIC0yIC8vIGFBc3NldDogQXNzZXRJRAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6OTEKCS8vIHRoaXMuYXNzZXRCLnZhbHVlID0gYkFzc2V0CglieXRlYyAyIC8vICAiYiIKCWZyYW1lX2RpZyAtMyAvLyBiQXNzZXQ6IEFzc2V0SUQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjkyCgkvLyB0aGlzLnBvb2xUb2tlbi52YWx1ZSA9IHRoaXMuZG9DcmVhdGVQb29sVG9rZW4oYUFzc2V0LCBiQXNzZXQpCglieXRlYyA0IC8vICAicCIKCWZyYW1lX2RpZyAtMyAvLyBiQXNzZXQ6IEFzc2V0SUQKCWZyYW1lX2RpZyAtMiAvLyBhQXNzZXQ6IEFzc2V0SUQKCWNhbGxzdWIgZG9DcmVhdGVQb29sVG9rZW4KCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjk0CgkvLyB0aGlzLmRvT3B0SW4oYUFzc2V0KQoJZnJhbWVfZGlnIC0yIC8vIGFBc3NldDogQXNzZXRJRAoJY2FsbHN1YiBkb09wdEluCgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjk1CgkvLyB0aGlzLmRvT3B0SW4oYkFzc2V0KQoJZnJhbWVfZGlnIC0zIC8vIGJBc3NldDogQXNzZXRJRAoJY2FsbHN1YiBkb09wdEluCgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjk3CgkvLyByZXR1cm4gdGhpcy5wb29sVG9rZW4udmFsdWU7CglieXRlYyA0IC8vICAicCIKCWFwcF9nbG9iYWxfZ2V0CglyZXRzdWIKCi8vIG1pbnQoYXhmZXIsYXhmZXIsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX21pbnQ6CgkvLyBiQXNzZXQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGFBc3NldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gcG9vbEFzc2V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBiWGZlcjogYXhmZXIKCXR4biBHcm91cEluZGV4CglpbnRjIDEgLy8gMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50YyAzIC8vICBheGZlcgoJPT0KCgkvLyBhcmd1bWVudCAzIChiWGZlcikgZm9yIG1pbnQgbXVzdCBiZSBhIGF4ZmVyIHRyYW5zYWN0aW9uCglhc3NlcnQKCgkvLyBhWGZlcjogYXhmZXIKCXR4biBHcm91cEluZGV4CglpbnRjIDUgLy8gMgoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50YyAzIC8vICBheGZlcgoJPT0KCgkvLyBhcmd1bWVudCA0IChhWGZlcikgZm9yIG1pbnQgbXVzdCBiZSBhIGF4ZmVyIHRyYW5zYWN0aW9uCglhc3NlcnQKCgkvLyBleGVjdXRlIG1pbnQoYXhmZXIsYXhmZXIsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBtaW50CglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBtaW50KGFYZmVyOiBBc3NldFRyYW5zZmVyVHhuLCBiWGZlcjogQXNzZXRUcmFuc2ZlclR4biwgcG9vbEFzc2V0OiBBc3NldElELCBhQXNzZXQ6IEFzc2V0SUQsIGJBc3NldDogQXNzZXRJRCk6IHZvaWQKbWludDoKCXByb3RvIDUgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gd2VsbCBmb3JtZWQgbWludAoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjEwMgoJLy8gYXNzZXJ0KGFBc3NldCA9PT0gdGhpcy5hc3NldEEudmFsdWUpCglmcmFtZV9kaWcgLTQgLy8gYUFzc2V0OiBBc3NldElECglieXRlYyAxIC8vICAiYSIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjEwMwoJLy8gYXNzZXJ0KGJBc3NldCA9PT0gdGhpcy5hc3NldEIudmFsdWUpCglmcmFtZV9kaWcgLTUgLy8gYkFzc2V0OiBBc3NldElECglieXRlYyAyIC8vICAiYiIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjEwNAoJLy8gYXNzZXJ0KHBvb2xBc3NldCA9PT0gdGhpcy5wb29sVG9rZW4udmFsdWUpCglmcmFtZV9kaWcgLTMgLy8gcG9vbEFzc2V0OiBBc3NldElECglieXRlYyA0IC8vICAicCIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJYXNzZXJ0CgoJLy8gdmFsaWQgYXNzZXQgQSBheGZlcgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjEwNwoJLy8gdmVyaWZ5QXNzZXRUcmFuc2ZlclR4bihhWGZlciwgewoJLy8gICAgICAgc2VuZGVyOiB0aGlzLnR4bi5zZW5kZXIsCgkvLyAgICAgICBhc3NldEFtb3VudDogeyBncmVhdGVyVGhhbjogMCB9LAoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIHhmZXJBc3NldDogYUFzc2V0LAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gYVhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFNlbmRlcgoJdHhuIFNlbmRlcgoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImFYZmVyIiwiZmllbGQiOiJzZW5kZXIiLCJleHBlY3RlZCI6InRoaXMudHhuLnNlbmRlciJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYXNzZXRBbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBhWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWludGMgMCAvLyAwCgk+CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJhWGZlciIsImZpZWxkIjoiYXNzZXRBbW91bnQiLCJjb25kaXRpb24iOiJncmVhdGVyVGhhbiIsImV4cGVjdGVkIjoiPjAifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0UmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyBhWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJhWGZlciIsImZpZWxkIjoiYXNzZXRSZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgeGZlckFzc2V0CglmcmFtZV9kaWcgLTEgLy8gYVhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFhmZXJBc3NldAoJZnJhbWVfZGlnIC00IC8vIGFBc3NldDogQXNzZXRJRAoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImFYZmVyIiwiZmllbGQiOiJ4ZmVyQXNzZXQiLCJleHBlY3RlZCI6ImFBc3NldCJ9Cglhc3NlcnQKCgkvLyB2YWxpZCBhc3NldCBCIGF4ZmVyCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MTE1CgkvLyB2ZXJpZnlBc3NldFRyYW5zZmVyVHhuKGJYZmVyLCB7CgkvLyAgICAgICBzZW5kZXI6IHRoaXMudHhuLnNlbmRlciwKCS8vICAgICAgIGFzc2V0QW1vdW50OiB7IGdyZWF0ZXJUaGFuOiAwIH0sCgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgeGZlckFzc2V0OiBiQXNzZXQsCgkvLyAgICAgfSkKCS8vIHZlcmlmeSBzZW5kZXIKCWZyYW1lX2RpZyAtMiAvLyBiWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgU2VuZGVyCgl0eG4gU2VuZGVyCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoiYlhmZXIiLCJmaWVsZCI6InNlbmRlciIsImV4cGVjdGVkIjoidGhpcy50eG4uc2VuZGVyIn0KCWFzc2VydAoKCS8vIHZlcmlmeSBhc3NldEFtb3VudAoJZnJhbWVfZGlnIC0yIC8vIGJYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldEFtb3VudAoJaW50YyAwIC8vIDAKCT4KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImJYZmVyIiwiZmllbGQiOiJhc3NldEFtb3VudCIsImNvbmRpdGlvbiI6ImdyZWF0ZXJUaGFuIiwiZXhwZWN0ZWQiOiI+MCJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIC0yIC8vIGJYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImJYZmVyIiwiZmllbGQiOiJhc3NldFJlY2VpdmVyIiwiZXhwZWN0ZWQiOiJ0aGlzLmFwcC5hZGRyZXNzIn0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAtMiAvLyBiWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTUgLy8gYkFzc2V0OiBBc3NldElECgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoiYlhmZXIiLCJmaWVsZCI6InhmZXJBc3NldCIsImV4cGVjdGVkIjoiYkFzc2V0In0KCWFzc2VydAoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MTIzCgkvLyB0aGlzLmFwcC5hZGRyZXNzLmFzc2V0QmFsYW5jZShhQXNzZXQpID09PSBhWGZlci5hc3NldEFtb3VudCAmJgoJLy8gICAgICAgdGhpcy5hcHAuYWRkcmVzcy5hc3NldEJhbGFuY2UoYkFzc2V0KSA9PT0gYlhmZXIuYXNzZXRBbW91bnQKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglmcmFtZV9kaWcgLTQgLy8gYUFzc2V0OiBBc3NldElECglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIC0xIC8vIGFYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldEFtb3VudAoJPT0KCWR1cAoJYnogKnNraXBfYW5kMAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWZyYW1lX2RpZyAtNSAvLyBiQXNzZXQ6IEFzc2V0SUQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCglmcmFtZV9kaWcgLTIgLy8gYlhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50Cgk9PQoJJiYKCipza2lwX2FuZDA6CglieiAqaWYwX2Vsc2UKCgkvLyAqaWYwX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czoxMjYKCS8vIHRoaXMudG9rZW5zVG9NaW50SW50aWFsKGFYZmVyLmFzc2V0QW1vdW50LCBiWGZlci5hc3NldEFtb3VudCkKCWZyYW1lX2RpZyAtMiAvLyBiWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBhWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWNhbGxzdWIgdG9rZW5zVG9NaW50SW50aWFsCgliICppZjBfZW5kCgoqaWYwX2Vsc2U6CgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MTI4CgkvLyB0b01pbnQgPSB0aGlzLnRva2Vuc1RvTWludCgKCS8vICAgICAgICAgVE9UQUxfU1VQUExZIC0gdGhpcy5hcHAuYWRkcmVzcy5hc3NldEJhbGFuY2UocG9vbEFzc2V0KSwKCS8vICAgICAgICAgdGhpcy5hcHAuYWRkcmVzcy5hc3NldEJhbGFuY2UoYUFzc2V0KSAtIGFYZmVyLmFzc2V0QW1vdW50LAoJLy8gICAgICAgICB0aGlzLmFwcC5hZGRyZXNzLmFzc2V0QmFsYW5jZShiQXNzZXQpIC0gYlhmZXIuYXNzZXRBbW91bnQsCgkvLyAgICAgICAgIGFYZmVyLmFzc2V0QW1vdW50LAoJLy8gICAgICAgICBiWGZlci5hc3NldEFtb3VudAoJLy8gICAgICAgKQoJZnJhbWVfZGlnIC0yIC8vIGJYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldEFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIGFYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldEFtb3VudAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWZyYW1lX2RpZyAtNSAvLyBiQXNzZXQ6IEFzc2V0SUQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCglmcmFtZV9kaWcgLTIgLy8gYlhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CgktCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZnJhbWVfZGlnIC00IC8vIGFBc3NldDogQXNzZXRJRAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAtMSAvLyBhWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCS0KCWludGMgNCAvLyAxMDAwMDAwMDAwMAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWZyYW1lX2RpZyAtMyAvLyBwb29sQXNzZXQ6IEFzc2V0SUQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCgktCgljYWxsc3ViIHRva2Vuc1RvTWludAoJZnJhbWVfYnVyeSAwIC8vIHRvTWludDogdWludDY0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjEzNgoJLy8gYXNzZXJ0KHRvTWludCA+IDApCglmcmFtZV9kaWcgMCAvLyB0b01pbnQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT4KCWFzc2VydAoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czoxMzgKCS8vIHRoaXMuZG9BeGZlcih0aGlzLnR4bi5zZW5kZXIsIHBvb2xBc3NldCwgdG9NaW50KQoJZnJhbWVfZGlnIDAgLy8gdG9NaW50OiB1aW50NjQKCWZyYW1lX2RpZyAtMyAvLyBwb29sQXNzZXQ6IEFzc2V0SUQKCXR4biBTZW5kZXIKCWNhbGxzdWIgZG9BeGZlcgoKKmlmMF9lbmQ6CglyZXRzdWIKCi8vIGJ1cm4oYXhmZXIsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX2J1cm46CgkvLyBiQXNzZXQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGFBc3NldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gcG9vbEFzc2V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBwb29sWGZlcjogYXhmZXIKCXR4biBHcm91cEluZGV4CglpbnRjIDEgLy8gMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50YyAzIC8vICBheGZlcgoJPT0KCgkvLyBhcmd1bWVudCAzIChwb29sWGZlcikgZm9yIGJ1cm4gbXVzdCBiZSBhIGF4ZmVyIHRyYW5zYWN0aW9uCglhc3NlcnQKCgkvLyBleGVjdXRlIGJ1cm4oYXhmZXIsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBidXJuCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBidXJuKHBvb2xYZmVyOiBBc3NldFRyYW5zZmVyVHhuLCBwb29sQXNzZXQ6IEFzc2V0SUQsIGFBc3NldDogQXNzZXRJRCwgYkFzc2V0OiBBc3NldElEKTogdm9pZApidXJuOgoJcHJvdG8gNCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gMgoKCS8vIHdlbGwgZm9ybWVkIGJ1cm4KCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czoxNDQKCS8vIGFzc2VydChwb29sQXNzZXQgPT09IHRoaXMucG9vbFRva2VuLnZhbHVlKQoJZnJhbWVfZGlnIC0yIC8vIHBvb2xBc3NldDogQXNzZXRJRAoJYnl0ZWMgNCAvLyAgInAiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czoxNDUKCS8vIGFzc2VydChhQXNzZXQgPT09IHRoaXMuYXNzZXRBLnZhbHVlKQoJZnJhbWVfZGlnIC0zIC8vIGFBc3NldDogQXNzZXRJRAoJYnl0ZWMgMSAvLyAgImEiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czoxNDYKCS8vIGFzc2VydChiQXNzZXQgPT09IHRoaXMuYXNzZXRCLnZhbHVlKQoJZnJhbWVfZGlnIC00IC8vIGJBc3NldDogQXNzZXRJRAoJYnl0ZWMgMiAvLyAgImIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIHZhbGlkIHBvb2wgYXhmZXIKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czoxNDkKCS8vIHZlcmlmeUFzc2V0VHJhbnNmZXJUeG4ocG9vbFhmZXIsIHsKCS8vICAgICAgIHNlbmRlcjogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgYXNzZXRBbW91bnQ6IHsgZ3JlYXRlclRoYW46IDAgfSwKCS8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICB4ZmVyQXNzZXQ6IHBvb2xBc3NldCwKCS8vICAgICB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBTZW5kZXIKCXR4biBTZW5kZXIKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJwb29sWGZlciIsImZpZWxkIjoic2VuZGVyIiwiZXhwZWN0ZWQiOiJ0aGlzLnR4bi5zZW5kZXIifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgLTEgLy8gcG9vbFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglpbnRjIDAgLy8gMAoJPgoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoicG9vbFhmZXIiLCJmaWVsZCI6ImFzc2V0QW1vdW50IiwiY29uZGl0aW9uIjoiZ3JlYXRlclRoYW4iLCJleHBlY3RlZCI6Ij4wIn0KCWFzc2VydAoKCS8vIHZlcmlmeSBhc3NldFJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gcG9vbFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0UmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoicG9vbFhmZXIiLCJmaWVsZCI6ImFzc2V0UmVjZWl2ZXIiLCJleHBlY3RlZCI6InRoaXMuYXBwLmFkZHJlc3MifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHhmZXJBc3NldAoJZnJhbWVfZGlnIC0xIC8vIHBvb2xYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBYZmVyQXNzZXQKCWZyYW1lX2RpZyAtMiAvLyBwb29sQXNzZXQ6IEFzc2V0SUQKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJwb29sWGZlciIsImZpZWxkIjoieGZlckFzc2V0IiwiZXhwZWN0ZWQiOiJwb29sQXNzZXQifQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjE1NgoJLy8gaXNzdWVkID0gVE9UQUxfU1VQUExZIC0gKHRoaXMuYXBwLmFkZHJlc3MuYXNzZXRCYWxhbmNlKHBvb2xBc3NldCkgLSBwb29sWGZlci5hc3NldEFtb3VudCkKCWludGMgNCAvLyAxMDAwMDAwMDAwMAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyBwb29sQXNzZXQ6IEFzc2V0SUQKCWFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQoJcG9wCglmcmFtZV9kaWcgLTEgLy8gcG9vbFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CgktCgktCglmcmFtZV9idXJ5IDAgLy8gaXNzdWVkOiB1aW50NjQKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MTU4CgkvLyBhQW10ID0gdGhpcy50b2tlbnNUb0J1cm4oaXNzdWVkLCB0aGlzLmFwcC5hZGRyZXNzLmFzc2V0QmFsYW5jZShhQXNzZXQpLCBwb29sWGZlci5hc3NldEFtb3VudCkKCWZyYW1lX2RpZyAtMSAvLyBwb29sWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglmcmFtZV9kaWcgLTMgLy8gYUFzc2V0OiBBc3NldElECglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIDAgLy8gaXNzdWVkOiB1aW50NjQKCWNhbGxzdWIgdG9rZW5zVG9CdXJuCglmcmFtZV9idXJ5IDEgLy8gYUFtdDogdWludDY0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjE2MAoJLy8gYkFtdCA9IHRoaXMudG9rZW5zVG9CdXJuKGlzc3VlZCwgdGhpcy5hcHAuYWRkcmVzcy5hc3NldEJhbGFuY2UoYkFzc2V0KSwgcG9vbFhmZXIuYXNzZXRBbW91bnQpCglmcmFtZV9kaWcgLTEgLy8gcG9vbFhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZnJhbWVfZGlnIC00IC8vIGJBc3NldDogQXNzZXRJRAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAwIC8vIGlzc3VlZDogdWludDY0CgljYWxsc3ViIHRva2Vuc1RvQnVybgoJZnJhbWVfYnVyeSAyIC8vIGJBbXQ6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL2FtbS9hbW0uYWxnby50czoxNjIKCS8vIHRoaXMuZG9BeGZlcih0aGlzLnR4bi5zZW5kZXIsIGFBc3NldCwgYUFtdCkKCWZyYW1lX2RpZyAxIC8vIGFBbXQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0zIC8vIGFBc3NldDogQXNzZXRJRAoJdHhuIFNlbmRlcgoJY2FsbHN1YiBkb0F4ZmVyCgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjE2MwoJLy8gdGhpcy5kb0F4ZmVyKHRoaXMudHhuLnNlbmRlciwgYkFzc2V0LCBiQW10KQoJZnJhbWVfZGlnIDIgLy8gYkFtdDogdWludDY0CglmcmFtZV9kaWcgLTQgLy8gYkFzc2V0OiBBc3NldElECgl0eG4gU2VuZGVyCgljYWxsc3ViIGRvQXhmZXIKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MTY1CgkvLyB0aGlzLnJhdGlvLnZhbHVlID0gdGhpcy5jb21wdXRlUmF0aW8oKQoJYnl0ZWMgNSAvLyAgInIiCgljYWxsc3ViIGNvbXB1dGVSYXRpbwoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gc3dhcChheGZlcix1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9zd2FwOgoJLy8gYkFzc2V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBhQXNzZXQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIHN3YXBYZmVyOiBheGZlcgoJdHhuIEdyb3VwSW5kZXgKCWludGMgMSAvLyAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnRjIDMgLy8gIGF4ZmVyCgk9PQoKCS8vIGFyZ3VtZW50IDIgKHN3YXBYZmVyKSBmb3Igc3dhcCBtdXN0IGJlIGEgYXhmZXIgdHJhbnNhY3Rpb24KCWFzc2VydAoKCS8vIGV4ZWN1dGUgc3dhcChheGZlcix1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgc3dhcAoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gc3dhcChzd2FwWGZlcjogQXNzZXRUcmFuc2ZlclR4biwgYUFzc2V0OiBBc3NldElELCBiQXNzZXQ6IEFzc2V0SUQpOiB2b2lkCnN3YXA6Cglwcm90byAzIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiAyCgoJLy8gd2VsbCBmb3JtZWQgc3dhcAoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjE3MAoJLy8gYXNzZXJ0KGFBc3NldCA9PT0gdGhpcy5hc3NldEEudmFsdWUpCglmcmFtZV9kaWcgLTIgLy8gYUFzc2V0OiBBc3NldElECglieXRlYyAxIC8vICAiYSIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjE3MQoJLy8gYXNzZXJ0KGJBc3NldCA9PT0gdGhpcy5hc3NldEIudmFsdWUpCglmcmFtZV9kaWcgLTMgLy8gYkFzc2V0OiBBc3NldElECglieXRlYyAyIC8vICAiYiIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjE3MwoJLy8gdmVyaWZ5QXNzZXRUcmFuc2ZlclR4bihzd2FwWGZlciwgewoJLy8gICAgICAgYXNzZXRBbW91bnQ6IHsgZ3JlYXRlclRoYW46IDAgfSwKCS8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICBzZW5kZXI6IHRoaXMudHhuLnNlbmRlciwKCS8vICAgICAgIHhmZXJBc3NldDogeyBpbmNsdWRlZEluOiBbYUFzc2V0LCBiQXNzZXRdIH0sCgkvLyAgICAgfSkKCS8vIHZlcmlmeSBhc3NldEFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIHN3YXBYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldEFtb3VudAoJaW50YyAwIC8vIDAKCT4KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InN3YXBYZmVyIiwiZmllbGQiOiJhc3NldEFtb3VudCIsImNvbmRpdGlvbiI6ImdyZWF0ZXJUaGFuIiwiZXhwZWN0ZWQiOiI+MCJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIHN3YXBYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InN3YXBYZmVyIiwiZmllbGQiOiJhc3NldFJlY2VpdmVyIiwiZXhwZWN0ZWQiOiJ0aGlzLmFwcC5hZGRyZXNzIn0KCWFzc2VydAoKCS8vIHZlcmlmeSBzZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBzd2FwWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgU2VuZGVyCgl0eG4gU2VuZGVyCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoic3dhcFhmZXIiLCJmaWVsZCI6InNlbmRlciIsImV4cGVjdGVkIjoidGhpcy50eG4uc2VuZGVyIn0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAtMSAvLyBzd2FwWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgWGZlckFzc2V0CglmcmFtZV9kaWcgLTIgLy8gYUFzc2V0OiBBc3NldElECgk9PQoJZnJhbWVfZGlnIC0xIC8vIHN3YXBYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBYZmVyQXNzZXQKCWZyYW1lX2RpZyAtMyAvLyBiQXNzZXQ6IEFzc2V0SUQKCT09Cgl8fAoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjp7InR4blRleHQiOiJzd2FwWGZlciJ9LCJmaWVsZCI6InhmZXJBc3NldCIsImNvbmRpdGlvbiI6ImluY2x1ZGVkSW4iLCJleHBlY3RlZCI6IlthQXNzZXQsIGJBc3NldF0ifQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjE4MAoJLy8gb3V0SWQgPSBzd2FwWGZlci54ZmVyQXNzZXQgPT09IGFBc3NldCA/IGFBc3NldCA6IGJBc3NldAoJZnJhbWVfZGlnIC0xIC8vIHN3YXBYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBYZmVyQXNzZXQKCWZyYW1lX2RpZyAtMiAvLyBhQXNzZXQ6IEFzc2V0SUQKCT09CglieiAqdGVybmFyeTFfZmFsc2UKCWZyYW1lX2RpZyAtMiAvLyBhQXNzZXQ6IEFzc2V0SUQKCWIgKnRlcm5hcnkxX2VuZAoKKnRlcm5hcnkxX2ZhbHNlOgoJZnJhbWVfZGlnIC0zIC8vIGJBc3NldDogQXNzZXRJRAoKKnRlcm5hcnkxX2VuZDoKCWZyYW1lX2J1cnkgMCAvLyBvdXRJZDogdWludDY0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjE4MgoJLy8gaW5JZCA9IHN3YXBYZmVyLnhmZXJBc3NldAoJZnJhbWVfZGlnIC0xIC8vIHN3YXBYZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBYZmVyQXNzZXQKCWZyYW1lX2J1cnkgMSAvLyBpbklkOiB1aW50NjQKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MTg0CgkvLyB0b1N3YXAgPSB0aGlzLnRva2Vuc1RvU3dhcCgKCS8vICAgICAgIHN3YXBYZmVyLmFzc2V0QW1vdW50LAoJLy8gICAgICAgdGhpcy5hcHAuYWRkcmVzcy5hc3NldEJhbGFuY2UoaW5JZCkgLSBzd2FwWGZlci5hc3NldEFtb3VudCwKCS8vICAgICAgIHRoaXMuYXBwLmFkZHJlc3MuYXNzZXRCYWxhbmNlKG91dElkKQoJLy8gICAgICkKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglmcmFtZV9kaWcgMCAvLyBvdXRJZDogdWludDY0Cglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWZyYW1lX2RpZyAxIC8vIGluSWQ6IHVpbnQ2NAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAtMSAvLyBzd2FwWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCS0KCWZyYW1lX2RpZyAtMSAvLyBzd2FwWGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWNhbGxzdWIgdG9rZW5zVG9Td2FwCglmcmFtZV9idXJ5IDIgLy8gdG9Td2FwOiB1aW50NjQKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MTkwCgkvLyBhc3NlcnQodG9Td2FwID4gMCkKCWZyYW1lX2RpZyAyIC8vIHRvU3dhcDogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvYW1tL2FtbS5hbGdvLnRzOjE5MgoJLy8gdGhpcy5kb0F4ZmVyKHRoaXMudHhuLnNlbmRlciwgb3V0SWQsIHRvU3dhcCkKCWZyYW1lX2RpZyAyIC8vIHRvU3dhcDogdWludDY0CglmcmFtZV9kaWcgMCAvLyBvdXRJZDogdWludDY0Cgl0eG4gU2VuZGVyCgljYWxsc3ViIGRvQXhmZXIKCgkvLyBleGFtcGxlcy9hbW0vYW1tLmFsZ28udHM6MTk0CgkvLyB0aGlzLnJhdGlvLnZhbHVlID0gdGhpcy5jb21wdXRlUmF0aW8oKQoJYnl0ZWMgNSAvLyAgInIiCgljYWxsc3ViIGNvbXB1dGVSYXRpbwoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKKmNyZWF0ZV9Ob09wOgoJcHVzaGJ5dGVzIDB4Yjg0NDdiMzYgLy8gbWV0aG9kICJjcmVhdGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY3JlYXRlIE5vT3AKCWVycgoKKmNhbGxfTm9PcDoKCXB1c2hieXRlcyAweGRkYzRjYjRhIC8vIG1ldGhvZCAic2V0X2dvdmVybm9yKGFkZHJlc3Mpdm9pZCIKCXB1c2hieXRlcyAweDI1ZTZjMzc2IC8vIG1ldGhvZCAiYm9vdHN0cmFwKHBheSx1aW50NjQsdWludDY0KXVpbnQ2NCIKCXB1c2hieXRlcyAweDEwMDQ1Yzc5IC8vIG1ldGhvZCAibWludChheGZlcixheGZlcix1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIgoJcHVzaGJ5dGVzIDB4MDI4ZTM3YzEgLy8gbWV0aG9kICJidXJuKGF4ZmVyLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCglwdXNoYnl0ZXMgMHg2MzJhYWVkOCAvLyBtZXRob2QgInN3YXAoYXhmZXIsdWludDY0LHVpbnQ2NCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9zZXRfZ292ZXJub3IgKmFiaV9yb3V0ZV9ib290c3RyYXAgKmFiaV9yb3V0ZV9taW50ICphYmlfcm91dGVfYnVybiAqYWJpX3JvdXRlX3N3YXAKCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBOb09wCgllcnI=",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 1,
      "num_uints": 4,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples AbstractedAccount Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 1 0 32 6
bytecblock 0x70 0x61 0x 0x63 0x6e 0x0000000000000000 0x0f885493 0x00

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 3 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// verifyRekeyToAbstractedAccount(): void
//
// Ensure that by the end of the group the abstracted account has control of its address
verifyRekeyToAbstractedAccount:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 2 // 0x
	dupn 2

	// examples/arc58/arc58.algo.ts:45
	// rekeyedBack = false
	intc 1 // 0
	frame_bury 0 // rekeyedBack: bool

	// examples/arc58/arc58.algo.ts:47
	// for (let i = this.txn.groupIndex; i < this.txnGroup.length; i += 1)
	txn GroupIndex
	frame_bury 1 // i: uint64

*for_0:
	// examples/arc58/arc58.algo.ts:47
	// i < this.txnGroup.length
	frame_dig 1 // i: uint64
	global GroupSize
	<
	bz *for_0_end

	// examples/arc58/arc58.algo.ts:48
	// txn = this.txnGroup[i]
	frame_dig 1 // i: uint64
	frame_bury 2 // txn: txn

	// *if0_condition
	// examples/arc58/arc58.algo.ts:51
	// txn.sender === this.controlledAddress.value && txn.rekeyTo === this.controlledAddress.value
	frame_dig 2 // txn: txn
	gtxns Sender
	bytec 3 //  "c"
	app_global_get
	==
	dup
	bz *skip_and0
	frame_dig 2 // txn: txn
	gtxns RekeyTo
	bytec 3 //  "c"
	app_global_get
	==
	&&

*skip_and0:
	bz *if0_end

	// *if0_consequent
	// examples/arc58/arc58.algo.ts:52
	// rekeyedBack = true
	intc 0 // 1
	frame_bury 0 // rekeyedBack: bool
	b *for_0_end

*if0_end:
	// *if1_condition
	// examples/arc58/arc58.algo.ts:58
	// txn.typeEnum === TransactionType.ApplicationCall &&
	//         txn.applicationID === this.app &&
	//         txn.numAppArgs === 1 &&
	//         txn.applicationArgs[0] === method('arc58_verifyAuthAddr()void')
	frame_dig 2 // txn: txn
	gtxns TypeEnum
	intc 3 //  appl
	==
	dup
	bz *skip_and1
	frame_dig 2 // txn: txn
	gtxns ApplicationID
	txna Applications 0
	==
	&&

*skip_and1:
	dup
	bz *skip_and2
	frame_dig 2 // txn: txn
	gtxns NumAppArgs
	intc 0 // 1
	==
	&&

*skip_and2:
	dup
	bz *skip_and3
	frame_dig 2 // txn: txn
	gtxns ApplicationArgs 0
	bytec 6 //  method "arc58_verifyAuthAddr()void"
	==
	&&

*skip_and3:
	bz *if1_end

	// *if1_consequent
	// examples/arc58/arc58.algo.ts:63
	// rekeyedBack = true
	intc 0 // 1
	frame_bury 0 // rekeyedBack: bool
	b *for_0_end

*if1_end:

*for_0_continue:
	// examples/arc58/arc58.algo.ts:47
	// i += 1
	frame_dig 1 // i: uint64
	intc 0 // 1
	+
	frame_bury 1 // i: uint64
	b *for_0

*for_0_end:
	// examples/arc58/arc58.algo.ts:68
	// assert(rekeyedBack)
	frame_dig 0 // rekeyedBack: bool
	assert
	retsub

// getAuthAddr(): Address
//
// What the value of this.address.value.authAddr should be when this.controlledAddress
// is able to be controlled by this app. It will either be this.app.address or zeroAddress
getAuthAddr:
	proto 0 1

	// examples/arc58/arc58.algo.ts:76
	// return this.controlledAddress.value === this.app.address ? Address.zeroAddress : this.app.address;
	bytec 3 //  "c"
	app_global_get
	global CurrentApplicationAddress
	==
	bz *ternary0_false
	global ZeroAddress
	b *ternary0_end

*ternary0_false:
	global CurrentApplicationAddress

*ternary0_end:
	retsub

// createApplication(address,address)void
*abi_route_createApplication:
	// admin: address
	txna ApplicationArgs 2
	dup
	len
	intc 2 // 32
	==

	// argument 0 (admin) for createApplication must be a address
	assert

	// controlledAddress: address
	txna ApplicationArgs 1
	dup
	len
	intc 2 // 32
	==

	// argument 1 (controlledAddress) for createApplication must be a address
	assert

	// execute createApplication(address,address)void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(controlledAddress: Address, admin: Address): void
//
// Create an abstracted account application.
// This is not part of ARC58 and implementation specific.
//
// @param controlledAddress The address of the abstracted account. If zeroAddress, then the address of the contract account will be used
// @param admin The admin for this app
createApplication:
	proto 2 0

	// examples/arc58/arc58.algo.ts:87
	// verifyAppCallTxn(this.txn, {
	//       sender: { includedIn: [controlledAddress, admin] },
	//     })
	// verify sender
	txn Sender
	frame_dig -1 // controlledAddress: Address
	==
	txn Sender
	frame_dig -2 // admin: Address
	==
	||

	// transaction verification failed: {"txn":{"txnText":"this.txn"},"field":"sender","condition":"includedIn","expected":"[controlledAddress, admin]"}
	assert

	// examples/arc58/arc58.algo.ts:91
	// assert(admin !== controlledAddress)
	frame_dig -2 // admin: Address
	frame_dig -1 // controlledAddress: Address
	!=
	assert

	// examples/arc58/arc58.algo.ts:93
	// this.admin.value = admin
	bytec 1 //  "a"
	frame_dig -2 // admin: Address
	app_global_put

	// examples/arc58/arc58.algo.ts:94
	// this.controlledAddress.value = controlledAddress === Address.zeroAddress ? this.app.address : controlledAddress
	bytec 3 //  "c"
	frame_dig -1 // controlledAddress: Address
	global ZeroAddress
	==
	bz *ternary1_false
	global CurrentApplicationAddress
	b *ternary1_end

*ternary1_false:
	frame_dig -1 // controlledAddress: Address

*ternary1_end:
	app_global_put
	retsub

// arc58_changeAdmin(address)void
*abi_route_arc58_changeAdmin:
	// newAdmin: address
	txna ApplicationArgs 1
	dup
	len
	intc 2 // 32
	==

	// argument 0 (newAdmin) for arc58_changeAdmin must be a address
	assert

	// execute arc58_changeAdmin(address)void
	callsub arc58_changeAdmin
	intc 0 // 1
	return

// arc58_changeAdmin(newAdmin: Address): void
//
// Attempt to change the admin for this app. Some implementations MAY not support this.
//
// @param newAdmin The new admin
arc58_changeAdmin:
	proto 1 0

	// examples/arc58/arc58.algo.ts:103
	// verifyTxn(this.txn, { sender: this.admin.value })
	// verify sender
	txn Sender
	bytec 1 //  "a"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.admin.value"}
	assert

	// examples/arc58/arc58.algo.ts:104
	// this.admin.value = newAdmin
	bytec 1 //  "a"
	frame_dig -1 // newAdmin: Address
	app_global_put
	retsub

// arc58_pluginChangeAdmin(uint64,address,address)void
*abi_route_arc58_pluginChangeAdmin:
	// newAdmin: address
	txna ApplicationArgs 3
	dup
	len
	intc 2 // 32
	==

	// argument 0 (newAdmin) for arc58_pluginChangeAdmin must be a address
	assert

	// allowedCaller: address
	txna ApplicationArgs 2
	dup
	len
	intc 2 // 32
	==

	// argument 1 (allowedCaller) for arc58_pluginChangeAdmin must be a address
	assert

	// plugin: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc58_pluginChangeAdmin(uint64,address,address)void
	callsub arc58_pluginChangeAdmin
	intc 0 // 1
	return

// arc58_pluginChangeAdmin(plugin: AppID, allowedCaller: Address, newAdmin: Address): void
//
// Attempt to change the admin via plugin.
//
// @param plugin The app calling the plugin
// @param allowedCaller The address that triggered the plugin
// @param newAdmin The new admin
arc58_pluginChangeAdmin:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 2 // 0x

	// examples/arc58/arc58.algo.ts:116
	// verifyTxn(this.txn, { sender: plugin.address })
	// verify sender
	txn Sender
	frame_dig -1 // plugin: AppID
	app_params_get AppAddress
	pop
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"plugin.address"}
	assert

	// examples/arc58/arc58.algo.ts:117
	// assert(this.controlledAddress.value.authAddr === plugin.address, 'This plugin is not in control of the account')
	bytec 3 //  "c"
	app_global_get
	acct_params_get AcctAuthAddr
	pop
	frame_dig -1 // plugin: AppID
	app_params_get AppAddress
	pop
	==

	// This plugin is not in control of the account
	assert

	// examples/arc58/arc58.algo.ts:119
	// key: PluginsKey = { application: plugin, allowedCaller: allowedCaller }
	frame_dig -1 // plugin: AppID
	itob
	frame_dig -2 // allowedCaller: Address
	concat
	frame_bury 0 // key: PluginsKey

	// examples/arc58/arc58.algo.ts:120
	// assert(
	//       this.plugins(key).exists && this.plugins(key).value.adminPrivileges,
	//       'This plugin does not have admin privileges'
	//     )
	bytec 0 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_len
	swap
	pop
	dup
	bz *skip_and4
	bytec 0 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	load 255 // full array
	pushint 192
	getbit
	&&

*skip_and4:
	// This plugin does not have admin privileges
	assert

	// examples/arc58/arc58.algo.ts:125
	// this.admin.value = newAdmin
	bytec 1 //  "a"
	frame_dig -3 // newAdmin: Address
	app_global_put
	retsub

// arc58_getAdmin()address
*abi_route_arc58_getAdmin:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// execute arc58_getAdmin()address
	callsub arc58_getAdmin
	concat
	log
	intc 0 // 1
	return

// arc58_getAdmin(): Address
//
// Get the admin of this app. This method SHOULD always be used rather than reading directly from state
// because different implementations may have different ways of determining the admin.
arc58_getAdmin:
	proto 0 1

	// examples/arc58/arc58.algo.ts:133
	// return this.admin.value;
	bytec 1 //  "a"
	app_global_get
	retsub

// arc58_verifyAuthAddr()void
*abi_route_arc58_verifyAuthAddr:
	// execute arc58_verifyAuthAddr()void
	callsub arc58_verifyAuthAddr
	intc 0 // 1
	return

// arc58_verifyAuthAddr(): void
//
// Verify the abstracted account is rekeyed to this app
arc58_verifyAuthAddr:
	proto 0 0

	// examples/arc58/arc58.algo.ts:140
	// assert(this.controlledAddress.value.authAddr === this.getAuthAddr())
	bytec 3 //  "c"
	app_global_get
	acct_params_get AcctAuthAddr
	pop
	callsub getAuthAddr
	==
	assert
	retsub

// arc58_rekeyTo(address,bool)void
*abi_route_arc58_rekeyTo:
	// flash: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 0 (flash) for arc58_rekeyTo must be a bool
	assert
	intc 1 // 0
	getbit

	// addr: address
	txna ApplicationArgs 1
	dup
	len
	intc 2 // 32
	==

	// argument 1 (addr) for arc58_rekeyTo must be a address
	assert

	// execute arc58_rekeyTo(address,bool)void
	callsub arc58_rekeyTo
	intc 0 // 1
	return

// arc58_rekeyTo(addr: Address, flash: boolean): void
//
// Rekey the abstracted account to another address. Primarily useful for rekeying to an EOA.
//
// @param addr The address to rekey to
// @param flash Whether or not this should be a flash rekey. If true, the rekey back to the app address must done in the same txn group as this call
arc58_rekeyTo:
	proto 2 0

	// examples/arc58/arc58.algo.ts:150
	// verifyAppCallTxn(this.txn, { sender: this.admin.value })
	// verify sender
	txn Sender
	bytec 1 //  "a"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.admin.value"}
	assert

	// examples/arc58/arc58.algo.ts:152
	// sendPayment({
	//       sender: this.controlledAddress.value,
	//       receiver: addr,
	//       rekeyTo: addr,
	//       note: 'rekeying abstracted account',
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// examples/arc58/arc58.algo.ts:153
	// sender: this.controlledAddress.value
	bytec 3 //  "c"
	app_global_get
	itxn_field Sender

	// examples/arc58/arc58.algo.ts:154
	// receiver: addr
	frame_dig -1 // addr: Address
	itxn_field Receiver

	// examples/arc58/arc58.algo.ts:155
	// rekeyTo: addr
	frame_dig -1 // addr: Address
	itxn_field RekeyTo

	// examples/arc58/arc58.algo.ts:156
	// note: 'rekeying abstracted account'
	pushbytes 0x72656b6579696e672061627374726163746564206163636f756e74 // "rekeying abstracted account"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// *if2_condition
	// examples/arc58/arc58.algo.ts:159
	// flash
	frame_dig -2 // flash: boolean
	bz *if2_end

	// *if2_consequent
	// examples/arc58/arc58.algo.ts:159
	// this.verifyRekeyToAbstractedAccount()
	callsub verifyRekeyToAbstractedAccount

*if2_end:
	retsub

// pluginCallAllowed(app: AppID, caller: Address): boolean
pluginCallAllowed:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 2 // 0x

	// examples/arc58/arc58.algo.ts:163
	// key: PluginsKey = { application: app, allowedCaller: caller }
	frame_dig -1 // app: AppID
	itob
	frame_dig -2 // caller: Address
	concat
	frame_bury 0 // key: PluginsKey

	// examples/arc58/arc58.algo.ts:165
	// return (
	//       this.plugins(key).exists &&
	//       this.plugins(key).value.lastValidRound >= globals.round &&
	//       globals.round - this.plugins(key).value.lastCalled >= this.plugins(key).value.cooldown
	//     );
	bytec 0 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_len
	swap
	pop
	dup
	bz *skip_and5
	bytec 0 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	global Round
	>=
	&&

*skip_and5:
	dup
	bz *skip_and6
	global Round
	bytec 0 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	-
	bytec 0 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	>=
	&&

*skip_and6:
	// set the subroutine return value
	frame_bury 0
	retsub

// arc58_rekeyToPlugin(uint64)void
*abi_route_arc58_rekeyToPlugin:
	// plugin: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc58_rekeyToPlugin(uint64)void
	callsub arc58_rekeyToPlugin
	intc 0 // 1
	return

// arc58_rekeyToPlugin(plugin: AppID): void
//
// Temporarily rekey to an approved plugin app address
//
// @param plugin The app to rekey to
arc58_rekeyToPlugin:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 2 // 0x

	// examples/arc58/arc58.algo.ts:178
	// globalAllowed = this.pluginCallAllowed(plugin, Address.zeroAddress)
	global ZeroAddress
	frame_dig -1 // plugin: AppID
	callsub pluginCallAllowed
	frame_bury 0 // globalAllowed: bool

	// *if3_condition
	// examples/arc58/arc58.algo.ts:180
	// !globalAllowed
	frame_dig 0 // globalAllowed: bool
	!
	bz *if3_end

	// *if3_consequent
	// examples/arc58/arc58.algo.ts:181
	// assert(this.pluginCallAllowed(plugin, this.txn.sender), 'This sender is not allowed to trigger this plugin')
	txn Sender
	frame_dig -1 // plugin: AppID
	callsub pluginCallAllowed

	// This sender is not allowed to trigger this plugin
	assert

*if3_end:
	// examples/arc58/arc58.algo.ts:183
	// sendPayment({
	//       sender: this.controlledAddress.value,
	//       receiver: this.controlledAddress.value,
	//       rekeyTo: plugin.address,
	//       note: 'rekeying to plugin app',
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// examples/arc58/arc58.algo.ts:184
	// sender: this.controlledAddress.value
	bytec 3 //  "c"
	app_global_get
	itxn_field Sender

	// examples/arc58/arc58.algo.ts:185
	// receiver: this.controlledAddress.value
	bytec 3 //  "c"
	app_global_get
	itxn_field Receiver

	// examples/arc58/arc58.algo.ts:186
	// rekeyTo: plugin.address
	frame_dig -1 // plugin: AppID
	app_params_get AppAddress
	pop
	itxn_field RekeyTo

	// examples/arc58/arc58.algo.ts:187
	// note: 'rekeying to plugin app'
	pushbytes 0x72656b6579696e6720746f20706c7567696e20617070 // "rekeying to plugin app"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/arc58/arc58.algo.ts:190
	// this.plugins({
	//       application: plugin,
	//       allowedCaller: globalAllowed ? Address.zeroAddress : this.txn.sender,
	//     }).value.lastCalled = globals.round
	bytec 0 //  "p"
	frame_dig -1 // plugin: AppID
	itob
	frame_dig 0 // globalAllowed: bool
	bz *ternary3_false
	global ZeroAddress
	b *ternary3_end

*ternary3_false:
	txn Sender

*ternary3_end:
	concat
	concat
	box_get

	// box value does not exist: this.plugins({ application: plugin, allowedCaller: globalAllowed ? Address.zeroAddress : this.txn.sender, }).value
	assert
	store 255 // full array
	load 255 // full array
	pushint 16
	global Round
	itob
	bytec 0 //  "p"
	frame_dig -1 // plugin: AppID
	itob
	frame_dig 0 // globalAllowed: bool
	bz *ternary5_false
	global ZeroAddress
	b *ternary5_end

*ternary5_false:
	txn Sender

*ternary5_end:
	concat
	concat
	cover 2
	box_replace

	// examples/arc58/arc58.algo.ts:195
	// this.verifyRekeyToAbstractedAccount()
	callsub verifyRekeyToAbstractedAccount
	retsub

// arc58_rekeyToNamedPlugin(string)void
*abi_route_arc58_rekeyToNamedPlugin:
	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute arc58_rekeyToNamedPlugin(string)void
	callsub arc58_rekeyToNamedPlugin
	intc 0 // 1
	return

// arc58_rekeyToNamedPlugin(name: string): void
//
// Temporarily rekey to a named plugin app address
//
// @param name The name of the plugin to rekey to
arc58_rekeyToNamedPlugin:
	proto 1 0

	// examples/arc58/arc58.algo.ts:204
	// this.arc58_rekeyToPlugin(this.namedPlugins(name).value.application)
	intc 1 // 0
	pushint 8
	bytec 4 //  "n"
	frame_dig -1 // name: string
	concat
	cover 2
	box_extract
	btoi
	callsub arc58_rekeyToPlugin
	retsub

// arc58_addPlugin(uint64,address,uint64,uint64,bool)void
*abi_route_arc58_addPlugin:
	// adminPrivileges: bool
	txna ApplicationArgs 5
	dup
	len
	intc 0 // 1
	==

	// argument 0 (adminPrivileges) for arc58_addPlugin must be a bool
	assert
	intc 1 // 0
	getbit

	// cooldown: uint64
	txna ApplicationArgs 4
	btoi

	// lastValidRound: uint64
	txna ApplicationArgs 3
	btoi

	// allowedCaller: address
	txna ApplicationArgs 2
	dup
	len
	intc 2 // 32
	==

	// argument 3 (allowedCaller) for arc58_addPlugin must be a address
	assert

	// app: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc58_addPlugin(uint64,address,uint64,uint64,bool)void
	callsub arc58_addPlugin
	intc 0 // 1
	return

// arc58_addPlugin(app: AppID, allowedCaller: Address, lastValidRound: uint64, cooldown: uint64, adminPrivileges: boolean): void
//
// Add an app to the list of approved plugins
//
// @param app The app to add
// @param allowedCaller The address of that's allowed to call the app
// or the global zero address for all addresses
// @param lastValidRound The round when the permission expires
// @param cooldown  The number of rounds that must pass before the plugin can be called again
// @param adminPrivileges Whether the plugin has permissions to change the admin account
arc58_addPlugin:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 2 // 0x

	// examples/arc58/arc58.algo.ts:224
	// verifyTxn(this.txn, { sender: this.admin.value })
	// verify sender
	txn Sender
	bytec 1 //  "a"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.admin.value"}
	assert

	// examples/arc58/arc58.algo.ts:225
	// key: PluginsKey = { application: app, allowedCaller: allowedCaller }
	frame_dig -1 // app: AppID
	itob
	frame_dig -2 // allowedCaller: Address
	concat
	frame_bury 0 // key: PluginsKey

	// examples/arc58/arc58.algo.ts:226
	// this.plugins(key).value = {
	//       lastValidRound: lastValidRound,
	//       cooldown: cooldown,
	//       lastCalled: 0,
	//       adminPrivileges: adminPrivileges,
	//     }
	bytec 0 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	frame_dig -3 // lastValidRound: uint64
	itob
	frame_dig -4 // cooldown: uint64
	itob
	concat
	bytec 5 // 0x0000000000000000
	concat
	bytec 7 // 0x00
	intc 1 // 0
	frame_dig -5 // adminPrivileges: boolean
	setbit
	concat
	box_put
	retsub

// arc58_removePlugin(uint64,address)void
*abi_route_arc58_removePlugin:
	// allowedCaller: address
	txna ApplicationArgs 2
	dup
	len
	intc 2 // 32
	==

	// argument 0 (allowedCaller) for arc58_removePlugin must be a address
	assert

	// app: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc58_removePlugin(uint64,address)void
	callsub arc58_removePlugin
	intc 0 // 1
	return

// arc58_removePlugin(app: AppID, allowedCaller: Address): void
//
// Remove an app from the list of approved plugins
//
// @param app The app to remove
arc58_removePlugin:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 2 // 0x

	// examples/arc58/arc58.algo.ts:240
	// verifyTxn(this.txn, { sender: this.admin.value })
	// verify sender
	txn Sender
	bytec 1 //  "a"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.admin.value"}
	assert

	// examples/arc58/arc58.algo.ts:242
	// key: PluginsKey = { application: app, allowedCaller: allowedCaller }
	frame_dig -1 // app: AppID
	itob
	frame_dig -2 // allowedCaller: Address
	concat
	frame_bury 0 // key: PluginsKey

	// examples/arc58/arc58.algo.ts:243
	// this.plugins(key).delete()
	bytec 0 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_del
	retsub

// arc58_addNamedPlugin(string,uint64,address,uint64,uint64,bool)void
*abi_route_arc58_addNamedPlugin:
	// adminPrivileges: bool
	txna ApplicationArgs 6
	dup
	len
	intc 0 // 1
	==

	// argument 0 (adminPrivileges) for arc58_addNamedPlugin must be a bool
	assert
	intc 1 // 0
	getbit

	// cooldown: uint64
	txna ApplicationArgs 5
	btoi

	// lastValidRound: uint64
	txna ApplicationArgs 4
	btoi

	// allowedCaller: address
	txna ApplicationArgs 3
	dup
	len
	intc 2 // 32
	==

	// argument 3 (allowedCaller) for arc58_addNamedPlugin must be a address
	assert

	// app: uint64
	txna ApplicationArgs 2
	btoi

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute arc58_addNamedPlugin(string,uint64,address,uint64,uint64,bool)void
	callsub arc58_addNamedPlugin
	intc 0 // 1
	return

// arc58_addNamedPlugin(name: string, app: AppID, allowedCaller: Address, lastValidRound: uint64, cooldown: uint64, adminPrivileges: boolean): void
//
// Add a named plugin
//
// @param app The plugin app
// @param name The plugin name
// @param allowedCaller The address of that's allowed to call the app
// or the global zero address for all addresses
// @param lastValidRound The round when the permission expires
// @param cooldown  The number of rounds that must pass before the plugin can be called again
// @param adminPrivileges Whether the plugin has permissions to change the admin account
arc58_addNamedPlugin:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 2 // 0x

	// examples/arc58/arc58.algo.ts:265
	// verifyTxn(this.txn, { sender: this.admin.value })
	// verify sender
	txn Sender
	bytec 1 //  "a"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.admin.value"}
	assert

	// examples/arc58/arc58.algo.ts:266
	// assert(!this.namedPlugins(name).exists)
	bytec 4 //  "n"
	frame_dig -1 // name: string
	concat
	box_len
	swap
	pop
	!
	assert

	// examples/arc58/arc58.algo.ts:268
	// key: PluginsKey = { application: app, allowedCaller: allowedCaller }
	frame_dig -2 // app: AppID
	itob
	frame_dig -3 // allowedCaller: Address
	concat
	frame_bury 0 // key: PluginsKey

	// examples/arc58/arc58.algo.ts:269
	// this.namedPlugins(name).value = key
	bytec 4 //  "n"
	frame_dig -1 // name: string
	concat
	frame_dig 0 // key: PluginsKey
	box_put

	// examples/arc58/arc58.algo.ts:270
	// this.plugins(key).value = {
	//       lastValidRound: lastValidRound,
	//       cooldown: cooldown,
	//       lastCalled: 0,
	//       adminPrivileges: adminPrivileges,
	//     }
	bytec 0 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	frame_dig -4 // lastValidRound: uint64
	itob
	frame_dig -5 // cooldown: uint64
	itob
	concat
	bytec 5 // 0x0000000000000000
	concat
	bytec 7 // 0x00
	intc 1 // 0
	frame_dig -6 // adminPrivileges: boolean
	setbit
	concat
	box_put
	retsub

// arc58_removeNamedPlugin(string)void
*abi_route_arc58_removeNamedPlugin:
	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute arc58_removeNamedPlugin(string)void
	callsub arc58_removeNamedPlugin
	intc 0 // 1
	return

// arc58_removeNamedPlugin(name: string): void
//
// Remove a named plugin
//
// @param name The plugin name
arc58_removeNamedPlugin:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 2 // 0x

	// examples/arc58/arc58.algo.ts:284
	// verifyTxn(this.txn, { sender: this.admin.value })
	// verify sender
	txn Sender
	bytec 1 //  "a"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.admin.value"}
	assert

	// examples/arc58/arc58.algo.ts:286
	// app = this.namedPlugins(name).value
	bytec 4 //  "n"
	frame_dig -1 // name: string
	concat
	frame_bury 0 // storage key//app

	// examples/arc58/arc58.algo.ts:287
	// this.namedPlugins(name).delete()
	bytec 4 //  "n"
	frame_dig -1 // name: string
	concat
	box_del

	// examples/arc58/arc58.algo.ts:288
	// this.plugins(app).delete()
	bytec 0 //  "p"
	frame_dig 0 // storage key//app
	box_get

	// box value does not exist: this.namedPlugins(name).value
	assert
	concat
	box_del
	retsub

*create_NoOp:
	pushbytes 0xb4c77d71 // method "createApplication(address,address)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xd24b7556 // method "arc58_changeAdmin(address)void"
	pushbytes 0x5fa449c6 // method "arc58_pluginChangeAdmin(uint64,address,address)void"
	pushbytes 0x13bc44e4 // method "arc58_getAdmin()address"
	bytec 6 //  method "arc58_verifyAuthAddr()void"
	pushbytes 0xc95a5d3d // method "arc58_rekeyTo(address,bool)void"
	pushbytes 0x7c766ddc // method "arc58_rekeyToPlugin(uint64)void"
	pushbytes 0x56f28b58 // method "arc58_rekeyToNamedPlugin(string)void"
	pushbytes 0xd12dcb61 // method "arc58_addPlugin(uint64,address,uint64,uint64,bool)void"
	pushbytes 0x4d372355 // method "arc58_removePlugin(uint64,address)void"
	pushbytes 0x8a72a750 // method "arc58_addNamedPlugin(string,uint64,address,uint64,uint64,bool)void"
	pushbytes 0xe350b9d4 // method "arc58_removeNamedPlugin(string)void"
	txna ApplicationArgs 0
	match *abi_route_arc58_changeAdmin *abi_route_arc58_pluginChangeAdmin *abi_route_arc58_getAdmin *abi_route_arc58_verifyAuthAddr *abi_route_arc58_rekeyTo *abi_route_arc58_rekeyToPlugin *abi_route_arc58_rekeyToNamedPlugin *abi_route_arc58_addPlugin *abi_route_arc58_removePlugin *abi_route_arc58_addNamedPlugin *abi_route_arc58_removeNamedPlugin

	// this contract does not implement the given ABI method for call NoOp
	err"
`;

exports[`Examples AbstractedAccount Artifacts Maintains program size 1`] = `1130`;

exports[`Examples AbstractedAccount Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [
        {
          "desc": "The address of the abstracted account. If zeroAddress, then the address of the contract account will be used",
          "name": "controlledAddress",
          "type": "address",
        },
        {
          "desc": "The admin for this app",
          "name": "admin",
          "type": "address",
        },
      ],
      "desc": 
"Create an abstracted account application.
This is not part of ARC58 and implementation specific."
,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The new admin",
          "name": "newAdmin",
          "type": "address",
        },
      ],
      "desc": "Attempt to change the admin for this app. Some implementations MAY not support this.",
      "events": undefined,
      "name": "arc58_changeAdmin",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The app calling the plugin",
          "name": "plugin",
          "type": "uint64",
        },
        {
          "desc": "The address that triggered the plugin",
          "name": "allowedCaller",
          "type": "address",
        },
        {
          "desc": "The new admin",
          "name": "newAdmin",
          "type": "address",
        },
      ],
      "desc": "Attempt to change the admin via plugin.",
      "events": undefined,
      "name": "arc58_pluginChangeAdmin",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": 
"Get the admin of this app. This method SHOULD always be used rather than reading directly from state
because different implementations may have different ways of determining the admin."
,
      "events": undefined,
      "name": "arc58_getAdmin",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "address",
      },
    },
    {
      "args": [],
      "desc": "Verify the abstracted account is rekeyed to this app",
      "events": undefined,
      "name": "arc58_verifyAuthAddr",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The address to rekey to",
          "name": "addr",
          "type": "address",
        },
        {
          "desc": "Whether or not this should be a flash rekey. If true, the rekey back to the app address must done in the same txn group as this call",
          "name": "flash",
          "type": "bool",
        },
      ],
      "desc": "Rekey the abstracted account to another address. Primarily useful for rekeying to an EOA.",
      "events": undefined,
      "name": "arc58_rekeyTo",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The app to rekey to",
          "name": "plugin",
          "type": "uint64",
        },
      ],
      "desc": "Temporarily rekey to an approved plugin app address",
      "events": undefined,
      "name": "arc58_rekeyToPlugin",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The name of the plugin to rekey to",
          "name": "name",
          "type": "string",
        },
      ],
      "desc": "Temporarily rekey to a named plugin app address",
      "events": undefined,
      "name": "arc58_rekeyToNamedPlugin",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The app to add",
          "name": "app",
          "type": "uint64",
        },
        {
          "desc": 
"The address of that's allowed to call the app
or the global zero address for all addresses"
,
          "name": "allowedCaller",
          "type": "address",
        },
        {
          "desc": "The round when the permission expires",
          "name": "lastValidRound",
          "type": "uint64",
        },
        {
          "desc": "The number of rounds that must pass before the plugin can be called again",
          "name": "cooldown",
          "type": "uint64",
        },
        {
          "desc": "Whether the plugin has permissions to change the admin account",
          "name": "adminPrivileges",
          "type": "bool",
        },
      ],
      "desc": "Add an app to the list of approved plugins",
      "events": undefined,
      "name": "arc58_addPlugin",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The app to remove",
          "name": "app",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "allowedCaller",
          "type": "address",
        },
      ],
      "desc": "Remove an app from the list of approved plugins",
      "events": undefined,
      "name": "arc58_removePlugin",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The plugin name",
          "name": "name",
          "type": "string",
        },
        {
          "desc": "The plugin app",
          "name": "app",
          "type": "uint64",
        },
        {
          "desc": 
"The address of that's allowed to call the app
or the global zero address for all addresses"
,
          "name": "allowedCaller",
          "type": "address",
        },
        {
          "desc": "The round when the permission expires",
          "name": "lastValidRound",
          "type": "uint64",
        },
        {
          "desc": "The number of rounds that must pass before the plugin can be called again",
          "name": "cooldown",
          "type": "uint64",
        },
        {
          "desc": "Whether the plugin has permissions to change the admin account",
          "name": "adminPrivileges",
          "type": "bool",
        },
      ],
      "desc": "Add a named plugin",
      "events": undefined,
      "name": "arc58_addNamedPlugin",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The plugin name",
          "name": "name",
          "type": "string",
        },
      ],
      "desc": "Remove a named plugin",
      "events": undefined,
      "name": "arc58_removeNamedPlugin",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "AbstractedAccount",
}
`;

exports[`Examples AbstractedAccount Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [
          {
            "desc": "The address of the abstracted account. If zeroAddress, then the address of the contract account will be used",
            "name": "controlledAddress",
            "type": "address",
          },
          {
            "desc": "The admin for this app",
            "name": "admin",
            "type": "address",
          },
        ],
        "desc": 
"Create an abstracted account application.
This is not part of ARC58 and implementation specific."
,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The new admin",
            "name": "newAdmin",
            "type": "address",
          },
        ],
        "desc": "Attempt to change the admin for this app. Some implementations MAY not support this.",
        "events": undefined,
        "name": "arc58_changeAdmin",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The app calling the plugin",
            "name": "plugin",
            "type": "uint64",
          },
          {
            "desc": "The address that triggered the plugin",
            "name": "allowedCaller",
            "type": "address",
          },
          {
            "desc": "The new admin",
            "name": "newAdmin",
            "type": "address",
          },
        ],
        "desc": "Attempt to change the admin via plugin.",
        "events": undefined,
        "name": "arc58_pluginChangeAdmin",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": 
"Get the admin of this app. This method SHOULD always be used rather than reading directly from state
because different implementations may have different ways of determining the admin."
,
        "events": undefined,
        "name": "arc58_getAdmin",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "address",
        },
      },
      {
        "args": [],
        "desc": "Verify the abstracted account is rekeyed to this app",
        "events": undefined,
        "name": "arc58_verifyAuthAddr",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The address to rekey to",
            "name": "addr",
            "type": "address",
          },
          {
            "desc": "Whether or not this should be a flash rekey. If true, the rekey back to the app address must done in the same txn group as this call",
            "name": "flash",
            "type": "bool",
          },
        ],
        "desc": "Rekey the abstracted account to another address. Primarily useful for rekeying to an EOA.",
        "events": undefined,
        "name": "arc58_rekeyTo",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The app to rekey to",
            "name": "plugin",
            "type": "uint64",
          },
        ],
        "desc": "Temporarily rekey to an approved plugin app address",
        "events": undefined,
        "name": "arc58_rekeyToPlugin",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The name of the plugin to rekey to",
            "name": "name",
            "type": "string",
          },
        ],
        "desc": "Temporarily rekey to a named plugin app address",
        "events": undefined,
        "name": "arc58_rekeyToNamedPlugin",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The app to add",
            "name": "app",
            "type": "uint64",
          },
          {
            "desc": 
"The address of that's allowed to call the app
or the global zero address for all addresses"
,
            "name": "allowedCaller",
            "type": "address",
          },
          {
            "desc": "The round when the permission expires",
            "name": "lastValidRound",
            "type": "uint64",
          },
          {
            "desc": "The number of rounds that must pass before the plugin can be called again",
            "name": "cooldown",
            "type": "uint64",
          },
          {
            "desc": "Whether the plugin has permissions to change the admin account",
            "name": "adminPrivileges",
            "type": "bool",
          },
        ],
        "desc": "Add an app to the list of approved plugins",
        "events": undefined,
        "name": "arc58_addPlugin",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The app to remove",
            "name": "app",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "allowedCaller",
            "type": "address",
          },
        ],
        "desc": "Remove an app from the list of approved plugins",
        "events": undefined,
        "name": "arc58_removePlugin",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The plugin name",
            "name": "name",
            "type": "string",
          },
          {
            "desc": "The plugin app",
            "name": "app",
            "type": "uint64",
          },
          {
            "desc": 
"The address of that's allowed to call the app
or the global zero address for all addresses"
,
            "name": "allowedCaller",
            "type": "address",
          },
          {
            "desc": "The round when the permission expires",
            "name": "lastValidRound",
            "type": "uint64",
          },
          {
            "desc": "The number of rounds that must pass before the plugin can be called again",
            "name": "cooldown",
            "type": "uint64",
          },
          {
            "desc": "Whether the plugin has permissions to change the admin account",
            "name": "adminPrivileges",
            "type": "bool",
          },
        ],
        "desc": "Add a named plugin",
        "events": undefined,
        "name": "arc58_addNamedPlugin",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The plugin name",
            "name": "name",
            "type": "string",
          },
        ],
        "desc": "Remove a named plugin",
        "events": undefined,
        "name": "arc58_removeNamedPlugin",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "AbstractedAccount",
  },
  "hints": {
    "arc58_addNamedPlugin(string,uint64,address,uint64,uint64,bool)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc58_addPlugin(uint64,address,uint64,uint64,bool)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc58_changeAdmin(address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc58_getAdmin()address": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc58_pluginChangeAdmin(uint64,address,address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc58_rekeyTo(address,bool)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc58_rekeyToNamedPlugin(string)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc58_rekeyToPlugin(uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc58_removeNamedPlugin(string)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc58_removePlugin(uint64,address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc58_verifyAuthAddr()void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "createApplication(address,address)void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {
        "admin": {
          "key": "a",
          "type": "bytes",
        },
        "controlledAddress": {
          "key": "c",
          "type": "bytes",
        },
      },
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAxIDAgMzIgNgpieXRlY2Jsb2NrIDB4NzAgMHg2MSAweCAweDYzIDB4NmUgMHgwMDAwMDAwMDAwMDAwMDAwIDB4MGY4ODU0OTMgMHgwMAoKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludGMgMyAvLyA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJLy8gVGhlIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udHJhY3QuIEFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgT25Db21wbGV0ZT8gRGlkIHlvdSBzZXQgeW91ciBhcHAgSUQ/CgllcnIKCi8vIHZlcmlmeVJla2V5VG9BYnN0cmFjdGVkQWNjb3VudCgpOiB2b2lkCi8vCi8vIEVuc3VyZSB0aGF0IGJ5IHRoZSBlbmQgb2YgdGhlIGdyb3VwIHRoZSBhYnN0cmFjdGVkIGFjY291bnQgaGFzIGNvbnRyb2wgb2YgaXRzIGFkZHJlc3MKdmVyaWZ5UmVrZXlUb0Fic3RyYWN0ZWRBY2NvdW50OgoJcHJvdG8gMCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDIgLy8gMHgKCWR1cG4gMgoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6NDUKCS8vIHJla2V5ZWRCYWNrID0gZmFsc2UKCWludGMgMSAvLyAwCglmcmFtZV9idXJ5IDAgLy8gcmVrZXllZEJhY2s6IGJvb2wKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjQ3CgkvLyBmb3IgKGxldCBpID0gdGhpcy50eG4uZ3JvdXBJbmRleDsgaSA8IHRoaXMudHhuR3JvdXAubGVuZ3RoOyBpICs9IDEpCgl0eG4gR3JvdXBJbmRleAoJZnJhbWVfYnVyeSAxIC8vIGk6IHVpbnQ2NAoKKmZvcl8wOgoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czo0NwoJLy8gaSA8IHRoaXMudHhuR3JvdXAubGVuZ3RoCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWdsb2JhbCBHcm91cFNpemUKCTwKCWJ6ICpmb3JfMF9lbmQKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjQ4CgkvLyB0eG4gPSB0aGlzLnR4bkdyb3VwW2ldCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWZyYW1lX2J1cnkgMiAvLyB0eG46IHR4bgoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjUxCgkvLyB0eG4uc2VuZGVyID09PSB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlICYmIHR4bi5yZWtleVRvID09PSB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlCglmcmFtZV9kaWcgMiAvLyB0eG46IHR4bgoJZ3R4bnMgU2VuZGVyCglieXRlYyAzIC8vICAiYyIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJZHVwCglieiAqc2tpcF9hbmQwCglmcmFtZV9kaWcgMiAvLyB0eG46IHR4bgoJZ3R4bnMgUmVrZXlUbwoJYnl0ZWMgMyAvLyAgImMiCglhcHBfZ2xvYmFsX2dldAoJPT0KCSYmCgoqc2tpcF9hbmQwOgoJYnogKmlmMF9lbmQKCgkvLyAqaWYwX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6NTIKCS8vIHJla2V5ZWRCYWNrID0gdHJ1ZQoJaW50YyAwIC8vIDEKCWZyYW1lX2J1cnkgMCAvLyByZWtleWVkQmFjazogYm9vbAoJYiAqZm9yXzBfZW5kCgoqaWYwX2VuZDoKCS8vICppZjFfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjU4CgkvLyB0eG4udHlwZUVudW0gPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwgJiYKCS8vICAgICAgICAgdHhuLmFwcGxpY2F0aW9uSUQgPT09IHRoaXMuYXBwICYmCgkvLyAgICAgICAgIHR4bi5udW1BcHBBcmdzID09PSAxICYmCgkvLyAgICAgICAgIHR4bi5hcHBsaWNhdGlvbkFyZ3NbMF0gPT09IG1ldGhvZCgnYXJjNThfdmVyaWZ5QXV0aEFkZHIoKXZvaWQnKQoJZnJhbWVfZGlnIDIgLy8gdHhuOiB0eG4KCWd0eG5zIFR5cGVFbnVtCglpbnRjIDMgLy8gIGFwcGwKCT09CglkdXAKCWJ6ICpza2lwX2FuZDEKCWZyYW1lX2RpZyAyIC8vIHR4bjogdHhuCglndHhucyBBcHBsaWNhdGlvbklECgl0eG5hIEFwcGxpY2F0aW9ucyAwCgk9PQoJJiYKCipza2lwX2FuZDE6CglkdXAKCWJ6ICpza2lwX2FuZDIKCWZyYW1lX2RpZyAyIC8vIHR4bjogdHhuCglndHhucyBOdW1BcHBBcmdzCglpbnRjIDAgLy8gMQoJPT0KCSYmCgoqc2tpcF9hbmQyOgoJZHVwCglieiAqc2tpcF9hbmQzCglmcmFtZV9kaWcgMiAvLyB0eG46IHR4bgoJZ3R4bnMgQXBwbGljYXRpb25BcmdzIDAKCWJ5dGVjIDYgLy8gIG1ldGhvZCAiYXJjNThfdmVyaWZ5QXV0aEFkZHIoKXZvaWQiCgk9PQoJJiYKCipza2lwX2FuZDM6CglieiAqaWYxX2VuZAoKCS8vICppZjFfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czo2MwoJLy8gcmVrZXllZEJhY2sgPSB0cnVlCglpbnRjIDAgLy8gMQoJZnJhbWVfYnVyeSAwIC8vIHJla2V5ZWRCYWNrOiBib29sCgliICpmb3JfMF9lbmQKCippZjFfZW5kOgoKKmZvcl8wX2NvbnRpbnVlOgoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czo0NwoJLy8gaSArPSAxCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgMCAvLyAxCgkrCglmcmFtZV9idXJ5IDEgLy8gaTogdWludDY0CgliICpmb3JfMAoKKmZvcl8wX2VuZDoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6NjgKCS8vIGFzc2VydChyZWtleWVkQmFjaykKCWZyYW1lX2RpZyAwIC8vIHJla2V5ZWRCYWNrOiBib29sCglhc3NlcnQKCXJldHN1YgoKLy8gZ2V0QXV0aEFkZHIoKTogQWRkcmVzcwovLwovLyBXaGF0IHRoZSB2YWx1ZSBvZiB0aGlzLmFkZHJlc3MudmFsdWUuYXV0aEFkZHIgc2hvdWxkIGJlIHdoZW4gdGhpcy5jb250cm9sbGVkQWRkcmVzcwovLyBpcyBhYmxlIHRvIGJlIGNvbnRyb2xsZWQgYnkgdGhpcyBhcHAuIEl0IHdpbGwgZWl0aGVyIGJlIHRoaXMuYXBwLmFkZHJlc3Mgb3IgemVyb0FkZHJlc3MKZ2V0QXV0aEFkZHI6Cglwcm90byAwIDEKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjc2CgkvLyByZXR1cm4gdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSA9PT0gdGhpcy5hcHAuYWRkcmVzcyA/IEFkZHJlc3MuemVyb0FkZHJlc3MgOiB0aGlzLmFwcC5hZGRyZXNzOwoJYnl0ZWMgMyAvLyAgImMiCglhcHBfZ2xvYmFsX2dldAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CglieiAqdGVybmFyeTBfZmFsc2UKCWdsb2JhbCBaZXJvQWRkcmVzcwoJYiAqdGVybmFyeTBfZW5kCgoqdGVybmFyeTBfZmFsc2U6CglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoKKnRlcm5hcnkwX2VuZDoKCXJldHN1YgoKLy8gY3JlYXRlQXBwbGljYXRpb24oYWRkcmVzcyxhZGRyZXNzKXZvaWQKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCS8vIGFkbWluOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAyIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGFkbWluKSBmb3IgY3JlYXRlQXBwbGljYXRpb24gbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGNvbnRyb2xsZWRBZGRyZXNzOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50YyAyIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDEgKGNvbnRyb2xsZWRBZGRyZXNzKSBmb3IgY3JlYXRlQXBwbGljYXRpb24gbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGV4ZWN1dGUgY3JlYXRlQXBwbGljYXRpb24oYWRkcmVzcyxhZGRyZXNzKXZvaWQKCWNhbGxzdWIgY3JlYXRlQXBwbGljYXRpb24KCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKGNvbnRyb2xsZWRBZGRyZXNzOiBBZGRyZXNzLCBhZG1pbjogQWRkcmVzcyk6IHZvaWQKLy8KLy8gQ3JlYXRlIGFuIGFic3RyYWN0ZWQgYWNjb3VudCBhcHBsaWNhdGlvbi4KLy8gVGhpcyBpcyBub3QgcGFydCBvZiBBUkM1OCBhbmQgaW1wbGVtZW50YXRpb24gc3BlY2lmaWMuCi8vCi8vIEBwYXJhbSBjb250cm9sbGVkQWRkcmVzcyBUaGUgYWRkcmVzcyBvZiB0aGUgYWJzdHJhY3RlZCBhY2NvdW50LiBJZiB6ZXJvQWRkcmVzcywgdGhlbiB0aGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgYWNjb3VudCB3aWxsIGJlIHVzZWQKLy8gQHBhcmFtIGFkbWluIFRoZSBhZG1pbiBmb3IgdGhpcyBhcHAKY3JlYXRlQXBwbGljYXRpb246Cglwcm90byAyIDAKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjg3CgkvLyB2ZXJpZnlBcHBDYWxsVHhuKHRoaXMudHhuLCB7CgkvLyAgICAgICBzZW5kZXI6IHsgaW5jbHVkZWRJbjogW2NvbnRyb2xsZWRBZGRyZXNzLCBhZG1pbl0gfSwKCS8vICAgICB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIGNvbnRyb2xsZWRBZGRyZXNzOiBBZGRyZXNzCgk9PQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0yIC8vIGFkbWluOiBBZGRyZXNzCgk9PQoJfHwKCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6eyJ0eG5UZXh0IjoidGhpcy50eG4ifSwiZmllbGQiOiJzZW5kZXIiLCJjb25kaXRpb24iOiJpbmNsdWRlZEluIiwiZXhwZWN0ZWQiOiJbY29udHJvbGxlZEFkZHJlc3MsIGFkbWluXSJ9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjkxCgkvLyBhc3NlcnQoYWRtaW4gIT09IGNvbnRyb2xsZWRBZGRyZXNzKQoJZnJhbWVfZGlnIC0yIC8vIGFkbWluOiBBZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gY29udHJvbGxlZEFkZHJlc3M6IEFkZHJlc3MKCSE9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjkzCgkvLyB0aGlzLmFkbWluLnZhbHVlID0gYWRtaW4KCWJ5dGVjIDEgLy8gICJhIgoJZnJhbWVfZGlnIC0yIC8vIGFkbWluOiBBZGRyZXNzCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6OTQKCS8vIHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUgPSBjb250cm9sbGVkQWRkcmVzcyA9PT0gQWRkcmVzcy56ZXJvQWRkcmVzcyA/IHRoaXMuYXBwLmFkZHJlc3MgOiBjb250cm9sbGVkQWRkcmVzcwoJYnl0ZWMgMyAvLyAgImMiCglmcmFtZV9kaWcgLTEgLy8gY29udHJvbGxlZEFkZHJlc3M6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJPT0KCWJ6ICp0ZXJuYXJ5MV9mYWxzZQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWIgKnRlcm5hcnkxX2VuZAoKKnRlcm5hcnkxX2ZhbHNlOgoJZnJhbWVfZGlnIC0xIC8vIGNvbnRyb2xsZWRBZGRyZXNzOiBBZGRyZXNzCgoqdGVybmFyeTFfZW5kOgoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gYXJjNThfY2hhbmdlQWRtaW4oYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfYXJjNThfY2hhbmdlQWRtaW46CgkvLyBuZXdBZG1pbjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgMiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChuZXdBZG1pbikgZm9yIGFyYzU4X2NoYW5nZUFkbWluIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIGFyYzU4X2NoYW5nZUFkbWluKGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBhcmM1OF9jaGFuZ2VBZG1pbgoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gYXJjNThfY2hhbmdlQWRtaW4obmV3QWRtaW46IEFkZHJlc3MpOiB2b2lkCi8vCi8vIEF0dGVtcHQgdG8gY2hhbmdlIHRoZSBhZG1pbiBmb3IgdGhpcyBhcHAuIFNvbWUgaW1wbGVtZW50YXRpb25zIE1BWSBub3Qgc3VwcG9ydCB0aGlzLgovLwovLyBAcGFyYW0gbmV3QWRtaW4gVGhlIG5ldyBhZG1pbgphcmM1OF9jaGFuZ2VBZG1pbjoKCXByb3RvIDEgMAoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTAzCgkvLyB2ZXJpZnlUeG4odGhpcy50eG4sIHsgc2VuZGVyOiB0aGlzLmFkbWluLnZhbHVlIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCgl0eG4gU2VuZGVyCglieXRlYyAxIC8vICAiYSIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoidGhpcy50eG4iLCJmaWVsZCI6InNlbmRlciIsImV4cGVjdGVkIjoidGhpcy5hZG1pbi52YWx1ZSJ9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjEwNAoJLy8gdGhpcy5hZG1pbi52YWx1ZSA9IG5ld0FkbWluCglieXRlYyAxIC8vICAiYSIKCWZyYW1lX2RpZyAtMSAvLyBuZXdBZG1pbjogQWRkcmVzcwoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gYXJjNThfcGx1Z2luQ2hhbmdlQWRtaW4odWludDY0LGFkZHJlc3MsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfYXJjNThfcGx1Z2luQ2hhbmdlQWRtaW46CgkvLyBuZXdBZG1pbjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludGMgMiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChuZXdBZG1pbikgZm9yIGFyYzU4X3BsdWdpbkNoYW5nZUFkbWluIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBhbGxvd2VkQ2FsbGVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAyIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDEgKGFsbG93ZWRDYWxsZXIpIGZvciBhcmM1OF9wbHVnaW5DaGFuZ2VBZG1pbiBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gcGx1Z2luOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGFyYzU4X3BsdWdpbkNoYW5nZUFkbWluKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBhcmM1OF9wbHVnaW5DaGFuZ2VBZG1pbgoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gYXJjNThfcGx1Z2luQ2hhbmdlQWRtaW4ocGx1Z2luOiBBcHBJRCwgYWxsb3dlZENhbGxlcjogQWRkcmVzcywgbmV3QWRtaW46IEFkZHJlc3MpOiB2b2lkCi8vCi8vIEF0dGVtcHQgdG8gY2hhbmdlIHRoZSBhZG1pbiB2aWEgcGx1Z2luLgovLwovLyBAcGFyYW0gcGx1Z2luIFRoZSBhcHAgY2FsbGluZyB0aGUgcGx1Z2luCi8vIEBwYXJhbSBhbGxvd2VkQ2FsbGVyIFRoZSBhZGRyZXNzIHRoYXQgdHJpZ2dlcmVkIHRoZSBwbHVnaW4KLy8gQHBhcmFtIG5ld0FkbWluIFRoZSBuZXcgYWRtaW4KYXJjNThfcGx1Z2luQ2hhbmdlQWRtaW46Cglwcm90byAzIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMiAvLyAweAoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTE2CgkvLyB2ZXJpZnlUeG4odGhpcy50eG4sIHsgc2VuZGVyOiBwbHVnaW4uYWRkcmVzcyB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIHBsdWdpbjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InRoaXMudHhuIiwiZmllbGQiOiJzZW5kZXIiLCJleHBlY3RlZCI6InBsdWdpbi5hZGRyZXNzIn0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTE3CgkvLyBhc3NlcnQodGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZS5hdXRoQWRkciA9PT0gcGx1Z2luLmFkZHJlc3MsICdUaGlzIHBsdWdpbiBpcyBub3QgaW4gY29udHJvbCBvZiB0aGUgYWNjb3VudCcpCglieXRlYyAzIC8vICAiYyIKCWFwcF9nbG9iYWxfZ2V0CglhY2N0X3BhcmFtc19nZXQgQWNjdEF1dGhBZGRyCglwb3AKCWZyYW1lX2RpZyAtMSAvLyBwbHVnaW46IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCT09CgoJLy8gVGhpcyBwbHVnaW4gaXMgbm90IGluIGNvbnRyb2wgb2YgdGhlIGFjY291bnQKCWFzc2VydAoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTE5CgkvLyBrZXk6IFBsdWdpbnNLZXkgPSB7IGFwcGxpY2F0aW9uOiBwbHVnaW4sIGFsbG93ZWRDYWxsZXI6IGFsbG93ZWRDYWxsZXIgfQoJZnJhbWVfZGlnIC0xIC8vIHBsdWdpbjogQXBwSUQKCWl0b2IKCWZyYW1lX2RpZyAtMiAvLyBhbGxvd2VkQ2FsbGVyOiBBZGRyZXNzCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyBrZXk6IFBsdWdpbnNLZXkKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjEyMAoJLy8gYXNzZXJ0KAoJLy8gICAgICAgdGhpcy5wbHVnaW5zKGtleSkuZXhpc3RzICYmIHRoaXMucGx1Z2lucyhrZXkpLnZhbHVlLmFkbWluUHJpdmlsZWdlcywKCS8vICAgICAgICdUaGlzIHBsdWdpbiBkb2VzIG5vdCBoYXZlIGFkbWluIHByaXZpbGVnZXMnCgkvLyAgICAgKQoJYnl0ZWMgMCAvLyAgInAiCglmcmFtZV9kaWcgMCAvLyBrZXk6IFBsdWdpbnNLZXkKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglkdXAKCWJ6ICpza2lwX2FuZDQKCWJ5dGVjIDAgLy8gICJwIgoJZnJhbWVfZGlnIDAgLy8ga2V5OiBQbHVnaW5zS2V5Cgljb25jYXQKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucGx1Z2lucyhrZXkpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglwdXNoaW50IDE5MgoJZ2V0Yml0CgkmJgoKKnNraXBfYW5kNDoKCS8vIFRoaXMgcGx1Z2luIGRvZXMgbm90IGhhdmUgYWRtaW4gcHJpdmlsZWdlcwoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czoxMjUKCS8vIHRoaXMuYWRtaW4udmFsdWUgPSBuZXdBZG1pbgoJYnl0ZWMgMSAvLyAgImEiCglmcmFtZV9kaWcgLTMgLy8gbmV3QWRtaW46IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGFyYzU4X2dldEFkbWluKClhZGRyZXNzCiphYmlfcm91dGVfYXJjNThfZ2V0QWRtaW46CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCXB1c2hieXRlcyAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBhcmM1OF9nZXRBZG1pbigpYWRkcmVzcwoJY2FsbHN1YiBhcmM1OF9nZXRBZG1pbgoJY29uY2F0Cglsb2cKCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGFyYzU4X2dldEFkbWluKCk6IEFkZHJlc3MKLy8KLy8gR2V0IHRoZSBhZG1pbiBvZiB0aGlzIGFwcC4gVGhpcyBtZXRob2QgU0hPVUxEIGFsd2F5cyBiZSB1c2VkIHJhdGhlciB0aGFuIHJlYWRpbmcgZGlyZWN0bHkgZnJvbSBzdGF0ZQovLyBiZWNhdXNlIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbnMgbWF5IGhhdmUgZGlmZmVyZW50IHdheXMgb2YgZGV0ZXJtaW5pbmcgdGhlIGFkbWluLgphcmM1OF9nZXRBZG1pbjoKCXByb3RvIDAgMQoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTMzCgkvLyByZXR1cm4gdGhpcy5hZG1pbi52YWx1ZTsKCWJ5dGVjIDEgLy8gICJhIgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gYXJjNThfdmVyaWZ5QXV0aEFkZHIoKXZvaWQKKmFiaV9yb3V0ZV9hcmM1OF92ZXJpZnlBdXRoQWRkcjoKCS8vIGV4ZWN1dGUgYXJjNThfdmVyaWZ5QXV0aEFkZHIoKXZvaWQKCWNhbGxzdWIgYXJjNThfdmVyaWZ5QXV0aEFkZHIKCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGFyYzU4X3ZlcmlmeUF1dGhBZGRyKCk6IHZvaWQKLy8KLy8gVmVyaWZ5IHRoZSBhYnN0cmFjdGVkIGFjY291bnQgaXMgcmVrZXllZCB0byB0aGlzIGFwcAphcmM1OF92ZXJpZnlBdXRoQWRkcjoKCXByb3RvIDAgMAoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTQwCgkvLyBhc3NlcnQodGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZS5hdXRoQWRkciA9PT0gdGhpcy5nZXRBdXRoQWRkcigpKQoJYnl0ZWMgMyAvLyAgImMiCglhcHBfZ2xvYmFsX2dldAoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RBdXRoQWRkcgoJcG9wCgljYWxsc3ViIGdldEF1dGhBZGRyCgk9PQoJYXNzZXJ0CglyZXRzdWIKCi8vIGFyYzU4X3Jla2V5VG8oYWRkcmVzcyxib29sKXZvaWQKKmFiaV9yb3V0ZV9hcmM1OF9yZWtleVRvOgoJLy8gZmxhc2g6IGJvb2wKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDAgLy8gMQoJPT0KCgkvLyBhcmd1bWVudCAwIChmbGFzaCkgZm9yIGFyYzU4X3Jla2V5VG8gbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAxIC8vIDAKCWdldGJpdAoKCS8vIGFkZHI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDIgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMSAoYWRkcikgZm9yIGFyYzU4X3Jla2V5VG8gbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGV4ZWN1dGUgYXJjNThfcmVrZXlUbyhhZGRyZXNzLGJvb2wpdm9pZAoJY2FsbHN1YiBhcmM1OF9yZWtleVRvCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBhcmM1OF9yZWtleVRvKGFkZHI6IEFkZHJlc3MsIGZsYXNoOiBib29sZWFuKTogdm9pZAovLwovLyBSZWtleSB0aGUgYWJzdHJhY3RlZCBhY2NvdW50IHRvIGFub3RoZXIgYWRkcmVzcy4gUHJpbWFyaWx5IHVzZWZ1bCBmb3IgcmVrZXlpbmcgdG8gYW4gRU9BLgovLwovLyBAcGFyYW0gYWRkciBUaGUgYWRkcmVzcyB0byByZWtleSB0bwovLyBAcGFyYW0gZmxhc2ggV2hldGhlciBvciBub3QgdGhpcyBzaG91bGQgYmUgYSBmbGFzaCByZWtleS4gSWYgdHJ1ZSwgdGhlIHJla2V5IGJhY2sgdG8gdGhlIGFwcCBhZGRyZXNzIG11c3QgZG9uZSBpbiB0aGUgc2FtZSB0eG4gZ3JvdXAgYXMgdGhpcyBjYWxsCmFyYzU4X3Jla2V5VG86Cglwcm90byAyIDAKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjE1MAoJLy8gdmVyaWZ5QXBwQ2FsbFR4bih0aGlzLnR4biwgeyBzZW5kZXI6IHRoaXMuYWRtaW4udmFsdWUgfSkKCS8vIHZlcmlmeSBzZW5kZXIKCXR4biBTZW5kZXIKCWJ5dGVjIDEgLy8gICJhIgoJYXBwX2dsb2JhbF9nZXQKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJ0aGlzLnR4biIsImZpZWxkIjoic2VuZGVyIiwiZXhwZWN0ZWQiOiJ0aGlzLmFkbWluLnZhbHVlIn0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTUyCgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCgkvLyAgICAgICByZWNlaXZlcjogYWRkciwKCS8vICAgICAgIHJla2V5VG86IGFkZHIsCgkvLyAgICAgICBub3RlOiAncmVrZXlpbmcgYWJzdHJhY3RlZCBhY2NvdW50JywKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAwIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjE1MwoJLy8gc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlCglieXRlYyAzIC8vICAiYyIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIFNlbmRlcgoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTU0CgkvLyByZWNlaXZlcjogYWRkcgoJZnJhbWVfZGlnIC0xIC8vIGFkZHI6IEFkZHJlc3MKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjE1NQoJLy8gcmVrZXlUbzogYWRkcgoJZnJhbWVfZGlnIC0xIC8vIGFkZHI6IEFkZHJlc3MKCWl0eG5fZmllbGQgUmVrZXlUbwoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTU2CgkvLyBub3RlOiAncmVrZXlpbmcgYWJzdHJhY3RlZCBhY2NvdW50JwoJcHVzaGJ5dGVzIDB4NzI2NTZiNjU3OTY5NmU2NzIwNjE2MjczNzQ3MjYxNjM3NDY1NjQyMDYxNjM2MzZmNzU2ZTc0IC8vICJyZWtleWluZyBhYnN0cmFjdGVkIGFjY291bnQiCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDEgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gKmlmMl9jb25kaXRpb24KCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTU5CgkvLyBmbGFzaAoJZnJhbWVfZGlnIC0yIC8vIGZsYXNoOiBib29sZWFuCglieiAqaWYyX2VuZAoKCS8vICppZjJfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czoxNTkKCS8vIHRoaXMudmVyaWZ5UmVrZXlUb0Fic3RyYWN0ZWRBY2NvdW50KCkKCWNhbGxzdWIgdmVyaWZ5UmVrZXlUb0Fic3RyYWN0ZWRBY2NvdW50CgoqaWYyX2VuZDoKCXJldHN1YgoKLy8gcGx1Z2luQ2FsbEFsbG93ZWQoYXBwOiBBcHBJRCwgY2FsbGVyOiBBZGRyZXNzKTogYm9vbGVhbgpwbHVnaW5DYWxsQWxsb3dlZDoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAyIC8vIDB4CgoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czoxNjMKCS8vIGtleTogUGx1Z2luc0tleSA9IHsgYXBwbGljYXRpb246IGFwcCwgYWxsb3dlZENhbGxlcjogY2FsbGVyIH0KCWZyYW1lX2RpZyAtMSAvLyBhcHA6IEFwcElECglpdG9iCglmcmFtZV9kaWcgLTIgLy8gY2FsbGVyOiBBZGRyZXNzCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyBrZXk6IFBsdWdpbnNLZXkKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjE2NQoJLy8gcmV0dXJuICgKCS8vICAgICAgIHRoaXMucGx1Z2lucyhrZXkpLmV4aXN0cyAmJgoJLy8gICAgICAgdGhpcy5wbHVnaW5zKGtleSkudmFsdWUubGFzdFZhbGlkUm91bmQgPj0gZ2xvYmFscy5yb3VuZCAmJgoJLy8gICAgICAgZ2xvYmFscy5yb3VuZCAtIHRoaXMucGx1Z2lucyhrZXkpLnZhbHVlLmxhc3RDYWxsZWQgPj0gdGhpcy5wbHVnaW5zKGtleSkudmFsdWUuY29vbGRvd24KCS8vICAgICApOwoJYnl0ZWMgMCAvLyAgInAiCglmcmFtZV9kaWcgMCAvLyBrZXk6IFBsdWdpbnNLZXkKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglkdXAKCWJ6ICpza2lwX2FuZDUKCWJ5dGVjIDAgLy8gICJwIgoJZnJhbWVfZGlnIDAgLy8ga2V5OiBQbHVnaW5zS2V5Cgljb25jYXQKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucGx1Z2lucyhrZXkpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDAgOAoJYnRvaQoJZ2xvYmFsIFJvdW5kCgk+PQoJJiYKCipza2lwX2FuZDU6CglkdXAKCWJ6ICpza2lwX2FuZDYKCWdsb2JhbCBSb3VuZAoJYnl0ZWMgMCAvLyAgInAiCglmcmFtZV9kaWcgMCAvLyBrZXk6IFBsdWdpbnNLZXkKCWNvbmNhdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wbHVnaW5zKGtleSkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgMTYgOAoJYnRvaQoJLQoJYnl0ZWMgMCAvLyAgInAiCglmcmFtZV9kaWcgMCAvLyBrZXk6IFBsdWdpbnNLZXkKCWNvbmNhdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wbHVnaW5zKGtleSkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgOCA4CglidG9pCgk+PQoJJiYKCipza2lwX2FuZDY6CgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gYXJjNThfcmVrZXlUb1BsdWdpbih1aW50NjQpdm9pZAoqYWJpX3JvdXRlX2FyYzU4X3Jla2V5VG9QbHVnaW46CgkvLyBwbHVnaW46IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgYXJjNThfcmVrZXlUb1BsdWdpbih1aW50NjQpdm9pZAoJY2FsbHN1YiBhcmM1OF9yZWtleVRvUGx1Z2luCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBhcmM1OF9yZWtleVRvUGx1Z2luKHBsdWdpbjogQXBwSUQpOiB2b2lkCi8vCi8vIFRlbXBvcmFyaWx5IHJla2V5IHRvIGFuIGFwcHJvdmVkIHBsdWdpbiBhcHAgYWRkcmVzcwovLwovLyBAcGFyYW0gcGx1Z2luIFRoZSBhcHAgdG8gcmVrZXkgdG8KYXJjNThfcmVrZXlUb1BsdWdpbjoKCXByb3RvIDEgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAyIC8vIDB4CgoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czoxNzgKCS8vIGdsb2JhbEFsbG93ZWQgPSB0aGlzLnBsdWdpbkNhbGxBbGxvd2VkKHBsdWdpbiwgQWRkcmVzcy56ZXJvQWRkcmVzcykKCWdsb2JhbCBaZXJvQWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIHBsdWdpbjogQXBwSUQKCWNhbGxzdWIgcGx1Z2luQ2FsbEFsbG93ZWQKCWZyYW1lX2J1cnkgMCAvLyBnbG9iYWxBbGxvd2VkOiBib29sCgoJLy8gKmlmM19jb25kaXRpb24KCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTgwCgkvLyAhZ2xvYmFsQWxsb3dlZAoJZnJhbWVfZGlnIDAgLy8gZ2xvYmFsQWxsb3dlZDogYm9vbAoJIQoJYnogKmlmM19lbmQKCgkvLyAqaWYzX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTgxCgkvLyBhc3NlcnQodGhpcy5wbHVnaW5DYWxsQWxsb3dlZChwbHVnaW4sIHRoaXMudHhuLnNlbmRlciksICdUaGlzIHNlbmRlciBpcyBub3QgYWxsb3dlZCB0byB0cmlnZ2VyIHRoaXMgcGx1Z2luJykKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBwbHVnaW46IEFwcElECgljYWxsc3ViIHBsdWdpbkNhbGxBbGxvd2VkCgoJLy8gVGhpcyBzZW5kZXIgaXMgbm90IGFsbG93ZWQgdG8gdHJpZ2dlciB0aGlzIHBsdWdpbgoJYXNzZXJ0CgoqaWYzX2VuZDoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTgzCgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCgkvLyAgICAgICByZWNlaXZlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKCS8vICAgICAgIHJla2V5VG86IHBsdWdpbi5hZGRyZXNzLAoJLy8gICAgICAgbm90ZTogJ3Jla2V5aW5nIHRvIHBsdWdpbiBhcHAnLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDAgLy8gIHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTg0CgkvLyBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUKCWJ5dGVjIDMgLy8gICJjIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czoxODUKCS8vIHJlY2VpdmVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlCglieXRlYyAzIC8vICAiYyIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czoxODYKCS8vIHJla2V5VG86IHBsdWdpbi5hZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gcGx1Z2luOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglpdHhuX2ZpZWxkIFJla2V5VG8KCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjE4NwoJLy8gbm90ZTogJ3Jla2V5aW5nIHRvIHBsdWdpbiBhcHAnCglwdXNoYnl0ZXMgMHg3MjY1NmI2NTc5Njk2ZTY3MjA3NDZmMjA3MDZjNzU2NzY5NmUyMDYxNzA3MCAvLyAicmVrZXlpbmcgdG8gcGx1Z2luIGFwcCIKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMSAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjE5MAoJLy8gdGhpcy5wbHVnaW5zKHsKCS8vICAgICAgIGFwcGxpY2F0aW9uOiBwbHVnaW4sCgkvLyAgICAgICBhbGxvd2VkQ2FsbGVyOiBnbG9iYWxBbGxvd2VkID8gQWRkcmVzcy56ZXJvQWRkcmVzcyA6IHRoaXMudHhuLnNlbmRlciwKCS8vICAgICB9KS52YWx1ZS5sYXN0Q2FsbGVkID0gZ2xvYmFscy5yb3VuZAoJYnl0ZWMgMCAvLyAgInAiCglmcmFtZV9kaWcgLTEgLy8gcGx1Z2luOiBBcHBJRAoJaXRvYgoJZnJhbWVfZGlnIDAgLy8gZ2xvYmFsQWxsb3dlZDogYm9vbAoJYnogKnRlcm5hcnkzX2ZhbHNlCglnbG9iYWwgWmVyb0FkZHJlc3MKCWIgKnRlcm5hcnkzX2VuZAoKKnRlcm5hcnkzX2ZhbHNlOgoJdHhuIFNlbmRlcgoKKnRlcm5hcnkzX2VuZDoKCWNvbmNhdAoJY29uY2F0Cglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnBsdWdpbnMoeyBhcHBsaWNhdGlvbjogcGx1Z2luLCBhbGxvd2VkQ2FsbGVyOiBnbG9iYWxBbGxvd2VkID8gQWRkcmVzcy56ZXJvQWRkcmVzcyA6IHRoaXMudHhuLnNlbmRlciwgfSkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXB1c2hpbnQgMTYKCWdsb2JhbCBSb3VuZAoJaXRvYgoJYnl0ZWMgMCAvLyAgInAiCglmcmFtZV9kaWcgLTEgLy8gcGx1Z2luOiBBcHBJRAoJaXRvYgoJZnJhbWVfZGlnIDAgLy8gZ2xvYmFsQWxsb3dlZDogYm9vbAoJYnogKnRlcm5hcnk1X2ZhbHNlCglnbG9iYWwgWmVyb0FkZHJlc3MKCWIgKnRlcm5hcnk1X2VuZAoKKnRlcm5hcnk1X2ZhbHNlOgoJdHhuIFNlbmRlcgoKKnRlcm5hcnk1X2VuZDoKCWNvbmNhdAoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MTk1CgkvLyB0aGlzLnZlcmlmeVJla2V5VG9BYnN0cmFjdGVkQWNjb3VudCgpCgljYWxsc3ViIHZlcmlmeVJla2V5VG9BYnN0cmFjdGVkQWNjb3VudAoJcmV0c3ViCgovLyBhcmM1OF9yZWtleVRvTmFtZWRQbHVnaW4oc3RyaW5nKXZvaWQKKmFiaV9yb3V0ZV9hcmM1OF9yZWtleVRvTmFtZWRQbHVnaW46CgkvLyBuYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBhcmM1OF9yZWtleVRvTmFtZWRQbHVnaW4oc3RyaW5nKXZvaWQKCWNhbGxzdWIgYXJjNThfcmVrZXlUb05hbWVkUGx1Z2luCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBhcmM1OF9yZWtleVRvTmFtZWRQbHVnaW4obmFtZTogc3RyaW5nKTogdm9pZAovLwovLyBUZW1wb3JhcmlseSByZWtleSB0byBhIG5hbWVkIHBsdWdpbiBhcHAgYWRkcmVzcwovLwovLyBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIHJla2V5IHRvCmFyYzU4X3Jla2V5VG9OYW1lZFBsdWdpbjoKCXByb3RvIDEgMAoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MjA0CgkvLyB0aGlzLmFyYzU4X3Jla2V5VG9QbHVnaW4odGhpcy5uYW1lZFBsdWdpbnMobmFtZSkudmFsdWUuYXBwbGljYXRpb24pCglpbnRjIDEgLy8gMAoJcHVzaGludCA4CglieXRlYyA0IC8vICAibiIKCWZyYW1lX2RpZyAtMSAvLyBuYW1lOiBzdHJpbmcKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWNhbGxzdWIgYXJjNThfcmVrZXlUb1BsdWdpbgoJcmV0c3ViCgovLyBhcmM1OF9hZGRQbHVnaW4odWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCxib29sKXZvaWQKKmFiaV9yb3V0ZV9hcmM1OF9hZGRQbHVnaW46CgkvLyBhZG1pblByaXZpbGVnZXM6IGJvb2wKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWR1cAoJbGVuCglpbnRjIDAgLy8gMQoJPT0KCgkvLyBhcmd1bWVudCAwIChhZG1pblByaXZpbGVnZXMpIGZvciBhcmM1OF9hZGRQbHVnaW4gbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAxIC8vIDAKCWdldGJpdAoKCS8vIGNvb2xkb3duOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBsYXN0VmFsaWRSb3VuZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gYWxsb3dlZENhbGxlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAzIChhbGxvd2VkQ2FsbGVyKSBmb3IgYXJjNThfYWRkUGx1Z2luIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBhcHA6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgYXJjNThfYWRkUGx1Z2luKHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYm9vbCl2b2lkCgljYWxsc3ViIGFyYzU4X2FkZFBsdWdpbgoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gYXJjNThfYWRkUGx1Z2luKGFwcDogQXBwSUQsIGFsbG93ZWRDYWxsZXI6IEFkZHJlc3MsIGxhc3RWYWxpZFJvdW5kOiB1aW50NjQsIGNvb2xkb3duOiB1aW50NjQsIGFkbWluUHJpdmlsZWdlczogYm9vbGVhbik6IHZvaWQKLy8KLy8gQWRkIGFuIGFwcCB0byB0aGUgbGlzdCBvZiBhcHByb3ZlZCBwbHVnaW5zCi8vCi8vIEBwYXJhbSBhcHAgVGhlIGFwcCB0byBhZGQKLy8gQHBhcmFtIGFsbG93ZWRDYWxsZXIgVGhlIGFkZHJlc3Mgb2YgdGhhdCdzIGFsbG93ZWQgdG8gY2FsbCB0aGUgYXBwCi8vIG9yIHRoZSBnbG9iYWwgemVybyBhZGRyZXNzIGZvciBhbGwgYWRkcmVzc2VzCi8vIEBwYXJhbSBsYXN0VmFsaWRSb3VuZCBUaGUgcm91bmQgd2hlbiB0aGUgcGVybWlzc2lvbiBleHBpcmVzCi8vIEBwYXJhbSBjb29sZG93biAgVGhlIG51bWJlciBvZiByb3VuZHMgdGhhdCBtdXN0IHBhc3MgYmVmb3JlIHRoZSBwbHVnaW4gY2FuIGJlIGNhbGxlZCBhZ2FpbgovLyBAcGFyYW0gYWRtaW5Qcml2aWxlZ2VzIFdoZXRoZXIgdGhlIHBsdWdpbiBoYXMgcGVybWlzc2lvbnMgdG8gY2hhbmdlIHRoZSBhZG1pbiBhY2NvdW50CmFyYzU4X2FkZFBsdWdpbjoKCXByb3RvIDUgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAyIC8vIDB4CgoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czoyMjQKCS8vIHZlcmlmeVR4bih0aGlzLnR4biwgeyBzZW5kZXI6IHRoaXMuYWRtaW4udmFsdWUgfSkKCS8vIHZlcmlmeSBzZW5kZXIKCXR4biBTZW5kZXIKCWJ5dGVjIDEgLy8gICJhIgoJYXBwX2dsb2JhbF9nZXQKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJ0aGlzLnR4biIsImZpZWxkIjoic2VuZGVyIiwiZXhwZWN0ZWQiOiJ0aGlzLmFkbWluLnZhbHVlIn0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MjI1CgkvLyBrZXk6IFBsdWdpbnNLZXkgPSB7IGFwcGxpY2F0aW9uOiBhcHAsIGFsbG93ZWRDYWxsZXI6IGFsbG93ZWRDYWxsZXIgfQoJZnJhbWVfZGlnIC0xIC8vIGFwcDogQXBwSUQKCWl0b2IKCWZyYW1lX2RpZyAtMiAvLyBhbGxvd2VkQ2FsbGVyOiBBZGRyZXNzCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyBrZXk6IFBsdWdpbnNLZXkKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjIyNgoJLy8gdGhpcy5wbHVnaW5zKGtleSkudmFsdWUgPSB7CgkvLyAgICAgICBsYXN0VmFsaWRSb3VuZDogbGFzdFZhbGlkUm91bmQsCgkvLyAgICAgICBjb29sZG93bjogY29vbGRvd24sCgkvLyAgICAgICBsYXN0Q2FsbGVkOiAwLAoJLy8gICAgICAgYWRtaW5Qcml2aWxlZ2VzOiBhZG1pblByaXZpbGVnZXMsCgkvLyAgICAgfQoJYnl0ZWMgMCAvLyAgInAiCglmcmFtZV9kaWcgMCAvLyBrZXk6IFBsdWdpbnNLZXkKCWNvbmNhdAoJZnJhbWVfZGlnIC0zIC8vIGxhc3RWYWxpZFJvdW5kOiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAtNCAvLyBjb29sZG93bjogdWludDY0CglpdG9iCgljb25jYXQKCWJ5dGVjIDUgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCgljb25jYXQKCWJ5dGVjIDcgLy8gMHgwMAoJaW50YyAxIC8vIDAKCWZyYW1lX2RpZyAtNSAvLyBhZG1pblByaXZpbGVnZXM6IGJvb2xlYW4KCXNldGJpdAoJY29uY2F0Cglib3hfcHV0CglyZXRzdWIKCi8vIGFyYzU4X3JlbW92ZVBsdWdpbih1aW50NjQsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfYXJjNThfcmVtb3ZlUGx1Z2luOgoJLy8gYWxsb3dlZENhbGxlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChhbGxvd2VkQ2FsbGVyKSBmb3IgYXJjNThfcmVtb3ZlUGx1Z2luIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBhcHA6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgYXJjNThfcmVtb3ZlUGx1Z2luKHVpbnQ2NCxhZGRyZXNzKXZvaWQKCWNhbGxzdWIgYXJjNThfcmVtb3ZlUGx1Z2luCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBhcmM1OF9yZW1vdmVQbHVnaW4oYXBwOiBBcHBJRCwgYWxsb3dlZENhbGxlcjogQWRkcmVzcyk6IHZvaWQKLy8KLy8gUmVtb3ZlIGFuIGFwcCBmcm9tIHRoZSBsaXN0IG9mIGFwcHJvdmVkIHBsdWdpbnMKLy8KLy8gQHBhcmFtIGFwcCBUaGUgYXBwIHRvIHJlbW92ZQphcmM1OF9yZW1vdmVQbHVnaW46Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMiAvLyAweAoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MjQwCgkvLyB2ZXJpZnlUeG4odGhpcy50eG4sIHsgc2VuZGVyOiB0aGlzLmFkbWluLnZhbHVlIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCgl0eG4gU2VuZGVyCglieXRlYyAxIC8vICAiYSIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoidGhpcy50eG4iLCJmaWVsZCI6InNlbmRlciIsImV4cGVjdGVkIjoidGhpcy5hZG1pbi52YWx1ZSJ9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjI0MgoJLy8ga2V5OiBQbHVnaW5zS2V5ID0geyBhcHBsaWNhdGlvbjogYXBwLCBhbGxvd2VkQ2FsbGVyOiBhbGxvd2VkQ2FsbGVyIH0KCWZyYW1lX2RpZyAtMSAvLyBhcHA6IEFwcElECglpdG9iCglmcmFtZV9kaWcgLTIgLy8gYWxsb3dlZENhbGxlcjogQWRkcmVzcwoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8ga2V5OiBQbHVnaW5zS2V5CgoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czoyNDMKCS8vIHRoaXMucGx1Z2lucyhrZXkpLmRlbGV0ZSgpCglieXRlYyAwIC8vICAicCIKCWZyYW1lX2RpZyAwIC8vIGtleTogUGx1Z2luc0tleQoJY29uY2F0Cglib3hfZGVsCglyZXRzdWIKCi8vIGFyYzU4X2FkZE5hbWVkUGx1Z2luKHN0cmluZyx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LGJvb2wpdm9pZAoqYWJpX3JvdXRlX2FyYzU4X2FkZE5hbWVkUGx1Z2luOgoJLy8gYWRtaW5Qcml2aWxlZ2VzOiBib29sCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA2CglkdXAKCWxlbgoJaW50YyAwIC8vIDEKCT09CgoJLy8gYXJndW1lbnQgMCAoYWRtaW5Qcml2aWxlZ2VzKSBmb3IgYXJjNThfYWRkTmFtZWRQbHVnaW4gbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAxIC8vIDAKCWdldGJpdAoKCS8vIGNvb2xkb3duOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWJ0b2kKCgkvLyBsYXN0VmFsaWRSb3VuZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglidG9pCgoJLy8gYWxsb3dlZENhbGxlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludGMgMiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAzIChhbGxvd2VkQ2FsbGVyKSBmb3IgYXJjNThfYWRkTmFtZWRQbHVnaW4gbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGFwcDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gbmFtZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgYXJjNThfYWRkTmFtZWRQbHVnaW4oc3RyaW5nLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYm9vbCl2b2lkCgljYWxsc3ViIGFyYzU4X2FkZE5hbWVkUGx1Z2luCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBhcmM1OF9hZGROYW1lZFBsdWdpbihuYW1lOiBzdHJpbmcsIGFwcDogQXBwSUQsIGFsbG93ZWRDYWxsZXI6IEFkZHJlc3MsIGxhc3RWYWxpZFJvdW5kOiB1aW50NjQsIGNvb2xkb3duOiB1aW50NjQsIGFkbWluUHJpdmlsZWdlczogYm9vbGVhbik6IHZvaWQKLy8KLy8gQWRkIGEgbmFtZWQgcGx1Z2luCi8vCi8vIEBwYXJhbSBhcHAgVGhlIHBsdWdpbiBhcHAKLy8gQHBhcmFtIG5hbWUgVGhlIHBsdWdpbiBuYW1lCi8vIEBwYXJhbSBhbGxvd2VkQ2FsbGVyIFRoZSBhZGRyZXNzIG9mIHRoYXQncyBhbGxvd2VkIHRvIGNhbGwgdGhlIGFwcAovLyBvciB0aGUgZ2xvYmFsIHplcm8gYWRkcmVzcyBmb3IgYWxsIGFkZHJlc3NlcwovLyBAcGFyYW0gbGFzdFZhbGlkUm91bmQgVGhlIHJvdW5kIHdoZW4gdGhlIHBlcm1pc3Npb24gZXhwaXJlcwovLyBAcGFyYW0gY29vbGRvd24gIFRoZSBudW1iZXIgb2Ygcm91bmRzIHRoYXQgbXVzdCBwYXNzIGJlZm9yZSB0aGUgcGx1Z2luIGNhbiBiZSBjYWxsZWQgYWdhaW4KLy8gQHBhcmFtIGFkbWluUHJpdmlsZWdlcyBXaGV0aGVyIHRoZSBwbHVnaW4gaGFzIHBlcm1pc3Npb25zIHRvIGNoYW5nZSB0aGUgYWRtaW4gYWNjb3VudAphcmM1OF9hZGROYW1lZFBsdWdpbjoKCXByb3RvIDYgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAyIC8vIDB4CgoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czoyNjUKCS8vIHZlcmlmeVR4bih0aGlzLnR4biwgeyBzZW5kZXI6IHRoaXMuYWRtaW4udmFsdWUgfSkKCS8vIHZlcmlmeSBzZW5kZXIKCXR4biBTZW5kZXIKCWJ5dGVjIDEgLy8gICJhIgoJYXBwX2dsb2JhbF9nZXQKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJ0aGlzLnR4biIsImZpZWxkIjoic2VuZGVyIiwiZXhwZWN0ZWQiOiJ0aGlzLmFkbWluLnZhbHVlIn0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MjY2CgkvLyBhc3NlcnQoIXRoaXMubmFtZWRQbHVnaW5zKG5hbWUpLmV4aXN0cykKCWJ5dGVjIDQgLy8gICJuIgoJZnJhbWVfZGlnIC0xIC8vIG5hbWU6IHN0cmluZwoJY29uY2F0Cglib3hfbGVuCglzd2FwCglwb3AKCSEKCWFzc2VydAoKCS8vIGV4YW1wbGVzL2FyYzU4L2FyYzU4LmFsZ28udHM6MjY4CgkvLyBrZXk6IFBsdWdpbnNLZXkgPSB7IGFwcGxpY2F0aW9uOiBhcHAsIGFsbG93ZWRDYWxsZXI6IGFsbG93ZWRDYWxsZXIgfQoJZnJhbWVfZGlnIC0yIC8vIGFwcDogQXBwSUQKCWl0b2IKCWZyYW1lX2RpZyAtMyAvLyBhbGxvd2VkQ2FsbGVyOiBBZGRyZXNzCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyBrZXk6IFBsdWdpbnNLZXkKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjI2OQoJLy8gdGhpcy5uYW1lZFBsdWdpbnMobmFtZSkudmFsdWUgPSBrZXkKCWJ5dGVjIDQgLy8gICJuIgoJZnJhbWVfZGlnIC0xIC8vIG5hbWU6IHN0cmluZwoJY29uY2F0CglmcmFtZV9kaWcgMCAvLyBrZXk6IFBsdWdpbnNLZXkKCWJveF9wdXQKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjI3MAoJLy8gdGhpcy5wbHVnaW5zKGtleSkudmFsdWUgPSB7CgkvLyAgICAgICBsYXN0VmFsaWRSb3VuZDogbGFzdFZhbGlkUm91bmQsCgkvLyAgICAgICBjb29sZG93bjogY29vbGRvd24sCgkvLyAgICAgICBsYXN0Q2FsbGVkOiAwLAoJLy8gICAgICAgYWRtaW5Qcml2aWxlZ2VzOiBhZG1pblByaXZpbGVnZXMsCgkvLyAgICAgfQoJYnl0ZWMgMCAvLyAgInAiCglmcmFtZV9kaWcgMCAvLyBrZXk6IFBsdWdpbnNLZXkKCWNvbmNhdAoJZnJhbWVfZGlnIC00IC8vIGxhc3RWYWxpZFJvdW5kOiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAtNSAvLyBjb29sZG93bjogdWludDY0CglpdG9iCgljb25jYXQKCWJ5dGVjIDUgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCgljb25jYXQKCWJ5dGVjIDcgLy8gMHgwMAoJaW50YyAxIC8vIDAKCWZyYW1lX2RpZyAtNiAvLyBhZG1pblByaXZpbGVnZXM6IGJvb2xlYW4KCXNldGJpdAoJY29uY2F0Cglib3hfcHV0CglyZXRzdWIKCi8vIGFyYzU4X3JlbW92ZU5hbWVkUGx1Z2luKHN0cmluZyl2b2lkCiphYmlfcm91dGVfYXJjNThfcmVtb3ZlTmFtZWRQbHVnaW46CgkvLyBuYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBhcmM1OF9yZW1vdmVOYW1lZFBsdWdpbihzdHJpbmcpdm9pZAoJY2FsbHN1YiBhcmM1OF9yZW1vdmVOYW1lZFBsdWdpbgoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gYXJjNThfcmVtb3ZlTmFtZWRQbHVnaW4obmFtZTogc3RyaW5nKTogdm9pZAovLwovLyBSZW1vdmUgYSBuYW1lZCBwbHVnaW4KLy8KLy8gQHBhcmFtIG5hbWUgVGhlIHBsdWdpbiBuYW1lCmFyYzU4X3JlbW92ZU5hbWVkUGx1Z2luOgoJcHJvdG8gMSAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDIgLy8gMHgKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjI4NAoJLy8gdmVyaWZ5VHhuKHRoaXMudHhuLCB7IHNlbmRlcjogdGhpcy5hZG1pbi52YWx1ZSB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJdHhuIFNlbmRlcgoJYnl0ZWMgMSAvLyAgImEiCglhcHBfZ2xvYmFsX2dldAoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InRoaXMudHhuIiwiZmllbGQiOiJzZW5kZXIiLCJleHBlY3RlZCI6InRoaXMuYWRtaW4udmFsdWUifQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czoyODYKCS8vIGFwcCA9IHRoaXMubmFtZWRQbHVnaW5zKG5hbWUpLnZhbHVlCglieXRlYyA0IC8vICAibiIKCWZyYW1lX2RpZyAtMSAvLyBuYW1lOiBzdHJpbmcKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIHN0b3JhZ2Uga2V5Ly9hcHAKCgkvLyBleGFtcGxlcy9hcmM1OC9hcmM1OC5hbGdvLnRzOjI4NwoJLy8gdGhpcy5uYW1lZFBsdWdpbnMobmFtZSkuZGVsZXRlKCkKCWJ5dGVjIDQgLy8gICJuIgoJZnJhbWVfZGlnIC0xIC8vIG5hbWU6IHN0cmluZwoJY29uY2F0Cglib3hfZGVsCgoJLy8gZXhhbXBsZXMvYXJjNTgvYXJjNTguYWxnby50czoyODgKCS8vIHRoaXMucGx1Z2lucyhhcHApLmRlbGV0ZSgpCglieXRlYyAwIC8vICAicCIKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9hcHAKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMubmFtZWRQbHVnaW5zKG5hbWUpLnZhbHVlCglhc3NlcnQKCWNvbmNhdAoJYm94X2RlbAoJcmV0c3ViCgoqY3JlYXRlX05vT3A6CglwdXNoYnl0ZXMgMHhiNGM3N2Q3MSAvLyBtZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKGFkZHJlc3MsYWRkcmVzcyl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjcmVhdGUgTm9PcAoJZXJyCgoqY2FsbF9Ob09wOgoJcHVzaGJ5dGVzIDB4ZDI0Yjc1NTYgLy8gbWV0aG9kICJhcmM1OF9jaGFuZ2VBZG1pbihhZGRyZXNzKXZvaWQiCglwdXNoYnl0ZXMgMHg1ZmE0NDljNiAvLyBtZXRob2QgImFyYzU4X3BsdWdpbkNoYW5nZUFkbWluKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3Mpdm9pZCIKCXB1c2hieXRlcyAweDEzYmM0NGU0IC8vIG1ldGhvZCAiYXJjNThfZ2V0QWRtaW4oKWFkZHJlc3MiCglieXRlYyA2IC8vICBtZXRob2QgImFyYzU4X3ZlcmlmeUF1dGhBZGRyKCl2b2lkIgoJcHVzaGJ5dGVzIDB4Yzk1YTVkM2QgLy8gbWV0aG9kICJhcmM1OF9yZWtleVRvKGFkZHJlc3MsYm9vbCl2b2lkIgoJcHVzaGJ5dGVzIDB4N2M3NjZkZGMgLy8gbWV0aG9kICJhcmM1OF9yZWtleVRvUGx1Z2luKHVpbnQ2NCl2b2lkIgoJcHVzaGJ5dGVzIDB4NTZmMjhiNTggLy8gbWV0aG9kICJhcmM1OF9yZWtleVRvTmFtZWRQbHVnaW4oc3RyaW5nKXZvaWQiCglwdXNoYnl0ZXMgMHhkMTJkY2I2MSAvLyBtZXRob2QgImFyYzU4X2FkZFBsdWdpbih1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LGJvb2wpdm9pZCIKCXB1c2hieXRlcyAweDRkMzcyMzU1IC8vIG1ldGhvZCAiYXJjNThfcmVtb3ZlUGx1Z2luKHVpbnQ2NCxhZGRyZXNzKXZvaWQiCglwdXNoYnl0ZXMgMHg4YTcyYTc1MCAvLyBtZXRob2QgImFyYzU4X2FkZE5hbWVkUGx1Z2luKHN0cmluZyx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LGJvb2wpdm9pZCIKCXB1c2hieXRlcyAweGUzNTBiOWQ0IC8vIG1ldGhvZCAiYXJjNThfcmVtb3ZlTmFtZWRQbHVnaW4oc3RyaW5nKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2FyYzU4X2NoYW5nZUFkbWluICphYmlfcm91dGVfYXJjNThfcGx1Z2luQ2hhbmdlQWRtaW4gKmFiaV9yb3V0ZV9hcmM1OF9nZXRBZG1pbiAqYWJpX3JvdXRlX2FyYzU4X3ZlcmlmeUF1dGhBZGRyICphYmlfcm91dGVfYXJjNThfcmVrZXlUbyAqYWJpX3JvdXRlX2FyYzU4X3Jla2V5VG9QbHVnaW4gKmFiaV9yb3V0ZV9hcmM1OF9yZWtleVRvTmFtZWRQbHVnaW4gKmFiaV9yb3V0ZV9hcmM1OF9hZGRQbHVnaW4gKmFiaV9yb3V0ZV9hcmM1OF9yZW1vdmVQbHVnaW4gKmFiaV9yb3V0ZV9hcmM1OF9hZGROYW1lZFBsdWdpbiAqYWJpX3JvdXRlX2FyYzU4X3JlbW92ZU5hbWVkUGx1Z2luCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNhbGwgTm9PcAoJZXJy",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 2,
      "num_uints": 0,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples ARC72 Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 32 1 256 0 288
bytecblock 0x 0x151f7c75 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0x696e646578

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// arc72_ownerOf(uint256)address
*abi_route_arc72_ownerOf:
	// The ABI return prefix
	bytec 1 // 0x151f7c75

	// tokenId: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 0 (tokenId) for arc72_ownerOf must be a uint256
	assert

	// execute arc72_ownerOf(uint256)address
	callsub arc72_ownerOf
	concat
	log
	intc 1 // 1
	return

// arc72_ownerOf(tokenId: uint256): Address
//
//
// Returns the address of the current owner of the NFT with the given tokenId
//
// @param tokenId The ID of the NFT
// @returns The current owner of the NFT
arc72_ownerOf:
	proto 1 1

	// examples/arc72/arc72.algo.ts:25
	// return this.tokenBox(tokenId).value.owner;
	frame_dig -1 // tokenId: uint256
	intc 3 // 0
	intc 0 // 32
	box_extract
	retsub

// arc72_tokenURI(uint256)byte[256]
*abi_route_arc72_tokenURI:
	// The ABI return prefix
	bytec 1 // 0x151f7c75

	// tokenId: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 0 (tokenId) for arc72_tokenURI must be a uint256
	assert

	// execute arc72_tokenURI(uint256)byte[256]
	callsub arc72_tokenURI
	concat
	log
	intc 1 // 1
	return

// arc72_tokenURI(tokenId: uint256): Bytes256
//
//
// Returns a URI pointing to the NFT metadata
//
// @param tokenId The ID of the NFT
// @returns URI to token metadata
arc72_tokenURI:
	proto 1 1

	// examples/arc72/arc72.algo.ts:37
	// return this.tokenBox(tokenId).value.uri;
	frame_dig -1 // tokenId: uint256
	intc 0 //  headOffset
	intc 2 // 256
	box_extract
	retsub

// transferTo(to: Address, tokenId: uint256): void
transferTo:
	proto 2 0

	// examples/arc72/arc72.algo.ts:41
	// this.tokenBox(tokenId).value.owner = to
	frame_dig -2 // tokenId: uint256
	intc 3 // 0
	frame_dig -1 // to: Address
	box_replace
	retsub

// arc72_transferFrom(address,address,uint256)void
*abi_route_arc72_transferFrom:
	// tokenId: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 0 (tokenId) for arc72_transferFrom must be a uint256
	assert

	// to: address
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 1 (to) for arc72_transferFrom must be a address
	assert

	// _from: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 2 (_from) for arc72_transferFrom must be a address
	assert

	// execute arc72_transferFrom(address,address,uint256)void
	callsub arc72_transferFrom
	intc 1 // 1
	return

// arc72_transferFrom(_from: Address, to: Address, tokenId: uint256): void
//
// Transfers ownership of an NFT
arc72_transferFrom:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// examples/arc72/arc72.algo.ts:48
	// token = this.tokenBox(tokenId).value
	frame_dig -3 // tokenId: uint256
	frame_bury 0 // storage key//token

	// examples/arc72/arc72.algo.ts:50
	// key: Control = { owner: this.txn.sender, controller: _from }
	txn Sender
	frame_dig -1 // _from: Address
	concat
	frame_bury 1 // key: Control

	// *if0_condition
	// examples/arc72/arc72.algo.ts:52
	// this.txn.sender === _from || this.txn.sender === token.controller || this.controlBox(key).exists
	txn Sender
	frame_dig -1 // _from: Address
	==
	dup
	bnz *skip_or0
	txn Sender
	frame_dig -3 // tokenId: uint256
	intc 4 //  headOffset
	intc 0 // 32
	box_extract
	==
	||

*skip_or0:
	dup
	bnz *skip_or1
	frame_dig 1 // key: Control
	box_len
	swap
	pop
	||

*skip_or1:
	bz *if0_else

	// *if0_consequent
	// examples/arc72/arc72.algo.ts:53
	// this.transferTo(to, tokenId)
	frame_dig -3 // tokenId: uint256
	frame_dig -2 // to: Address
	callsub transferTo
	b *if0_end

*if0_else:
	// Transfer not authorized
	err

*if0_end:
	retsub

// arc72_approve(address,uint256)void
*abi_route_arc72_approve:
	// tokenId: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 0 (tokenId) for arc72_approve must be a uint256
	assert

	// approved: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 1 (approved) for arc72_approve must be a address
	assert

	// execute arc72_approve(address,uint256)void
	callsub arc72_approve
	intc 1 // 1
	return

// arc72_approve(approved: Address, tokenId: uint256): void
//
//
// Approve a controller for a single NFT
//
// @param approved Approved controller address
// @param tokenId The ID of the NFT
arc72_approve:
	proto 2 0

	// examples/arc72/arc72.algo.ts:65
	// this.tokenBox(tokenId).value.controller = approved
	frame_dig -2 // tokenId: uint256
	intc 4 //  headOffset
	frame_dig -1 // approved: Address
	box_replace
	retsub

// arc72_setApprovalForAll(address,bool)void
*abi_route_arc72_setApprovalForAll:
	// approved: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 0 (approved) for arc72_setApprovalForAll must be a bool
	assert
	intc 3 // 0
	getbit

	// operator: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 1 (operator) for arc72_setApprovalForAll must be a address
	assert

	// execute arc72_setApprovalForAll(address,bool)void
	callsub arc72_setApprovalForAll
	intc 1 // 1
	return

// arc72_setApprovalForAll(operator: Address, approved: boolean): void
//
//
// Approve an operator for all NFTs for a user
//
// @param operator Approved operator address
// @param approved true to give approval, false to revoke
// @returns
arc72_setApprovalForAll:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/arc72/arc72.algo.ts:77
	// key: Control = { owner: this.txn.sender, controller: operator }
	txn Sender
	frame_dig -1 // operator: Address
	concat
	frame_bury 0 // key: Control

	// *if1_condition
	// examples/arc72/arc72.algo.ts:79
	// approved
	frame_dig -2 // approved: boolean
	bz *if1_elseif1_condition

	// *if1_consequent
	// examples/arc72/arc72.algo.ts:79
	// this.controlBox(key).value = ''
	frame_dig 0 // key: Control
	dup
	box_del
	pop
	bytec 0 //  ""
	box_put
	b *if1_end

*if1_elseif1_condition:
	// examples/arc72/arc72.algo.ts:80
	// this.controlBox(key).exists
	frame_dig 0 // key: Control
	box_len
	swap
	pop
	bz *if1_end

	// *if1_elseif1_consequent
	// examples/arc72/arc72.algo.ts:80
	// this.controlBox(key).delete()
	frame_dig 0 // key: Control
	box_del

*if1_end:
	retsub

// mint(address)void
*abi_route_mint:
	// to: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 0 (to) for mint must be a address
	assert

	// execute mint(address)void
	callsub mint
	intc 1 // 1
	return

// mint(to: Address): void
mint:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// examples/arc72/arc72.algo.ts:84
	// index = this.index.value
	bytec 3 //  "index"
	app_global_get
	frame_bury 0 // index: uint256

	// examples/arc72/arc72.algo.ts:86
	// token: Token = {
	//       owner: to,
	//       uri: 'https://github.com/algorandfoundation/ARCs' as Bytes256,
	//       controller: Address.zeroAddress,
	//     }
	frame_dig -1 // to: Address
	pushbytes 0x68747470733a2f2f6769746875622e636f6d2f616c676f72616e64666f756e646174696f6e2f4152437300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 // "https://github.com/algorandfoundation/ARCs"
	concat
	global ZeroAddress
	concat
	frame_bury 1 // token: Token

	// examples/arc72/arc72.algo.ts:92
	// this.tokenBox(index).value = token
	frame_dig 0 // index: uint256
	frame_dig 1 // token: Token
	box_put

	// examples/arc72/arc72.algo.ts:93
	// this.transferTo(to, index)
	frame_dig 0 // index: uint256
	frame_dig -1 // to: Address
	callsub transferTo

	// examples/arc72/arc72.algo.ts:94
	// this.index.value = index + 1
	bytec 3 //  "index"
	frame_dig 0 // index: uint256
	pushbytes 0x0000000000000000000000000000000000000000000000000000000000000001
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// index + 1 overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put
	retsub

// arc72_totalSupply()uint256
*abi_route_arc72_totalSupply:
	// The ABI return prefix
	bytec 1 // 0x151f7c75

	// execute arc72_totalSupply()uint256
	callsub arc72_totalSupply
	dup
	bitlen
	intc 2 // 256
	<=

	// arc72_totalSupply return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 1 // 1
	return

// arc72_totalSupply(): uint256
//
// Returns the number of NFTs currently defined by this contract
arc72_totalSupply:
	proto 0 1

	// examples/arc72/arc72.algo.ts:102
	// return this.index.value;
	bytec 3 //  "index"
	app_global_get
	retsub

// arc72_tokenByIndex(uint256)uint256
*abi_route_arc72_tokenByIndex:
	// The ABI return prefix
	bytec 1 // 0x151f7c75

	// index: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 0 (index) for arc72_tokenByIndex must be a uint256
	assert

	// execute arc72_tokenByIndex(uint256)uint256
	callsub arc72_tokenByIndex
	dup
	bitlen
	intc 2 // 256
	<=

	// arc72_tokenByIndex return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 1 // 1
	return

// arc72_tokenByIndex(index: uint256): uint256
//
// Returns the token ID of the token with the given index among all NFTs defined by the contract
arc72_tokenByIndex:
	proto 1 1

	// examples/arc72/arc72.algo.ts:110
	// return index;
	frame_dig -1 // index: uint256
	retsub

*abi_route_createApplication:
	intc 1 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x79096a14 // method "arc72_ownerOf(uint256)address"
	pushbytes 0xc3c1fc00 // method "arc72_tokenURI(uint256)byte[256]"
	pushbytes 0xf2f194a0 // method "arc72_transferFrom(address,address,uint256)void"
	pushbytes 0xb4edba4e // method "arc72_approve(address,uint256)void"
	pushbytes 0x7134395f // method "arc72_setApprovalForAll(address,bool)void"
	pushbytes 0xac4cfadf // method "mint(address)void"
	pushbytes 0x64d72a7a // method "arc72_totalSupply()uint256"
	pushbytes 0x6d9bfd27 // method "arc72_tokenByIndex(uint256)uint256"
	txna ApplicationArgs 0
	match *abi_route_arc72_ownerOf *abi_route_arc72_tokenURI *abi_route_arc72_transferFrom *abi_route_arc72_approve *abi_route_arc72_setApprovalForAll *abi_route_mint *abi_route_arc72_totalSupply *abi_route_arc72_tokenByIndex

	// this contract does not implement the given ABI method for call NoOp
	err"
`;

exports[`Examples ARC72 Artifacts Maintains program size 1`] = `840`;

exports[`Examples ARC72 Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [
        {
          "desc": "The ID of the NFT",
          "name": "tokenId",
          "type": "uint256",
        },
      ],
      "desc": "Returns the address of the current owner of the NFT with the given tokenId",
      "events": undefined,
      "name": "arc72_ownerOf",
      "readonly": true,
      "returns": {
        "desc": "The current owner of the NFT",
        "type": "address",
      },
    },
    {
      "args": [
        {
          "desc": "The ID of the NFT",
          "name": "tokenId",
          "type": "uint256",
        },
      ],
      "desc": "Returns a URI pointing to the NFT metadata",
      "events": undefined,
      "name": "arc72_tokenURI",
      "readonly": true,
      "returns": {
        "desc": "URI to token metadata",
        "type": "byte[256]",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "_from",
          "type": "address",
        },
        {
          "desc": undefined,
          "name": "to",
          "type": "address",
        },
        {
          "desc": undefined,
          "name": "tokenId",
          "type": "uint256",
        },
      ],
      "desc": "Transfers ownership of an NFT",
      "events": undefined,
      "name": "arc72_transferFrom",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "Approved controller address",
          "name": "approved",
          "type": "address",
        },
        {
          "desc": "The ID of the NFT",
          "name": "tokenId",
          "type": "uint256",
        },
      ],
      "desc": "Approve a controller for a single NFT",
      "events": undefined,
      "name": "arc72_approve",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "Approved operator address",
          "name": "operator",
          "type": "address",
        },
        {
          "desc": "true to give approval, false to revoke",
          "name": "approved",
          "type": "bool",
        },
      ],
      "desc": "Approve an operator for all NFTs for a user",
      "events": undefined,
      "name": "arc72_setApprovalForAll",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "to",
          "type": "address",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "mint",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": "Returns the number of NFTs currently defined by this contract",
      "events": undefined,
      "name": "arc72_totalSupply",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "uint256",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "index",
          "type": "uint256",
        },
      ],
      "desc": "Returns the token ID of the token with the given index among all NFTs defined by the contract",
      "events": undefined,
      "name": "arc72_tokenByIndex",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "uint256",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "ARC72",
}
`;

exports[`Examples ARC72 Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [
          {
            "desc": "The ID of the NFT",
            "name": "tokenId",
            "type": "uint256",
          },
        ],
        "desc": "Returns the address of the current owner of the NFT with the given tokenId",
        "events": undefined,
        "name": "arc72_ownerOf",
        "readonly": true,
        "returns": {
          "desc": "The current owner of the NFT",
          "type": "address",
        },
      },
      {
        "args": [
          {
            "desc": "The ID of the NFT",
            "name": "tokenId",
            "type": "uint256",
          },
        ],
        "desc": "Returns a URI pointing to the NFT metadata",
        "events": undefined,
        "name": "arc72_tokenURI",
        "readonly": true,
        "returns": {
          "desc": "URI to token metadata",
          "type": "byte[256]",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "_from",
            "type": "address",
          },
          {
            "desc": undefined,
            "name": "to",
            "type": "address",
          },
          {
            "desc": undefined,
            "name": "tokenId",
            "type": "uint256",
          },
        ],
        "desc": "Transfers ownership of an NFT",
        "events": undefined,
        "name": "arc72_transferFrom",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "Approved controller address",
            "name": "approved",
            "type": "address",
          },
          {
            "desc": "The ID of the NFT",
            "name": "tokenId",
            "type": "uint256",
          },
        ],
        "desc": "Approve a controller for a single NFT",
        "events": undefined,
        "name": "arc72_approve",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "Approved operator address",
            "name": "operator",
            "type": "address",
          },
          {
            "desc": "true to give approval, false to revoke",
            "name": "approved",
            "type": "bool",
          },
        ],
        "desc": "Approve an operator for all NFTs for a user",
        "events": undefined,
        "name": "arc72_setApprovalForAll",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "to",
            "type": "address",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "mint",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": "Returns the number of NFTs currently defined by this contract",
        "events": undefined,
        "name": "arc72_totalSupply",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "uint256",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "index",
            "type": "uint256",
          },
        ],
        "desc": "Returns the token ID of the token with the given index among all NFTs defined by the contract",
        "events": undefined,
        "name": "arc72_tokenByIndex",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "uint256",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "ARC72",
  },
  "hints": {
    "arc72_approve(address,uint256)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc72_ownerOf(uint256)address": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc72_setApprovalForAll(address,bool)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc72_tokenByIndex(uint256)uint256": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc72_tokenURI(uint256)byte[256]": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc72_totalSupply()uint256": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "arc72_transferFrom(address,address,uint256)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "mint(address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {
        "index": {
          "key": "index",
          "type": "bytes",
        },
      },
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAzMiAxIDI1NiAwIDI4OApieXRlY2Jsb2NrIDB4IDB4MTUxZjdjNzUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGIDB4Njk2ZTY0NjU3OAoKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCnB1c2hpbnQgNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggKmNhbGxfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKmNyZWF0ZV9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRAoKKk5PVF9JTVBMRU1FTlRFRDoKCS8vIFRoZSByZXF1ZXN0ZWQgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIGNvbnRyYWN0LiBBcmUgeW91IHVzaW5nIHRoZSBjb3JyZWN0IE9uQ29tcGxldGU/IERpZCB5b3Ugc2V0IHlvdXIgYXBwIElEPwoJZXJyCgovLyBhcmM3Ml9vd25lck9mKHVpbnQyNTYpYWRkcmVzcwoqYWJpX3JvdXRlX2FyYzcyX293bmVyT2Y6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDEgLy8gMHgxNTFmN2M3NQoKCS8vIHRva2VuSWQ6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDAgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMCAodG9rZW5JZCkgZm9yIGFyYzcyX293bmVyT2YgbXVzdCBiZSBhIHVpbnQyNTYKCWFzc2VydAoKCS8vIGV4ZWN1dGUgYXJjNzJfb3duZXJPZih1aW50MjU2KWFkZHJlc3MKCWNhbGxzdWIgYXJjNzJfb3duZXJPZgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGFyYzcyX293bmVyT2YodG9rZW5JZDogdWludDI1Nik6IEFkZHJlc3MKLy8KLy8KLy8gUmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgY3VycmVudCBvd25lciBvZiB0aGUgTkZUIHdpdGggdGhlIGdpdmVuIHRva2VuSWQKLy8KLy8gQHBhcmFtIHRva2VuSWQgVGhlIElEIG9mIHRoZSBORlQKLy8gQHJldHVybnMgVGhlIGN1cnJlbnQgb3duZXIgb2YgdGhlIE5GVAphcmM3Ml9vd25lck9mOgoJcHJvdG8gMSAxCgoJLy8gZXhhbXBsZXMvYXJjNzIvYXJjNzIuYWxnby50czoyNQoJLy8gcmV0dXJuIHRoaXMudG9rZW5Cb3godG9rZW5JZCkudmFsdWUub3duZXI7CglmcmFtZV9kaWcgLTEgLy8gdG9rZW5JZDogdWludDI1NgoJaW50YyAzIC8vIDAKCWludGMgMCAvLyAzMgoJYm94X2V4dHJhY3QKCXJldHN1YgoKLy8gYXJjNzJfdG9rZW5VUkkodWludDI1NilieXRlWzI1Nl0KKmFiaV9yb3V0ZV9hcmM3Ml90b2tlblVSSToKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMSAvLyAweDE1MWY3Yzc1CgoJLy8gdG9rZW5JZDogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgMCAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwICh0b2tlbklkKSBmb3IgYXJjNzJfdG9rZW5VUkkgbXVzdCBiZSBhIHVpbnQyNTYKCWFzc2VydAoKCS8vIGV4ZWN1dGUgYXJjNzJfdG9rZW5VUkkodWludDI1NilieXRlWzI1Nl0KCWNhbGxzdWIgYXJjNzJfdG9rZW5VUkkKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBhcmM3Ml90b2tlblVSSSh0b2tlbklkOiB1aW50MjU2KTogQnl0ZXMyNTYKLy8KLy8KLy8gUmV0dXJucyBhIFVSSSBwb2ludGluZyB0byB0aGUgTkZUIG1ldGFkYXRhCi8vCi8vIEBwYXJhbSB0b2tlbklkIFRoZSBJRCBvZiB0aGUgTkZUCi8vIEByZXR1cm5zIFVSSSB0byB0b2tlbiBtZXRhZGF0YQphcmM3Ml90b2tlblVSSToKCXByb3RvIDEgMQoKCS8vIGV4YW1wbGVzL2FyYzcyL2FyYzcyLmFsZ28udHM6MzcKCS8vIHJldHVybiB0aGlzLnRva2VuQm94KHRva2VuSWQpLnZhbHVlLnVyaTsKCWZyYW1lX2RpZyAtMSAvLyB0b2tlbklkOiB1aW50MjU2CglpbnRjIDAgLy8gIGhlYWRPZmZzZXQKCWludGMgMiAvLyAyNTYKCWJveF9leHRyYWN0CglyZXRzdWIKCi8vIHRyYW5zZmVyVG8odG86IEFkZHJlc3MsIHRva2VuSWQ6IHVpbnQyNTYpOiB2b2lkCnRyYW5zZmVyVG86Cglwcm90byAyIDAKCgkvLyBleGFtcGxlcy9hcmM3Mi9hcmM3Mi5hbGdvLnRzOjQxCgkvLyB0aGlzLnRva2VuQm94KHRva2VuSWQpLnZhbHVlLm93bmVyID0gdG8KCWZyYW1lX2RpZyAtMiAvLyB0b2tlbklkOiB1aW50MjU2CglpbnRjIDMgLy8gMAoJZnJhbWVfZGlnIC0xIC8vIHRvOiBBZGRyZXNzCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBhcmM3Ml90cmFuc2ZlckZyb20oYWRkcmVzcyxhZGRyZXNzLHVpbnQyNTYpdm9pZAoqYWJpX3JvdXRlX2FyYzcyX3RyYW5zZmVyRnJvbToKCS8vIHRva2VuSWQ6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnRjIDAgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMCAodG9rZW5JZCkgZm9yIGFyYzcyX3RyYW5zZmVyRnJvbSBtdXN0IGJlIGEgdWludDI1NgoJYXNzZXJ0CgoJLy8gdG86IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDAgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMSAodG8pIGZvciBhcmM3Ml90cmFuc2ZlckZyb20gbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIF9mcm9tOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50YyAwIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDIgKF9mcm9tKSBmb3IgYXJjNzJfdHJhbnNmZXJGcm9tIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIGFyYzcyX3RyYW5zZmVyRnJvbShhZGRyZXNzLGFkZHJlc3MsdWludDI1Nil2b2lkCgljYWxsc3ViIGFyYzcyX3RyYW5zZmVyRnJvbQoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gYXJjNzJfdHJhbnNmZXJGcm9tKF9mcm9tOiBBZGRyZXNzLCB0bzogQWRkcmVzcywgdG9rZW5JZDogdWludDI1Nik6IHZvaWQKLy8KLy8gVHJhbnNmZXJzIG93bmVyc2hpcCBvZiBhbiBORlQKYXJjNzJfdHJhbnNmZXJGcm9tOgoJcHJvdG8gMyAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cAoKCS8vIGV4YW1wbGVzL2FyYzcyL2FyYzcyLmFsZ28udHM6NDgKCS8vIHRva2VuID0gdGhpcy50b2tlbkJveCh0b2tlbklkKS52YWx1ZQoJZnJhbWVfZGlnIC0zIC8vIHRva2VuSWQ6IHVpbnQyNTYKCWZyYW1lX2J1cnkgMCAvLyBzdG9yYWdlIGtleS8vdG9rZW4KCgkvLyBleGFtcGxlcy9hcmM3Mi9hcmM3Mi5hbGdvLnRzOjUwCgkvLyBrZXk6IENvbnRyb2wgPSB7IG93bmVyOiB0aGlzLnR4bi5zZW5kZXIsIGNvbnRyb2xsZXI6IF9mcm9tIH0KCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBfZnJvbTogQWRkcmVzcwoJY29uY2F0CglmcmFtZV9idXJ5IDEgLy8ga2V5OiBDb250cm9sCgoJLy8gKmlmMF9jb25kaXRpb24KCS8vIGV4YW1wbGVzL2FyYzcyL2FyYzcyLmFsZ28udHM6NTIKCS8vIHRoaXMudHhuLnNlbmRlciA9PT0gX2Zyb20gfHwgdGhpcy50eG4uc2VuZGVyID09PSB0b2tlbi5jb250cm9sbGVyIHx8IHRoaXMuY29udHJvbEJveChrZXkpLmV4aXN0cwoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIF9mcm9tOiBBZGRyZXNzCgk9PQoJZHVwCglibnogKnNraXBfb3IwCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgLTMgLy8gdG9rZW5JZDogdWludDI1NgoJaW50YyA0IC8vICBoZWFkT2Zmc2V0CglpbnRjIDAgLy8gMzIKCWJveF9leHRyYWN0Cgk9PQoJfHwKCipza2lwX29yMDoKCWR1cAoJYm56ICpza2lwX29yMQoJZnJhbWVfZGlnIDEgLy8ga2V5OiBDb250cm9sCglib3hfbGVuCglzd2FwCglwb3AKCXx8Cgoqc2tpcF9vcjE6CglieiAqaWYwX2Vsc2UKCgkvLyAqaWYwX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL2FyYzcyL2FyYzcyLmFsZ28udHM6NTMKCS8vIHRoaXMudHJhbnNmZXJUbyh0bywgdG9rZW5JZCkKCWZyYW1lX2RpZyAtMyAvLyB0b2tlbklkOiB1aW50MjU2CglmcmFtZV9kaWcgLTIgLy8gdG86IEFkZHJlc3MKCWNhbGxzdWIgdHJhbnNmZXJUbwoJYiAqaWYwX2VuZAoKKmlmMF9lbHNlOgoJLy8gVHJhbnNmZXIgbm90IGF1dGhvcml6ZWQKCWVycgoKKmlmMF9lbmQ6CglyZXRzdWIKCi8vIGFyYzcyX2FwcHJvdmUoYWRkcmVzcyx1aW50MjU2KXZvaWQKKmFiaV9yb3V0ZV9hcmM3Ml9hcHByb3ZlOgoJLy8gdG9rZW5JZDogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMCAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwICh0b2tlbklkKSBmb3IgYXJjNzJfYXBwcm92ZSBtdXN0IGJlIGEgdWludDI1NgoJYXNzZXJ0CgoJLy8gYXBwcm92ZWQ6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDAgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMSAoYXBwcm92ZWQpIGZvciBhcmM3Ml9hcHByb3ZlIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIGFyYzcyX2FwcHJvdmUoYWRkcmVzcyx1aW50MjU2KXZvaWQKCWNhbGxzdWIgYXJjNzJfYXBwcm92ZQoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gYXJjNzJfYXBwcm92ZShhcHByb3ZlZDogQWRkcmVzcywgdG9rZW5JZDogdWludDI1Nik6IHZvaWQKLy8KLy8KLy8gQXBwcm92ZSBhIGNvbnRyb2xsZXIgZm9yIGEgc2luZ2xlIE5GVAovLwovLyBAcGFyYW0gYXBwcm92ZWQgQXBwcm92ZWQgY29udHJvbGxlciBhZGRyZXNzCi8vIEBwYXJhbSB0b2tlbklkIFRoZSBJRCBvZiB0aGUgTkZUCmFyYzcyX2FwcHJvdmU6Cglwcm90byAyIDAKCgkvLyBleGFtcGxlcy9hcmM3Mi9hcmM3Mi5hbGdvLnRzOjY1CgkvLyB0aGlzLnRva2VuQm94KHRva2VuSWQpLnZhbHVlLmNvbnRyb2xsZXIgPSBhcHByb3ZlZAoJZnJhbWVfZGlnIC0yIC8vIHRva2VuSWQ6IHVpbnQyNTYKCWludGMgNCAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIC0xIC8vIGFwcHJvdmVkOiBBZGRyZXNzCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBhcmM3Ml9zZXRBcHByb3ZhbEZvckFsbChhZGRyZXNzLGJvb2wpdm9pZAoqYWJpX3JvdXRlX2FyYzcyX3NldEFwcHJvdmFsRm9yQWxsOgoJLy8gYXBwcm92ZWQ6IGJvb2wKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDEgLy8gMQoJPT0KCgkvLyBhcmd1bWVudCAwIChhcHByb3ZlZCkgZm9yIGFyYzcyX3NldEFwcHJvdmFsRm9yQWxsIG11c3QgYmUgYSBib29sCglhc3NlcnQKCWludGMgMyAvLyAwCglnZXRiaXQKCgkvLyBvcGVyYXRvcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgMCAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAxIChvcGVyYXRvcikgZm9yIGFyYzcyX3NldEFwcHJvdmFsRm9yQWxsIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIGFyYzcyX3NldEFwcHJvdmFsRm9yQWxsKGFkZHJlc3MsYm9vbCl2b2lkCgljYWxsc3ViIGFyYzcyX3NldEFwcHJvdmFsRm9yQWxsCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBhcmM3Ml9zZXRBcHByb3ZhbEZvckFsbChvcGVyYXRvcjogQWRkcmVzcywgYXBwcm92ZWQ6IGJvb2xlYW4pOiB2b2lkCi8vCi8vCi8vIEFwcHJvdmUgYW4gb3BlcmF0b3IgZm9yIGFsbCBORlRzIGZvciBhIHVzZXIKLy8KLy8gQHBhcmFtIG9wZXJhdG9yIEFwcHJvdmVkIG9wZXJhdG9yIGFkZHJlc3MKLy8gQHBhcmFtIGFwcHJvdmVkIHRydWUgdG8gZ2l2ZSBhcHByb3ZhbCwgZmFsc2UgdG8gcmV2b2tlCi8vIEByZXR1cm5zCmFyYzcyX3NldEFwcHJvdmFsRm9yQWxsOgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCgkvLyBleGFtcGxlcy9hcmM3Mi9hcmM3Mi5hbGdvLnRzOjc3CgkvLyBrZXk6IENvbnRyb2wgPSB7IG93bmVyOiB0aGlzLnR4bi5zZW5kZXIsIGNvbnRyb2xsZXI6IG9wZXJhdG9yIH0KCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBvcGVyYXRvcjogQWRkcmVzcwoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8ga2V5OiBDb250cm9sCgoJLy8gKmlmMV9jb25kaXRpb24KCS8vIGV4YW1wbGVzL2FyYzcyL2FyYzcyLmFsZ28udHM6NzkKCS8vIGFwcHJvdmVkCglmcmFtZV9kaWcgLTIgLy8gYXBwcm92ZWQ6IGJvb2xlYW4KCWJ6ICppZjFfZWxzZWlmMV9jb25kaXRpb24KCgkvLyAqaWYxX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL2FyYzcyL2FyYzcyLmFsZ28udHM6NzkKCS8vIHRoaXMuY29udHJvbEJveChrZXkpLnZhbHVlID0gJycKCWZyYW1lX2RpZyAwIC8vIGtleTogQ29udHJvbAoJZHVwCglib3hfZGVsCglwb3AKCWJ5dGVjIDAgLy8gICIiCglib3hfcHV0CgliICppZjFfZW5kCgoqaWYxX2Vsc2VpZjFfY29uZGl0aW9uOgoJLy8gZXhhbXBsZXMvYXJjNzIvYXJjNzIuYWxnby50czo4MAoJLy8gdGhpcy5jb250cm9sQm94KGtleSkuZXhpc3RzCglmcmFtZV9kaWcgMCAvLyBrZXk6IENvbnRyb2wKCWJveF9sZW4KCXN3YXAKCXBvcAoJYnogKmlmMV9lbmQKCgkvLyAqaWYxX2Vsc2VpZjFfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvYXJjNzIvYXJjNzIuYWxnby50czo4MAoJLy8gdGhpcy5jb250cm9sQm94KGtleSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAwIC8vIGtleTogQ29udHJvbAoJYm94X2RlbAoKKmlmMV9lbmQ6CglyZXRzdWIKCi8vIG1pbnQoYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfbWludDoKCS8vIHRvOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50YyAwIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKHRvKSBmb3IgbWludCBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBtaW50KGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBtaW50CglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBtaW50KHRvOiBBZGRyZXNzKTogdm9pZAptaW50OgoJcHJvdG8gMSAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cAoKCS8vIGV4YW1wbGVzL2FyYzcyL2FyYzcyLmFsZ28udHM6ODQKCS8vIGluZGV4ID0gdGhpcy5pbmRleC52YWx1ZQoJYnl0ZWMgMyAvLyAgImluZGV4IgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2J1cnkgMCAvLyBpbmRleDogdWludDI1NgoKCS8vIGV4YW1wbGVzL2FyYzcyL2FyYzcyLmFsZ28udHM6ODYKCS8vIHRva2VuOiBUb2tlbiA9IHsKCS8vICAgICAgIG93bmVyOiB0bywKCS8vICAgICAgIHVyaTogJ2h0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZGZvdW5kYXRpb24vQVJDcycgYXMgQnl0ZXMyNTYsCgkvLyAgICAgICBjb250cm9sbGVyOiBBZGRyZXNzLnplcm9BZGRyZXNzLAoJLy8gICAgIH0KCWZyYW1lX2RpZyAtMSAvLyB0bzogQWRkcmVzcwoJcHVzaGJ5dGVzIDB4Njg3NDc0NzA3MzNhMmYyZjY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTZjNjc2ZjcyNjE2ZTY0NjY2Zjc1NmU2NDYxNzQ2OTZmNmUyZjQxNTI0MzczMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgLy8gImh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZGZvdW5kYXRpb24vQVJDcyIKCWNvbmNhdAoJZ2xvYmFsIFplcm9BZGRyZXNzCgljb25jYXQKCWZyYW1lX2J1cnkgMSAvLyB0b2tlbjogVG9rZW4KCgkvLyBleGFtcGxlcy9hcmM3Mi9hcmM3Mi5hbGdvLnRzOjkyCgkvLyB0aGlzLnRva2VuQm94KGluZGV4KS52YWx1ZSA9IHRva2VuCglmcmFtZV9kaWcgMCAvLyBpbmRleDogdWludDI1NgoJZnJhbWVfZGlnIDEgLy8gdG9rZW46IFRva2VuCglib3hfcHV0CgoJLy8gZXhhbXBsZXMvYXJjNzIvYXJjNzIuYWxnby50czo5MwoJLy8gdGhpcy50cmFuc2ZlclRvKHRvLCBpbmRleCkKCWZyYW1lX2RpZyAwIC8vIGluZGV4OiB1aW50MjU2CglmcmFtZV9kaWcgLTEgLy8gdG86IEFkZHJlc3MKCWNhbGxzdWIgdHJhbnNmZXJUbwoKCS8vIGV4YW1wbGVzL2FyYzcyL2FyYzcyLmFsZ28udHM6OTQKCS8vIHRoaXMuaW5kZXgudmFsdWUgPSBpbmRleCArIDEKCWJ5dGVjIDMgLy8gICJpbmRleCIKCWZyYW1lX2RpZyAwIC8vIGluZGV4OiB1aW50MjU2CglwdXNoYnl0ZXMgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxCgliKwoJZHVwCgliaXRsZW4KCWludGMgMiAvLyAyNTYKCTw9CgoJLy8gaW5kZXggKyAxIG92ZXJmbG93ZWQgMjU2IGJpdHMKCWFzc2VydAoJYnl0ZWMgMiAvLyAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnRjIDAgLy8gMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGFyYzcyX3RvdGFsU3VwcGx5KCl1aW50MjU2CiphYmlfcm91dGVfYXJjNzJfdG90YWxTdXBwbHk6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDEgLy8gMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgYXJjNzJfdG90YWxTdXBwbHkoKXVpbnQyNTYKCWNhbGxzdWIgYXJjNzJfdG90YWxTdXBwbHkKCWR1cAoJYml0bGVuCglpbnRjIDIgLy8gMjU2Cgk8PQoKCS8vIGFyYzcyX3RvdGFsU3VwcGx5IHJldHVybiB2YWx1ZSBvdmVyZmxvd2VkIDI1NiBiaXRzCglhc3NlcnQKCWJ5dGVjIDIgLy8gMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50YyAwIC8vIDMyCgktCglzd2FwCglzdWJzdHJpbmczCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gYXJjNzJfdG90YWxTdXBwbHkoKTogdWludDI1NgovLwovLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgTkZUcyBjdXJyZW50bHkgZGVmaW5lZCBieSB0aGlzIGNvbnRyYWN0CmFyYzcyX3RvdGFsU3VwcGx5OgoJcHJvdG8gMCAxCgoJLy8gZXhhbXBsZXMvYXJjNzIvYXJjNzIuYWxnby50czoxMDIKCS8vIHJldHVybiB0aGlzLmluZGV4LnZhbHVlOwoJYnl0ZWMgMyAvLyAgImluZGV4IgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gYXJjNzJfdG9rZW5CeUluZGV4KHVpbnQyNTYpdWludDI1NgoqYWJpX3JvdXRlX2FyYzcyX3Rva2VuQnlJbmRleDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMSAvLyAweDE1MWY3Yzc1CgoJLy8gaW5kZXg6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDAgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMCAoaW5kZXgpIGZvciBhcmM3Ml90b2tlbkJ5SW5kZXggbXVzdCBiZSBhIHVpbnQyNTYKCWFzc2VydAoKCS8vIGV4ZWN1dGUgYXJjNzJfdG9rZW5CeUluZGV4KHVpbnQyNTYpdWludDI1NgoJY2FsbHN1YiBhcmM3Ml90b2tlbkJ5SW5kZXgKCWR1cAoJYml0bGVuCglpbnRjIDIgLy8gMjU2Cgk8PQoKCS8vIGFyYzcyX3Rva2VuQnlJbmRleCByZXR1cm4gdmFsdWUgb3ZlcmZsb3dlZCAyNTYgYml0cwoJYXNzZXJ0CglieXRlYyAyIC8vIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludGMgMCAvLyAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGFyYzcyX3Rva2VuQnlJbmRleChpbmRleDogdWludDI1Nik6IHVpbnQyNTYKLy8KLy8gUmV0dXJucyB0aGUgdG9rZW4gSUQgb2YgdGhlIHRva2VuIHdpdGggdGhlIGdpdmVuIGluZGV4IGFtb25nIGFsbCBORlRzIGRlZmluZWQgYnkgdGhlIGNvbnRyYWN0CmFyYzcyX3Rva2VuQnlJbmRleDoKCXByb3RvIDEgMQoKCS8vIGV4YW1wbGVzL2FyYzcyL2FyYzcyLmFsZ28udHM6MTEwCgkvLyByZXR1cm4gaW5kZXg7CglmcmFtZV9kaWcgLTEgLy8gaW5kZXg6IHVpbnQyNTYKCXJldHN1YgoKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCWludGMgMSAvLyAxCglyZXR1cm4KCipjcmVhdGVfTm9PcDoKCXB1c2hieXRlcyAweGI4NDQ3YjM2IC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNyZWF0ZSBOb09wCgllcnIKCipjYWxsX05vT3A6CglwdXNoYnl0ZXMgMHg3OTA5NmExNCAvLyBtZXRob2QgImFyYzcyX293bmVyT2YodWludDI1NilhZGRyZXNzIgoJcHVzaGJ5dGVzIDB4YzNjMWZjMDAgLy8gbWV0aG9kICJhcmM3Ml90b2tlblVSSSh1aW50MjU2KWJ5dGVbMjU2XSIKCXB1c2hieXRlcyAweGYyZjE5NGEwIC8vIG1ldGhvZCAiYXJjNzJfdHJhbnNmZXJGcm9tKGFkZHJlc3MsYWRkcmVzcyx1aW50MjU2KXZvaWQiCglwdXNoYnl0ZXMgMHhiNGVkYmE0ZSAvLyBtZXRob2QgImFyYzcyX2FwcHJvdmUoYWRkcmVzcyx1aW50MjU2KXZvaWQiCglwdXNoYnl0ZXMgMHg3MTM0Mzk1ZiAvLyBtZXRob2QgImFyYzcyX3NldEFwcHJvdmFsRm9yQWxsKGFkZHJlc3MsYm9vbCl2b2lkIgoJcHVzaGJ5dGVzIDB4YWM0Y2ZhZGYgLy8gbWV0aG9kICJtaW50KGFkZHJlc3Mpdm9pZCIKCXB1c2hieXRlcyAweDY0ZDcyYTdhIC8vIG1ldGhvZCAiYXJjNzJfdG90YWxTdXBwbHkoKXVpbnQyNTYiCglwdXNoYnl0ZXMgMHg2ZDliZmQyNyAvLyBtZXRob2QgImFyYzcyX3Rva2VuQnlJbmRleCh1aW50MjU2KXVpbnQyNTYiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2FyYzcyX293bmVyT2YgKmFiaV9yb3V0ZV9hcmM3Ml90b2tlblVSSSAqYWJpX3JvdXRlX2FyYzcyX3RyYW5zZmVyRnJvbSAqYWJpX3JvdXRlX2FyYzcyX2FwcHJvdmUgKmFiaV9yb3V0ZV9hcmM3Ml9zZXRBcHByb3ZhbEZvckFsbCAqYWJpX3JvdXRlX21pbnQgKmFiaV9yb3V0ZV9hcmM3Ml90b3RhbFN1cHBseSAqYWJpX3JvdXRlX2FyYzcyX3Rva2VuQnlJbmRleAoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjYWxsIE5vT3AKCWVycg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 1,
      "num_uints": 0,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples ARC75 Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 1 8 2 0
bytecblock 0x 0x0024

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// verifyMBRPayment(payment: PayTxn, preMBR: uint64): void
verifyMBRPayment:
	proto 2 0

	// examples/arc75/arc75.algo.ts:10
	// verifyPayTxn(payment, {
	//       receiver: this.app.address,
	//       amount: this.app.address.minBalance - preMBR,
	//     })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_dig -2 // preMBR: uint64
	-
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"this.app.address.minBalance - preMBR"}
	assert
	retsub

// sendMBRPayment(preMBR: uint64): void
sendMBRPayment:
	proto 1 0

	// examples/arc75/arc75.algo.ts:17
	// sendPayment({
	//       receiver: this.txn.sender,
	//       amount: preMBR - this.app.address.minBalance,
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// examples/arc75/arc75.algo.ts:18
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// examples/arc75/arc75.algo.ts:19
	// amount: preMBR - this.app.address.minBalance
	frame_dig -1 // preMBR: uint64
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	-
	itxn_field Amount

	// Fee field not set, defaulting to 0
	intc 3 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// addAppToWhiteList(string,uint16,uint64,pay)void
*abi_route_addAppToWhiteList:
	// payment: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 0 (payment) for addAppToWhiteList must be a pay transaction
	assert

	// appID: uint64
	txna ApplicationArgs 3
	btoi

	// boxIndex: uint16
	txna ApplicationArgs 2
	dup
	len
	intc 2 // 2
	==

	// argument 2 (boxIndex) for addAppToWhiteList must be a uint16
	assert
	btoi

	// arc: string
	txna ApplicationArgs 1
	extract 2 0

	// execute addAppToWhiteList(string,uint16,uint64,pay)void
	callsub addAppToWhiteList
	intc 0 // 1
	return

// addAppToWhiteList(arc: string, boxIndex: uint16, appID: uint64, payment: PayTxn): void
//
// Add app to whitelist box
//
// @param arc - The ARC the whitelist corresponds to
// @param boxIndex - The index of the whitelist box to add the app to
// @param appID - The app ID to add to the whitelist
// @param payment - The payment transaction to cover the MBR change
addAppToWhiteList:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// examples/arc75/arc75.algo.ts:33
	// preMBR = this.app.address.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 0 // preMBR: uint64

	// examples/arc75/arc75.algo.ts:34
	// whitelist: Whitelist = { account: this.txn.sender, boxIndex: boxIndex, arc: arc }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 1 //  initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -2 // boxIndex: uint16
	itob
	extract 6 2
	callsub *process_static_tuple_element
	frame_dig -1 // arc: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // whitelist: Whitelist

	// *if0_condition
	// examples/arc75/arc75.algo.ts:36
	// this.whitelist(whitelist).exists
	frame_dig 1 // whitelist: Whitelist
	box_len
	swap
	pop
	bz *if0_else

	// *if0_consequent
	// examples/arc75/arc75.algo.ts:37
	// this.whitelist(whitelist).value.push(appID)
	frame_dig 1 // whitelist: Whitelist
	box_get

	// box value does not exist: this.whitelist(whitelist).value
	assert
	extract 2 0
	frame_dig -3 // appID: uint64
	itob
	concat
	frame_dig 1 // whitelist: Whitelist
	dup
	box_del
	pop
	swap
	dup
	len
	intc 1 // 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	b *if0_end

*if0_else:
	// examples/arc75/arc75.algo.ts:39
	// newWhitelist: uint64[] = [appID]
	frame_dig -3 // appID: uint64
	itob
	frame_bury 2 // newWhitelist: uint64[]

	// examples/arc75/arc75.algo.ts:40
	// this.whitelist(whitelist).value = newWhitelist
	frame_dig 1 // whitelist: Whitelist
	dup
	box_del
	pop
	frame_dig 2 // newWhitelist: uint64[]
	dup
	len
	intc 1 // 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put

*if0_end:
	// examples/arc75/arc75.algo.ts:43
	// this.verifyMBRPayment(payment, preMBR)
	frame_dig 0 // preMBR: uint64
	frame_dig -4 // payment: PayTxn
	callsub verifyMBRPayment
	retsub

// setAppWhitelist(string,uint16,uint64[])void
*abi_route_setAppWhitelist:
	// appIDs: uint64[]
	txna ApplicationArgs 3
	extract 2 0

	// boxIndex: uint16
	txna ApplicationArgs 2
	dup
	len
	intc 2 // 2
	==

	// argument 1 (boxIndex) for setAppWhitelist must be a uint16
	assert
	btoi

	// arc: string
	txna ApplicationArgs 1
	extract 2 0

	// execute setAppWhitelist(string,uint16,uint64[])void
	callsub setAppWhitelist
	intc 0 // 1
	return

// setAppWhitelist(arc: string, boxIndex: uint16, appIDs: uint64[]): void
//
// Sets a app whitelist for the sender. Should only be used when adding/removing
// more than one app
//
// @param boxIndex - The index of the whitelist box to put the app IDs in
// @param appIDs - Array of app IDs that signify the whitelisted apps
setAppWhitelist:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// examples/arc75/arc75.algo.ts:55
	// preMBR = this.app.address.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 0 // preMBR: uint64

	// examples/arc75/arc75.algo.ts:56
	// whitelist: Whitelist = { account: this.txn.sender, boxIndex: boxIndex, arc: arc }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 1 //  initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -2 // boxIndex: uint16
	itob
	extract 6 2
	callsub *process_static_tuple_element
	frame_dig -1 // arc: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // whitelist: Whitelist

	// examples/arc75/arc75.algo.ts:58
	// this.whitelist(whitelist).delete()
	frame_dig 1 // whitelist: Whitelist
	box_del

	// examples/arc75/arc75.algo.ts:60
	// this.whitelist(whitelist).value = appIDs
	frame_dig 1 // whitelist: Whitelist
	dup
	box_del
	pop
	frame_dig -3 // appIDs: uint64[]
	dup
	len
	intc 1 // 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put

	// *if1_condition
	// examples/arc75/arc75.algo.ts:62
	// preMBR > this.app.address.minBalance
	frame_dig 0 // preMBR: uint64
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	>
	bz *if1_else

	// *if1_consequent
	// examples/arc75/arc75.algo.ts:63
	// this.sendMBRPayment(preMBR)
	frame_dig 0 // preMBR: uint64
	callsub sendMBRPayment
	b *if1_end

*if1_else:
	// examples/arc75/arc75.algo.ts:65
	// this.verifyMBRPayment(this.txnGroup[this.txn.groupIndex - 1] as PayTxn, preMBR)
	frame_dig 0 // preMBR: uint64
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// failed to cast this.txnGroup[this.txn.groupIndex - 1] to pay
	assert
	callsub verifyMBRPayment

*if1_end:
	retsub

// deleteWhitelist(string,uint16)void
*abi_route_deleteWhitelist:
	// boxIndex: uint16
	txna ApplicationArgs 2
	dup
	len
	intc 2 // 2
	==

	// argument 0 (boxIndex) for deleteWhitelist must be a uint16
	assert
	btoi

	// arc: string
	txna ApplicationArgs 1
	extract 2 0

	// execute deleteWhitelist(string,uint16)void
	callsub deleteWhitelist
	intc 0 // 1
	return

// deleteWhitelist(arc: string, boxIndex: uint16): void
//
// Deletes a app whitelist for the sender
//
// @param arc - The ARC the whitelist corresponds to
// @param boxIndex - The index of the whitelist box to delete
deleteWhitelist:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// examples/arc75/arc75.algo.ts:77
	// preMBR = this.app.address.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 0 // preMBR: uint64

	// examples/arc75/arc75.algo.ts:78
	// whitelist: Whitelist = { account: this.txn.sender, boxIndex: boxIndex, arc: arc }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 1 //  initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -2 // boxIndex: uint16
	itob
	extract 6 2
	callsub *process_static_tuple_element
	frame_dig -1 // arc: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // whitelist: Whitelist

	// examples/arc75/arc75.algo.ts:80
	// this.whitelist(whitelist).delete()
	frame_dig 1 // whitelist: Whitelist
	box_del

	// examples/arc75/arc75.algo.ts:82
	// this.sendMBRPayment(preMBR)
	frame_dig 0 // preMBR: uint64
	callsub sendMBRPayment
	retsub

// deleteAppFromWhitelist(string,uint16,uint64,uint64)void
*abi_route_deleteAppFromWhitelist:
	// index: uint64
	txna ApplicationArgs 4
	btoi

	// appID: uint64
	txna ApplicationArgs 3
	btoi

	// boxIndex: uint16
	txna ApplicationArgs 2
	dup
	len
	intc 2 // 2
	==

	// argument 2 (boxIndex) for deleteAppFromWhitelist must be a uint16
	assert
	btoi

	// arc: string
	txna ApplicationArgs 1
	extract 2 0

	// execute deleteAppFromWhitelist(string,uint16,uint64,uint64)void
	callsub deleteAppFromWhitelist
	intc 0 // 1
	return

// deleteAppFromWhitelist(arc: string, boxIndex: uint16, appID: uint64, index: uint64): void
//
// Deletes a app from a whitelist for the sender
//
// @param boxIndex - The index of the whitelist box to delete from
// @param appID - The app ID to delete from the whitelist
// @param index - The index of the app in the whitelist
deleteAppFromWhitelist:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// examples/arc75/arc75.algo.ts:94
	// preMBR = this.app.address.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 0 // preMBR: uint64

	// examples/arc75/arc75.algo.ts:95
	// whitelist: Whitelist = { account: this.txn.sender, boxIndex: boxIndex, arc: arc }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 1 //  initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -2 // boxIndex: uint16
	itob
	extract 6 2
	callsub *process_static_tuple_element
	frame_dig -1 // arc: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // whitelist: Whitelist

	// examples/arc75/arc75.algo.ts:97
	// spliced = this.whitelist(whitelist).value.splice(index, 1)
	frame_dig 1 // whitelist: Whitelist
	box_get

	// box value does not exist: this.whitelist(whitelist).value
	assert
	extract 2 0
	intc 0 // 1
	frame_dig -4 // index: uint64
	intc 1 // 8
	*
	store 247 // splice start
	pushint 16
	store 246 // splice byte length
	frame_dig 1 // whitelist: Whitelist
	box_get

	// box value does not exist: this.whitelist(whitelist).value
	assert
	extract 2 0
	intc 3 // 0
	load 247 // splice start
	substring3
	frame_dig 1 // whitelist: Whitelist
	box_get

	// box value does not exist: this.whitelist(whitelist).value
	assert
	extract 2 0
	dup
	len
	load 247 // splice start
	load 246 // splice byte length
	+
	intc 1 // 8
	-
	swap
	substring3
	concat
	frame_dig 1 // whitelist: Whitelist
	box_get

	// box value does not exist: this.whitelist(whitelist).value
	assert
	extract 2 0
	load 247 // splice start
	load 246 // splice byte length
	intc 1 // 8
	-
	extract3
	swap
	frame_dig 1 // whitelist: Whitelist
	dup
	box_del
	pop
	swap
	dup
	len
	intc 1 // 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	frame_bury 2 // spliced: uint64[]

	// examples/arc75/arc75.algo.ts:99
	// assert(spliced[0] === appID)
	frame_dig 2 // spliced: uint64[]
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	frame_dig -3 // appID: uint64
	==
	assert

	// examples/arc75/arc75.algo.ts:101
	// this.sendMBRPayment(preMBR)
	frame_dig 0 // preMBR: uint64
	callsub sendMBRPayment
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x467c7cbd // method "addAppToWhiteList(string,uint16,uint64,pay)void"
	pushbytes 0xd198fcb8 // method "setAppWhitelist(string,uint16,uint64[])void"
	pushbytes 0x7c33e832 // method "deleteWhitelist(string,uint16)void"
	pushbytes 0x7e1674ac // method "deleteAppFromWhitelist(string,uint16,uint64,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_addAppToWhiteList *abi_route_setAppWhitelist *abi_route_deleteWhitelist *abi_route_deleteAppFromWhitelist

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub"
`;

exports[`Examples ARC75 Artifacts Maintains program size 1`] = `736`;

exports[`Examples ARC75 Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [
        {
          "desc": "The ARC the whitelist corresponds to",
          "name": "arc",
          "type": "string",
        },
        {
          "desc": "The index of the whitelist box to add the app to",
          "name": "boxIndex",
          "type": "uint16",
        },
        {
          "desc": "The app ID to add to the whitelist",
          "name": "appID",
          "type": "uint64",
        },
        {
          "desc": "The payment transaction to cover the MBR change",
          "name": "payment",
          "type": "pay",
        },
      ],
      "desc": "Add app to whitelist box",
      "events": undefined,
      "name": "addAppToWhiteList",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "arc",
          "type": "string",
        },
        {
          "desc": "The index of the whitelist box to put the app IDs in",
          "name": "boxIndex",
          "type": "uint16",
        },
        {
          "desc": "Array of app IDs that signify the whitelisted apps",
          "name": "appIDs",
          "type": "uint64[]",
        },
      ],
      "desc": 
"Sets a app whitelist for the sender. Should only be used when adding/removing
more than one app"
,
      "events": undefined,
      "name": "setAppWhitelist",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The ARC the whitelist corresponds to",
          "name": "arc",
          "type": "string",
        },
        {
          "desc": "The index of the whitelist box to delete",
          "name": "boxIndex",
          "type": "uint16",
        },
      ],
      "desc": "Deletes a app whitelist for the sender",
      "events": undefined,
      "name": "deleteWhitelist",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "arc",
          "type": "string",
        },
        {
          "desc": "The index of the whitelist box to delete from",
          "name": "boxIndex",
          "type": "uint16",
        },
        {
          "desc": "The app ID to delete from the whitelist",
          "name": "appID",
          "type": "uint64",
        },
        {
          "desc": "The index of the app in the whitelist",
          "name": "index",
          "type": "uint64",
        },
      ],
      "desc": "Deletes a app from a whitelist for the sender",
      "events": undefined,
      "name": "deleteAppFromWhitelist",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "ARC75",
}
`;

exports[`Examples ARC75 Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [
          {
            "desc": "The ARC the whitelist corresponds to",
            "name": "arc",
            "type": "string",
          },
          {
            "desc": "The index of the whitelist box to add the app to",
            "name": "boxIndex",
            "type": "uint16",
          },
          {
            "desc": "The app ID to add to the whitelist",
            "name": "appID",
            "type": "uint64",
          },
          {
            "desc": "The payment transaction to cover the MBR change",
            "name": "payment",
            "type": "pay",
          },
        ],
        "desc": "Add app to whitelist box",
        "events": undefined,
        "name": "addAppToWhiteList",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "arc",
            "type": "string",
          },
          {
            "desc": "The index of the whitelist box to put the app IDs in",
            "name": "boxIndex",
            "type": "uint16",
          },
          {
            "desc": "Array of app IDs that signify the whitelisted apps",
            "name": "appIDs",
            "type": "uint64[]",
          },
        ],
        "desc": 
"Sets a app whitelist for the sender. Should only be used when adding/removing
more than one app"
,
        "events": undefined,
        "name": "setAppWhitelist",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The ARC the whitelist corresponds to",
            "name": "arc",
            "type": "string",
          },
          {
            "desc": "The index of the whitelist box to delete",
            "name": "boxIndex",
            "type": "uint16",
          },
        ],
        "desc": "Deletes a app whitelist for the sender",
        "events": undefined,
        "name": "deleteWhitelist",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "arc",
            "type": "string",
          },
          {
            "desc": "The index of the whitelist box to delete from",
            "name": "boxIndex",
            "type": "uint16",
          },
          {
            "desc": "The app ID to delete from the whitelist",
            "name": "appID",
            "type": "uint64",
          },
          {
            "desc": "The index of the app in the whitelist",
            "name": "index",
            "type": "uint64",
          },
        ],
        "desc": "Deletes a app from a whitelist for the sender",
        "events": undefined,
        "name": "deleteAppFromWhitelist",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "ARC75",
  },
  "hints": {
    "addAppToWhiteList(string,uint16,uint64,pay)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "deleteAppFromWhitelist(string,uint16,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "deleteWhitelist(string,uint16)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "setAppWhitelist(string,uint16,uint64[])void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {},
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAxIDggMiAwCmJ5dGVjYmxvY2sgMHggMHgwMDI0CgovLyBodHRwczovL2dpdGh1Yi5jb20vYWxnb3JhbmRmb3VuZGF0aW9uL1RFQUxTY3JpcHQKCi8vIFRoaXMgY29udHJhY3QgaXMgY29tcGxpYW50IHdpdGggYW5kL29yIGltcGxlbWVudHMgdGhlIGZvbGxvd2luZyBBUkNzOiBbIEFSQzQgXQoKLy8gVGhlIGZvbGxvd2luZyB0ZW4gbGluZXMgb2YgVEVBTCBoYW5kbGUgaW5pdGlhbCBwcm9ncmFtIGZsb3cKLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgdG8gbWFrZSBpdCBlYXN5IGZvciBhbnlvbmUgdG8gcGFyc2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGFuZCBkZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyBhY3Rpb24gaXMgYWxsb3dlZAovLyBIZXJlLCBhY3Rpb24gcmVmZXJzIHRvIHRoZSBPbkNvbXBsZXRlIGluIGNvbWJpbmF0aW9uIHdpdGggd2hldGhlciB0aGUgYXBwIGlzIGJlaW5nIGNyZWF0ZWQgb3IgY2FsbGVkCi8vIEV2ZXJ5IHBvc3NpYmxlIGFjdGlvbiBmb3IgdGhpcyBjb250cmFjdCBpcyByZXByZXNlbnRlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudAovLyBJZiB0aGUgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgY29udHJhY3QsIGl0cyByZXNwZWN0aXZlIGJyYW5jaCB3aWxsIGJlICIqTk9UX0lNUExFTUVOVEVEIiB3aGljaCBqdXN0IGNvbnRhaW5zICJlcnIiCnR4biBBcHBsaWNhdGlvbklECiEKcHVzaGludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJLy8gVGhlIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udHJhY3QuIEFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgT25Db21wbGV0ZT8gRGlkIHlvdSBzZXQgeW91ciBhcHAgSUQ/CgllcnIKCi8vIHZlcmlmeU1CUlBheW1lbnQocGF5bWVudDogUGF5VHhuLCBwcmVNQlI6IHVpbnQ2NCk6IHZvaWQKdmVyaWZ5TUJSUGF5bWVudDoKCXByb3RvIDIgMAoKCS8vIGV4YW1wbGVzL2FyYzc1L2FyYzc1LmFsZ28udHM6MTAKCS8vIHZlcmlmeVBheVR4bihwYXltZW50LCB7CgkvLyAgICAgICByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIGFtb3VudDogdGhpcy5hcHAuYWRkcmVzcy5taW5CYWxhbmNlIC0gcHJlTUJSLAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyBwYXltZW50OiBQYXlUeG4KCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InBheW1lbnQiLCJmaWVsZCI6InJlY2VpdmVyIiwiZXhwZWN0ZWQiOiJ0aGlzLmFwcC5hZGRyZXNzIn0KCWFzc2VydAoKCS8vIHZlcmlmeSBhbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBwYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQoJcG9wCglmcmFtZV9kaWcgLTIgLy8gcHJlTUJSOiB1aW50NjQKCS0KCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJwYXltZW50IiwiZmllbGQiOiJhbW91bnQiLCJleHBlY3RlZCI6InRoaXMuYXBwLmFkZHJlc3MubWluQmFsYW5jZSAtIHByZU1CUiJ9Cglhc3NlcnQKCXJldHN1YgoKLy8gc2VuZE1CUlBheW1lbnQocHJlTUJSOiB1aW50NjQpOiB2b2lkCnNlbmRNQlJQYXltZW50OgoJcHJvdG8gMSAwCgoJLy8gZXhhbXBsZXMvYXJjNzUvYXJjNzUuYWxnby50czoxNwoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlciwKCS8vICAgICAgIGFtb3VudDogcHJlTUJSIC0gdGhpcy5hcHAuYWRkcmVzcy5taW5CYWxhbmNlLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDAgLy8gIHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGV4YW1wbGVzL2FyYzc1L2FyYzc1LmFsZ28udHM6MTgKCS8vIHJlY2VpdmVyOiB0aGlzLnR4bi5zZW5kZXIKCXR4biBTZW5kZXIKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBleGFtcGxlcy9hcmM3NS9hcmM3NS5hbGdvLnRzOjE5CgkvLyBhbW91bnQ6IHByZU1CUiAtIHRoaXMuYXBwLmFkZHJlc3MubWluQmFsYW5jZQoJZnJhbWVfZGlnIC0xIC8vIHByZU1CUjogdWludDY0CglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCglwb3AKCS0KCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAzIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBhZGRBcHBUb1doaXRlTGlzdChzdHJpbmcsdWludDE2LHVpbnQ2NCxwYXkpdm9pZAoqYWJpX3JvdXRlX2FkZEFwcFRvV2hpdGVMaXN0OgoJLy8gcGF5bWVudDogcGF5Cgl0eG4gR3JvdXBJbmRleAoJaW50YyAwIC8vIDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludGMgMCAvLyAgcGF5Cgk9PQoKCS8vIGFyZ3VtZW50IDAgKHBheW1lbnQpIGZvciBhZGRBcHBUb1doaXRlTGlzdCBtdXN0IGJlIGEgcGF5IHRyYW5zYWN0aW9uCglhc3NlcnQKCgkvLyBhcHBJRDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gYm94SW5kZXg6IHVpbnQxNgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMiAvLyAyCgk9PQoKCS8vIGFyZ3VtZW50IDIgKGJveEluZGV4KSBmb3IgYWRkQXBwVG9XaGl0ZUxpc3QgbXVzdCBiZSBhIHVpbnQxNgoJYXNzZXJ0CglidG9pCgoJLy8gYXJjOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBhZGRBcHBUb1doaXRlTGlzdChzdHJpbmcsdWludDE2LHVpbnQ2NCxwYXkpdm9pZAoJY2FsbHN1YiBhZGRBcHBUb1doaXRlTGlzdAoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gYWRkQXBwVG9XaGl0ZUxpc3QoYXJjOiBzdHJpbmcsIGJveEluZGV4OiB1aW50MTYsIGFwcElEOiB1aW50NjQsIHBheW1lbnQ6IFBheVR4bik6IHZvaWQKLy8KLy8gQWRkIGFwcCB0byB3aGl0ZWxpc3QgYm94Ci8vCi8vIEBwYXJhbSBhcmMgLSBUaGUgQVJDIHRoZSB3aGl0ZWxpc3QgY29ycmVzcG9uZHMgdG8KLy8gQHBhcmFtIGJveEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSB3aGl0ZWxpc3QgYm94IHRvIGFkZCB0aGUgYXBwIHRvCi8vIEBwYXJhbSBhcHBJRCAtIFRoZSBhcHAgSUQgdG8gYWRkIHRvIHRoZSB3aGl0ZWxpc3QKLy8gQHBhcmFtIHBheW1lbnQgLSBUaGUgcGF5bWVudCB0cmFuc2FjdGlvbiB0byBjb3ZlciB0aGUgTUJSIGNoYW5nZQphZGRBcHBUb1doaXRlTGlzdDoKCXByb3RvIDQgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXBuIDIKCgkvLyBleGFtcGxlcy9hcmM3NS9hcmM3NS5hbGdvLnRzOjMzCgkvLyBwcmVNQlIgPSB0aGlzLmFwcC5hZGRyZXNzLm1pbkJhbGFuY2UKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKCXBvcAoJZnJhbWVfYnVyeSAwIC8vIHByZU1CUjogdWludDY0CgoJLy8gZXhhbXBsZXMvYXJjNzUvYXJjNzUuYWxnby50czozNAoJLy8gd2hpdGVsaXN0OiBXaGl0ZWxpc3QgPSB7IGFjY291bnQ6IHRoaXMudHhuLnNlbmRlciwgYm94SW5kZXg6IGJveEluZGV4LCBhcmM6IGFyYyB9CglieXRlYyAwIC8vICBpbml0aWFsIGhlYWQKCWJ5dGVjIDAgLy8gIGluaXRpYWwgdGFpbAoJYnl0ZWMgMSAvLyAgaW5pdGlhbCBoZWFkIG9mZnNldAoJdHhuIFNlbmRlcgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIC0yIC8vIGJveEluZGV4OiB1aW50MTYKCWl0b2IKCWV4dHJhY3QgNiAyCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTEgLy8gYXJjOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CgljYWxsc3ViICpwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCglmcmFtZV9idXJ5IDEgLy8gd2hpdGVsaXN0OiBXaGl0ZWxpc3QKCgkvLyAqaWYwX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvYXJjNzUvYXJjNzUuYWxnby50czozNgoJLy8gdGhpcy53aGl0ZWxpc3Qod2hpdGVsaXN0KS5leGlzdHMKCWZyYW1lX2RpZyAxIC8vIHdoaXRlbGlzdDogV2hpdGVsaXN0Cglib3hfbGVuCglzd2FwCglwb3AKCWJ6ICppZjBfZWxzZQoKCS8vICppZjBfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvYXJjNzUvYXJjNzUuYWxnby50czozNwoJLy8gdGhpcy53aGl0ZWxpc3Qod2hpdGVsaXN0KS52YWx1ZS5wdXNoKGFwcElEKQoJZnJhbWVfZGlnIDEgLy8gd2hpdGVsaXN0OiBXaGl0ZWxpc3QKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMud2hpdGVsaXN0KHdoaXRlbGlzdCkudmFsdWUKCWFzc2VydAoJZXh0cmFjdCAyIDAKCWZyYW1lX2RpZyAtMyAvLyBhcHBJRDogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAxIC8vIHdoaXRlbGlzdDogV2hpdGVsaXN0CglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJZHVwCglsZW4KCWludGMgMSAvLyA4CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cglib3hfcHV0CgliICppZjBfZW5kCgoqaWYwX2Vsc2U6CgkvLyBleGFtcGxlcy9hcmM3NS9hcmM3NS5hbGdvLnRzOjM5CgkvLyBuZXdXaGl0ZWxpc3Q6IHVpbnQ2NFtdID0gW2FwcElEXQoJZnJhbWVfZGlnIC0zIC8vIGFwcElEOiB1aW50NjQKCWl0b2IKCWZyYW1lX2J1cnkgMiAvLyBuZXdXaGl0ZWxpc3Q6IHVpbnQ2NFtdCgoJLy8gZXhhbXBsZXMvYXJjNzUvYXJjNzUuYWxnby50czo0MAoJLy8gdGhpcy53aGl0ZWxpc3Qod2hpdGVsaXN0KS52YWx1ZSA9IG5ld1doaXRlbGlzdAoJZnJhbWVfZGlnIDEgLy8gd2hpdGVsaXN0OiBXaGl0ZWxpc3QKCWR1cAoJYm94X2RlbAoJcG9wCglmcmFtZV9kaWcgMiAvLyBuZXdXaGl0ZWxpc3Q6IHVpbnQ2NFtdCglkdXAKCWxlbgoJaW50YyAxIC8vIDgKCS8KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWJveF9wdXQKCippZjBfZW5kOgoJLy8gZXhhbXBsZXMvYXJjNzUvYXJjNzUuYWxnby50czo0MwoJLy8gdGhpcy52ZXJpZnlNQlJQYXltZW50KHBheW1lbnQsIHByZU1CUikKCWZyYW1lX2RpZyAwIC8vIHByZU1CUjogdWludDY0CglmcmFtZV9kaWcgLTQgLy8gcGF5bWVudDogUGF5VHhuCgljYWxsc3ViIHZlcmlmeU1CUlBheW1lbnQKCXJldHN1YgoKLy8gc2V0QXBwV2hpdGVsaXN0KHN0cmluZyx1aW50MTYsdWludDY0W10pdm9pZAoqYWJpX3JvdXRlX3NldEFwcFdoaXRlbGlzdDoKCS8vIGFwcElEczogdWludDY0W10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWV4dHJhY3QgMiAwCgoJLy8gYm94SW5kZXg6IHVpbnQxNgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMiAvLyAyCgk9PQoKCS8vIGFyZ3VtZW50IDEgKGJveEluZGV4KSBmb3Igc2V0QXBwV2hpdGVsaXN0IG11c3QgYmUgYSB1aW50MTYKCWFzc2VydAoJYnRvaQoKCS8vIGFyYzogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgc2V0QXBwV2hpdGVsaXN0KHN0cmluZyx1aW50MTYsdWludDY0W10pdm9pZAoJY2FsbHN1YiBzZXRBcHBXaGl0ZWxpc3QKCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIHNldEFwcFdoaXRlbGlzdChhcmM6IHN0cmluZywgYm94SW5kZXg6IHVpbnQxNiwgYXBwSURzOiB1aW50NjRbXSk6IHZvaWQKLy8KLy8gU2V0cyBhIGFwcCB3aGl0ZWxpc3QgZm9yIHRoZSBzZW5kZXIuIFNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBhZGRpbmcvcmVtb3ZpbmcKLy8gbW9yZSB0aGFuIG9uZSBhcHAKLy8KLy8gQHBhcmFtIGJveEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSB3aGl0ZWxpc3QgYm94IHRvIHB1dCB0aGUgYXBwIElEcyBpbgovLyBAcGFyYW0gYXBwSURzIC0gQXJyYXkgb2YgYXBwIElEcyB0aGF0IHNpZ25pZnkgdGhlIHdoaXRlbGlzdGVkIGFwcHMKc2V0QXBwV2hpdGVsaXN0OgoJcHJvdG8gMyAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cAoKCS8vIGV4YW1wbGVzL2FyYzc1L2FyYzc1LmFsZ28udHM6NTUKCS8vIHByZU1CUiA9IHRoaXMuYXBwLmFkZHJlc3MubWluQmFsYW5jZQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQoJcG9wCglmcmFtZV9idXJ5IDAgLy8gcHJlTUJSOiB1aW50NjQKCgkvLyBleGFtcGxlcy9hcmM3NS9hcmM3NS5hbGdvLnRzOjU2CgkvLyB3aGl0ZWxpc3Q6IFdoaXRlbGlzdCA9IHsgYWNjb3VudDogdGhpcy50eG4uc2VuZGVyLCBib3hJbmRleDogYm94SW5kZXgsIGFyYzogYXJjIH0KCWJ5dGVjIDAgLy8gIGluaXRpYWwgaGVhZAoJYnl0ZWMgMCAvLyAgaW5pdGlhbCB0YWlsCglieXRlYyAxIC8vICBpbml0aWFsIGhlYWQgb2Zmc2V0Cgl0eG4gU2VuZGVyCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTIgLy8gYm94SW5kZXg6IHVpbnQxNgoJaXRvYgoJZXh0cmFjdCA2IDIKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMSAvLyBhcmM6IHN0cmluZwoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50Cglwb3AgLy8gcG9wIGhlYWQgb2Zmc2V0Cgljb25jYXQgLy8gY29uY2F0IGhlYWQgYW5kIHRhaWwKCWZyYW1lX2J1cnkgMSAvLyB3aGl0ZWxpc3Q6IFdoaXRlbGlzdAoKCS8vIGV4YW1wbGVzL2FyYzc1L2FyYzc1LmFsZ28udHM6NTgKCS8vIHRoaXMud2hpdGVsaXN0KHdoaXRlbGlzdCkuZGVsZXRlKCkKCWZyYW1lX2RpZyAxIC8vIHdoaXRlbGlzdDogV2hpdGVsaXN0Cglib3hfZGVsCgoJLy8gZXhhbXBsZXMvYXJjNzUvYXJjNzUuYWxnby50czo2MAoJLy8gdGhpcy53aGl0ZWxpc3Qod2hpdGVsaXN0KS52YWx1ZSA9IGFwcElEcwoJZnJhbWVfZGlnIDEgLy8gd2hpdGVsaXN0OiBXaGl0ZWxpc3QKCWR1cAoJYm94X2RlbAoJcG9wCglmcmFtZV9kaWcgLTMgLy8gYXBwSURzOiB1aW50NjRbXQoJZHVwCglsZW4KCWludGMgMSAvLyA4CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cglib3hfcHV0CgoJLy8gKmlmMV9jb25kaXRpb24KCS8vIGV4YW1wbGVzL2FyYzc1L2FyYzc1LmFsZ28udHM6NjIKCS8vIHByZU1CUiA+IHRoaXMuYXBwLmFkZHJlc3MubWluQmFsYW5jZQoJZnJhbWVfZGlnIDAgLy8gcHJlTUJSOiB1aW50NjQKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKCXBvcAoJPgoJYnogKmlmMV9lbHNlCgoJLy8gKmlmMV9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9hcmM3NS9hcmM3NS5hbGdvLnRzOjYzCgkvLyB0aGlzLnNlbmRNQlJQYXltZW50KHByZU1CUikKCWZyYW1lX2RpZyAwIC8vIHByZU1CUjogdWludDY0CgljYWxsc3ViIHNlbmRNQlJQYXltZW50CgliICppZjFfZW5kCgoqaWYxX2Vsc2U6CgkvLyBleGFtcGxlcy9hcmM3NS9hcmM3NS5hbGdvLnRzOjY1CgkvLyB0aGlzLnZlcmlmeU1CUlBheW1lbnQodGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4IC0gMV0gYXMgUGF5VHhuLCBwcmVNQlIpCglmcmFtZV9kaWcgMCAvLyBwcmVNQlI6IHVpbnQ2NAoJdHhuIEdyb3VwSW5kZXgKCWludGMgMCAvLyAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnRjIDAgLy8gIHBheQoJPT0KCgkvLyBmYWlsZWQgdG8gY2FzdCB0aGlzLnR4bkdyb3VwW3RoaXMudHhuLmdyb3VwSW5kZXggLSAxXSB0byBwYXkKCWFzc2VydAoJY2FsbHN1YiB2ZXJpZnlNQlJQYXltZW50CgoqaWYxX2VuZDoKCXJldHN1YgoKLy8gZGVsZXRlV2hpdGVsaXN0KHN0cmluZyx1aW50MTYpdm9pZAoqYWJpX3JvdXRlX2RlbGV0ZVdoaXRlbGlzdDoKCS8vIGJveEluZGV4OiB1aW50MTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDIgLy8gMgoJPT0KCgkvLyBhcmd1bWVudCAwIChib3hJbmRleCkgZm9yIGRlbGV0ZVdoaXRlbGlzdCBtdXN0IGJlIGEgdWludDE2Cglhc3NlcnQKCWJ0b2kKCgkvLyBhcmM6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIGRlbGV0ZVdoaXRlbGlzdChzdHJpbmcsdWludDE2KXZvaWQKCWNhbGxzdWIgZGVsZXRlV2hpdGVsaXN0CglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBkZWxldGVXaGl0ZWxpc3QoYXJjOiBzdHJpbmcsIGJveEluZGV4OiB1aW50MTYpOiB2b2lkCi8vCi8vIERlbGV0ZXMgYSBhcHAgd2hpdGVsaXN0IGZvciB0aGUgc2VuZGVyCi8vCi8vIEBwYXJhbSBhcmMgLSBUaGUgQVJDIHRoZSB3aGl0ZWxpc3QgY29ycmVzcG9uZHMgdG8KLy8gQHBhcmFtIGJveEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSB3aGl0ZWxpc3QgYm94IHRvIGRlbGV0ZQpkZWxldGVXaGl0ZWxpc3Q6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gZXhhbXBsZXMvYXJjNzUvYXJjNzUuYWxnby50czo3NwoJLy8gcHJlTUJSID0gdGhpcy5hcHAuYWRkcmVzcy5taW5CYWxhbmNlCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCglwb3AKCWZyYW1lX2J1cnkgMCAvLyBwcmVNQlI6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL2FyYzc1L2FyYzc1LmFsZ28udHM6NzgKCS8vIHdoaXRlbGlzdDogV2hpdGVsaXN0ID0geyBhY2NvdW50OiB0aGlzLnR4bi5zZW5kZXIsIGJveEluZGV4OiBib3hJbmRleCwgYXJjOiBhcmMgfQoJYnl0ZWMgMCAvLyAgaW5pdGlhbCBoZWFkCglieXRlYyAwIC8vICBpbml0aWFsIHRhaWwKCWJ5dGVjIDEgLy8gIGluaXRpYWwgaGVhZCBvZmZzZXQKCXR4biBTZW5kZXIKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMiAvLyBib3hJbmRleDogdWludDE2CglpdG9iCglleHRyYWN0IDYgMgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIC0xIC8vIGFyYzogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJZnJhbWVfYnVyeSAxIC8vIHdoaXRlbGlzdDogV2hpdGVsaXN0CgoJLy8gZXhhbXBsZXMvYXJjNzUvYXJjNzUuYWxnby50czo4MAoJLy8gdGhpcy53aGl0ZWxpc3Qod2hpdGVsaXN0KS5kZWxldGUoKQoJZnJhbWVfZGlnIDEgLy8gd2hpdGVsaXN0OiBXaGl0ZWxpc3QKCWJveF9kZWwKCgkvLyBleGFtcGxlcy9hcmM3NS9hcmM3NS5hbGdvLnRzOjgyCgkvLyB0aGlzLnNlbmRNQlJQYXltZW50KHByZU1CUikKCWZyYW1lX2RpZyAwIC8vIHByZU1CUjogdWludDY0CgljYWxsc3ViIHNlbmRNQlJQYXltZW50CglyZXRzdWIKCi8vIGRlbGV0ZUFwcEZyb21XaGl0ZWxpc3Qoc3RyaW5nLHVpbnQxNix1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9kZWxldGVBcHBGcm9tV2hpdGVsaXN0OgoJLy8gaW5kZXg6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJYnRvaQoKCS8vIGFwcElEOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyBib3hJbmRleDogdWludDE2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAyIC8vIDIKCT09CgoJLy8gYXJndW1lbnQgMiAoYm94SW5kZXgpIGZvciBkZWxldGVBcHBGcm9tV2hpdGVsaXN0IG11c3QgYmUgYSB1aW50MTYKCWFzc2VydAoJYnRvaQoKCS8vIGFyYzogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgZGVsZXRlQXBwRnJvbVdoaXRlbGlzdChzdHJpbmcsdWludDE2LHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBkZWxldGVBcHBGcm9tV2hpdGVsaXN0CglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBkZWxldGVBcHBGcm9tV2hpdGVsaXN0KGFyYzogc3RyaW5nLCBib3hJbmRleDogdWludDE2LCBhcHBJRDogdWludDY0LCBpbmRleDogdWludDY0KTogdm9pZAovLwovLyBEZWxldGVzIGEgYXBwIGZyb20gYSB3aGl0ZWxpc3QgZm9yIHRoZSBzZW5kZXIKLy8KLy8gQHBhcmFtIGJveEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSB3aGl0ZWxpc3QgYm94IHRvIGRlbGV0ZSBmcm9tCi8vIEBwYXJhbSBhcHBJRCAtIFRoZSBhcHAgSUQgdG8gZGVsZXRlIGZyb20gdGhlIHdoaXRlbGlzdAovLyBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGFwcCBpbiB0aGUgd2hpdGVsaXN0CmRlbGV0ZUFwcEZyb21XaGl0ZWxpc3Q6Cglwcm90byA0IDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiAyCgoJLy8gZXhhbXBsZXMvYXJjNzUvYXJjNzUuYWxnby50czo5NAoJLy8gcHJlTUJSID0gdGhpcy5hcHAuYWRkcmVzcy5taW5CYWxhbmNlCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCglwb3AKCWZyYW1lX2J1cnkgMCAvLyBwcmVNQlI6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL2FyYzc1L2FyYzc1LmFsZ28udHM6OTUKCS8vIHdoaXRlbGlzdDogV2hpdGVsaXN0ID0geyBhY2NvdW50OiB0aGlzLnR4bi5zZW5kZXIsIGJveEluZGV4OiBib3hJbmRleCwgYXJjOiBhcmMgfQoJYnl0ZWMgMCAvLyAgaW5pdGlhbCBoZWFkCglieXRlYyAwIC8vICBpbml0aWFsIHRhaWwKCWJ5dGVjIDEgLy8gIGluaXRpYWwgaGVhZCBvZmZzZXQKCXR4biBTZW5kZXIKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMiAvLyBib3hJbmRleDogdWludDE2CglpdG9iCglleHRyYWN0IDYgMgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIC0xIC8vIGFyYzogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJZnJhbWVfYnVyeSAxIC8vIHdoaXRlbGlzdDogV2hpdGVsaXN0CgoJLy8gZXhhbXBsZXMvYXJjNzUvYXJjNzUuYWxnby50czo5NwoJLy8gc3BsaWNlZCA9IHRoaXMud2hpdGVsaXN0KHdoaXRlbGlzdCkudmFsdWUuc3BsaWNlKGluZGV4LCAxKQoJZnJhbWVfZGlnIDEgLy8gd2hpdGVsaXN0OiBXaGl0ZWxpc3QKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMud2hpdGVsaXN0KHdoaXRlbGlzdCkudmFsdWUKCWFzc2VydAoJZXh0cmFjdCAyIDAKCWludGMgMCAvLyAxCglmcmFtZV9kaWcgLTQgLy8gaW5kZXg6IHVpbnQ2NAoJaW50YyAxIC8vIDgKCSoKCXN0b3JlIDI0NyAvLyBzcGxpY2Ugc3RhcnQKCXB1c2hpbnQgMTYKCXN0b3JlIDI0NiAvLyBzcGxpY2UgYnl0ZSBsZW5ndGgKCWZyYW1lX2RpZyAxIC8vIHdoaXRlbGlzdDogV2hpdGVsaXN0Cglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLndoaXRlbGlzdCh3aGl0ZWxpc3QpLnZhbHVlCglhc3NlcnQKCWV4dHJhY3QgMiAwCglpbnRjIDMgLy8gMAoJbG9hZCAyNDcgLy8gc3BsaWNlIHN0YXJ0CglzdWJzdHJpbmczCglmcmFtZV9kaWcgMSAvLyB3aGl0ZWxpc3Q6IFdoaXRlbGlzdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy53aGl0ZWxpc3Qod2hpdGVsaXN0KS52YWx1ZQoJYXNzZXJ0CglleHRyYWN0IDIgMAoJZHVwCglsZW4KCWxvYWQgMjQ3IC8vIHNwbGljZSBzdGFydAoJbG9hZCAyNDYgLy8gc3BsaWNlIGJ5dGUgbGVuZ3RoCgkrCglpbnRjIDEgLy8gOAoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY29uY2F0CglmcmFtZV9kaWcgMSAvLyB3aGl0ZWxpc3Q6IFdoaXRlbGlzdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy53aGl0ZWxpc3Qod2hpdGVsaXN0KS52YWx1ZQoJYXNzZXJ0CglleHRyYWN0IDIgMAoJbG9hZCAyNDcgLy8gc3BsaWNlIHN0YXJ0Cglsb2FkIDI0NiAvLyBzcGxpY2UgYnl0ZSBsZW5ndGgKCWludGMgMSAvLyA4CgktCglleHRyYWN0MwoJc3dhcAoJZnJhbWVfZGlnIDEgLy8gd2hpdGVsaXN0OiBXaGl0ZWxpc3QKCWR1cAoJYm94X2RlbAoJcG9wCglzd2FwCglkdXAKCWxlbgoJaW50YyAxIC8vIDgKCS8KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWJveF9wdXQKCWZyYW1lX2J1cnkgMiAvLyBzcGxpY2VkOiB1aW50NjRbXQoKCS8vIGV4YW1wbGVzL2FyYzc1L2FyYzc1LmFsZ28udHM6OTkKCS8vIGFzc2VydChzcGxpY2VkWzBdID09PSBhcHBJRCkKCWZyYW1lX2RpZyAyIC8vIHNwbGljZWQ6IHVpbnQ2NFtdCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWZyYW1lX2RpZyAtMyAvLyBhcHBJRDogdWludDY0Cgk9PQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvYXJjNzUvYXJjNzUuYWxnby50czoxMDEKCS8vIHRoaXMuc2VuZE1CUlBheW1lbnQocHJlTUJSKQoJZnJhbWVfZGlnIDAgLy8gcHJlTUJSOiB1aW50NjQKCWNhbGxzdWIgc2VuZE1CUlBheW1lbnQKCXJldHN1YgoKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCWludGMgMCAvLyAxCglyZXR1cm4KCipjcmVhdGVfTm9PcDoKCXB1c2hieXRlcyAweGI4NDQ3YjM2IC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNyZWF0ZSBOb09wCgllcnIKCipjYWxsX05vT3A6CglwdXNoYnl0ZXMgMHg0NjdjN2NiZCAvLyBtZXRob2QgImFkZEFwcFRvV2hpdGVMaXN0KHN0cmluZyx1aW50MTYsdWludDY0LHBheSl2b2lkIgoJcHVzaGJ5dGVzIDB4ZDE5OGZjYjggLy8gbWV0aG9kICJzZXRBcHBXaGl0ZWxpc3Qoc3RyaW5nLHVpbnQxNix1aW50NjRbXSl2b2lkIgoJcHVzaGJ5dGVzIDB4N2MzM2U4MzIgLy8gbWV0aG9kICJkZWxldGVXaGl0ZWxpc3Qoc3RyaW5nLHVpbnQxNil2b2lkIgoJcHVzaGJ5dGVzIDB4N2UxNjc0YWMgLy8gbWV0aG9kICJkZWxldGVBcHBGcm9tV2hpdGVsaXN0KHN0cmluZyx1aW50MTYsdWludDY0LHVpbnQ2NCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9hZGRBcHBUb1doaXRlTGlzdCAqYWJpX3JvdXRlX3NldEFwcFdoaXRlbGlzdCAqYWJpX3JvdXRlX2RlbGV0ZVdoaXRlbGlzdCAqYWJpX3JvdXRlX2RlbGV0ZUFwcEZyb21XaGl0ZWxpc3QKCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBOb09wCgllcnIKCipwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50OgoJcHJvdG8gNCAzCglmcmFtZV9kaWcgLTQgLy8gdHVwbGUgaGVhZAoJZnJhbWVfZGlnIC0xIC8vIGVsZW1lbnQKCWNvbmNhdAoJZnJhbWVfZGlnIC0zIC8vIHR1cGxlIHRhaWwKCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJcmV0c3ViCgoqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQ6Cglwcm90byA0IDMKCWZyYW1lX2RpZyAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCWNvbmNhdAoJZnJhbWVfYnVyeSAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTEgLy8gZWxlbWVudAoJZHVwCglsZW4KCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJYnRvaQoJKwoJaXRvYgoJZXh0cmFjdCA2IDIKCWZyYW1lX2J1cnkgLTIgLy8gaGVhZCBvZmZzZXQKCWZyYW1lX2RpZyAtMyAvLyB0dXBsZSB0YWlsCglzd2FwCgljb25jYXQKCWZyYW1lX2J1cnkgLTMgLy8gdHVwbGUgdGFpbAoJZnJhbWVfZGlnIC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMyAvLyB0dXBsZSB0YWlsCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCXJldHN1Yg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples Auction Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 1 0 4
bytecblock 0x70726576696f7573426964646572 0x70726576696f7573426964 0x61756374696f6e456e64 0x636c61696d61626c65416d6f756e74 0x617361416d74 0x617361 0x

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *call_OptIn *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// examples/auction/auction.algo.ts:18
	// this.auctionEnd.value = 0
	bytec 2 //  "auctionEnd"
	intc 1 // 0
	app_global_put

	// examples/auction/auction.algo.ts:19
	// this.previousBid.value = 0
	bytec 1 //  "previousBid"
	intc 1 // 0
	app_global_put

	// examples/auction/auction.algo.ts:20
	// this.asaAmt.value = 0
	bytec 4 //  "asaAmt"
	intc 1 // 0
	app_global_put

	// examples/auction/auction.algo.ts:21
	// this.asa.value = AssetID.zeroIndex
	bytec 5 //  "asa"
	intc 1 // 0
	app_global_put

	// examples/auction/auction.algo.ts:24
	// this.previousBidder.value = globals.zeroAddress
	bytec 0 //  "previousBidder"
	global ZeroAddress
	app_global_put
	retsub

// optIntoAsset(uint64)void
*abi_route_optIntoAsset:
	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute optIntoAsset(uint64)void
	callsub optIntoAsset
	intc 0 // 1
	return

// optIntoAsset(asset: AssetID): void
optIntoAsset:
	proto 1 0

	// Only allow app creator to opt the app account into a ASA
	// examples/auction/auction.algo.ts:29
	// verifyAppCallTxn(this.txn, { sender: globals.creatorAddress })
	// verify sender
	txn Sender
	global CreatorAddress
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"globals.creatorAddress"}
	assert

	// Verify a ASA hasn't already been opted into
	// examples/auction/auction.algo.ts:32
	// assert(this.asa.value === AssetID.zeroIndex)
	bytec 5 //  "asa"
	app_global_get
	intc 1 // 0
	==
	assert

	// Save ASA ID in global state
	// examples/auction/auction.algo.ts:35
	// this.asa.value = asset
	bytec 5 //  "asa"
	frame_dig -1 // asset: AssetID
	app_global_put

	// Submit opt-in transaction: 0 asset transfer to self
	// examples/auction/auction.algo.ts:38
	// sendAssetTransfer({
	//       assetReceiver: this.app.address,
	//       xferAsset: asset,
	//       assetAmount: 0,
	//     })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// examples/auction/auction.algo.ts:39
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// examples/auction/auction.algo.ts:40
	// xferAsset: asset
	frame_dig -1 // asset: AssetID
	itxn_field XferAsset

	// examples/auction/auction.algo.ts:41
	// assetAmount: 0
	intc 1 // 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// startAuction(uint64,uint64,axfer)void
*abi_route_startAuction:
	// axfer: axfer
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 2 //  axfer
	==

	// argument 0 (axfer) for startAuction must be a axfer transaction
	assert

	// length: uint64
	txna ApplicationArgs 2
	btoi

	// startingPrice: uint64
	txna ApplicationArgs 1
	btoi

	// execute startAuction(uint64,uint64,axfer)void
	callsub startAuction
	intc 0 // 1
	return

// startAuction(startingPrice: uint64, length: uint64, axfer: AssetTransferTxn): void
startAuction:
	proto 3 0

	// examples/auction/auction.algo.ts:46
	// verifyAppCallTxn(this.txn, { sender: globals.creatorAddress })
	// verify sender
	txn Sender
	global CreatorAddress
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"globals.creatorAddress"}
	assert

	// Ensure the auction hasn't already been started
	// examples/auction/auction.algo.ts:49
	// assert(this.auctionEnd.value === 0)
	bytec 2 //  "auctionEnd"
	app_global_get
	intc 1 // 0
	==
	assert

	// Verify axfer
	// examples/auction/auction.algo.ts:52
	// verifyAssetTransferTxn(axfer, { assetReceiver: this.app.address })
	// verify assetReceiver
	frame_dig -3 // axfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"axfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// Set global state
	// examples/auction/auction.algo.ts:55
	// this.asaAmt.value = axfer.assetAmount
	bytec 4 //  "asaAmt"
	frame_dig -3 // axfer: AssetTransferTxn
	gtxns AssetAmount
	app_global_put

	// examples/auction/auction.algo.ts:56
	// this.auctionEnd.value = globals.latestTimestamp + length
	bytec 2 //  "auctionEnd"
	global LatestTimestamp
	frame_dig -2 // length: uint64
	+
	app_global_put

	// examples/auction/auction.algo.ts:57
	// this.previousBid.value = startingPrice
	bytec 1 //  "previousBid"
	frame_dig -1 // startingPrice: uint64
	app_global_put
	retsub

// pay(receiver: Address, amount: uint64): void
pay:
	proto 2 0

	// examples/auction/auction.algo.ts:61
	// sendPayment({
	//       receiver: receiver,
	//       amount: amount,
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// examples/auction/auction.algo.ts:62
	// receiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field Receiver

	// examples/auction/auction.algo.ts:63
	// amount: amount
	frame_dig -2 // amount: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// optInToApplication()void
*abi_route_optInToApplication:
	// execute optInToApplication()void
	callsub optInToApplication
	intc 0 // 1
	return

// optInToApplication(): void
optInToApplication:
	proto 0 0
	retsub

// bid(pay)void
*abi_route_bid:
	// payment: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 0 (payment) for bid must be a pay transaction
	assert

	// execute bid(pay)void
	callsub bid
	intc 0 // 1
	return

// bid(payment: PayTxn): void
bid:
	proto 1 0

	// Ensure auction hasn't ended
	// examples/auction/auction.algo.ts:72
	// assert(globals.latestTimestamp < this.auctionEnd.value)
	global LatestTimestamp
	bytec 2 //  "auctionEnd"
	app_global_get
	<
	assert

	// Verify payment transaction
	// examples/auction/auction.algo.ts:75
	// verifyPayTxn(payment, {
	//       sender: this.txn.sender,
	//       amount: { greaterThan: this.previousBid.value },
	//     })
	// verify sender
	frame_dig -1 // payment: PayTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"payment","field":"sender","expected":"this.txn.sender"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	bytec 1 //  "previousBid"
	app_global_get
	>

	// transaction verification failed: {"txn":"payment","field":"amount","condition":"greaterThan","expected":">this.previousBid.value"}
	assert

	// Set global state
	// examples/auction/auction.algo.ts:81
	// this.previousBid.value = payment.amount
	bytec 1 //  "previousBid"
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	app_global_put

	// examples/auction/auction.algo.ts:82
	// this.previousBidder.value = payment.sender
	bytec 0 //  "previousBidder"
	frame_dig -1 // payment: PayTxn
	gtxns Sender
	app_global_put

	// Update claimable amount
	// examples/auction/auction.algo.ts:85
	// this.claimableAmount(this.txn.sender).value = payment.amount
	txn Sender
	bytec 3 //  "claimableAmount"
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	app_local_put
	retsub

// claimBids()void
*abi_route_claimBids:
	// execute claimBids()void
	callsub claimBids
	intc 0 // 1
	return

// claimBids(): void
claimBids:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 6 // 0x
	dup

	// examples/auction/auction.algo.ts:89
	// originalAmount = this.claimableAmount(this.txn.sender).value
	txn Sender
	bytec 3 //  "claimableAmount"
	app_local_get
	frame_bury 0 // originalAmount: uint64

	// examples/auction/auction.algo.ts:90
	// amount = originalAmount
	frame_dig 0 // originalAmount: uint64
	frame_bury 1 // amount: uint64

	// subtract previous bid if sender is previous bidder
	// *if0_condition
	// examples/auction/auction.algo.ts:93
	// this.txn.sender === this.previousBidder.value
	txn Sender
	bytec 0 //  "previousBidder"
	app_global_get
	==
	bz *if0_end

	// *if0_consequent
	// examples/auction/auction.algo.ts:93
	// amount = amount - this.previousBid.value
	frame_dig 1 // amount: uint64
	bytec 1 //  "previousBid"
	app_global_get
	-
	frame_bury 1 // amount: uint64

*if0_end:
	// examples/auction/auction.algo.ts:95
	// this.pay(this.txn.sender, amount)
	frame_dig 1 // amount: uint64
	txn Sender
	callsub pay

	// examples/auction/auction.algo.ts:96
	// this.claimableAmount(this.txn.sender).value = originalAmount - amount
	txn Sender
	bytec 3 //  "claimableAmount"
	frame_dig 0 // originalAmount: uint64
	frame_dig 1 // amount: uint64
	-
	app_local_put
	retsub

// claim_asset(uint64)void
*abi_route_claim_asset:
	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute claim_asset(uint64)void
	callsub claim_asset
	intc 0 // 1
	return

// claim_asset(asset: AssetID): void
claim_asset:
	proto 1 0

	// examples/auction/auction.algo.ts:100
	// assert(globals.latestTimestamp > this.auctionEnd.value)
	global LatestTimestamp
	bytec 2 //  "auctionEnd"
	app_global_get
	>
	assert

	// Send ASA to previous bidder
	// examples/auction/auction.algo.ts:103
	// sendAssetTransfer({
	//       assetReceiver: this.previousBidder.value,
	//       xferAsset: asset,
	//       assetAmount: this.asaAmt.value,
	//       assetCloseTo: this.previousBidder.value,
	//     })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// examples/auction/auction.algo.ts:104
	// assetReceiver: this.previousBidder.value
	bytec 0 //  "previousBidder"
	app_global_get
	itxn_field AssetReceiver

	// examples/auction/auction.algo.ts:105
	// xferAsset: asset
	frame_dig -1 // asset: AssetID
	itxn_field XferAsset

	// examples/auction/auction.algo.ts:106
	// assetAmount: this.asaAmt.value
	bytec 4 //  "asaAmt"
	app_global_get
	itxn_field AssetAmount

	// examples/auction/auction.algo.ts:107
	// assetCloseTo: this.previousBidder.value
	bytec 0 //  "previousBidder"
	app_global_get
	itxn_field AssetCloseTo

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	intc 0 // 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// examples/auction/auction.algo.ts:112
	// sendPayment({
	//       receiver: globals.creatorAddress,
	//       closeRemainderTo: globals.creatorAddress,
	//       amount: 0,
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// examples/auction/auction.algo.ts:113
	// receiver: globals.creatorAddress
	global CreatorAddress
	itxn_field Receiver

	// examples/auction/auction.algo.ts:114
	// closeRemainderTo: globals.creatorAddress
	global CreatorAddress
	itxn_field CloseRemainderTo

	// examples/auction/auction.algo.ts:115
	// amount: 0
	intc 1 // 0
	itxn_field Amount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x3987f0c1 // method "optIntoAsset(uint64)void"
	pushbytes 0xc2725922 // method "startAuction(uint64,uint64,axfer)void"
	pushbytes 0xdb7fe843 // method "bid(pay)void"
	pushbytes 0x032f650d // method "claimBids()void"
	pushbytes 0x59b2ab26 // method "claim_asset(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_optIntoAsset *abi_route_startAuction *abi_route_bid *abi_route_claimBids *abi_route_claim_asset

	// this contract does not implement the given ABI method for call NoOp
	err

*call_OptIn:
	pushbytes 0x01a3a3ff // method "optInToApplication()void"
	txna ApplicationArgs 0
	match *abi_route_optInToApplication

	// this contract does not implement the given ABI method for call OptIn
	err

*call_DeleteApplication:
	pushbytes 0x2487c32c // method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err"
`;

exports[`Examples Auction Artifacts Maintains program size 1`] = `553`;

exports[`Examples Auction Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "asset",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "optIntoAsset",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "startingPrice",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "length",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "axfer",
          "type": "axfer",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "startAuction",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "optInToApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "payment",
          "type": "pay",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "bid",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "claimBids",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "asset",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "claim_asset",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "deleteApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "Auction",
}
`;

exports[`Examples Auction Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "asset",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "optIntoAsset",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "startingPrice",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "length",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "axfer",
            "type": "axfer",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "startAuction",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "optInToApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "payment",
            "type": "pay",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "bid",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "claimBids",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "asset",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "claim_asset",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "deleteApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "Auction",
  },
  "hints": {
    "bid(pay)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "claimBids()void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "claim_asset(uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "deleteApplication()void": {
      "call_config": {
        "delete_application": "CALL",
      },
    },
    "optInToApplication()void": {
      "call_config": {
        "opt_in": "CALL",
      },
    },
    "optIntoAsset(uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "startAuction(uint64,uint64,axfer)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {
        "asa": {
          "key": "asa",
          "type": "uint64",
        },
        "asaAmt": {
          "key": "asaAmt",
          "type": "uint64",
        },
        "auctionEnd": {
          "key": "auctionEnd",
          "type": "uint64",
        },
        "previousBid": {
          "key": "previousBid",
          "type": "uint64",
        },
        "previousBidder": {
          "key": "previousBidder",
          "type": "bytes",
        },
      },
      "reserved": {},
    },
    "local": {
      "declared": {
        "claimableAmount": {
          "key": "claimableAmount",
          "type": "uint64",
        },
      },
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAxIDAgNApieXRlY2Jsb2NrIDB4NzA3MjY1NzY2OTZmNzU3MzQyNjk2NDY0NjU3MiAweDcwNzI2NTc2Njk2Zjc1NzM0MjY5NjQgMHg2MTc1NjM3NDY5NmY2ZTQ1NmU2NCAweDYzNmM2MTY5NmQ2MTYyNmM2NTQxNmQ2Zjc1NmU3NCAweDYxNzM2MTQxNmQ3NCAweDYxNzM2MSAweAoKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCnB1c2hpbnQgNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggKmNhbGxfTm9PcCAqY2FsbF9PcHRJbiAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY2FsbF9EZWxldGVBcHBsaWNhdGlvbiAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJLy8gVGhlIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udHJhY3QuIEFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgT25Db21wbGV0ZT8gRGlkIHlvdSBzZXQgeW91ciBhcHAgSUQ/CgllcnIKCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CgkvLyBleGVjdXRlIGNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkCgljYWxsc3ViIGNyZWF0ZUFwcGxpY2F0aW9uCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpOiB2b2lkCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMCAwCgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6MTgKCS8vIHRoaXMuYXVjdGlvbkVuZC52YWx1ZSA9IDAKCWJ5dGVjIDIgLy8gICJhdWN0aW9uRW5kIgoJaW50YyAxIC8vIDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6MTkKCS8vIHRoaXMucHJldmlvdXNCaWQudmFsdWUgPSAwCglieXRlYyAxIC8vICAicHJldmlvdXNCaWQiCglpbnRjIDEgLy8gMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czoyMAoJLy8gdGhpcy5hc2FBbXQudmFsdWUgPSAwCglieXRlYyA0IC8vICAiYXNhQW10IgoJaW50YyAxIC8vIDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6MjEKCS8vIHRoaXMuYXNhLnZhbHVlID0gQXNzZXRJRC56ZXJvSW5kZXgKCWJ5dGVjIDUgLy8gICJhc2EiCglpbnRjIDEgLy8gMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czoyNAoJLy8gdGhpcy5wcmV2aW91c0JpZGRlci52YWx1ZSA9IGdsb2JhbHMuemVyb0FkZHJlc3MKCWJ5dGVjIDAgLy8gICJwcmV2aW91c0JpZGRlciIKCWdsb2JhbCBaZXJvQWRkcmVzcwoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gb3B0SW50b0Fzc2V0KHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfb3B0SW50b0Fzc2V0OgoJLy8gYXNzZXQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgb3B0SW50b0Fzc2V0KHVpbnQ2NCl2b2lkCgljYWxsc3ViIG9wdEludG9Bc3NldAoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gb3B0SW50b0Fzc2V0KGFzc2V0OiBBc3NldElEKTogdm9pZApvcHRJbnRvQXNzZXQ6Cglwcm90byAxIDAKCgkvLyBPbmx5IGFsbG93IGFwcCBjcmVhdG9yIHRvIG9wdCB0aGUgYXBwIGFjY291bnQgaW50byBhIEFTQQoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6MjkKCS8vIHZlcmlmeUFwcENhbGxUeG4odGhpcy50eG4sIHsgc2VuZGVyOiBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCgl0eG4gU2VuZGVyCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJ0aGlzLnR4biIsImZpZWxkIjoic2VuZGVyIiwiZXhwZWN0ZWQiOiJnbG9iYWxzLmNyZWF0b3JBZGRyZXNzIn0KCWFzc2VydAoKCS8vIFZlcmlmeSBhIEFTQSBoYXNuJ3QgYWxyZWFkeSBiZWVuIG9wdGVkIGludG8KCS8vIGV4YW1wbGVzL2F1Y3Rpb24vYXVjdGlvbi5hbGdvLnRzOjMyCgkvLyBhc3NlcnQodGhpcy5hc2EudmFsdWUgPT09IEFzc2V0SUQuemVyb0luZGV4KQoJYnl0ZWMgNSAvLyAgImFzYSIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDEgLy8gMAoJPT0KCWFzc2VydAoKCS8vIFNhdmUgQVNBIElEIGluIGdsb2JhbCBzdGF0ZQoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6MzUKCS8vIHRoaXMuYXNhLnZhbHVlID0gYXNzZXQKCWJ5dGVjIDUgLy8gICJhc2EiCglmcmFtZV9kaWcgLTEgLy8gYXNzZXQ6IEFzc2V0SUQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gU3VibWl0IG9wdC1pbiB0cmFuc2FjdGlvbjogMCBhc3NldCB0cmFuc2ZlciB0byBzZWxmCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czozOAoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCgkvLyAgICAgICBhc3NldEFtb3VudDogMCwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAyIC8vICBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGV4YW1wbGVzL2F1Y3Rpb24vYXVjdGlvbi5hbGdvLnRzOjM5CgkvLyBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6NDAKCS8vIHhmZXJBc3NldDogYXNzZXQKCWZyYW1lX2RpZyAtMSAvLyBhc3NldDogQXNzZXRJRAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czo0MQoJLy8gYXNzZXRBbW91bnQ6IDAKCWludGMgMSAvLyAwCglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAxIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBzdGFydEF1Y3Rpb24odWludDY0LHVpbnQ2NCxheGZlcil2b2lkCiphYmlfcm91dGVfc3RhcnRBdWN0aW9uOgoJLy8gYXhmZXI6IGF4ZmVyCgl0eG4gR3JvdXBJbmRleAoJaW50YyAwIC8vIDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludGMgMiAvLyAgYXhmZXIKCT09CgoJLy8gYXJndW1lbnQgMCAoYXhmZXIpIGZvciBzdGFydEF1Y3Rpb24gbXVzdCBiZSBhIGF4ZmVyIHRyYW5zYWN0aW9uCglhc3NlcnQKCgkvLyBsZW5ndGg6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHN0YXJ0aW5nUHJpY2U6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgc3RhcnRBdWN0aW9uKHVpbnQ2NCx1aW50NjQsYXhmZXIpdm9pZAoJY2FsbHN1YiBzdGFydEF1Y3Rpb24KCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIHN0YXJ0QXVjdGlvbihzdGFydGluZ1ByaWNlOiB1aW50NjQsIGxlbmd0aDogdWludDY0LCBheGZlcjogQXNzZXRUcmFuc2ZlclR4bik6IHZvaWQKc3RhcnRBdWN0aW9uOgoJcHJvdG8gMyAwCgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6NDYKCS8vIHZlcmlmeUFwcENhbGxUeG4odGhpcy50eG4sIHsgc2VuZGVyOiBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCgl0eG4gU2VuZGVyCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJ0aGlzLnR4biIsImZpZWxkIjoic2VuZGVyIiwiZXhwZWN0ZWQiOiJnbG9iYWxzLmNyZWF0b3JBZGRyZXNzIn0KCWFzc2VydAoKCS8vIEVuc3VyZSB0aGUgYXVjdGlvbiBoYXNuJ3QgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQKCS8vIGV4YW1wbGVzL2F1Y3Rpb24vYXVjdGlvbi5hbGdvLnRzOjQ5CgkvLyBhc3NlcnQodGhpcy5hdWN0aW9uRW5kLnZhbHVlID09PSAwKQoJYnl0ZWMgMiAvLyAgImF1Y3Rpb25FbmQiCglhcHBfZ2xvYmFsX2dldAoJaW50YyAxIC8vIDAKCT09Cglhc3NlcnQKCgkvLyBWZXJpZnkgYXhmZXIKCS8vIGV4YW1wbGVzL2F1Y3Rpb24vYXVjdGlvbi5hbGdvLnRzOjUyCgkvLyB2ZXJpZnlBc3NldFRyYW5zZmVyVHhuKGF4ZmVyLCB7IGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MgfSkKCS8vIHZlcmlmeSBhc3NldFJlY2VpdmVyCglmcmFtZV9kaWcgLTMgLy8gYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0UmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoiYXhmZXIiLCJmaWVsZCI6ImFzc2V0UmVjZWl2ZXIiLCJleHBlY3RlZCI6InRoaXMuYXBwLmFkZHJlc3MifQoJYXNzZXJ0CgoJLy8gU2V0IGdsb2JhbCBzdGF0ZQoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6NTUKCS8vIHRoaXMuYXNhQW10LnZhbHVlID0gYXhmZXIuYXNzZXRBbW91bnQKCWJ5dGVjIDQgLy8gICJhc2FBbXQiCglmcmFtZV9kaWcgLTMgLy8gYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL2F1Y3Rpb24vYXVjdGlvbi5hbGdvLnRzOjU2CgkvLyB0aGlzLmF1Y3Rpb25FbmQudmFsdWUgPSBnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCArIGxlbmd0aAoJYnl0ZWMgMiAvLyAgImF1Y3Rpb25FbmQiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglmcmFtZV9kaWcgLTIgLy8gbGVuZ3RoOiB1aW50NjQKCSsKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6NTcKCS8vIHRoaXMucHJldmlvdXNCaWQudmFsdWUgPSBzdGFydGluZ1ByaWNlCglieXRlYyAxIC8vICAicHJldmlvdXNCaWQiCglmcmFtZV9kaWcgLTEgLy8gc3RhcnRpbmdQcmljZTogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBwYXkocmVjZWl2ZXI6IEFkZHJlc3MsIGFtb3VudDogdWludDY0KTogdm9pZApwYXk6Cglwcm90byAyIDAKCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czo2MQoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgcmVjZWl2ZXI6IHJlY2VpdmVyLAoJLy8gICAgICAgYW1vdW50OiBhbW91bnQsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMCAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6NjIKCS8vIHJlY2VpdmVyOiByZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIHJlY2VpdmVyOiBBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6NjMKCS8vIGFtb3VudDogYW1vdW50CglmcmFtZV9kaWcgLTIgLy8gYW1vdW50OiB1aW50NjQKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAxIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBvcHRJblRvQXBwbGljYXRpb24oKXZvaWQKKmFiaV9yb3V0ZV9vcHRJblRvQXBwbGljYXRpb246CgkvLyBleGVjdXRlIG9wdEluVG9BcHBsaWNhdGlvbigpdm9pZAoJY2FsbHN1YiBvcHRJblRvQXBwbGljYXRpb24KCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIG9wdEluVG9BcHBsaWNhdGlvbigpOiB2b2lkCm9wdEluVG9BcHBsaWNhdGlvbjoKCXByb3RvIDAgMAoJcmV0c3ViCgovLyBiaWQocGF5KXZvaWQKKmFiaV9yb3V0ZV9iaWQ6CgkvLyBwYXltZW50OiBwYXkKCXR4biBHcm91cEluZGV4CglpbnRjIDAgLy8gMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50YyAwIC8vICBwYXkKCT09CgoJLy8gYXJndW1lbnQgMCAocGF5bWVudCkgZm9yIGJpZCBtdXN0IGJlIGEgcGF5IHRyYW5zYWN0aW9uCglhc3NlcnQKCgkvLyBleGVjdXRlIGJpZChwYXkpdm9pZAoJY2FsbHN1YiBiaWQKCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGJpZChwYXltZW50OiBQYXlUeG4pOiB2b2lkCmJpZDoKCXByb3RvIDEgMAoKCS8vIEVuc3VyZSBhdWN0aW9uIGhhc24ndCBlbmRlZAoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6NzIKCS8vIGFzc2VydChnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCA8IHRoaXMuYXVjdGlvbkVuZC52YWx1ZSkKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWJ5dGVjIDIgLy8gICJhdWN0aW9uRW5kIgoJYXBwX2dsb2JhbF9nZXQKCTwKCWFzc2VydAoKCS8vIFZlcmlmeSBwYXltZW50IHRyYW5zYWN0aW9uCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czo3NQoJLy8gdmVyaWZ5UGF5VHhuKHBheW1lbnQsIHsKCS8vICAgICAgIHNlbmRlcjogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgYW1vdW50OiB7IGdyZWF0ZXJUaGFuOiB0aGlzLnByZXZpb3VzQmlkLnZhbHVlIH0sCgkvLyAgICAgfSkKCS8vIHZlcmlmeSBzZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBwYXltZW50OiBQYXlUeG4KCWd0eG5zIFNlbmRlcgoJdHhuIFNlbmRlcgoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InBheW1lbnQiLCJmaWVsZCI6InNlbmRlciIsImV4cGVjdGVkIjoidGhpcy50eG4uc2VuZGVyIn0KCWFzc2VydAoKCS8vIHZlcmlmeSBhbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBwYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJYnl0ZWMgMSAvLyAgInByZXZpb3VzQmlkIgoJYXBwX2dsb2JhbF9nZXQKCT4KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InBheW1lbnQiLCJmaWVsZCI6ImFtb3VudCIsImNvbmRpdGlvbiI6ImdyZWF0ZXJUaGFuIiwiZXhwZWN0ZWQiOiI+dGhpcy5wcmV2aW91c0JpZC52YWx1ZSJ9Cglhc3NlcnQKCgkvLyBTZXQgZ2xvYmFsIHN0YXRlCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czo4MQoJLy8gdGhpcy5wcmV2aW91c0JpZC52YWx1ZSA9IHBheW1lbnQuYW1vdW50CglieXRlYyAxIC8vICAicHJldmlvdXNCaWQiCglmcmFtZV9kaWcgLTEgLy8gcGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6ODIKCS8vIHRoaXMucHJldmlvdXNCaWRkZXIudmFsdWUgPSBwYXltZW50LnNlbmRlcgoJYnl0ZWMgMCAvLyAgInByZXZpb3VzQmlkZGVyIgoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCglhcHBfZ2xvYmFsX3B1dAoKCS8vIFVwZGF0ZSBjbGFpbWFibGUgYW1vdW50CgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czo4NQoJLy8gdGhpcy5jbGFpbWFibGVBbW91bnQodGhpcy50eG4uc2VuZGVyKS52YWx1ZSA9IHBheW1lbnQuYW1vdW50Cgl0eG4gU2VuZGVyCglieXRlYyAzIC8vICAiY2xhaW1hYmxlQW1vdW50IgoJZnJhbWVfZGlnIC0xIC8vIHBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglhcHBfbG9jYWxfcHV0CglyZXRzdWIKCi8vIGNsYWltQmlkcygpdm9pZAoqYWJpX3JvdXRlX2NsYWltQmlkczoKCS8vIGV4ZWN1dGUgY2xhaW1CaWRzKCl2b2lkCgljYWxsc3ViIGNsYWltQmlkcwoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gY2xhaW1CaWRzKCk6IHZvaWQKY2xhaW1CaWRzOgoJcHJvdG8gMCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDYgLy8gMHgKCWR1cAoKCS8vIGV4YW1wbGVzL2F1Y3Rpb24vYXVjdGlvbi5hbGdvLnRzOjg5CgkvLyBvcmlnaW5hbEFtb3VudCA9IHRoaXMuY2xhaW1hYmxlQW1vdW50KHRoaXMudHhuLnNlbmRlcikudmFsdWUKCXR4biBTZW5kZXIKCWJ5dGVjIDMgLy8gICJjbGFpbWFibGVBbW91bnQiCglhcHBfbG9jYWxfZ2V0CglmcmFtZV9idXJ5IDAgLy8gb3JpZ2luYWxBbW91bnQ6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL2F1Y3Rpb24vYXVjdGlvbi5hbGdvLnRzOjkwCgkvLyBhbW91bnQgPSBvcmlnaW5hbEFtb3VudAoJZnJhbWVfZGlnIDAgLy8gb3JpZ2luYWxBbW91bnQ6IHVpbnQ2NAoJZnJhbWVfYnVyeSAxIC8vIGFtb3VudDogdWludDY0CgoJLy8gc3VidHJhY3QgcHJldmlvdXMgYmlkIGlmIHNlbmRlciBpcyBwcmV2aW91cyBiaWRkZXIKCS8vICppZjBfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czo5MwoJLy8gdGhpcy50eG4uc2VuZGVyID09PSB0aGlzLnByZXZpb3VzQmlkZGVyLnZhbHVlCgl0eG4gU2VuZGVyCglieXRlYyAwIC8vICAicHJldmlvdXNCaWRkZXIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWJ6ICppZjBfZW5kCgoJLy8gKmlmMF9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czo5MwoJLy8gYW1vdW50ID0gYW1vdW50IC0gdGhpcy5wcmV2aW91c0JpZC52YWx1ZQoJZnJhbWVfZGlnIDEgLy8gYW1vdW50OiB1aW50NjQKCWJ5dGVjIDEgLy8gICJwcmV2aW91c0JpZCIKCWFwcF9nbG9iYWxfZ2V0CgktCglmcmFtZV9idXJ5IDEgLy8gYW1vdW50OiB1aW50NjQKCippZjBfZW5kOgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6OTUKCS8vIHRoaXMucGF5KHRoaXMudHhuLnNlbmRlciwgYW1vdW50KQoJZnJhbWVfZGlnIDEgLy8gYW1vdW50OiB1aW50NjQKCXR4biBTZW5kZXIKCWNhbGxzdWIgcGF5CgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6OTYKCS8vIHRoaXMuY2xhaW1hYmxlQW1vdW50KHRoaXMudHhuLnNlbmRlcikudmFsdWUgPSBvcmlnaW5hbEFtb3VudCAtIGFtb3VudAoJdHhuIFNlbmRlcgoJYnl0ZWMgMyAvLyAgImNsYWltYWJsZUFtb3VudCIKCWZyYW1lX2RpZyAwIC8vIG9yaWdpbmFsQW1vdW50OiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGFtb3VudDogdWludDY0CgktCglhcHBfbG9jYWxfcHV0CglyZXRzdWIKCi8vIGNsYWltX2Fzc2V0KHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfY2xhaW1fYXNzZXQ6CgkvLyBhc3NldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBjbGFpbV9hc3NldCh1aW50NjQpdm9pZAoJY2FsbHN1YiBjbGFpbV9hc3NldAoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gY2xhaW1fYXNzZXQoYXNzZXQ6IEFzc2V0SUQpOiB2b2lkCmNsYWltX2Fzc2V0OgoJcHJvdG8gMSAwCgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6MTAwCgkvLyBhc3NlcnQoZ2xvYmFscy5sYXRlc3RUaW1lc3RhbXAgPiB0aGlzLmF1Y3Rpb25FbmQudmFsdWUpCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglieXRlYyAyIC8vICAiYXVjdGlvbkVuZCIKCWFwcF9nbG9iYWxfZ2V0Cgk+Cglhc3NlcnQKCgkvLyBTZW5kIEFTQSB0byBwcmV2aW91cyBiaWRkZXIKCS8vIGV4YW1wbGVzL2F1Y3Rpb24vYXVjdGlvbi5hbGdvLnRzOjEwMwoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5wcmV2aW91c0JpZGRlci52YWx1ZSwKCS8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCgkvLyAgICAgICBhc3NldEFtb3VudDogdGhpcy5hc2FBbXQudmFsdWUsCgkvLyAgICAgICBhc3NldENsb3NlVG86IHRoaXMucHJldmlvdXNCaWRkZXIudmFsdWUsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMiAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czoxMDQKCS8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMucHJldmlvdXNCaWRkZXIudmFsdWUKCWJ5dGVjIDAgLy8gICJwcmV2aW91c0JpZGRlciIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czoxMDUKCS8vIHhmZXJBc3NldDogYXNzZXQKCWZyYW1lX2RpZyAtMSAvLyBhc3NldDogQXNzZXRJRAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czoxMDYKCS8vIGFzc2V0QW1vdW50OiB0aGlzLmFzYUFtdC52YWx1ZQoJYnl0ZWMgNCAvLyAgImFzYUFtdCIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6MTA3CgkvLyBhc3NldENsb3NlVG86IHRoaXMucHJldmlvdXNCaWRkZXIudmFsdWUKCWJ5dGVjIDAgLy8gICJwcmV2aW91c0JpZGRlciIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFzc2V0Q2xvc2VUbwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMSAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKLy8gZGVsZXRlQXBwbGljYXRpb24oKXZvaWQKKmFiaV9yb3V0ZV9kZWxldGVBcHBsaWNhdGlvbjoKCS8vIGV4ZWN1dGUgZGVsZXRlQXBwbGljYXRpb24oKXZvaWQKCWNhbGxzdWIgZGVsZXRlQXBwbGljYXRpb24KCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGRlbGV0ZUFwcGxpY2F0aW9uKCk6IHZvaWQKZGVsZXRlQXBwbGljYXRpb246Cglwcm90byAwIDAKCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czoxMTIKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgIHJlY2VpdmVyOiBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzLAoJLy8gICAgICAgY2xvc2VSZW1haW5kZXJUbzogZ2xvYmFscy5jcmVhdG9yQWRkcmVzcywKCS8vICAgICAgIGFtb3VudDogMCwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAwIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czoxMTMKCS8vIHJlY2VpdmVyOiBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBleGFtcGxlcy9hdWN0aW9uL2F1Y3Rpb24uYWxnby50czoxMTQKCS8vIGNsb3NlUmVtYWluZGVyVG86IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJaXR4bl9maWVsZCBDbG9zZVJlbWFpbmRlclRvCgoJLy8gZXhhbXBsZXMvYXVjdGlvbi9hdWN0aW9uLmFsZ28udHM6MTE1CgkvLyBhbW91bnQ6IDAKCWludGMgMSAvLyAwCglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMSAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKKmNyZWF0ZV9Ob09wOgoJcHVzaGJ5dGVzIDB4Yjg0NDdiMzYgLy8gbWV0aG9kICJjcmVhdGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY3JlYXRlIE5vT3AKCWVycgoKKmNhbGxfTm9PcDoKCXB1c2hieXRlcyAweDM5ODdmMGMxIC8vIG1ldGhvZCAib3B0SW50b0Fzc2V0KHVpbnQ2NCl2b2lkIgoJcHVzaGJ5dGVzIDB4YzI3MjU5MjIgLy8gbWV0aG9kICJzdGFydEF1Y3Rpb24odWludDY0LHVpbnQ2NCxheGZlcil2b2lkIgoJcHVzaGJ5dGVzIDB4ZGI3ZmU4NDMgLy8gbWV0aG9kICJiaWQocGF5KXZvaWQiCglwdXNoYnl0ZXMgMHgwMzJmNjUwZCAvLyBtZXRob2QgImNsYWltQmlkcygpdm9pZCIKCXB1c2hieXRlcyAweDU5YjJhYjI2IC8vIG1ldGhvZCAiY2xhaW1fYXNzZXQodWludDY0KXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX29wdEludG9Bc3NldCAqYWJpX3JvdXRlX3N0YXJ0QXVjdGlvbiAqYWJpX3JvdXRlX2JpZCAqYWJpX3JvdXRlX2NsYWltQmlkcyAqYWJpX3JvdXRlX2NsYWltX2Fzc2V0CgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNhbGwgTm9PcAoJZXJyCgoqY2FsbF9PcHRJbjoKCXB1c2hieXRlcyAweDAxYTNhM2ZmIC8vIG1ldGhvZCAib3B0SW5Ub0FwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9vcHRJblRvQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBPcHRJbgoJZXJyCgoqY2FsbF9EZWxldGVBcHBsaWNhdGlvbjoKCXB1c2hieXRlcyAweDI0ODdjMzJjIC8vIG1ldGhvZCAiZGVsZXRlQXBwbGljYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2RlbGV0ZUFwcGxpY2F0aW9uCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNhbGwgRGVsZXRlQXBwbGljYXRpb24KCWVycg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 1,
      "num_uints": 4,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 1,
    },
  },
}
`;

exports[`Examples BigBox Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 1 8 0 400 16 32768 2
bytecblock 0x 0x63757272656e74496e646578

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// startUpload(string,uint64,uint64,pay)void
*abi_route_startUpload:
	// mbrPayment: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 0 (mbrPayment) for startUpload must be a pay transaction
	assert

	// endBoxSize: uint64
	txna ApplicationArgs 3
	btoi

	// numBoxes: uint64
	txna ApplicationArgs 2
	btoi

	// dataIdentifier: string
	txna ApplicationArgs 1
	extract 2 0

	// execute startUpload(string,uint64,uint64,pay)void
	callsub startUpload
	intc 0 // 1
	return

// startUpload(dataIdentifier: string, numBoxes: uint64, endBoxSize: uint64, mbrPayment: PayTxn): void
//
//
// Allocate boxes to begin data upload process
//
// @param dataIdentifier The unique identifier for the data
// @param numBoxes The number of boxes that the data will take up
// @param endBoxSize The size of the last box
// @param mbrPayment Payment from the uploader to cover the box MBR
startUpload:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// examples/big_box/big_box.algo.ts:41
	// startBox = this.currentIndex.value
	bytec 1 //  "currentIndex"
	app_global_get
	frame_bury 0 // startBox: uint64

	// examples/big_box/big_box.algo.ts:42
	// endBox = startBox + numBoxes - 1
	frame_dig 0 // startBox: uint64
	frame_dig -2 // numBoxes: uint64
	+
	intc 0 // 1
	-
	frame_bury 1 // endBox: uint64

	// examples/big_box/big_box.algo.ts:44
	// metadata: Metadata = {
	//       start: startBox,
	//       end: endBox,
	//       status: IN_PROGRESS,
	//       endSize: endBoxSize,
	//     }
	frame_dig 0 // startBox: uint64
	itob
	frame_dig 1 // endBox: uint64
	itob
	concat
	pushbytes 0x00
	concat
	frame_dig -3 // endBoxSize: uint64
	itob
	concat
	frame_bury 2 // metadata: Metadata

	// examples/big_box/big_box.algo.ts:51
	// assert(!this.metadata(dataIdentifier).exists)
	frame_dig -1 // dataIdentifier: string
	box_len
	swap
	pop
	!
	assert

	// examples/big_box/big_box.algo.ts:53
	// this.metadata(dataIdentifier).value = metadata
	frame_dig -1 // dataIdentifier: string
	frame_dig 2 // metadata: Metadata
	box_put

	// examples/big_box/big_box.algo.ts:55
	// this.currentIndex.value = endBox + 1
	bytec 1 //  "currentIndex"
	frame_dig 1 // endBox: uint64
	intc 0 // 1
	+
	app_global_put

	// examples/big_box/big_box.algo.ts:57
	// totalCost =
	//       numBoxes * COST_PER_BOX + // cost of boxes
	//       (numBoxes - 1) * MAX_BOX_SIZE * COST_PER_BYTE + // cost of data
	//       numBoxes * 64 * COST_PER_BYTE + // cost of keys
	//       endBoxSize * COST_PER_BYTE
	frame_dig -2 // numBoxes: uint64
	pushint 2500
	*
	frame_dig -2 // numBoxes: uint64
	intc 0 // 1
	-
	intc 5 // 32768
	*
	intc 3 // 400
	*
	+
	frame_dig -2 // numBoxes: uint64
	pushint 64
	*
	intc 3 // 400
	*
	+
	frame_dig -3 // endBoxSize: uint64
	intc 3 // 400
	*
	+
	frame_bury 3 // totalCost: uint64

	// examples/big_box/big_box.algo.ts:63
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: totalCost })
	// verify receiver
	frame_dig -4 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -4 // mbrPayment: PayTxn
	gtxns Amount
	frame_dig 3 // totalCost: uint64
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"totalCost"}
	assert
	retsub

// upload(string,uint64,uint64,byte[])void
*abi_route_upload:
	// data: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// offset: uint64
	txna ApplicationArgs 3
	btoi

	// boxIndex: uint64
	txna ApplicationArgs 2
	btoi

	// dataIdentifier: string
	txna ApplicationArgs 1
	extract 2 0

	// execute upload(string,uint64,uint64,byte[])void
	callsub upload
	intc 0 // 1
	return

// upload(dataIdentifier: string, boxIndex: uint64, offset: uint64, data: bytes): void
//
//
// Upload data to a specific offset in a box
//
// @param dataIdentifier The unique identifier for the data
// @param boxIndex The index of the box to upload the given chunk of data to
// @param offset The offset within the box to start writing the data
// @param data The data to write
upload:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/big_box/big_box.algo.ts:76
	// metadata = this.metadata(dataIdentifier).value
	frame_dig -1 // dataIdentifier: string
	frame_bury 0 // storage key//metadata

	// examples/big_box/big_box.algo.ts:77
	// assert(metadata.status === IN_PROGRESS)
	frame_dig -1 // dataIdentifier: string
	intc 4 //  headOffset
	intc 0 // 1
	box_extract
	btoi
	intc 2 // 0
	==
	assert

	// examples/big_box/big_box.algo.ts:78
	// assert(metadata.start <= boxIndex && boxIndex <= metadata.end)
	frame_dig -1 // dataIdentifier: string
	intc 2 // 0
	intc 1 // 8
	box_extract
	btoi
	frame_dig -2 // boxIndex: uint64
	<=
	dup
	bz *skip_and0
	frame_dig -2 // boxIndex: uint64
	frame_dig -1 // dataIdentifier: string
	intc 1 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	<=
	&&

*skip_and0:
	assert

	// *if0_condition
	// examples/big_box/big_box.algo.ts:80
	// offset === 0
	frame_dig -3 // offset: uint64
	intc 2 // 0
	==
	bz *if0_end

	// *if0_consequent
	// examples/big_box/big_box.algo.ts:81
	// this.dataBoxes(boxIndex).create(boxIndex === metadata.end ? metadata.endSize : MAX_BOX_SIZE)
	frame_dig -2 // boxIndex: uint64
	itob
	frame_dig -2 // boxIndex: uint64
	frame_dig -1 // dataIdentifier: string
	intc 1 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	==
	bz *ternary0_false
	frame_dig -1 // dataIdentifier: string
	pushint 17 // headOffset
	intc 1 // 8
	box_extract
	btoi
	b *ternary0_end

*ternary0_false:
	intc 5 // 32768

*ternary0_end:
	box_create
	pop

*if0_end:
	// examples/big_box/big_box.algo.ts:84
	// this.dataBoxes(boxIndex).replace(offset, data)
	frame_dig -2 // boxIndex: uint64
	itob
	frame_dig -3 // offset: uint64
	frame_dig -4 // data: bytes
	box_replace
	retsub

// setStatus(string,uint8)void
*abi_route_setStatus:
	// status: uint8
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 0 (status) for setStatus must be a uint8
	assert
	btoi

	// dataIdentifier: string
	txna ApplicationArgs 1
	extract 2 0

	// execute setStatus(string,uint8)void
	callsub setStatus
	intc 0 // 1
	return

// setStatus(dataIdentifier: string, status: uint<8>): void
//
//
// Set the status of the data
//
// @param dataIdentifier The unique identifier for the data
// @param status The new status for the data
setStatus:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/big_box/big_box.algo.ts:95
	// currentStatus = this.metadata(dataIdentifier).value.status
	frame_dig -1 // dataIdentifier: string
	intc 4 //  headOffset
	intc 0 // 1
	box_extract
	btoi
	frame_bury 0 // currentStatus: uint8

	// examples/big_box/big_box.algo.ts:97
	// assert(status === READY || status === IMMUTABLE || status === IN_PROGRESS)
	frame_dig -2 // status: uint<8>
	intc 0 // 1
	==
	dup
	bnz *skip_or0
	frame_dig -2 // status: uint<8>
	intc 6 // 2
	==
	||

*skip_or0:
	dup
	bnz *skip_or1
	frame_dig -2 // status: uint<8>
	intc 2 // 0
	==
	||

*skip_or1:
	assert

	// examples/big_box/big_box.algo.ts:98
	// assert(currentStatus !== IMMUTABLE)
	frame_dig 0 // currentStatus: uint8
	intc 6 // 2
	!=
	assert

	// examples/big_box/big_box.algo.ts:100
	// this.metadata(dataIdentifier).value.status = status
	intc 4 //  headOffset
	frame_dig -2 // status: uint<8>
	itob
	extract 7 1
	frame_dig -1 // dataIdentifier: string
	cover 2
	box_replace
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xa05b5669 // method "startUpload(string,uint64,uint64,pay)void"
	pushbytes 0x1b7dfa35 // method "upload(string,uint64,uint64,byte[])void"
	pushbytes 0xbf3856f8 // method "setStatus(string,uint8)void"
	txna ApplicationArgs 0
	match *abi_route_startUpload *abi_route_upload *abi_route_setStatus

	// this contract does not implement the given ABI method for call NoOp
	err"
`;

exports[`Examples BigBox Artifacts Maintains program size 1`] = `431`;

exports[`Examples BigBox Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [
        {
          "desc": "The unique identifier for the data",
          "name": "dataIdentifier",
          "type": "string",
        },
        {
          "desc": "The number of boxes that the data will take up",
          "name": "numBoxes",
          "type": "uint64",
        },
        {
          "desc": "The size of the last box",
          "name": "endBoxSize",
          "type": "uint64",
        },
        {
          "desc": "Payment from the uploader to cover the box MBR",
          "name": "mbrPayment",
          "type": "pay",
        },
      ],
      "desc": "Allocate boxes to begin data upload process",
      "events": undefined,
      "name": "startUpload",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The unique identifier for the data",
          "name": "dataIdentifier",
          "type": "string",
        },
        {
          "desc": "The index of the box to upload the given chunk of data to",
          "name": "boxIndex",
          "type": "uint64",
        },
        {
          "desc": "The offset within the box to start writing the data",
          "name": "offset",
          "type": "uint64",
        },
        {
          "desc": "The data to write",
          "name": "data",
          "type": "byte[]",
        },
      ],
      "desc": "Upload data to a specific offset in a box",
      "events": undefined,
      "name": "upload",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The unique identifier for the data",
          "name": "dataIdentifier",
          "type": "string",
        },
        {
          "desc": "The new status for the data",
          "name": "status",
          "type": "uint8",
        },
      ],
      "desc": "Set the status of the data",
      "events": undefined,
      "name": "setStatus",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "BigBox",
}
`;

exports[`Examples BigBox Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [
          {
            "desc": "The unique identifier for the data",
            "name": "dataIdentifier",
            "type": "string",
          },
          {
            "desc": "The number of boxes that the data will take up",
            "name": "numBoxes",
            "type": "uint64",
          },
          {
            "desc": "The size of the last box",
            "name": "endBoxSize",
            "type": "uint64",
          },
          {
            "desc": "Payment from the uploader to cover the box MBR",
            "name": "mbrPayment",
            "type": "pay",
          },
        ],
        "desc": "Allocate boxes to begin data upload process",
        "events": undefined,
        "name": "startUpload",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The unique identifier for the data",
            "name": "dataIdentifier",
            "type": "string",
          },
          {
            "desc": "The index of the box to upload the given chunk of data to",
            "name": "boxIndex",
            "type": "uint64",
          },
          {
            "desc": "The offset within the box to start writing the data",
            "name": "offset",
            "type": "uint64",
          },
          {
            "desc": "The data to write",
            "name": "data",
            "type": "byte[]",
          },
        ],
        "desc": "Upload data to a specific offset in a box",
        "events": undefined,
        "name": "upload",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The unique identifier for the data",
            "name": "dataIdentifier",
            "type": "string",
          },
          {
            "desc": "The new status for the data",
            "name": "status",
            "type": "uint8",
          },
        ],
        "desc": "Set the status of the data",
        "events": undefined,
        "name": "setStatus",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "BigBox",
  },
  "hints": {
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "setStatus(string,uint8)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "startUpload(string,uint64,uint64,pay)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "upload(string,uint64,uint64,byte[])void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {
        "currentIndex": {
          "key": "currentIndex",
          "type": "uint64",
        },
      },
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAxIDggMCA0MDAgMTYgMzI3NjggMgpieXRlY2Jsb2NrIDB4IDB4NjM3NTcyNzI2NTZlNzQ0OTZlNjQ2NTc4CgovLyBodHRwczovL2dpdGh1Yi5jb20vYWxnb3JhbmRmb3VuZGF0aW9uL1RFQUxTY3JpcHQKCi8vIFRoaXMgY29udHJhY3QgaXMgY29tcGxpYW50IHdpdGggYW5kL29yIGltcGxlbWVudHMgdGhlIGZvbGxvd2luZyBBUkNzOiBbIEFSQzQgXQoKLy8gVGhlIGZvbGxvd2luZyB0ZW4gbGluZXMgb2YgVEVBTCBoYW5kbGUgaW5pdGlhbCBwcm9ncmFtIGZsb3cKLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgdG8gbWFrZSBpdCBlYXN5IGZvciBhbnlvbmUgdG8gcGFyc2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGFuZCBkZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyBhY3Rpb24gaXMgYWxsb3dlZAovLyBIZXJlLCBhY3Rpb24gcmVmZXJzIHRvIHRoZSBPbkNvbXBsZXRlIGluIGNvbWJpbmF0aW9uIHdpdGggd2hldGhlciB0aGUgYXBwIGlzIGJlaW5nIGNyZWF0ZWQgb3IgY2FsbGVkCi8vIEV2ZXJ5IHBvc3NpYmxlIGFjdGlvbiBmb3IgdGhpcyBjb250cmFjdCBpcyByZXByZXNlbnRlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudAovLyBJZiB0aGUgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgY29udHJhY3QsIGl0cyByZXNwZWN0aXZlIGJyYW5jaCB3aWxsIGJlICIqTk9UX0lNUExFTUVOVEVEIiB3aGljaCBqdXN0IGNvbnRhaW5zICJlcnIiCnR4biBBcHBsaWNhdGlvbklECiEKcHVzaGludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJLy8gVGhlIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udHJhY3QuIEFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgT25Db21wbGV0ZT8gRGlkIHlvdSBzZXQgeW91ciBhcHAgSUQ/CgllcnIKCi8vIHN0YXJ0VXBsb2FkKHN0cmluZyx1aW50NjQsdWludDY0LHBheSl2b2lkCiphYmlfcm91dGVfc3RhcnRVcGxvYWQ6CgkvLyBtYnJQYXltZW50OiBwYXkKCXR4biBHcm91cEluZGV4CglpbnRjIDAgLy8gMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50YyAwIC8vICBwYXkKCT09CgoJLy8gYXJndW1lbnQgMCAobWJyUGF5bWVudCkgZm9yIHN0YXJ0VXBsb2FkIG11c3QgYmUgYSBwYXkgdHJhbnNhY3Rpb24KCWFzc2VydAoKCS8vIGVuZEJveFNpemU6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIG51bUJveGVzOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBkYXRhSWRlbnRpZmllcjogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgc3RhcnRVcGxvYWQoc3RyaW5nLHVpbnQ2NCx1aW50NjQscGF5KXZvaWQKCWNhbGxzdWIgc3RhcnRVcGxvYWQKCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIHN0YXJ0VXBsb2FkKGRhdGFJZGVudGlmaWVyOiBzdHJpbmcsIG51bUJveGVzOiB1aW50NjQsIGVuZEJveFNpemU6IHVpbnQ2NCwgbWJyUGF5bWVudDogUGF5VHhuKTogdm9pZAovLwovLwovLyBBbGxvY2F0ZSBib3hlcyB0byBiZWdpbiBkYXRhIHVwbG9hZCBwcm9jZXNzCi8vCi8vIEBwYXJhbSBkYXRhSWRlbnRpZmllciBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBkYXRhCi8vIEBwYXJhbSBudW1Cb3hlcyBUaGUgbnVtYmVyIG9mIGJveGVzIHRoYXQgdGhlIGRhdGEgd2lsbCB0YWtlIHVwCi8vIEBwYXJhbSBlbmRCb3hTaXplIFRoZSBzaXplIG9mIHRoZSBsYXN0IGJveAovLyBAcGFyYW0gbWJyUGF5bWVudCBQYXltZW50IGZyb20gdGhlIHVwbG9hZGVyIHRvIGNvdmVyIHRoZSBib3ggTUJSCnN0YXJ0VXBsb2FkOgoJcHJvdG8gNCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gMwoKCS8vIGV4YW1wbGVzL2JpZ19ib3gvYmlnX2JveC5hbGdvLnRzOjQxCgkvLyBzdGFydEJveCA9IHRoaXMuY3VycmVudEluZGV4LnZhbHVlCglieXRlYyAxIC8vICAiY3VycmVudEluZGV4IgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2J1cnkgMCAvLyBzdGFydEJveDogdWludDY0CgoJLy8gZXhhbXBsZXMvYmlnX2JveC9iaWdfYm94LmFsZ28udHM6NDIKCS8vIGVuZEJveCA9IHN0YXJ0Qm94ICsgbnVtQm94ZXMgLSAxCglmcmFtZV9kaWcgMCAvLyBzdGFydEJveDogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gbnVtQm94ZXM6IHVpbnQ2NAoJKwoJaW50YyAwIC8vIDEKCS0KCWZyYW1lX2J1cnkgMSAvLyBlbmRCb3g6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL2JpZ19ib3gvYmlnX2JveC5hbGdvLnRzOjQ0CgkvLyBtZXRhZGF0YTogTWV0YWRhdGEgPSB7CgkvLyAgICAgICBzdGFydDogc3RhcnRCb3gsCgkvLyAgICAgICBlbmQ6IGVuZEJveCwKCS8vICAgICAgIHN0YXR1czogSU5fUFJPR1JFU1MsCgkvLyAgICAgICBlbmRTaXplOiBlbmRCb3hTaXplLAoJLy8gICAgIH0KCWZyYW1lX2RpZyAwIC8vIHN0YXJ0Qm94OiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAxIC8vIGVuZEJveDogdWludDY0CglpdG9iCgljb25jYXQKCXB1c2hieXRlcyAweDAwCgljb25jYXQKCWZyYW1lX2RpZyAtMyAvLyBlbmRCb3hTaXplOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfYnVyeSAyIC8vIG1ldGFkYXRhOiBNZXRhZGF0YQoKCS8vIGV4YW1wbGVzL2JpZ19ib3gvYmlnX2JveC5hbGdvLnRzOjUxCgkvLyBhc3NlcnQoIXRoaXMubWV0YWRhdGEoZGF0YUlkZW50aWZpZXIpLmV4aXN0cykKCWZyYW1lX2RpZyAtMSAvLyBkYXRhSWRlbnRpZmllcjogc3RyaW5nCglib3hfbGVuCglzd2FwCglwb3AKCSEKCWFzc2VydAoKCS8vIGV4YW1wbGVzL2JpZ19ib3gvYmlnX2JveC5hbGdvLnRzOjUzCgkvLyB0aGlzLm1ldGFkYXRhKGRhdGFJZGVudGlmaWVyKS52YWx1ZSA9IG1ldGFkYXRhCglmcmFtZV9kaWcgLTEgLy8gZGF0YUlkZW50aWZpZXI6IHN0cmluZwoJZnJhbWVfZGlnIDIgLy8gbWV0YWRhdGE6IE1ldGFkYXRhCglib3hfcHV0CgoJLy8gZXhhbXBsZXMvYmlnX2JveC9iaWdfYm94LmFsZ28udHM6NTUKCS8vIHRoaXMuY3VycmVudEluZGV4LnZhbHVlID0gZW5kQm94ICsgMQoJYnl0ZWMgMSAvLyAgImN1cnJlbnRJbmRleCIKCWZyYW1lX2RpZyAxIC8vIGVuZEJveDogdWludDY0CglpbnRjIDAgLy8gMQoJKwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9iaWdfYm94L2JpZ19ib3guYWxnby50czo1NwoJLy8gdG90YWxDb3N0ID0KCS8vICAgICAgIG51bUJveGVzICogQ09TVF9QRVJfQk9YICsgLy8gY29zdCBvZiBib3hlcwoJLy8gICAgICAgKG51bUJveGVzIC0gMSkgKiBNQVhfQk9YX1NJWkUgKiBDT1NUX1BFUl9CWVRFICsgLy8gY29zdCBvZiBkYXRhCgkvLyAgICAgICBudW1Cb3hlcyAqIDY0ICogQ09TVF9QRVJfQllURSArIC8vIGNvc3Qgb2Yga2V5cwoJLy8gICAgICAgZW5kQm94U2l6ZSAqIENPU1RfUEVSX0JZVEUKCWZyYW1lX2RpZyAtMiAvLyBudW1Cb3hlczogdWludDY0CglwdXNoaW50IDI1MDAKCSoKCWZyYW1lX2RpZyAtMiAvLyBudW1Cb3hlczogdWludDY0CglpbnRjIDAgLy8gMQoJLQoJaW50YyA1IC8vIDMyNzY4CgkqCglpbnRjIDMgLy8gNDAwCgkqCgkrCglmcmFtZV9kaWcgLTIgLy8gbnVtQm94ZXM6IHVpbnQ2NAoJcHVzaGludCA2NAoJKgoJaW50YyAzIC8vIDQwMAoJKgoJKwoJZnJhbWVfZGlnIC0zIC8vIGVuZEJveFNpemU6IHVpbnQ2NAoJaW50YyAzIC8vIDQwMAoJKgoJKwoJZnJhbWVfYnVyeSAzIC8vIHRvdGFsQ29zdDogdWludDY0CgoJLy8gZXhhbXBsZXMvYmlnX2JveC9iaWdfYm94LmFsZ28udHM6NjMKCS8vIHZlcmlmeVBheVR4bihtYnJQYXltZW50LCB7IHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLCBhbW91bnQ6IHRvdGFsQ29zdCB9KQoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTQgLy8gbWJyUGF5bWVudDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJtYnJQYXltZW50IiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTQgLy8gbWJyUGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWZyYW1lX2RpZyAzIC8vIHRvdGFsQ29zdDogdWludDY0Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoibWJyUGF5bWVudCIsImZpZWxkIjoiYW1vdW50IiwiZXhwZWN0ZWQiOiJ0b3RhbENvc3QifQoJYXNzZXJ0CglyZXRzdWIKCi8vIHVwbG9hZChzdHJpbmcsdWludDY0LHVpbnQ2NCxieXRlW10pdm9pZAoqYWJpX3JvdXRlX3VwbG9hZDoKCS8vIGRhdGE6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZXh0cmFjdCAyIDAKCgkvLyBvZmZzZXQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGJveEluZGV4OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBkYXRhSWRlbnRpZmllcjogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgdXBsb2FkKHN0cmluZyx1aW50NjQsdWludDY0LGJ5dGVbXSl2b2lkCgljYWxsc3ViIHVwbG9hZAoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gdXBsb2FkKGRhdGFJZGVudGlmaWVyOiBzdHJpbmcsIGJveEluZGV4OiB1aW50NjQsIG9mZnNldDogdWludDY0LCBkYXRhOiBieXRlcyk6IHZvaWQKLy8KLy8KLy8gVXBsb2FkIGRhdGEgdG8gYSBzcGVjaWZpYyBvZmZzZXQgaW4gYSBib3gKLy8KLy8gQHBhcmFtIGRhdGFJZGVudGlmaWVyIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGRhdGEKLy8gQHBhcmFtIGJveEluZGV4IFRoZSBpbmRleCBvZiB0aGUgYm94IHRvIHVwbG9hZCB0aGUgZ2l2ZW4gY2h1bmsgb2YgZGF0YSB0bwovLyBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgd2l0aGluIHRoZSBib3ggdG8gc3RhcnQgd3JpdGluZyB0aGUgZGF0YQovLyBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byB3cml0ZQp1cGxvYWQ6Cglwcm90byA0IDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoKCS8vIGV4YW1wbGVzL2JpZ19ib3gvYmlnX2JveC5hbGdvLnRzOjc2CgkvLyBtZXRhZGF0YSA9IHRoaXMubWV0YWRhdGEoZGF0YUlkZW50aWZpZXIpLnZhbHVlCglmcmFtZV9kaWcgLTEgLy8gZGF0YUlkZW50aWZpZXI6IHN0cmluZwoJZnJhbWVfYnVyeSAwIC8vIHN0b3JhZ2Uga2V5Ly9tZXRhZGF0YQoKCS8vIGV4YW1wbGVzL2JpZ19ib3gvYmlnX2JveC5hbGdvLnRzOjc3CgkvLyBhc3NlcnQobWV0YWRhdGEuc3RhdHVzID09PSBJTl9QUk9HUkVTUykKCWZyYW1lX2RpZyAtMSAvLyBkYXRhSWRlbnRpZmllcjogc3RyaW5nCglpbnRjIDQgLy8gIGhlYWRPZmZzZXQKCWludGMgMCAvLyAxCglib3hfZXh0cmFjdAoJYnRvaQoJaW50YyAyIC8vIDAKCT09Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9iaWdfYm94L2JpZ19ib3guYWxnby50czo3OAoJLy8gYXNzZXJ0KG1ldGFkYXRhLnN0YXJ0IDw9IGJveEluZGV4ICYmIGJveEluZGV4IDw9IG1ldGFkYXRhLmVuZCkKCWZyYW1lX2RpZyAtMSAvLyBkYXRhSWRlbnRpZmllcjogc3RyaW5nCglpbnRjIDIgLy8gMAoJaW50YyAxIC8vIDgKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgLTIgLy8gYm94SW5kZXg6IHVpbnQ2NAoJPD0KCWR1cAoJYnogKnNraXBfYW5kMAoJZnJhbWVfZGlnIC0yIC8vIGJveEluZGV4OiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBkYXRhSWRlbnRpZmllcjogc3RyaW5nCglpbnRjIDEgLy8gIGhlYWRPZmZzZXQKCWludGMgMSAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJPD0KCSYmCgoqc2tpcF9hbmQwOgoJYXNzZXJ0CgoJLy8gKmlmMF9jb25kaXRpb24KCS8vIGV4YW1wbGVzL2JpZ19ib3gvYmlnX2JveC5hbGdvLnRzOjgwCgkvLyBvZmZzZXQgPT09IDAKCWZyYW1lX2RpZyAtMyAvLyBvZmZzZXQ6IHVpbnQ2NAoJaW50YyAyIC8vIDAKCT09CglieiAqaWYwX2VuZAoKCS8vICppZjBfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvYmlnX2JveC9iaWdfYm94LmFsZ28udHM6ODEKCS8vIHRoaXMuZGF0YUJveGVzKGJveEluZGV4KS5jcmVhdGUoYm94SW5kZXggPT09IG1ldGFkYXRhLmVuZCA/IG1ldGFkYXRhLmVuZFNpemUgOiBNQVhfQk9YX1NJWkUpCglmcmFtZV9kaWcgLTIgLy8gYm94SW5kZXg6IHVpbnQ2NAoJaXRvYgoJZnJhbWVfZGlnIC0yIC8vIGJveEluZGV4OiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBkYXRhSWRlbnRpZmllcjogc3RyaW5nCglpbnRjIDEgLy8gIGhlYWRPZmZzZXQKCWludGMgMSAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJPT0KCWJ6ICp0ZXJuYXJ5MF9mYWxzZQoJZnJhbWVfZGlnIC0xIC8vIGRhdGFJZGVudGlmaWVyOiBzdHJpbmcKCXB1c2hpbnQgMTcgLy8gaGVhZE9mZnNldAoJaW50YyAxIC8vIDgKCWJveF9leHRyYWN0CglidG9pCgliICp0ZXJuYXJ5MF9lbmQKCip0ZXJuYXJ5MF9mYWxzZToKCWludGMgNSAvLyAzMjc2OAoKKnRlcm5hcnkwX2VuZDoKCWJveF9jcmVhdGUKCXBvcAoKKmlmMF9lbmQ6CgkvLyBleGFtcGxlcy9iaWdfYm94L2JpZ19ib3guYWxnby50czo4NAoJLy8gdGhpcy5kYXRhQm94ZXMoYm94SW5kZXgpLnJlcGxhY2Uob2Zmc2V0LCBkYXRhKQoJZnJhbWVfZGlnIC0yIC8vIGJveEluZGV4OiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAtMyAvLyBvZmZzZXQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC00IC8vIGRhdGE6IGJ5dGVzCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBzZXRTdGF0dXMoc3RyaW5nLHVpbnQ4KXZvaWQKKmFiaV9yb3V0ZV9zZXRTdGF0dXM6CgkvLyBzdGF0dXM6IHVpbnQ4Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAwIC8vIDEKCT09CgoJLy8gYXJndW1lbnQgMCAoc3RhdHVzKSBmb3Igc2V0U3RhdHVzIG11c3QgYmUgYSB1aW50OAoJYXNzZXJ0CglidG9pCgoJLy8gZGF0YUlkZW50aWZpZXI6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIHNldFN0YXR1cyhzdHJpbmcsdWludDgpdm9pZAoJY2FsbHN1YiBzZXRTdGF0dXMKCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIHNldFN0YXR1cyhkYXRhSWRlbnRpZmllcjogc3RyaW5nLCBzdGF0dXM6IHVpbnQ8OD4pOiB2b2lkCi8vCi8vCi8vIFNldCB0aGUgc3RhdHVzIG9mIHRoZSBkYXRhCi8vCi8vIEBwYXJhbSBkYXRhSWRlbnRpZmllciBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBkYXRhCi8vIEBwYXJhbSBzdGF0dXMgVGhlIG5ldyBzdGF0dXMgZm9yIHRoZSBkYXRhCnNldFN0YXR1czoKCXByb3RvIDIgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gZXhhbXBsZXMvYmlnX2JveC9iaWdfYm94LmFsZ28udHM6OTUKCS8vIGN1cnJlbnRTdGF0dXMgPSB0aGlzLm1ldGFkYXRhKGRhdGFJZGVudGlmaWVyKS52YWx1ZS5zdGF0dXMKCWZyYW1lX2RpZyAtMSAvLyBkYXRhSWRlbnRpZmllcjogc3RyaW5nCglpbnRjIDQgLy8gIGhlYWRPZmZzZXQKCWludGMgMCAvLyAxCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAwIC8vIGN1cnJlbnRTdGF0dXM6IHVpbnQ4CgoJLy8gZXhhbXBsZXMvYmlnX2JveC9iaWdfYm94LmFsZ28udHM6OTcKCS8vIGFzc2VydChzdGF0dXMgPT09IFJFQURZIHx8IHN0YXR1cyA9PT0gSU1NVVRBQkxFIHx8IHN0YXR1cyA9PT0gSU5fUFJPR1JFU1MpCglmcmFtZV9kaWcgLTIgLy8gc3RhdHVzOiB1aW50PDg+CglpbnRjIDAgLy8gMQoJPT0KCWR1cAoJYm56ICpza2lwX29yMAoJZnJhbWVfZGlnIC0yIC8vIHN0YXR1czogdWludDw4PgoJaW50YyA2IC8vIDIKCT09Cgl8fAoKKnNraXBfb3IwOgoJZHVwCglibnogKnNraXBfb3IxCglmcmFtZV9kaWcgLTIgLy8gc3RhdHVzOiB1aW50PDg+CglpbnRjIDIgLy8gMAoJPT0KCXx8Cgoqc2tpcF9vcjE6Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9iaWdfYm94L2JpZ19ib3guYWxnby50czo5OAoJLy8gYXNzZXJ0KGN1cnJlbnRTdGF0dXMgIT09IElNTVVUQUJMRSkKCWZyYW1lX2RpZyAwIC8vIGN1cnJlbnRTdGF0dXM6IHVpbnQ4CglpbnRjIDYgLy8gMgoJIT0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL2JpZ19ib3gvYmlnX2JveC5hbGdvLnRzOjEwMAoJLy8gdGhpcy5tZXRhZGF0YShkYXRhSWRlbnRpZmllcikudmFsdWUuc3RhdHVzID0gc3RhdHVzCglpbnRjIDQgLy8gIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAtMiAvLyBzdGF0dXM6IHVpbnQ8OD4KCWl0b2IKCWV4dHJhY3QgNyAxCglmcmFtZV9kaWcgLTEgLy8gZGF0YUlkZW50aWZpZXI6IHN0cmluZwoJY292ZXIgMgoJYm94X3JlcGxhY2UKCXJldHN1YgoKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCWludGMgMCAvLyAxCglyZXR1cm4KCipjcmVhdGVfTm9PcDoKCXB1c2hieXRlcyAweGI4NDQ3YjM2IC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNyZWF0ZSBOb09wCgllcnIKCipjYWxsX05vT3A6CglwdXNoYnl0ZXMgMHhhMDViNTY2OSAvLyBtZXRob2QgInN0YXJ0VXBsb2FkKHN0cmluZyx1aW50NjQsdWludDY0LHBheSl2b2lkIgoJcHVzaGJ5dGVzIDB4MWI3ZGZhMzUgLy8gbWV0aG9kICJ1cGxvYWQoc3RyaW5nLHVpbnQ2NCx1aW50NjQsYnl0ZVtdKXZvaWQiCglwdXNoYnl0ZXMgMHhiZjM4NTZmOCAvLyBtZXRob2QgInNldFN0YXR1cyhzdHJpbmcsdWludDgpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfc3RhcnRVcGxvYWQgKmFiaV9yb3V0ZV91cGxvYWQgKmFiaV9yb3V0ZV9zZXRTdGF0dXMKCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBOb09wCgllcnI=",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 1,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples Calculator Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 1

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// getSum(a: uint64, b: uint64): uint64
//
// Calculates the sum of two numbers
//
// @param a
// @param b
// @returns The sum of a and b
getSum:
	proto 2 1

	// examples/calculator/calculator.algo.ts:13
	// return a + b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	retsub

// getDifference(a: uint64, b: uint64): uint64
//
// Calculates the difference between two numbers
//
// @param a
// @param b
// @returns The difference between a and b.
getDifference:
	proto 2 1

	// examples/calculator/calculator.algo.ts:24
	// return a >= b ? a - b : b - a;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	>=
	bz *ternary0_false
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	-
	b *ternary0_end

*ternary0_false:
	frame_dig -2 // b: uint64
	frame_dig -1 // a: uint64
	-

*ternary0_end:
	retsub

// doMath(uint64,uint64,string)uint64
*abi_route_doMath:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// operation: string
	txna ApplicationArgs 3
	extract 2 0

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute doMath(uint64,uint64,string)uint64
	callsub doMath
	itob
	concat
	log
	intc 0 // 1
	return

// doMath(a: uint64, b: uint64, operation: string): uint64
//
// A method that takes two numbers and does either addition or subtraction
//
// @param a The first number
// @param b The second number
// @param operation The operation to perform. Can be either 'sum' or 'difference'
//
// @returns The result of the operation
doMath:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	pushbytes 0x

	// *if0_condition
	// examples/calculator/calculator.algo.ts:39
	// operation === 'sum'
	frame_dig -3 // operation: string
	pushbytes 0x73756d // "sum"
	==
	bz *if0_elseif1_condition

	// *if0_consequent
	// examples/calculator/calculator.algo.ts:40
	// result = this.getSum(a, b)
	frame_dig -2 // b: uint64
	frame_dig -1 // a: uint64
	callsub getSum
	frame_bury 0 // result: uint64
	b *if0_end

*if0_elseif1_condition:
	// examples/calculator/calculator.algo.ts:41
	// operation === 'difference'
	frame_dig -3 // operation: string
	pushbytes 0x646966666572656e6365 // "difference"
	==
	bz *if0_else

	// *if0_elseif1_consequent
	// examples/calculator/calculator.algo.ts:42
	// result = this.getDifference(a, b)
	frame_dig -2 // b: uint64
	frame_dig -1 // a: uint64
	callsub getDifference
	frame_bury 0 // result: uint64
	b *if0_end

*if0_else:
	// Invalid operation
	err

*if0_end:
	// examples/calculator/calculator.algo.ts:45
	// return result;
	frame_dig 0 // result: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x76a7ef33 // method "doMath(uint64,uint64,string)uint64"
	txna ApplicationArgs 0
	match *abi_route_doMath

	// this contract does not implement the given ABI method for call NoOp
	err"
`;

exports[`Examples Calculator Artifacts Maintains program size 1`] = `196`;

exports[`Examples Calculator Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [
        {
          "desc": "The first number",
          "name": "a",
          "type": "uint64",
        },
        {
          "desc": "The second number",
          "name": "b",
          "type": "uint64",
        },
        {
          "desc": "The operation to perform. Can be either 'sum' or 'difference'",
          "name": "operation",
          "type": "string",
        },
      ],
      "desc": "A method that takes two numbers and does either addition or subtraction",
      "events": undefined,
      "name": "doMath",
      "readonly": undefined,
      "returns": {
        "desc": "The result of the operation",
        "type": "uint64",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "Calculator",
}
`;

exports[`Examples Calculator Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [
          {
            "desc": "The first number",
            "name": "a",
            "type": "uint64",
          },
          {
            "desc": "The second number",
            "name": "b",
            "type": "uint64",
          },
          {
            "desc": "The operation to perform. Can be either 'sum' or 'difference'",
            "name": "operation",
            "type": "string",
          },
        ],
        "desc": "A method that takes two numbers and does either addition or subtraction",
        "events": undefined,
        "name": "doMath",
        "readonly": undefined,
        "returns": {
          "desc": "The result of the operation",
          "type": "uint64",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "Calculator",
  },
  "hints": {
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "doMath(uint64,uint64,string)uint64": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {},
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAxCgovLyBodHRwczovL2dpdGh1Yi5jb20vYWxnb3JhbmRmb3VuZGF0aW9uL1RFQUxTY3JpcHQKCi8vIFRoaXMgY29udHJhY3QgaXMgY29tcGxpYW50IHdpdGggYW5kL29yIGltcGxlbWVudHMgdGhlIGZvbGxvd2luZyBBUkNzOiBbIEFSQzQgXQoKLy8gVGhlIGZvbGxvd2luZyB0ZW4gbGluZXMgb2YgVEVBTCBoYW5kbGUgaW5pdGlhbCBwcm9ncmFtIGZsb3cKLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgdG8gbWFrZSBpdCBlYXN5IGZvciBhbnlvbmUgdG8gcGFyc2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGFuZCBkZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyBhY3Rpb24gaXMgYWxsb3dlZAovLyBIZXJlLCBhY3Rpb24gcmVmZXJzIHRvIHRoZSBPbkNvbXBsZXRlIGluIGNvbWJpbmF0aW9uIHdpdGggd2hldGhlciB0aGUgYXBwIGlzIGJlaW5nIGNyZWF0ZWQgb3IgY2FsbGVkCi8vIEV2ZXJ5IHBvc3NpYmxlIGFjdGlvbiBmb3IgdGhpcyBjb250cmFjdCBpcyByZXByZXNlbnRlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudAovLyBJZiB0aGUgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgY29udHJhY3QsIGl0cyByZXNwZWN0aXZlIGJyYW5jaCB3aWxsIGJlICIqTk9UX0lNUExFTUVOVEVEIiB3aGljaCBqdXN0IGNvbnRhaW5zICJlcnIiCnR4biBBcHBsaWNhdGlvbklECiEKcHVzaGludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJLy8gVGhlIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udHJhY3QuIEFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgT25Db21wbGV0ZT8gRGlkIHlvdSBzZXQgeW91ciBhcHAgSUQ/CgllcnIKCi8vIGdldFN1bShhOiB1aW50NjQsIGI6IHVpbnQ2NCk6IHVpbnQ2NAovLwovLyBDYWxjdWxhdGVzIHRoZSBzdW0gb2YgdHdvIG51bWJlcnMKLy8KLy8gQHBhcmFtIGEKLy8gQHBhcmFtIGIKLy8gQHJldHVybnMgVGhlIHN1bSBvZiBhIGFuZCBiCmdldFN1bToKCXByb3RvIDIgMQoKCS8vIGV4YW1wbGVzL2NhbGN1bGF0b3IvY2FsY3VsYXRvci5hbGdvLnRzOjEzCgkvLyByZXR1cm4gYSArIGI7CglmcmFtZV9kaWcgLTEgLy8gYTogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gYjogdWludDY0CgkrCglyZXRzdWIKCi8vIGdldERpZmZlcmVuY2UoYTogdWludDY0LCBiOiB1aW50NjQpOiB1aW50NjQKLy8KLy8gQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBudW1iZXJzCi8vCi8vIEBwYXJhbSBhCi8vIEBwYXJhbSBiCi8vIEByZXR1cm5zIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYSBhbmQgYi4KZ2V0RGlmZmVyZW5jZToKCXByb3RvIDIgMQoKCS8vIGV4YW1wbGVzL2NhbGN1bGF0b3IvY2FsY3VsYXRvci5hbGdvLnRzOjI0CgkvLyByZXR1cm4gYSA+PSBiID8gYSAtIGIgOiBiIC0gYTsKCWZyYW1lX2RpZyAtMSAvLyBhOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBiOiB1aW50NjQKCT49CglieiAqdGVybmFyeTBfZmFsc2UKCWZyYW1lX2RpZyAtMSAvLyBhOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBiOiB1aW50NjQKCS0KCWIgKnRlcm5hcnkwX2VuZAoKKnRlcm5hcnkwX2ZhbHNlOgoJZnJhbWVfZGlnIC0yIC8vIGI6IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIGE6IHVpbnQ2NAoJLQoKKnRlcm5hcnkwX2VuZDoKCXJldHN1YgoKLy8gZG9NYXRoKHVpbnQ2NCx1aW50NjQsc3RyaW5nKXVpbnQ2NAoqYWJpX3JvdXRlX2RvTWF0aDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJcHVzaGJ5dGVzIDB4MTUxZjdjNzUKCgkvLyBvcGVyYXRpb246IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZXh0cmFjdCAyIDAKCgkvLyBiOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBhOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGRvTWF0aCh1aW50NjQsdWludDY0LHN0cmluZyl1aW50NjQKCWNhbGxzdWIgZG9NYXRoCglpdG9iCgljb25jYXQKCWxvZwoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gZG9NYXRoKGE6IHVpbnQ2NCwgYjogdWludDY0LCBvcGVyYXRpb246IHN0cmluZyk6IHVpbnQ2NAovLwovLyBBIG1ldGhvZCB0aGF0IHRha2VzIHR3byBudW1iZXJzIGFuZCBkb2VzIGVpdGhlciBhZGRpdGlvbiBvciBzdWJ0cmFjdGlvbgovLwovLyBAcGFyYW0gYSBUaGUgZmlyc3QgbnVtYmVyCi8vIEBwYXJhbSBiIFRoZSBzZWNvbmQgbnVtYmVyCi8vIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBwZXJmb3JtLiBDYW4gYmUgZWl0aGVyICdzdW0nIG9yICdkaWZmZXJlbmNlJwovLwovLyBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb24KZG9NYXRoOgoJcHJvdG8gMyAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCXB1c2hieXRlcyAweAoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9jYWxjdWxhdG9yL2NhbGN1bGF0b3IuYWxnby50czozOQoJLy8gb3BlcmF0aW9uID09PSAnc3VtJwoJZnJhbWVfZGlnIC0zIC8vIG9wZXJhdGlvbjogc3RyaW5nCglwdXNoYnl0ZXMgMHg3Mzc1NmQgLy8gInN1bSIKCT09CglieiAqaWYwX2Vsc2VpZjFfY29uZGl0aW9uCgoJLy8gKmlmMF9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9jYWxjdWxhdG9yL2NhbGN1bGF0b3IuYWxnby50czo0MAoJLy8gcmVzdWx0ID0gdGhpcy5nZXRTdW0oYSwgYikKCWZyYW1lX2RpZyAtMiAvLyBiOiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBhOiB1aW50NjQKCWNhbGxzdWIgZ2V0U3VtCglmcmFtZV9idXJ5IDAgLy8gcmVzdWx0OiB1aW50NjQKCWIgKmlmMF9lbmQKCippZjBfZWxzZWlmMV9jb25kaXRpb246CgkvLyBleGFtcGxlcy9jYWxjdWxhdG9yL2NhbGN1bGF0b3IuYWxnby50czo0MQoJLy8gb3BlcmF0aW9uID09PSAnZGlmZmVyZW5jZScKCWZyYW1lX2RpZyAtMyAvLyBvcGVyYXRpb246IHN0cmluZwoJcHVzaGJ5dGVzIDB4NjQ2OTY2NjY2NTcyNjU2ZTYzNjUgLy8gImRpZmZlcmVuY2UiCgk9PQoJYnogKmlmMF9lbHNlCgoJLy8gKmlmMF9lbHNlaWYxX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL2NhbGN1bGF0b3IvY2FsY3VsYXRvci5hbGdvLnRzOjQyCgkvLyByZXN1bHQgPSB0aGlzLmdldERpZmZlcmVuY2UoYSwgYikKCWZyYW1lX2RpZyAtMiAvLyBiOiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBhOiB1aW50NjQKCWNhbGxzdWIgZ2V0RGlmZmVyZW5jZQoJZnJhbWVfYnVyeSAwIC8vIHJlc3VsdDogdWludDY0CgliICppZjBfZW5kCgoqaWYwX2Vsc2U6CgkvLyBJbnZhbGlkIG9wZXJhdGlvbgoJZXJyCgoqaWYwX2VuZDoKCS8vIGV4YW1wbGVzL2NhbGN1bGF0b3IvY2FsY3VsYXRvci5hbGdvLnRzOjQ1CgkvLyByZXR1cm4gcmVzdWx0OwoJZnJhbWVfZGlnIDAgLy8gcmVzdWx0OiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCWludGMgMCAvLyAxCglyZXR1cm4KCipjcmVhdGVfTm9PcDoKCXB1c2hieXRlcyAweGI4NDQ3YjM2IC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNyZWF0ZSBOb09wCgllcnIKCipjYWxsX05vT3A6CglwdXNoYnl0ZXMgMHg3NmE3ZWYzMyAvLyBtZXRob2QgImRvTWF0aCh1aW50NjQsdWludDY0LHN0cmluZyl1aW50NjQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2RvTWF0aAoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjYWxsIE5vT3AKCWVycg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples FactoryCaller Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 0 1 6
bytecblock 0xb8447b36 0x

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 2 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// mintAndGetAsset()uint64
*abi_route_mintAndGetAsset:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// execute mintAndGetAsset()uint64
	callsub mintAndGetAsset
	itob
	concat
	log
	intc 1 // 1
	return

// mintAndGetAsset(): AssetID
mintAndGetAsset:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// examples/itxns/itxns.algo.ts:25
	// sendMethodCall<typeof NFTFactory.prototype.createApplication>({
	//       clearStateProgram: NFTFactory.clearProgram(),
	//       approvalProgram: NFTFactory.approvalProgram(),
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 0 //  method "createApplication()void"
	itxn_field ApplicationArgs

	// examples/itxns/itxns.algo.ts:26
	// clearStateProgram: NFTFactory.clearProgram()
	pushbytes 0x0a
	itxn_field ClearStateProgram

	// examples/itxns/itxns.algo.ts:27
	// approvalProgram: NFTFactory.approvalProgram()
	pushbytes 0x0a2002010031181481060b3119088d0c006f00000000000000000000006100000000000000000000008004151f7c75361a02570200361a015702008800051650b022438a0201b18103b2108bffb2268bfeb22522b22223b201b3b43c89361a02491581201244361a011788000222438a0200b18104b2108bfeb21422b2128bffb21123b201b38922438004b8447b36361a008e01fff1008004d2024c738004c7e260af361a008e02ff7dffb100
	itxn_field ApprovalProgram

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/itxns/itxns.algo.ts:30
	// factoryApp = this.itxn.createdApplicationID
	itxn CreatedApplicationID
	frame_bury 0 // factoryApp: uint64

	// examples/itxns/itxns.algo.ts:32
	// sendPayment({
	//       amount: 200_000,
	//       receiver: factoryApp.address,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// examples/itxns/itxns.algo.ts:33
	// amount: 200_000
	pushint 200_000
	itxn_field Amount

	// examples/itxns/itxns.algo.ts:34
	// receiver: factoryApp.address
	frame_dig 0 // factoryApp: uint64
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/itxns/itxns.algo.ts:37
	// createdAsset = sendMethodCall<typeof NFTFactory.prototype.createNFT>({
	//       applicationID: factoryApp,
	//       methodArgs: ['My NFT', 'MNFT'],
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0xd2024c73 // method "createNFT(string,string)uint64"
	itxn_field ApplicationArgs

	// examples/itxns/itxns.algo.ts:38
	// applicationID: factoryApp
	frame_dig 0 // factoryApp: uint64
	itxn_field ApplicationID

	// examples/itxns/itxns.algo.ts:39
	// methodArgs: ['My NFT', 'MNFT']
	pushbytes 0x00064d79204e4654
	itxn_field ApplicationArgs
	pushbytes 0x00044d4e4654
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	btoi
	frame_bury 1 // createdAsset: uint64

	// examples/itxns/itxns.algo.ts:42
	// sendAssetTransfer({
	//       assetReceiver: this.app.address,
	//       assetAmount: 0,
	//       xferAsset: createdAsset,
	//     })
	itxn_begin
	pushint 4 // axfer
	itxn_field TypeEnum

	// examples/itxns/itxns.algo.ts:43
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// examples/itxns/itxns.algo.ts:44
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// examples/itxns/itxns.algo.ts:45
	// xferAsset: createdAsset
	frame_dig 1 // createdAsset: uint64
	itxn_field XferAsset

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/itxns/itxns.algo.ts:48
	// sendMethodCall<typeof NFTFactory.prototype.transferNFT>({
	//       applicationID: factoryApp,
	//       methodArgs: [createdAsset, this.app.address],
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0xc7e260af // method "transferNFT(uint64,address)void"
	itxn_field ApplicationArgs

	// examples/itxns/itxns.algo.ts:49
	// applicationID: factoryApp
	frame_dig 0 // factoryApp: uint64
	itxn_field ApplicationID

	// examples/itxns/itxns.algo.ts:50
	// methodArgs: [createdAsset, this.app.address]
	frame_dig 1 // createdAsset: uint64
	itob
	itxn_field ApplicationArgs
	global CurrentApplicationAddress
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/itxns/itxns.algo.ts:53
	// return createdAsset;
	frame_dig 1 // createdAsset: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

*abi_route_createApplication:
	intc 1 // 1
	return

*create_NoOp:
	bytec 0 //  method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x45ded8e0 // method "mintAndGetAsset()uint64"
	txna ApplicationArgs 0
	match *abi_route_mintAndGetAsset

	// this contract does not implement the given ABI method for call NoOp
	err"
`;

exports[`Examples FactoryCaller Artifacts Maintains program size 1`] = `422`;

exports[`Examples FactoryCaller Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "mintAndGetAsset",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "uint64",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "FactoryCaller",
}
`;

exports[`Examples FactoryCaller Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "mintAndGetAsset",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "uint64",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "FactoryCaller",
  },
  "hints": {
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "mintAndGetAsset()uint64": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {},
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAwIDEgNgpieXRlY2Jsb2NrIDB4Yjg0NDdiMzYgMHgKCi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZGZvdW5kYXRpb24vVEVBTFNjcmlwdAoKLy8gVGhpcyBjb250cmFjdCBpcyBjb21wbGlhbnQgd2l0aCBhbmQvb3IgaW1wbGVtZW50cyB0aGUgZm9sbG93aW5nIEFSQ3M6IFsgQVJDNCBdCgovLyBUaGUgZm9sbG93aW5nIHRlbiBsaW5lcyBvZiBURUFMIGhhbmRsZSBpbml0aWFsIHByb2dyYW0gZmxvdwovLyBUaGlzIHBhdHRlcm4gaXMgdXNlZCB0byBtYWtlIGl0IGVhc3kgZm9yIGFueW9uZSB0byBwYXJzZSB0aGUgc3RhcnQgb2YgdGhlIHByb2dyYW0gYW5kIGRldGVybWluZSBpZiBhIHNwZWNpZmljIGFjdGlvbiBpcyBhbGxvd2VkCi8vIEhlcmUsIGFjdGlvbiByZWZlcnMgdG8gdGhlIE9uQ29tcGxldGUgaW4gY29tYmluYXRpb24gd2l0aCB3aGV0aGVyIHRoZSBhcHAgaXMgYmVpbmcgY3JlYXRlZCBvciBjYWxsZWQKLy8gRXZlcnkgcG9zc2libGUgYWN0aW9uIGZvciB0aGlzIGNvbnRyYWN0IGlzIHJlcHJlc2VudGVkIGluIHRoZSBzd2l0Y2ggc3RhdGVtZW50Ci8vIElmIHRoZSBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBjb250cmFjdCwgaXRzIHJlc3BlY3RpdmUgYnJhbmNoIHdpbGwgYmUgIipOT1RfSU1QTEVNRU5URUQiIHdoaWNoIGp1c3QgY29udGFpbnMgImVyciIKdHhuIEFwcGxpY2F0aW9uSUQKIQppbnRjIDIgLy8gNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggKmNhbGxfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKmNyZWF0ZV9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRAoKKk5PVF9JTVBMRU1FTlRFRDoKCS8vIFRoZSByZXF1ZXN0ZWQgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIGNvbnRyYWN0LiBBcmUgeW91IHVzaW5nIHRoZSBjb3JyZWN0IE9uQ29tcGxldGU/IERpZCB5b3Ugc2V0IHlvdXIgYXBwIElEPwoJZXJyCgovLyBtaW50QW5kR2V0QXNzZXQoKXVpbnQ2NAoqYWJpX3JvdXRlX21pbnRBbmRHZXRBc3NldDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJcHVzaGJ5dGVzIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIG1pbnRBbmRHZXRBc3NldCgpdWludDY0CgljYWxsc3ViIG1pbnRBbmRHZXRBc3NldAoJaXRvYgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIG1pbnRBbmRHZXRBc3NldCgpOiBBc3NldElECm1pbnRBbmRHZXRBc3NldDoKCXByb3RvIDAgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CglkdXAKCgkvLyBleGFtcGxlcy9pdHhucy9pdHhucy5hbGdvLnRzOjI1CgkvLyBzZW5kTWV0aG9kQ2FsbDx0eXBlb2YgTkZURmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQXBwbGljYXRpb24+KHsKCS8vICAgICAgIGNsZWFyU3RhdGVQcm9ncmFtOiBORlRGYWN0b3J5LmNsZWFyUHJvZ3JhbSgpLAoJLy8gICAgICAgYXBwcm92YWxQcm9ncmFtOiBORlRGYWN0b3J5LmFwcHJvdmFsUHJvZ3JhbSgpLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDIgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWJ5dGVjIDAgLy8gIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24oKXZvaWQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGV4YW1wbGVzL2l0eG5zL2l0eG5zLmFsZ28udHM6MjYKCS8vIGNsZWFyU3RhdGVQcm9ncmFtOiBORlRGYWN0b3J5LmNsZWFyUHJvZ3JhbSgpCglwdXNoYnl0ZXMgMHgwYQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoKCS8vIGV4YW1wbGVzL2l0eG5zL2l0eG5zLmFsZ28udHM6MjcKCS8vIGFwcHJvdmFsUHJvZ3JhbTogTkZURmFjdG9yeS5hcHByb3ZhbFByb2dyYW0oKQoJcHVzaGJ5dGVzIDB4MGEyMDAyMDEwMDMxMTgxNDgxMDYwYjMxMTkwODhkMGMwMDZmMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwMDQxNTFmN2M3NTM2MWEwMjU3MDIwMDM2MWEwMTU3MDIwMDg4MDAwNTE2NTBiMDIyNDM4YTAyMDFiMTgxMDNiMjEwOGJmZmIyMjY4YmZlYjIyNTIyYjIyMjIzYjIwMWIzYjQzYzg5MzYxYTAyNDkxNTgxMjAxMjQ0MzYxYTAxMTc4ODAwMDIyMjQzOGEwMjAwYjE4MTA0YjIxMDhiZmViMjE0MjJiMjEyOGJmZmIyMTEyM2IyMDFiMzg5MjI0MzgwMDRiODQ0N2IzNjM2MWEwMDhlMDFmZmYxMDA4MDA0ZDIwMjRjNzM4MDA0YzdlMjYwYWYzNjFhMDA4ZTAyZmY3ZGZmYjEwMAoJaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gZXhhbXBsZXMvaXR4bnMvaXR4bnMuYWxnby50czozMAoJLy8gZmFjdG9yeUFwcCA9IHRoaXMuaXR4bi5jcmVhdGVkQXBwbGljYXRpb25JRAoJaXR4biBDcmVhdGVkQXBwbGljYXRpb25JRAoJZnJhbWVfYnVyeSAwIC8vIGZhY3RvcnlBcHA6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL2l0eG5zL2l0eG5zLmFsZ28udHM6MzIKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgIGFtb3VudDogMjAwXzAwMCwKCS8vICAgICAgIHJlY2VpdmVyOiBmYWN0b3J5QXBwLmFkZHJlc3MsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gZXhhbXBsZXMvaXR4bnMvaXR4bnMuYWxnby50czozMwoJLy8gYW1vdW50OiAyMDBfMDAwCglwdXNoaW50IDIwMF8wMDAKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gZXhhbXBsZXMvaXR4bnMvaXR4bnMuYWxnby50czozNAoJLy8gcmVjZWl2ZXI6IGZhY3RvcnlBcHAuYWRkcmVzcwoJZnJhbWVfZGlnIDAgLy8gZmFjdG9yeUFwcDogdWludDY0CglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gZXhhbXBsZXMvaXR4bnMvaXR4bnMuYWxnby50czozNwoJLy8gY3JlYXRlZEFzc2V0ID0gc2VuZE1ldGhvZENhbGw8dHlwZW9mIE5GVEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZU5GVD4oewoJLy8gICAgICAgYXBwbGljYXRpb25JRDogZmFjdG9yeUFwcCwKCS8vICAgICAgIG1ldGhvZEFyZ3M6IFsnTXkgTkZUJywgJ01ORlQnXSwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAyIC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglwdXNoYnl0ZXMgMHhkMjAyNGM3MyAvLyBtZXRob2QgImNyZWF0ZU5GVChzdHJpbmcsc3RyaW5nKXVpbnQ2NCIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gZXhhbXBsZXMvaXR4bnMvaXR4bnMuYWxnby50czozOAoJLy8gYXBwbGljYXRpb25JRDogZmFjdG9yeUFwcAoJZnJhbWVfZGlnIDAgLy8gZmFjdG9yeUFwcDogdWludDY0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBleGFtcGxlcy9pdHhucy9pdHhucy5hbGdvLnRzOjM5CgkvLyBtZXRob2RBcmdzOiBbJ015IE5GVCcsICdNTkZUJ10KCXB1c2hieXRlcyAweDAwMDY0ZDc5MjA0ZTQ2NTQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglwdXNoYnl0ZXMgMHgwMDA0NGQ0ZTQ2NTQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnRjIDEgLy8gMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCglidG9pCglmcmFtZV9idXJ5IDEgLy8gY3JlYXRlZEFzc2V0OiB1aW50NjQKCgkvLyBleGFtcGxlcy9pdHhucy9pdHhucy5hbGdvLnRzOjQyCgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgYXNzZXRBbW91bnQ6IDAsCgkvLyAgICAgICB4ZmVyQXNzZXQ6IGNyZWF0ZWRBc3NldCwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJcHVzaGludCA0IC8vIGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gZXhhbXBsZXMvaXR4bnMvaXR4bnMuYWxnby50czo0MwoJLy8gYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGV4YW1wbGVzL2l0eG5zL2l0eG5zLmFsZ28udHM6NDQKCS8vIGFzc2V0QW1vdW50OiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIGV4YW1wbGVzL2l0eG5zL2l0eG5zLmFsZ28udHM6NDUKCS8vIHhmZXJBc3NldDogY3JlYXRlZEFzc2V0CglmcmFtZV9kaWcgMSAvLyBjcmVhdGVkQXNzZXQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gZXhhbXBsZXMvaXR4bnMvaXR4bnMuYWxnby50czo0OAoJLy8gc2VuZE1ldGhvZENhbGw8dHlwZW9mIE5GVEZhY3RvcnkucHJvdG90eXBlLnRyYW5zZmVyTkZUPih7CgkvLyAgICAgICBhcHBsaWNhdGlvbklEOiBmYWN0b3J5QXBwLAoJLy8gICAgICAgbWV0aG9kQXJnczogW2NyZWF0ZWRBc3NldCwgdGhpcy5hcHAuYWRkcmVzc10sCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMiAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJcHVzaGJ5dGVzIDB4YzdlMjYwYWYgLy8gbWV0aG9kICJ0cmFuc2Zlck5GVCh1aW50NjQsYWRkcmVzcyl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBleGFtcGxlcy9pdHhucy9pdHhucy5hbGdvLnRzOjQ5CgkvLyBhcHBsaWNhdGlvbklEOiBmYWN0b3J5QXBwCglmcmFtZV9kaWcgMCAvLyBmYWN0b3J5QXBwOiB1aW50NjQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGV4YW1wbGVzL2l0eG5zL2l0eG5zLmFsZ28udHM6NTAKCS8vIG1ldGhvZEFyZ3M6IFtjcmVhdGVkQXNzZXQsIHRoaXMuYXBwLmFkZHJlc3NdCglmcmFtZV9kaWcgMSAvLyBjcmVhdGVkQXNzZXQ6IHVpbnQ2NAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBleGFtcGxlcy9pdHhucy9pdHhucy5hbGdvLnRzOjUzCgkvLyByZXR1cm4gY3JlYXRlZEFzc2V0OwoJZnJhbWVfZGlnIDEgLy8gY3JlYXRlZEFzc2V0OiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxCglyZXRzdWIKCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CglpbnRjIDEgLy8gMQoJcmV0dXJuCgoqY3JlYXRlX05vT3A6CglieXRlYyAwIC8vICBtZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjcmVhdGUgTm9PcAoJZXJyCgoqY2FsbF9Ob09wOgoJcHVzaGJ5dGVzIDB4NDVkZWQ4ZTAgLy8gbWV0aG9kICJtaW50QW5kR2V0QXNzZXQoKXVpbnQ2NCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfbWludEFuZEdldEFzc2V0CgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNhbGwgTm9PcAoJZXJy",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples NFTFactory Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 1 0

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createNFT(string,string)uint64
*abi_route_createNFT:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// unitName: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute createNFT(string,string)uint64
	callsub createNFT
	itob
	concat
	log
	intc 0 // 1
	return

// createNFT(name: string, unitName: string): AssetID
createNFT:
	proto 2 1

	// examples/itxns/itxns.algo.ts:6
	// return sendAssetCreation({
	//       configAssetName: name,
	//       configAssetUnitName: unitName,
	//       configAssetTotal: 1,
	//     });
	itxn_begin
	pushint 3 // acfg
	itxn_field TypeEnum

	// examples/itxns/itxns.algo.ts:7
	// configAssetName: name
	frame_dig -1 // name: string
	itxn_field ConfigAssetName

	// examples/itxns/itxns.algo.ts:8
	// configAssetUnitName: unitName
	frame_dig -2 // unitName: string
	itxn_field ConfigAssetUnitName

	// examples/itxns/itxns.algo.ts:9
	// configAssetTotal: 1
	intc 0 // 1
	itxn_field ConfigAssetTotal

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	retsub

// transferNFT(uint64,address)void
*abi_route_transferNFT:
	// receiver: address
	txna ApplicationArgs 2
	dup
	len
	pushint 32
	==

	// argument 0 (receiver) for transferNFT must be a address
	assert

	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute transferNFT(uint64,address)void
	callsub transferNFT
	intc 0 // 1
	return

// transferNFT(asset: AssetID, receiver: Address): void
transferNFT:
	proto 2 0

	// examples/itxns/itxns.algo.ts:14
	// sendAssetTransfer({
	//       assetReceiver: receiver,
	//       assetAmount: 1,
	//       xferAsset: asset,
	//     })
	itxn_begin
	pushint 4 // axfer
	itxn_field TypeEnum

	// examples/itxns/itxns.algo.ts:15
	// assetReceiver: receiver
	frame_dig -2 // receiver: Address
	itxn_field AssetReceiver

	// examples/itxns/itxns.algo.ts:16
	// assetAmount: 1
	intc 0 // 1
	itxn_field AssetAmount

	// examples/itxns/itxns.algo.ts:17
	// xferAsset: asset
	frame_dig -1 // asset: AssetID
	itxn_field XferAsset

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xd2024c73 // method "createNFT(string,string)uint64"
	pushbytes 0xc7e260af // method "transferNFT(uint64,address)void"
	txna ApplicationArgs 0
	match *abi_route_createNFT *abi_route_transferNFT

	// this contract does not implement the given ABI method for call NoOp
	err"
`;

exports[`Examples NFTFactory Artifacts Maintains program size 1`] = `173`;

exports[`Examples NFTFactory Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [
        {
          "desc": undefined,
          "name": "name",
          "type": "string",
        },
        {
          "desc": undefined,
          "name": "unitName",
          "type": "string",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "createNFT",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "uint64",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "asset",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "receiver",
          "type": "address",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "transferNFT",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "NFTFactory",
}
`;

exports[`Examples NFTFactory Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [
          {
            "desc": undefined,
            "name": "name",
            "type": "string",
          },
          {
            "desc": undefined,
            "name": "unitName",
            "type": "string",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "createNFT",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "uint64",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "asset",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "receiver",
            "type": "address",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "transferNFT",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "NFTFactory",
  },
  "hints": {
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "createNFT(string,string)uint64": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "transferNFT(uint64,address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {},
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAxIDAKCi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZGZvdW5kYXRpb24vVEVBTFNjcmlwdAoKLy8gVGhpcyBjb250cmFjdCBpcyBjb21wbGlhbnQgd2l0aCBhbmQvb3IgaW1wbGVtZW50cyB0aGUgZm9sbG93aW5nIEFSQ3M6IFsgQVJDNCBdCgovLyBUaGUgZm9sbG93aW5nIHRlbiBsaW5lcyBvZiBURUFMIGhhbmRsZSBpbml0aWFsIHByb2dyYW0gZmxvdwovLyBUaGlzIHBhdHRlcm4gaXMgdXNlZCB0byBtYWtlIGl0IGVhc3kgZm9yIGFueW9uZSB0byBwYXJzZSB0aGUgc3RhcnQgb2YgdGhlIHByb2dyYW0gYW5kIGRldGVybWluZSBpZiBhIHNwZWNpZmljIGFjdGlvbiBpcyBhbGxvd2VkCi8vIEhlcmUsIGFjdGlvbiByZWZlcnMgdG8gdGhlIE9uQ29tcGxldGUgaW4gY29tYmluYXRpb24gd2l0aCB3aGV0aGVyIHRoZSBhcHAgaXMgYmVpbmcgY3JlYXRlZCBvciBjYWxsZWQKLy8gRXZlcnkgcG9zc2libGUgYWN0aW9uIGZvciB0aGlzIGNvbnRyYWN0IGlzIHJlcHJlc2VudGVkIGluIHRoZSBzd2l0Y2ggc3RhdGVtZW50Ci8vIElmIHRoZSBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBjb250cmFjdCwgaXRzIHJlc3BlY3RpdmUgYnJhbmNoIHdpbGwgYmUgIipOT1RfSU1QTEVNRU5URUQiIHdoaWNoIGp1c3QgY29udGFpbnMgImVyciIKdHhuIEFwcGxpY2F0aW9uSUQKIQpwdXNoaW50IDYKKgp0eG4gT25Db21wbGV0aW9uCisKc3dpdGNoICpjYWxsX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpjcmVhdGVfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQKCipOT1RfSU1QTEVNRU5URUQ6CgkvLyBUaGUgcmVxdWVzdGVkIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBjb250cmFjdC4gQXJlIHlvdSB1c2luZyB0aGUgY29ycmVjdCBPbkNvbXBsZXRlPyBEaWQgeW91IHNldCB5b3VyIGFwcCBJRD8KCWVycgoKLy8gY3JlYXRlTkZUKHN0cmluZyxzdHJpbmcpdWludDY0CiphYmlfcm91dGVfY3JlYXRlTkZUOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglwdXNoYnl0ZXMgMHgxNTFmN2M3NQoKCS8vIHVuaXROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWV4dHJhY3QgMiAwCgoJLy8gbmFtZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgY3JlYXRlTkZUKHN0cmluZyxzdHJpbmcpdWludDY0CgljYWxsc3ViIGNyZWF0ZU5GVAoJaXRvYgoJY29uY2F0Cglsb2cKCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGNyZWF0ZU5GVChuYW1lOiBzdHJpbmcsIHVuaXROYW1lOiBzdHJpbmcpOiBBc3NldElECmNyZWF0ZU5GVDoKCXByb3RvIDIgMQoKCS8vIGV4YW1wbGVzL2l0eG5zL2l0eG5zLmFsZ28udHM6NgoJLy8gcmV0dXJuIHNlbmRBc3NldENyZWF0aW9uKHsKCS8vICAgICAgIGNvbmZpZ0Fzc2V0TmFtZTogbmFtZSwKCS8vICAgICAgIGNvbmZpZ0Fzc2V0VW5pdE5hbWU6IHVuaXROYW1lLAoJLy8gICAgICAgY29uZmlnQXNzZXRUb3RhbDogMSwKCS8vICAgICB9KTsKCWl0eG5fYmVnaW4KCXB1c2hpbnQgMyAvLyBhY2ZnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gZXhhbXBsZXMvaXR4bnMvaXR4bnMuYWxnby50czo3CgkvLyBjb25maWdBc3NldE5hbWU6IG5hbWUKCWZyYW1lX2RpZyAtMSAvLyBuYW1lOiBzdHJpbmcKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXROYW1lCgoJLy8gZXhhbXBsZXMvaXR4bnMvaXR4bnMuYWxnby50czo4CgkvLyBjb25maWdBc3NldFVuaXROYW1lOiB1bml0TmFtZQoJZnJhbWVfZGlnIC0yIC8vIHVuaXROYW1lOiBzdHJpbmcKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRVbml0TmFtZQoKCS8vIGV4YW1wbGVzL2l0eG5zL2l0eG5zLmFsZ28udHM6OQoJLy8gY29uZmlnQXNzZXRUb3RhbDogMQoJaW50YyAwIC8vIDEKCWl0eG5fZmllbGQgQ29uZmlnQXNzZXRUb3RhbAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMSAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gQ3JlYXRlZEFzc2V0SUQKCXJldHN1YgoKLy8gdHJhbnNmZXJORlQodWludDY0LGFkZHJlc3Mpdm9pZAoqYWJpX3JvdXRlX3RyYW5zZmVyTkZUOgoJLy8gcmVjZWl2ZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglwdXNoaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKHJlY2VpdmVyKSBmb3IgdHJhbnNmZXJORlQgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGFzc2V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIHRyYW5zZmVyTkZUKHVpbnQ2NCxhZGRyZXNzKXZvaWQKCWNhbGxzdWIgdHJhbnNmZXJORlQKCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIHRyYW5zZmVyTkZUKGFzc2V0OiBBc3NldElELCByZWNlaXZlcjogQWRkcmVzcyk6IHZvaWQKdHJhbnNmZXJORlQ6Cglwcm90byAyIDAKCgkvLyBleGFtcGxlcy9pdHhucy9pdHhucy5hbGdvLnRzOjE0CgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiByZWNlaXZlciwKCS8vICAgICAgIGFzc2V0QW1vdW50OiAxLAoJLy8gICAgICAgeGZlckFzc2V0OiBhc3NldCwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJcHVzaGludCA0IC8vIGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gZXhhbXBsZXMvaXR4bnMvaXR4bnMuYWxnby50czoxNQoJLy8gYXNzZXRSZWNlaXZlcjogcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMiAvLyByZWNlaXZlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gZXhhbXBsZXMvaXR4bnMvaXR4bnMuYWxnby50czoxNgoJLy8gYXNzZXRBbW91bnQ6IDEKCWludGMgMCAvLyAxCglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gZXhhbXBsZXMvaXR4bnMvaXR4bnMuYWxnby50czoxNwoJLy8geGZlckFzc2V0OiBhc3NldAoJZnJhbWVfZGlnIC0xIC8vIGFzc2V0OiBBc3NldElECglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMSAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCWludGMgMCAvLyAxCglyZXR1cm4KCipjcmVhdGVfTm9PcDoKCXB1c2hieXRlcyAweGI4NDQ3YjM2IC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNyZWF0ZSBOb09wCgllcnIKCipjYWxsX05vT3A6CglwdXNoYnl0ZXMgMHhkMjAyNGM3MyAvLyBtZXRob2QgImNyZWF0ZU5GVChzdHJpbmcsc3RyaW5nKXVpbnQ2NCIKCXB1c2hieXRlcyAweGM3ZTI2MGFmIC8vIG1ldGhvZCAidHJhbnNmZXJORlQodWludDY0LGFkZHJlc3Mpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfY3JlYXRlTkZUICphYmlfcm91dGVfdHJhbnNmZXJORlQKCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBOb09wCgllcnI=",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples OptInLsig Artifacts Generates TEAL 1`] = `
"#pragma version 10
//#pragma mode logicsig
intcblock 0 1 TMPL_APP_ID

// https://github.com/algorandfoundation/TEALScript

// The address of this logic signature is FKZPLQTSDQKAIA2GQUXW2QPXIN7P5VBZU7H67MP5WZSBLJNMXMMALMPEME

b *route_logic

// logic()void
*route_logic:
	// execute logic()void
	callsub logic
	intc 1 // 1
	return

// logic(): void
//
// Verify this is an opt in transaction
logic:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	pushbytes 0x

	// examples/lsig_with_app/lsig_with_app.algo.ts:14
	// verifyAssetTransferTxn(this.txn, {
	//       assetAmount: 0,
	//       assetReceiver: this.txn.sender,
	//       // It's very important to set fee to 0 for delegated logic signatures
	//       // Otherwise the fee can be used to drain the signer's account
	//       fee: 0,
	//       // Also very important to check that the rekey is set to zero address
	//       rekeyTo: globals.zeroAddress,
	//       // Finally we must ensure that this is not a close transaction, which will drain the signer's account of the given asset
	//       assetCloseTo: globals.zeroAddress,
	//     })
	// verify axfer
	txn TypeEnum
	pushint 4 // axfer
	==

	// transaction verification failed: {"txn":"this.txn","field":"typeEnum","expected":"axfer"}
	assert

	// verify assetAmount
	txn AssetAmount
	intc 0 // 0
	==

	// transaction verification failed: {"txn":"this.txn","field":"assetAmount","expected":"0"}
	assert

	// verify assetReceiver
	txn AssetReceiver
	txn Sender
	==

	// transaction verification failed: {"txn":"this.txn","field":"assetReceiver","expected":"this.txn.sender"}
	assert

	// verify fee
	txn Fee
	intc 0 // 0
	==

	// transaction verification failed: {"txn":"this.txn","field":"fee","expected":"0"}
	assert

	// verify rekeyTo
	txn RekeyTo
	global ZeroAddress
	==

	// transaction verification failed: {"txn":"this.txn","field":"rekeyTo","expected":"globals.zeroAddress"}
	assert

	// verify assetCloseTo
	txn AssetCloseTo
	global ZeroAddress
	==

	// transaction verification failed: {"txn":"this.txn","field":"assetCloseTo","expected":"globals.zeroAddress"}
	assert

	// examples/lsig_with_app/lsig_with_app.algo.ts:26
	// appCall = this.txnGroup[this.txn.groupIndex + 1]
	txn GroupIndex
	intc 1 // 1
	+
	frame_bury 0 // appCall: txn

	// examples/lsig_with_app/lsig_with_app.algo.ts:29
	// assert(appCall.applicationID === this.APP_ID)
	frame_dig 0 // appCall: txn
	gtxns ApplicationID
	intc 2 // TMPL_APP_ID
	==
	assert

	// examples/lsig_with_app/lsig_with_app.algo.ts:30
	// assert(appCall.applicationArgs[0] === method('verifyCreator(axfer,asset)void'))
	frame_dig 0 // appCall: txn
	gtxns ApplicationArgs 0
	pushbytes 0xd47b9716 // method "verifyCreator(axfer,asset)void"
	==
	assert
	retsub"
`;

exports[`Examples OptInLsig Artifacts Maintains program size 1`] = `80`;

exports[`Examples CreatorVerifier Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 1 0 32
bytecblock 0x00

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// allowOptInsFrom(address)void
*abi_route_allowOptInsFrom:
	// creator: address
	txna ApplicationArgs 1
	dup
	len
	intc 2 // 32
	==

	// argument 0 (creator) for allowOptInsFrom must be a address
	assert

	// execute allowOptInsFrom(address)void
	callsub allowOptInsFrom
	intc 0 // 1
	return

// allowOptInsFrom(creator: Address): void
//
// Allow anyone to use the lsig to opt in the txn sender into an asset created by the creator
allowOptInsFrom:
	proto 1 0

	// examples/lsig_with_app/lsig_with_app.algo.ts:41
	// this.allowedCreators([this.txn.sender, creator]).value = true
	txn Sender
	frame_dig -1 // creator: Address
	concat
	intc 0 // 1
	bytec 0 // 0x00
	intc 1 // 0
	uncover 2
	setbit
	box_put
	retsub

// disableOptInsFrom(address)void
*abi_route_disableOptInsFrom:
	// creator: address
	txna ApplicationArgs 1
	dup
	len
	intc 2 // 32
	==

	// argument 0 (creator) for disableOptInsFrom must be a address
	assert

	// execute disableOptInsFrom(address)void
	callsub disableOptInsFrom
	intc 0 // 1
	return

// disableOptInsFrom(creator: Address): void
//
// Disable opt-ins for ASAs from the given creator
disableOptInsFrom:
	proto 1 0

	// examples/lsig_with_app/lsig_with_app.algo.ts:46
	// this.allowedCreators([this.txn.sender, creator]).value = false
	txn Sender
	frame_dig -1 // creator: Address
	concat
	intc 1 // 0
	bytec 0 // 0x00
	intc 1 // 0
	uncover 2
	setbit
	box_put
	retsub

// verifyCreator(axfer)void
*abi_route_verifyCreator:
	// optIn: axfer
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	pushint 4 // axfer
	==

	// argument 0 (optIn) for verifyCreator must be a axfer transaction
	assert

	// execute verifyCreator(axfer)void
	callsub verifyCreator
	intc 0 // 1
	return

// verifyCreator(optIn: AssetTransferTxn): void
verifyCreator:
	proto 1 0

	// examples/lsig_with_app/lsig_with_app.algo.ts:52
	// assert(this.allowedCreators([optIn.sender, optIn.xferAsset.creator]).value)
	frame_dig -1 // optIn: AssetTransferTxn
	gtxns Sender
	frame_dig -1 // optIn: AssetTransferTxn
	gtxns XferAsset
	asset_params_get AssetCreator
	pop
	concat
	box_get

	// box value does not exist: this.allowedCreators([optIn.sender, optIn.xferAsset.creator]).value
	assert
	intc 1 // 0
	getbit
	assert
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xf1bf2ca8 // method "allowOptInsFrom(address)void"
	pushbytes 0xbc28ac2b // method "disableOptInsFrom(address)void"
	pushbytes 0x8d5aa727 // method "verifyCreator(axfer)void"
	txna ApplicationArgs 0
	match *abi_route_allowOptInsFrom *abi_route_disableOptInsFrom *abi_route_verifyCreator

	// this contract does not implement the given ABI method for call NoOp
	err"
`;

exports[`Examples CreatorVerifier Artifacts Maintains program size 1`] = `187`;

exports[`Examples CreatorVerifier Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [
        {
          "desc": undefined,
          "name": "creator",
          "type": "address",
        },
      ],
      "desc": "Allow anyone to use the lsig to opt in the txn sender into an asset created by the creator",
      "events": undefined,
      "name": "allowOptInsFrom",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "creator",
          "type": "address",
        },
      ],
      "desc": "Disable opt-ins for ASAs from the given creator",
      "events": undefined,
      "name": "disableOptInsFrom",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "optIn",
          "type": "axfer",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "verifyCreator",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "CreatorVerifier",
}
`;

exports[`Examples CreatorVerifier Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [
          {
            "desc": undefined,
            "name": "creator",
            "type": "address",
          },
        ],
        "desc": "Allow anyone to use the lsig to opt in the txn sender into an asset created by the creator",
        "events": undefined,
        "name": "allowOptInsFrom",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "creator",
            "type": "address",
          },
        ],
        "desc": "Disable opt-ins for ASAs from the given creator",
        "events": undefined,
        "name": "disableOptInsFrom",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "optIn",
            "type": "axfer",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "verifyCreator",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "CreatorVerifier",
  },
  "hints": {
    "allowOptInsFrom(address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "disableOptInsFrom(address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "verifyCreator(axfer)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {},
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAxIDAgMzIKYnl0ZWNibG9jayAweDAwCgovLyBodHRwczovL2dpdGh1Yi5jb20vYWxnb3JhbmRmb3VuZGF0aW9uL1RFQUxTY3JpcHQKCi8vIFRoaXMgY29udHJhY3QgaXMgY29tcGxpYW50IHdpdGggYW5kL29yIGltcGxlbWVudHMgdGhlIGZvbGxvd2luZyBBUkNzOiBbIEFSQzQgXQoKLy8gVGhlIGZvbGxvd2luZyB0ZW4gbGluZXMgb2YgVEVBTCBoYW5kbGUgaW5pdGlhbCBwcm9ncmFtIGZsb3cKLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgdG8gbWFrZSBpdCBlYXN5IGZvciBhbnlvbmUgdG8gcGFyc2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGFuZCBkZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyBhY3Rpb24gaXMgYWxsb3dlZAovLyBIZXJlLCBhY3Rpb24gcmVmZXJzIHRvIHRoZSBPbkNvbXBsZXRlIGluIGNvbWJpbmF0aW9uIHdpdGggd2hldGhlciB0aGUgYXBwIGlzIGJlaW5nIGNyZWF0ZWQgb3IgY2FsbGVkCi8vIEV2ZXJ5IHBvc3NpYmxlIGFjdGlvbiBmb3IgdGhpcyBjb250cmFjdCBpcyByZXByZXNlbnRlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudAovLyBJZiB0aGUgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgY29udHJhY3QsIGl0cyByZXNwZWN0aXZlIGJyYW5jaCB3aWxsIGJlICIqTk9UX0lNUExFTUVOVEVEIiB3aGljaCBqdXN0IGNvbnRhaW5zICJlcnIiCnR4biBBcHBsaWNhdGlvbklECiEKcHVzaGludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJLy8gVGhlIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udHJhY3QuIEFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgT25Db21wbGV0ZT8gRGlkIHlvdSBzZXQgeW91ciBhcHAgSUQ/CgllcnIKCi8vIGFsbG93T3B0SW5zRnJvbShhZGRyZXNzKXZvaWQKKmFiaV9yb3V0ZV9hbGxvd09wdEluc0Zyb206CgkvLyBjcmVhdG9yOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50YyAyIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGNyZWF0b3IpIGZvciBhbGxvd09wdEluc0Zyb20gbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGV4ZWN1dGUgYWxsb3dPcHRJbnNGcm9tKGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBhbGxvd09wdEluc0Zyb20KCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGFsbG93T3B0SW5zRnJvbShjcmVhdG9yOiBBZGRyZXNzKTogdm9pZAovLwovLyBBbGxvdyBhbnlvbmUgdG8gdXNlIHRoZSBsc2lnIHRvIG9wdCBpbiB0aGUgdHhuIHNlbmRlciBpbnRvIGFuIGFzc2V0IGNyZWF0ZWQgYnkgdGhlIGNyZWF0b3IKYWxsb3dPcHRJbnNGcm9tOgoJcHJvdG8gMSAwCgoJLy8gZXhhbXBsZXMvbHNpZ193aXRoX2FwcC9sc2lnX3dpdGhfYXBwLmFsZ28udHM6NDEKCS8vIHRoaXMuYWxsb3dlZENyZWF0b3JzKFt0aGlzLnR4bi5zZW5kZXIsIGNyZWF0b3JdKS52YWx1ZSA9IHRydWUKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBjcmVhdG9yOiBBZGRyZXNzCgljb25jYXQKCWludGMgMCAvLyAxCglieXRlYyAwIC8vIDB4MDAKCWludGMgMSAvLyAwCgl1bmNvdmVyIDIKCXNldGJpdAoJYm94X3B1dAoJcmV0c3ViCgovLyBkaXNhYmxlT3B0SW5zRnJvbShhZGRyZXNzKXZvaWQKKmFiaV9yb3V0ZV9kaXNhYmxlT3B0SW5zRnJvbToKCS8vIGNyZWF0b3I6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDIgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMCAoY3JlYXRvcikgZm9yIGRpc2FibGVPcHRJbnNGcm9tIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIGRpc2FibGVPcHRJbnNGcm9tKGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBkaXNhYmxlT3B0SW5zRnJvbQoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gZGlzYWJsZU9wdEluc0Zyb20oY3JlYXRvcjogQWRkcmVzcyk6IHZvaWQKLy8KLy8gRGlzYWJsZSBvcHQtaW5zIGZvciBBU0FzIGZyb20gdGhlIGdpdmVuIGNyZWF0b3IKZGlzYWJsZU9wdEluc0Zyb206Cglwcm90byAxIDAKCgkvLyBleGFtcGxlcy9sc2lnX3dpdGhfYXBwL2xzaWdfd2l0aF9hcHAuYWxnby50czo0NgoJLy8gdGhpcy5hbGxvd2VkQ3JlYXRvcnMoW3RoaXMudHhuLnNlbmRlciwgY3JlYXRvcl0pLnZhbHVlID0gZmFsc2UKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBjcmVhdG9yOiBBZGRyZXNzCgljb25jYXQKCWludGMgMSAvLyAwCglieXRlYyAwIC8vIDB4MDAKCWludGMgMSAvLyAwCgl1bmNvdmVyIDIKCXNldGJpdAoJYm94X3B1dAoJcmV0c3ViCgovLyB2ZXJpZnlDcmVhdG9yKGF4ZmVyKXZvaWQKKmFiaV9yb3V0ZV92ZXJpZnlDcmVhdG9yOgoJLy8gb3B0SW46IGF4ZmVyCgl0eG4gR3JvdXBJbmRleAoJaW50YyAwIC8vIDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCXB1c2hpbnQgNCAvLyBheGZlcgoJPT0KCgkvLyBhcmd1bWVudCAwIChvcHRJbikgZm9yIHZlcmlmeUNyZWF0b3IgbXVzdCBiZSBhIGF4ZmVyIHRyYW5zYWN0aW9uCglhc3NlcnQKCgkvLyBleGVjdXRlIHZlcmlmeUNyZWF0b3IoYXhmZXIpdm9pZAoJY2FsbHN1YiB2ZXJpZnlDcmVhdG9yCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyB2ZXJpZnlDcmVhdG9yKG9wdEluOiBBc3NldFRyYW5zZmVyVHhuKTogdm9pZAp2ZXJpZnlDcmVhdG9yOgoJcHJvdG8gMSAwCgoJLy8gZXhhbXBsZXMvbHNpZ193aXRoX2FwcC9sc2lnX3dpdGhfYXBwLmFsZ28udHM6NTIKCS8vIGFzc2VydCh0aGlzLmFsbG93ZWRDcmVhdG9ycyhbb3B0SW4uc2VuZGVyLCBvcHRJbi54ZmVyQXNzZXQuY3JlYXRvcl0pLnZhbHVlKQoJZnJhbWVfZGlnIC0xIC8vIG9wdEluOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBTZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBvcHRJbjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgWGZlckFzc2V0Cglhc3NldF9wYXJhbXNfZ2V0IEFzc2V0Q3JlYXRvcgoJcG9wCgljb25jYXQKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYWxsb3dlZENyZWF0b3JzKFtvcHRJbi5zZW5kZXIsIG9wdEluLnhmZXJBc3NldC5jcmVhdG9yXSkudmFsdWUKCWFzc2VydAoJaW50YyAxIC8vIDAKCWdldGJpdAoJYXNzZXJ0CglyZXRzdWIKCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CglpbnRjIDAgLy8gMQoJcmV0dXJuCgoqY3JlYXRlX05vT3A6CglwdXNoYnl0ZXMgMHhiODQ0N2IzNiAvLyBtZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjcmVhdGUgTm9PcAoJZXJyCgoqY2FsbF9Ob09wOgoJcHVzaGJ5dGVzIDB4ZjFiZjJjYTggLy8gbWV0aG9kICJhbGxvd09wdEluc0Zyb20oYWRkcmVzcyl2b2lkIgoJcHVzaGJ5dGVzIDB4YmMyOGFjMmIgLy8gbWV0aG9kICJkaXNhYmxlT3B0SW5zRnJvbShhZGRyZXNzKXZvaWQiCglwdXNoYnl0ZXMgMHg4ZDVhYTcyNyAvLyBtZXRob2QgInZlcmlmeUNyZWF0b3IoYXhmZXIpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfYWxsb3dPcHRJbnNGcm9tICphYmlfcm91dGVfZGlzYWJsZU9wdEluc0Zyb20gKmFiaV9yb3V0ZV92ZXJpZnlDcmVhdG9yCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNhbGwgTm9PcAoJZXJy",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples MerkleTree Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 1 33 0 99 3
bytecblock 0x 0x726f6f74 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b8550000000000000000000000000000000000000000000000000000000000000000 0x0000000000000000000000000000000000000000000000000000000000000000 0x73697a65

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// calcInitRoot(): bytes32
calcInitRoot:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// examples/merkle/merkle.algo.ts:17
	// result = hex(EMPTY_HASH) as bytes32
	bytec 2 // 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b8550000000000000000000000000000000000000000000000000000000000000000
	bytec 0 // 0x
	dup
	b==
	assert
	extract 0 32
	frame_bury 0 // result: byte[32]

	// examples/merkle/merkle.algo.ts:19
	// for (let i = 0; i < TREE_DEPTH; i = i + 1)
	intc 2 // 0
	frame_bury 1 // i: uint64

*for_0:
	// examples/merkle/merkle.algo.ts:19
	// i < TREE_DEPTH
	frame_dig 1 // i: uint64
	intc 4 // 3
	<
	bz *for_0_end

	// examples/merkle/merkle.algo.ts:20
	// result = sha256(result + result)
	frame_dig 0 // result: byte[32]
	frame_dig 0 // result: byte[32]
	concat
	sha256
	frame_bury 0 // result: byte[32]

*for_0_continue:
	// examples/merkle/merkle.algo.ts:19
	// i = i + 1
	frame_dig 1 // i: uint64
	intc 0 // 1
	+
	frame_bury 1 // i: uint64
	b *for_0

*for_0_end:
	// examples/merkle/merkle.algo.ts:23
	// return result;
	frame_dig 0 // result: byte[32]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// hashConcat(left: bytes32, right: bytes32): bytes32
hashConcat:
	proto 2 1

	// examples/merkle/merkle.algo.ts:27
	// return sha256(left + right);
	frame_dig -1 // left: bytes32
	frame_dig -2 // right: bytes32
	concat
	sha256
	retsub

// isRightSibling(elem: Branch): boolean
isRightSibling:
	proto 1 1

	// examples/merkle/merkle.algo.ts:31
	// return getbyte(elem, 0) === RIGHT_SIBLING_PREFIX;
	frame_dig -1 // elem: Branch
	intc 2 // 0
	getbyte
	pushint 170
	==
	retsub

// calcRoot(leaf: bytes32, path: Path): bytes32
calcRoot:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// examples/merkle/merkle.algo.ts:37
	// for (let i = 0; i < TREE_DEPTH; i = i + 1)
	intc 2 // 0
	frame_bury 0 // i: uint64

*for_1:
	// examples/merkle/merkle.algo.ts:37
	// i < TREE_DEPTH
	frame_dig 0 // i: uint64
	intc 4 // 3
	<
	bz *for_1_end
	frame_dig 0 // i: uint64
	frame_bury 1 // accessor: accessor//0//elem

	// *if0_condition
	// examples/merkle/merkle.algo.ts:40
	// this.isRightSibling(elem)
	frame_dig -2 // path: Path
	frame_dig 1 // saved accessor: accessor//0//elem
	intc 1 // 33
	* // acc * typeLength
	intc 1 // 33
	extract3
	callsub isRightSibling
	bz *if0_else

	// *if0_consequent
	// examples/merkle/merkle.algo.ts:41
	// result = this.hashConcat(result, extract3(elem, 1, 32) as bytes32)
	frame_dig -2 // path: Path
	frame_dig 1 // saved accessor: accessor//0//elem
	intc 1 // 33
	* // acc * typeLength
	intc 1 // 33
	extract3
	extract 1 32
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	bytec 0 // 0x
	b==
	assert
	extract 0 32
	frame_dig -1 // leaf: bytes32
	callsub hashConcat
	frame_bury -1 // result: bytes32
	b *if0_end

*if0_else:
	// examples/merkle/merkle.algo.ts:43
	// result = this.hashConcat(extract3(elem, 1, 32) as bytes32, result)
	frame_dig -1 // leaf: bytes32
	frame_dig -2 // path: Path
	frame_dig 1 // saved accessor: accessor//0//elem
	intc 1 // 33
	* // acc * typeLength
	intc 1 // 33
	extract3
	extract 1 32
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	bytec 0 // 0x
	b==
	assert
	extract 0 32
	callsub hashConcat
	frame_bury -1 // result: bytes32

*if0_end:

*for_1_continue:
	// examples/merkle/merkle.algo.ts:37
	// i = i + 1
	frame_dig 0 // i: uint64
	intc 0 // 1
	+
	frame_bury 0 // i: uint64
	b *for_1

*for_1_end:
	// examples/merkle/merkle.algo.ts:47
	// return result;
	frame_dig -1 // leaf: bytes32

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	intc 0 // 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// examples/merkle/merkle.algo.ts:51
	// verifyAppCallTxn(this.txn, { sender: this.app.creator })
	// verify sender
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.app.creator"}
	assert
	retsub

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// examples/merkle/merkle.algo.ts:55
	// this.root.value = this.calcInitRoot()
	bytec 1 //  "root"
	callsub calcInitRoot
	app_global_put
	retsub

// verify(byte[],byte[33][3])void
*abi_route_verify:
	// path: byte[33][3]
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 99
	==

	// argument 0 (path) for verify must be a byte[33][3]
	assert

	// data: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute verify(byte[],byte[33][3])void
	callsub verify
	intc 0 // 1
	return

// verify(data: bytes, path: Path): void
verify:
	proto 2 0

	// examples/merkle/merkle.algo.ts:59
	// assert(this.root.value === this.calcRoot(sha256(data), path))
	bytec 1 //  "root"
	app_global_get
	frame_dig -2 // path: Path
	frame_dig -1 // data: bytes
	sha256
	callsub calcRoot
	==
	assert
	retsub

// appendLeaf(byte[],byte[33][3])void
*abi_route_appendLeaf:
	// path: byte[33][3]
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 99
	==

	// argument 0 (path) for appendLeaf must be a byte[33][3]
	assert

	// data: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute appendLeaf(byte[],byte[33][3])void
	callsub appendLeaf
	intc 0 // 1
	return

// appendLeaf(data: bytes, path: Path): void
appendLeaf:
	proto 2 0

	// examples/merkle/merkle.algo.ts:63
	// assert(data !== '')
	frame_dig -1 // data: bytes
	bytec 0 //  ""
	!=
	assert

	// examples/merkle/merkle.algo.ts:64
	// assert(this.root.value === this.calcRoot(hex(EMPTY_HASH) as bytes32, path))
	bytec 1 //  "root"
	app_global_get
	frame_dig -2 // path: Path
	bytec 2 // 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b8550000000000000000000000000000000000000000000000000000000000000000
	bytec 0 // 0x
	dup
	b==
	assert
	extract 0 32
	callsub calcRoot
	==
	assert

	// examples/merkle/merkle.algo.ts:66
	// this.root.value = this.calcRoot(sha256(data), path)
	bytec 1 //  "root"
	frame_dig -2 // path: Path
	frame_dig -1 // data: bytes
	sha256
	callsub calcRoot
	app_global_put

	// examples/merkle/merkle.algo.ts:68
	// this.size.value = this.size.value + 1
	bytec 4 //  "size"
	dup
	app_global_get
	intc 0 // 1
	+
	app_global_put
	retsub

// updateLeaf(byte[],byte[],byte[33][3])void
*abi_route_updateLeaf:
	// path: byte[33][3]
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 99
	==

	// argument 0 (path) for updateLeaf must be a byte[33][3]
	assert

	// newData: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// oldData: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute updateLeaf(byte[],byte[],byte[33][3])void
	callsub updateLeaf
	intc 0 // 1
	return

// updateLeaf(oldData: bytes, newData: bytes, path: Path): void
updateLeaf:
	proto 3 0

	// examples/merkle/merkle.algo.ts:72
	// assert(newData !== '')
	frame_dig -2 // newData: bytes
	bytec 0 //  ""
	!=
	assert

	// examples/merkle/merkle.algo.ts:73
	// assert(this.root.value === this.calcRoot(sha256(oldData), path))
	bytec 1 //  "root"
	app_global_get
	frame_dig -3 // path: Path
	frame_dig -1 // oldData: bytes
	sha256
	callsub calcRoot
	==
	assert

	// examples/merkle/merkle.algo.ts:75
	// this.root.value = this.calcRoot(sha256(newData), path)
	bytec 1 //  "root"
	frame_dig -3 // path: Path
	frame_dig -2 // newData: bytes
	sha256
	callsub calcRoot
	app_global_put
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x506cb8d8 // method "verify(byte[],byte[33][3])void"
	pushbytes 0x04f63238 // method "appendLeaf(byte[],byte[33][3])void"
	pushbytes 0x255d93e3 // method "updateLeaf(byte[],byte[],byte[33][3])void"
	txna ApplicationArgs 0
	match *abi_route_verify *abi_route_appendLeaf *abi_route_updateLeaf

	// this contract does not implement the given ABI method for call NoOp
	err

*call_DeleteApplication:
	pushbytes 0x2487c32c // method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err"
`;

exports[`Examples MerkleTree Artifacts Maintains program size 1`] = `584`;

exports[`Examples MerkleTree Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "deleteApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "data",
          "type": "byte[]",
        },
        {
          "desc": undefined,
          "name": "path",
          "type": "byte[33][3]",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "verify",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "data",
          "type": "byte[]",
        },
        {
          "desc": undefined,
          "name": "path",
          "type": "byte[33][3]",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "appendLeaf",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "oldData",
          "type": "byte[]",
        },
        {
          "desc": undefined,
          "name": "newData",
          "type": "byte[]",
        },
        {
          "desc": undefined,
          "name": "path",
          "type": "byte[33][3]",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "updateLeaf",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "MerkleTree",
}
`;

exports[`Examples MerkleTree Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "deleteApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "data",
            "type": "byte[]",
          },
          {
            "desc": undefined,
            "name": "path",
            "type": "byte[33][3]",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "verify",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "data",
            "type": "byte[]",
          },
          {
            "desc": undefined,
            "name": "path",
            "type": "byte[33][3]",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "appendLeaf",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "oldData",
            "type": "byte[]",
          },
          {
            "desc": undefined,
            "name": "newData",
            "type": "byte[]",
          },
          {
            "desc": undefined,
            "name": "path",
            "type": "byte[33][3]",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "updateLeaf",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "MerkleTree",
  },
  "hints": {
    "appendLeaf(byte[],byte[33][3])void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "deleteApplication()void": {
      "call_config": {
        "delete_application": "CALL",
      },
    },
    "updateLeaf(byte[],byte[],byte[33][3])void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "verify(byte[],byte[33][3])void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {
        "root": {
          "key": "root",
          "type": "bytes",
        },
        "size": {
          "key": "size",
          "type": "uint64",
        },
      },
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAxIDMzIDAgOTkgMwpieXRlY2Jsb2NrIDB4IDB4NzI2ZjZmNzQgMHhlM2IwYzQ0Mjk4ZmMxYzE0OWFmYmY0Yzg5OTZmYjkyNDI3YWU0MWU0NjQ5YjkzNGNhNDk1OTkxYjc4NTJiODU1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgMHg3MzY5N2E2NQoKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCnB1c2hpbnQgNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggKmNhbGxfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpjYWxsX0RlbGV0ZUFwcGxpY2F0aW9uICpjcmVhdGVfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQKCipOT1RfSU1QTEVNRU5URUQ6CgkvLyBUaGUgcmVxdWVzdGVkIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBjb250cmFjdC4gQXJlIHlvdSB1c2luZyB0aGUgY29ycmVjdCBPbkNvbXBsZXRlPyBEaWQgeW91IHNldCB5b3VyIGFwcCBJRD8KCWVycgoKLy8gY2FsY0luaXRSb290KCk6IGJ5dGVzMzIKY2FsY0luaXRSb290OgoJcHJvdG8gMCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cAoKCS8vIGV4YW1wbGVzL21lcmtsZS9tZXJrbGUuYWxnby50czoxNwoJLy8gcmVzdWx0ID0gaGV4KEVNUFRZX0hBU0gpIGFzIGJ5dGVzMzIKCWJ5dGVjIDIgLy8gMHhlM2IwYzQ0Mjk4ZmMxYzE0OWFmYmY0Yzg5OTZmYjkyNDI3YWU0MWU0NjQ5YjkzNGNhNDk1OTkxYjc4NTJiODU1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJYnl0ZWMgMCAvLyAweAoJZHVwCgliPT0KCWFzc2VydAoJZXh0cmFjdCAwIDMyCglmcmFtZV9idXJ5IDAgLy8gcmVzdWx0OiBieXRlWzMyXQoKCS8vIGV4YW1wbGVzL21lcmtsZS9tZXJrbGUuYWxnby50czoxOQoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBUUkVFX0RFUFRIOyBpID0gaSArIDEpCglpbnRjIDIgLy8gMAoJZnJhbWVfYnVyeSAxIC8vIGk6IHVpbnQ2NAoKKmZvcl8wOgoJLy8gZXhhbXBsZXMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjE5CgkvLyBpIDwgVFJFRV9ERVBUSAoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnRjIDQgLy8gMwoJPAoJYnogKmZvcl8wX2VuZAoKCS8vIGV4YW1wbGVzL21lcmtsZS9tZXJrbGUuYWxnby50czoyMAoJLy8gcmVzdWx0ID0gc2hhMjU2KHJlc3VsdCArIHJlc3VsdCkKCWZyYW1lX2RpZyAwIC8vIHJlc3VsdDogYnl0ZVszMl0KCWZyYW1lX2RpZyAwIC8vIHJlc3VsdDogYnl0ZVszMl0KCWNvbmNhdAoJc2hhMjU2CglmcmFtZV9idXJ5IDAgLy8gcmVzdWx0OiBieXRlWzMyXQoKKmZvcl8wX2NvbnRpbnVlOgoJLy8gZXhhbXBsZXMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjE5CgkvLyBpID0gaSArIDEKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50YyAwIC8vIDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCWIgKmZvcl8wCgoqZm9yXzBfZW5kOgoJLy8gZXhhbXBsZXMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjIzCgkvLyByZXR1cm4gcmVzdWx0OwoJZnJhbWVfZGlnIDAgLy8gcmVzdWx0OiBieXRlWzMyXQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gaGFzaENvbmNhdChsZWZ0OiBieXRlczMyLCByaWdodDogYnl0ZXMzMik6IGJ5dGVzMzIKaGFzaENvbmNhdDoKCXByb3RvIDIgMQoKCS8vIGV4YW1wbGVzL21lcmtsZS9tZXJrbGUuYWxnby50czoyNwoJLy8gcmV0dXJuIHNoYTI1NihsZWZ0ICsgcmlnaHQpOwoJZnJhbWVfZGlnIC0xIC8vIGxlZnQ6IGJ5dGVzMzIKCWZyYW1lX2RpZyAtMiAvLyByaWdodDogYnl0ZXMzMgoJY29uY2F0CglzaGEyNTYKCXJldHN1YgoKLy8gaXNSaWdodFNpYmxpbmcoZWxlbTogQnJhbmNoKTogYm9vbGVhbgppc1JpZ2h0U2libGluZzoKCXByb3RvIDEgMQoKCS8vIGV4YW1wbGVzL21lcmtsZS9tZXJrbGUuYWxnby50czozMQoJLy8gcmV0dXJuIGdldGJ5dGUoZWxlbSwgMCkgPT09IFJJR0hUX1NJQkxJTkdfUFJFRklYOwoJZnJhbWVfZGlnIC0xIC8vIGVsZW06IEJyYW5jaAoJaW50YyAyIC8vIDAKCWdldGJ5dGUKCXB1c2hpbnQgMTcwCgk9PQoJcmV0c3ViCgovLyBjYWxjUm9vdChsZWFmOiBieXRlczMyLCBwYXRoOiBQYXRoKTogYnl0ZXMzMgpjYWxjUm9vdDoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXAKCgkvLyBleGFtcGxlcy9tZXJrbGUvbWVya2xlLmFsZ28udHM6MzcKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgVFJFRV9ERVBUSDsgaSA9IGkgKyAxKQoJaW50YyAyIC8vIDAKCWZyYW1lX2J1cnkgMCAvLyBpOiB1aW50NjQKCipmb3JfMToKCS8vIGV4YW1wbGVzL21lcmtsZS9tZXJrbGUuYWxnby50czozNwoJLy8gaSA8IFRSRUVfREVQVEgKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJaW50YyA0IC8vIDMKCTwKCWJ6ICpmb3JfMV9lbmQKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJZnJhbWVfYnVyeSAxIC8vIGFjY2Vzc29yOiBhY2Nlc3Nvci8vMC8vZWxlbQoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9tZXJrbGUvbWVya2xlLmFsZ28udHM6NDAKCS8vIHRoaXMuaXNSaWdodFNpYmxpbmcoZWxlbSkKCWZyYW1lX2RpZyAtMiAvLyBwYXRoOiBQYXRoCglmcmFtZV9kaWcgMSAvLyBzYXZlZCBhY2Nlc3NvcjogYWNjZXNzb3IvLzAvL2VsZW0KCWludGMgMSAvLyAzMwoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDEgLy8gMzMKCWV4dHJhY3QzCgljYWxsc3ViIGlzUmlnaHRTaWJsaW5nCglieiAqaWYwX2Vsc2UKCgkvLyAqaWYwX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL21lcmtsZS9tZXJrbGUuYWxnby50czo0MQoJLy8gcmVzdWx0ID0gdGhpcy5oYXNoQ29uY2F0KHJlc3VsdCwgZXh0cmFjdDMoZWxlbSwgMSwgMzIpIGFzIGJ5dGVzMzIpCglmcmFtZV9kaWcgLTIgLy8gcGF0aDogUGF0aAoJZnJhbWVfZGlnIDEgLy8gc2F2ZWQgYWNjZXNzb3I6IGFjY2Vzc29yLy8wLy9lbGVtCglpbnRjIDEgLy8gMzMKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAxIC8vIDMzCglleHRyYWN0MwoJZXh0cmFjdCAxIDMyCglieXRlYyAzIC8vIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJY29uY2F0CglkdXAKCWV4dHJhY3QgMzIgMAoJYnl0ZWMgMCAvLyAweAoJYj09Cglhc3NlcnQKCWV4dHJhY3QgMCAzMgoJZnJhbWVfZGlnIC0xIC8vIGxlYWY6IGJ5dGVzMzIKCWNhbGxzdWIgaGFzaENvbmNhdAoJZnJhbWVfYnVyeSAtMSAvLyByZXN1bHQ6IGJ5dGVzMzIKCWIgKmlmMF9lbmQKCippZjBfZWxzZToKCS8vIGV4YW1wbGVzL21lcmtsZS9tZXJrbGUuYWxnby50czo0MwoJLy8gcmVzdWx0ID0gdGhpcy5oYXNoQ29uY2F0KGV4dHJhY3QzKGVsZW0sIDEsIDMyKSBhcyBieXRlczMyLCByZXN1bHQpCglmcmFtZV9kaWcgLTEgLy8gbGVhZjogYnl0ZXMzMgoJZnJhbWVfZGlnIC0yIC8vIHBhdGg6IFBhdGgKCWZyYW1lX2RpZyAxIC8vIHNhdmVkIGFjY2Vzc29yOiBhY2Nlc3Nvci8vMC8vZWxlbQoJaW50YyAxIC8vIDMzCgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMSAvLyAzMwoJZXh0cmFjdDMKCWV4dHJhY3QgMSAzMgoJYnl0ZWMgMyAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJZHVwCglleHRyYWN0IDMyIDAKCWJ5dGVjIDAgLy8gMHgKCWI9PQoJYXNzZXJ0CglleHRyYWN0IDAgMzIKCWNhbGxzdWIgaGFzaENvbmNhdAoJZnJhbWVfYnVyeSAtMSAvLyByZXN1bHQ6IGJ5dGVzMzIKCippZjBfZW5kOgoKKmZvcl8xX2NvbnRpbnVlOgoJLy8gZXhhbXBsZXMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjM3CgkvLyBpID0gaSArIDEKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJaW50YyAwIC8vIDEKCSsKCWZyYW1lX2J1cnkgMCAvLyBpOiB1aW50NjQKCWIgKmZvcl8xCgoqZm9yXzFfZW5kOgoJLy8gZXhhbXBsZXMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjQ3CgkvLyByZXR1cm4gcmVzdWx0OwoJZnJhbWVfZGlnIC0xIC8vIGxlYWY6IGJ5dGVzMzIKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxCglyZXRzdWIKCi8vIGRlbGV0ZUFwcGxpY2F0aW9uKCl2b2lkCiphYmlfcm91dGVfZGVsZXRlQXBwbGljYXRpb246CgkvLyBleGVjdXRlIGRlbGV0ZUFwcGxpY2F0aW9uKCl2b2lkCgljYWxsc3ViIGRlbGV0ZUFwcGxpY2F0aW9uCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBkZWxldGVBcHBsaWNhdGlvbigpOiB2b2lkCmRlbGV0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMCAwCgoJLy8gZXhhbXBsZXMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjUxCgkvLyB2ZXJpZnlBcHBDYWxsVHhuKHRoaXMudHhuLCB7IHNlbmRlcjogdGhpcy5hcHAuY3JlYXRvciB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJdHhuIFNlbmRlcgoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoidGhpcy50eG4iLCJmaWVsZCI6InNlbmRlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuY3JlYXRvciJ9Cglhc3NlcnQKCXJldHN1YgoKLy8gY3JlYXRlQXBwbGljYXRpb24oKXZvaWQKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCS8vIGV4ZWN1dGUgY3JlYXRlQXBwbGljYXRpb24oKXZvaWQKCWNhbGxzdWIgY3JlYXRlQXBwbGljYXRpb24KCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKCk6IHZvaWQKY3JlYXRlQXBwbGljYXRpb246Cglwcm90byAwIDAKCgkvLyBleGFtcGxlcy9tZXJrbGUvbWVya2xlLmFsZ28udHM6NTUKCS8vIHRoaXMucm9vdC52YWx1ZSA9IHRoaXMuY2FsY0luaXRSb290KCkKCWJ5dGVjIDEgLy8gICJyb290IgoJY2FsbHN1YiBjYWxjSW5pdFJvb3QKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIHZlcmlmeShieXRlW10sYnl0ZVszM11bM10pdm9pZAoqYWJpX3JvdXRlX3ZlcmlmeToKCS8vIHBhdGg6IGJ5dGVbMzNdWzNdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAzIC8vIDk5Cgk9PQoKCS8vIGFyZ3VtZW50IDAgKHBhdGgpIGZvciB2ZXJpZnkgbXVzdCBiZSBhIGJ5dGVbMzNdWzNdCglhc3NlcnQKCgkvLyBkYXRhOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSB2ZXJpZnkoYnl0ZVtdLGJ5dGVbMzNdWzNdKXZvaWQKCWNhbGxzdWIgdmVyaWZ5CglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyB2ZXJpZnkoZGF0YTogYnl0ZXMsIHBhdGg6IFBhdGgpOiB2b2lkCnZlcmlmeToKCXByb3RvIDIgMAoKCS8vIGV4YW1wbGVzL21lcmtsZS9tZXJrbGUuYWxnby50czo1OQoJLy8gYXNzZXJ0KHRoaXMucm9vdC52YWx1ZSA9PT0gdGhpcy5jYWxjUm9vdChzaGEyNTYoZGF0YSksIHBhdGgpKQoJYnl0ZWMgMSAvLyAgInJvb3QiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0yIC8vIHBhdGg6IFBhdGgKCWZyYW1lX2RpZyAtMSAvLyBkYXRhOiBieXRlcwoJc2hhMjU2CgljYWxsc3ViIGNhbGNSb290Cgk9PQoJYXNzZXJ0CglyZXRzdWIKCi8vIGFwcGVuZExlYWYoYnl0ZVtdLGJ5dGVbMzNdWzNdKXZvaWQKKmFiaV9yb3V0ZV9hcHBlbmRMZWFmOgoJLy8gcGF0aDogYnl0ZVszM11bM10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDMgLy8gOTkKCT09CgoJLy8gYXJndW1lbnQgMCAocGF0aCkgZm9yIGFwcGVuZExlYWYgbXVzdCBiZSBhIGJ5dGVbMzNdWzNdCglhc3NlcnQKCgkvLyBkYXRhOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBhcHBlbmRMZWFmKGJ5dGVbXSxieXRlWzMzXVszXSl2b2lkCgljYWxsc3ViIGFwcGVuZExlYWYKCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGFwcGVuZExlYWYoZGF0YTogYnl0ZXMsIHBhdGg6IFBhdGgpOiB2b2lkCmFwcGVuZExlYWY6Cglwcm90byAyIDAKCgkvLyBleGFtcGxlcy9tZXJrbGUvbWVya2xlLmFsZ28udHM6NjMKCS8vIGFzc2VydChkYXRhICE9PSAnJykKCWZyYW1lX2RpZyAtMSAvLyBkYXRhOiBieXRlcwoJYnl0ZWMgMCAvLyAgIiIKCSE9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9tZXJrbGUvbWVya2xlLmFsZ28udHM6NjQKCS8vIGFzc2VydCh0aGlzLnJvb3QudmFsdWUgPT09IHRoaXMuY2FsY1Jvb3QoaGV4KEVNUFRZX0hBU0gpIGFzIGJ5dGVzMzIsIHBhdGgpKQoJYnl0ZWMgMSAvLyAgInJvb3QiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0yIC8vIHBhdGg6IFBhdGgKCWJ5dGVjIDIgLy8gMHhlM2IwYzQ0Mjk4ZmMxYzE0OWFmYmY0Yzg5OTZmYjkyNDI3YWU0MWU0NjQ5YjkzNGNhNDk1OTkxYjc4NTJiODU1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJYnl0ZWMgMCAvLyAweAoJZHVwCgliPT0KCWFzc2VydAoJZXh0cmFjdCAwIDMyCgljYWxsc3ViIGNhbGNSb290Cgk9PQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjY2CgkvLyB0aGlzLnJvb3QudmFsdWUgPSB0aGlzLmNhbGNSb290KHNoYTI1NihkYXRhKSwgcGF0aCkKCWJ5dGVjIDEgLy8gICJyb290IgoJZnJhbWVfZGlnIC0yIC8vIHBhdGg6IFBhdGgKCWZyYW1lX2RpZyAtMSAvLyBkYXRhOiBieXRlcwoJc2hhMjU2CgljYWxsc3ViIGNhbGNSb290CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL21lcmtsZS9tZXJrbGUuYWxnby50czo2OAoJLy8gdGhpcy5zaXplLnZhbHVlID0gdGhpcy5zaXplLnZhbHVlICsgMQoJYnl0ZWMgNCAvLyAgInNpemUiCglkdXAKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDAgLy8gMQoJKwoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gdXBkYXRlTGVhZihieXRlW10sYnl0ZVtdLGJ5dGVbMzNdWzNdKXZvaWQKKmFiaV9yb3V0ZV91cGRhdGVMZWFmOgoJLy8gcGF0aDogYnl0ZVszM11bM10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnRjIDMgLy8gOTkKCT09CgoJLy8gYXJndW1lbnQgMCAocGF0aCkgZm9yIHVwZGF0ZUxlYWYgbXVzdCBiZSBhIGJ5dGVbMzNdWzNdCglhc3NlcnQKCgkvLyBuZXdEYXRhOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWV4dHJhY3QgMiAwCgoJLy8gb2xkRGF0YTogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgdXBkYXRlTGVhZihieXRlW10sYnl0ZVtdLGJ5dGVbMzNdWzNdKXZvaWQKCWNhbGxzdWIgdXBkYXRlTGVhZgoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gdXBkYXRlTGVhZihvbGREYXRhOiBieXRlcywgbmV3RGF0YTogYnl0ZXMsIHBhdGg6IFBhdGgpOiB2b2lkCnVwZGF0ZUxlYWY6Cglwcm90byAzIDAKCgkvLyBleGFtcGxlcy9tZXJrbGUvbWVya2xlLmFsZ28udHM6NzIKCS8vIGFzc2VydChuZXdEYXRhICE9PSAnJykKCWZyYW1lX2RpZyAtMiAvLyBuZXdEYXRhOiBieXRlcwoJYnl0ZWMgMCAvLyAgIiIKCSE9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9tZXJrbGUvbWVya2xlLmFsZ28udHM6NzMKCS8vIGFzc2VydCh0aGlzLnJvb3QudmFsdWUgPT09IHRoaXMuY2FsY1Jvb3Qoc2hhMjU2KG9sZERhdGEpLCBwYXRoKSkKCWJ5dGVjIDEgLy8gICJyb290IgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMyAvLyBwYXRoOiBQYXRoCglmcmFtZV9kaWcgLTEgLy8gb2xkRGF0YTogYnl0ZXMKCXNoYTI1NgoJY2FsbHN1YiBjYWxjUm9vdAoJPT0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL21lcmtsZS9tZXJrbGUuYWxnby50czo3NQoJLy8gdGhpcy5yb290LnZhbHVlID0gdGhpcy5jYWxjUm9vdChzaGEyNTYobmV3RGF0YSksIHBhdGgpCglieXRlYyAxIC8vICAicm9vdCIKCWZyYW1lX2RpZyAtMyAvLyBwYXRoOiBQYXRoCglmcmFtZV9kaWcgLTIgLy8gbmV3RGF0YTogYnl0ZXMKCXNoYTI1NgoJY2FsbHN1YiBjYWxjUm9vdAoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKKmNyZWF0ZV9Ob09wOgoJcHVzaGJ5dGVzIDB4Yjg0NDdiMzYgLy8gbWV0aG9kICJjcmVhdGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY3JlYXRlIE5vT3AKCWVycgoKKmNhbGxfTm9PcDoKCXB1c2hieXRlcyAweDUwNmNiOGQ4IC8vIG1ldGhvZCAidmVyaWZ5KGJ5dGVbXSxieXRlWzMzXVszXSl2b2lkIgoJcHVzaGJ5dGVzIDB4MDRmNjMyMzggLy8gbWV0aG9kICJhcHBlbmRMZWFmKGJ5dGVbXSxieXRlWzMzXVszXSl2b2lkIgoJcHVzaGJ5dGVzIDB4MjU1ZDkzZTMgLy8gbWV0aG9kICJ1cGRhdGVMZWFmKGJ5dGVbXSxieXRlW10sYnl0ZVszM11bM10pdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfdmVyaWZ5ICphYmlfcm91dGVfYXBwZW5kTGVhZiAqYWJpX3JvdXRlX3VwZGF0ZUxlYWYKCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBOb09wCgllcnIKCipjYWxsX0RlbGV0ZUFwcGxpY2F0aW9uOgoJcHVzaGJ5dGVzIDB4MjQ4N2MzMmMgLy8gbWV0aG9kICJkZWxldGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfZGVsZXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBEZWxldGVBcHBsaWNhdGlvbgoJZXJy",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 1,
      "num_uints": 1,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples NonABIExample Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 1
bytecblock 0x

// https://github.com/algorandfoundation/TEALScript

// !!!! WARNING: This contract is *NOT* ARC4 compliant. It may contain ABI methods, but it also allows app calls where the first argument does NOT match an ABI selector

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// add(x: uint64, y: uint64): uint64
add:
	proto 2 1

	// examples/non_abi/non_abi.algo.ts:6
	// return x + y;
	frame_dig -1 // x: uint64
	frame_dig -2 // y: uint64
	+
	retsub

// abiAdd(uint64,uint64)uint64
*abi_route_abiAdd:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// y: uint64
	txna ApplicationArgs 2
	btoi

	// x: uint64
	txna ApplicationArgs 1
	btoi

	// execute abiAdd(uint64,uint64)uint64
	callsub abiAdd
	itob
	concat
	log
	intc 0 // 1
	return

// abiAdd(x: uint64, y: uint64): uint64
abiAdd:
	proto 2 1

	// examples/non_abi/non_abi.algo.ts:10
	// return this.add(x, y);
	frame_dig -2 // y: uint64
	frame_dig -1 // x: uint64
	callsub add
	retsub

// nonAbiAdd(): void
nonAbiAdd:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// examples/non_abi/non_abi.algo.ts:15
	// x = btoi(this.txn.applicationArgs![0])
	txn ApplicationArgs 0
	btoi
	frame_bury 0 // x: uint64

	// examples/non_abi/non_abi.algo.ts:16
	// y = btoi(this.txn.applicationArgs![1])
	txn ApplicationArgs 1
	btoi
	frame_bury 1 // y: uint64

	// examples/non_abi/non_abi.algo.ts:17
	// log(itob(this.add(x, y)))
	frame_dig 1 // y: uint64
	frame_dig 0 // x: uint64
	callsub add
	itob
	log
	retsub

// nonAbiUpdate(): void
nonAbiUpdate:
	proto 0 0

	// examples/non_abi/non_abi.algo.ts:22
	// log('Updated!')
	pushbytes 0x5570646174656421 // "Updated!"
	log
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xb8b84484 // method "abiAdd(uint64,uint64)uint64"
	txna ApplicationArgs 0
	match *abi_route_abiAdd

	// !!!! WARNING: non-ABI routing
	callsub nonAbiAdd
	intc 0 // 1
	return

*call_UpdateApplication:
	// !!!! WARNING: non-ABI routing
	callsub nonAbiUpdate
	intc 0 // 1
	return"
`;

exports[`Examples NonABIExample Artifacts Maintains program size 1`] = `166`;

exports[`Examples NonABIExample Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [
        {
          "desc": undefined,
          "name": "x",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "y",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "abiAdd",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "uint64",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "NonABIExample",
}
`;

exports[`Examples NonABIExample Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [
          {
            "desc": undefined,
            "name": "x",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "y",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "abiAdd",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "uint64",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "NonABIExample",
  },
  "hints": {
    "abiAdd(uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {},
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAxCmJ5dGVjYmxvY2sgMHgKCi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZGZvdW5kYXRpb24vVEVBTFNjcmlwdAoKLy8gISEhISBXQVJOSU5HOiBUaGlzIGNvbnRyYWN0IGlzICpOT1QqIEFSQzQgY29tcGxpYW50LiBJdCBtYXkgY29udGFpbiBBQkkgbWV0aG9kcywgYnV0IGl0IGFsc28gYWxsb3dzIGFwcCBjYWxscyB3aGVyZSB0aGUgZmlyc3QgYXJndW1lbnQgZG9lcyBOT1QgbWF0Y2ggYW4gQUJJIHNlbGVjdG9yCgovLyBUaGUgZm9sbG93aW5nIHRlbiBsaW5lcyBvZiBURUFMIGhhbmRsZSBpbml0aWFsIHByb2dyYW0gZmxvdwovLyBUaGlzIHBhdHRlcm4gaXMgdXNlZCB0byBtYWtlIGl0IGVhc3kgZm9yIGFueW9uZSB0byBwYXJzZSB0aGUgc3RhcnQgb2YgdGhlIHByb2dyYW0gYW5kIGRldGVybWluZSBpZiBhIHNwZWNpZmljIGFjdGlvbiBpcyBhbGxvd2VkCi8vIEhlcmUsIGFjdGlvbiByZWZlcnMgdG8gdGhlIE9uQ29tcGxldGUgaW4gY29tYmluYXRpb24gd2l0aCB3aGV0aGVyIHRoZSBhcHAgaXMgYmVpbmcgY3JlYXRlZCBvciBjYWxsZWQKLy8gRXZlcnkgcG9zc2libGUgYWN0aW9uIGZvciB0aGlzIGNvbnRyYWN0IGlzIHJlcHJlc2VudGVkIGluIHRoZSBzd2l0Y2ggc3RhdGVtZW50Ci8vIElmIHRoZSBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBjb250cmFjdCwgaXRzIHJlc3BlY3RpdmUgYnJhbmNoIHdpbGwgYmUgIipOT1RfSU1QTEVNRU5URUQiIHdoaWNoIGp1c3QgY29udGFpbnMgImVyciIKdHhuIEFwcGxpY2F0aW9uSUQKIQpwdXNoaW50IDYKKgp0eG4gT25Db21wbGV0aW9uCisKc3dpdGNoICpjYWxsX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKmNhbGxfVXBkYXRlQXBwbGljYXRpb24gKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJLy8gVGhlIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udHJhY3QuIEFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgT25Db21wbGV0ZT8gRGlkIHlvdSBzZXQgeW91ciBhcHAgSUQ/CgllcnIKCi8vIGFkZCh4OiB1aW50NjQsIHk6IHVpbnQ2NCk6IHVpbnQ2NAphZGQ6Cglwcm90byAyIDEKCgkvLyBleGFtcGxlcy9ub25fYWJpL25vbl9hYmkuYWxnby50czo2CgkvLyByZXR1cm4geCArIHk7CglmcmFtZV9kaWcgLTEgLy8geDogdWludDY0CglmcmFtZV9kaWcgLTIgLy8geTogdWludDY0CgkrCglyZXRzdWIKCi8vIGFiaUFkZCh1aW50NjQsdWludDY0KXVpbnQ2NAoqYWJpX3JvdXRlX2FiaUFkZDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJcHVzaGJ5dGVzIDB4MTUxZjdjNzUKCgkvLyB5OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyB4OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGFiaUFkZCh1aW50NjQsdWludDY0KXVpbnQ2NAoJY2FsbHN1YiBhYmlBZGQKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBhYmlBZGQoeDogdWludDY0LCB5OiB1aW50NjQpOiB1aW50NjQKYWJpQWRkOgoJcHJvdG8gMiAxCgoJLy8gZXhhbXBsZXMvbm9uX2FiaS9ub25fYWJpLmFsZ28udHM6MTAKCS8vIHJldHVybiB0aGlzLmFkZCh4LCB5KTsKCWZyYW1lX2RpZyAtMiAvLyB5OiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyB4OiB1aW50NjQKCWNhbGxzdWIgYWRkCglyZXRzdWIKCi8vIG5vbkFiaUFkZCgpOiB2b2lkCm5vbkFiaUFkZDoKCXByb3RvIDAgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXAKCgkvLyBleGFtcGxlcy9ub25fYWJpL25vbl9hYmkuYWxnby50czoxNQoJLy8geCA9IGJ0b2kodGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVswXSkKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMAoJYnRvaQoJZnJhbWVfYnVyeSAwIC8vIHg6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL25vbl9hYmkvbm9uX2FiaS5hbGdvLnRzOjE2CgkvLyB5ID0gYnRvaSh0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzFdKQoJdHhuIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCglmcmFtZV9idXJ5IDEgLy8geTogdWludDY0CgoJLy8gZXhhbXBsZXMvbm9uX2FiaS9ub25fYWJpLmFsZ28udHM6MTcKCS8vIGxvZyhpdG9iKHRoaXMuYWRkKHgsIHkpKSkKCWZyYW1lX2RpZyAxIC8vIHk6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8geDogdWludDY0CgljYWxsc3ViIGFkZAoJaXRvYgoJbG9nCglyZXRzdWIKCi8vIG5vbkFiaVVwZGF0ZSgpOiB2b2lkCm5vbkFiaVVwZGF0ZToKCXByb3RvIDAgMAoKCS8vIGV4YW1wbGVzL25vbl9hYmkvbm9uX2FiaS5hbGdvLnRzOjIyCgkvLyBsb2coJ1VwZGF0ZWQhJykKCXB1c2hieXRlcyAweDU1NzA2NDYxNzQ2NTY0MjEgLy8gIlVwZGF0ZWQhIgoJbG9nCglyZXRzdWIKCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CglpbnRjIDAgLy8gMQoJcmV0dXJuCgoqY3JlYXRlX05vT3A6CglwdXNoYnl0ZXMgMHhiODQ0N2IzNiAvLyBtZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjcmVhdGUgTm9PcAoJZXJyCgoqY2FsbF9Ob09wOgoJcHVzaGJ5dGVzIDB4YjhiODQ0ODQgLy8gbWV0aG9kICJhYmlBZGQodWludDY0LHVpbnQ2NCl1aW50NjQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2FiaUFkZAoKCS8vICEhISEgV0FSTklORzogbm9uLUFCSSByb3V0aW5nCgljYWxsc3ViIG5vbkFiaUFkZAoJaW50YyAwIC8vIDEKCXJldHVybgoKKmNhbGxfVXBkYXRlQXBwbGljYXRpb246CgkvLyAhISEhIFdBUk5JTkc6IG5vbi1BQkkgcm91dGluZwoJY2FsbHN1YiBub25BYmlVcGRhdGUKCWludGMgMCAvLyAxCglyZXR1cm4=",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples Simple Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 32 1 256
bytecblock 0x636f756e746572 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0x151f7c75

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// incrementCounter(i: uint64): void
incrementCounter:
	proto 1 0

	// examples/simple/simple.algo.ts:7
	// this.counter.value = this.counter.value + i
	bytec 0 //  "counter"
	dup
	app_global_get
	frame_dig -1 // i: uint64
	+
	app_global_put
	retsub

// incr(uint64)void
*abi_route_incr:
	// i: uint64
	txna ApplicationArgs 1
	btoi

	// execute incr(uint64)void
	callsub incr
	intc 1 // 1
	return

// incr(i: uint64): void
incr:
	proto 1 0

	// examples/simple/simple.algo.ts:11
	// this.incrementCounter(i)
	frame_dig -1 // i: uint64
	callsub incrementCounter
	retsub

// decr(uint64)void
*abi_route_decr:
	// i: uint64
	txna ApplicationArgs 1
	btoi

	// execute decr(uint64)void
	callsub decr
	intc 1 // 1
	return

// decr(i: uint64): void
decr:
	proto 1 0

	// examples/simple/simple.algo.ts:15
	// this.counter.value = this.counter.value - i
	bytec 0 //  "counter"
	dup
	app_global_get
	frame_dig -1 // i: uint64
	-
	app_global_put
	retsub

// add(uint256,uint256)uint256
*abi_route_add:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 0 (b) for add must be a uint256
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 1 (a) for add must be a uint256
	assert

	// execute add(uint256,uint256)uint256
	callsub add
	dup
	bitlen
	intc 2 // 256
	<=

	// add return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 1 // 1
	return

// add(a: uint256, b: uint256): uint256
add:
	proto 2 1

	// examples/simple/simple.algo.ts:19
	// return a + b;
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b+
	retsub

// sub(uint256,uint256)uint256
*abi_route_sub:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 0 (b) for sub must be a uint256
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 1 (a) for sub must be a uint256
	assert

	// execute sub(uint256,uint256)uint256
	callsub sub
	dup
	bitlen
	intc 2 // 256
	<=

	// sub return value overflowed 256 bits
	assert
	bytec 1 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 1 // 1
	return

// sub(a: uint256, b: uint256): uint256
sub:
	proto 2 1

	// examples/simple/simple.algo.ts:23
	// return a - b;
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b-
	retsub

*abi_route_createApplication:
	intc 1 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x9fab8610 // method "incr(uint64)void"
	pushbytes 0x2e0c5a47 // method "decr(uint64)void"
	pushbytes 0xac976e02 // method "add(uint256,uint256)uint256"
	pushbytes 0x091b32a7 // method "sub(uint256,uint256)uint256"
	txna ApplicationArgs 0
	match *abi_route_incr *abi_route_decr *abi_route_add *abi_route_sub

	// this contract does not implement the given ABI method for call NoOp
	err"
`;

exports[`Examples Simple Artifacts Maintains program size 1`] = `288`;

exports[`Examples Simple Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [
        {
          "desc": undefined,
          "name": "i",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "incr",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "i",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "decr",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "a",
          "type": "uint256",
        },
        {
          "desc": undefined,
          "name": "b",
          "type": "uint256",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "add",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "uint256",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "a",
          "type": "uint256",
        },
        {
          "desc": undefined,
          "name": "b",
          "type": "uint256",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "sub",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "uint256",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "Simple",
}
`;

exports[`Examples Simple Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [
          {
            "desc": undefined,
            "name": "i",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "incr",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "i",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "decr",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "a",
            "type": "uint256",
          },
          {
            "desc": undefined,
            "name": "b",
            "type": "uint256",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "add",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "uint256",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "a",
            "type": "uint256",
          },
          {
            "desc": undefined,
            "name": "b",
            "type": "uint256",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "sub",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "uint256",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "Simple",
  },
  "hints": {
    "add(uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "decr(uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "incr(uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "sub(uint256,uint256)uint256": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {
        "counter": {
          "key": "counter",
          "type": "uint64",
        },
      },
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAzMiAxIDI1NgpieXRlY2Jsb2NrIDB4NjM2Zjc1NmU3NDY1NzIgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGIDB4MTUxZjdjNzUKCi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZGZvdW5kYXRpb24vVEVBTFNjcmlwdAoKLy8gVGhpcyBjb250cmFjdCBpcyBjb21wbGlhbnQgd2l0aCBhbmQvb3IgaW1wbGVtZW50cyB0aGUgZm9sbG93aW5nIEFSQ3M6IFsgQVJDNCBdCgovLyBUaGUgZm9sbG93aW5nIHRlbiBsaW5lcyBvZiBURUFMIGhhbmRsZSBpbml0aWFsIHByb2dyYW0gZmxvdwovLyBUaGlzIHBhdHRlcm4gaXMgdXNlZCB0byBtYWtlIGl0IGVhc3kgZm9yIGFueW9uZSB0byBwYXJzZSB0aGUgc3RhcnQgb2YgdGhlIHByb2dyYW0gYW5kIGRldGVybWluZSBpZiBhIHNwZWNpZmljIGFjdGlvbiBpcyBhbGxvd2VkCi8vIEhlcmUsIGFjdGlvbiByZWZlcnMgdG8gdGhlIE9uQ29tcGxldGUgaW4gY29tYmluYXRpb24gd2l0aCB3aGV0aGVyIHRoZSBhcHAgaXMgYmVpbmcgY3JlYXRlZCBvciBjYWxsZWQKLy8gRXZlcnkgcG9zc2libGUgYWN0aW9uIGZvciB0aGlzIGNvbnRyYWN0IGlzIHJlcHJlc2VudGVkIGluIHRoZSBzd2l0Y2ggc3RhdGVtZW50Ci8vIElmIHRoZSBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBjb250cmFjdCwgaXRzIHJlc3BlY3RpdmUgYnJhbmNoIHdpbGwgYmUgIipOT1RfSU1QTEVNRU5URUQiIHdoaWNoIGp1c3QgY29udGFpbnMgImVyciIKdHhuIEFwcGxpY2F0aW9uSUQKIQpwdXNoaW50IDYKKgp0eG4gT25Db21wbGV0aW9uCisKc3dpdGNoICpjYWxsX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpjcmVhdGVfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQKCipOT1RfSU1QTEVNRU5URUQ6CgkvLyBUaGUgcmVxdWVzdGVkIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBjb250cmFjdC4gQXJlIHlvdSB1c2luZyB0aGUgY29ycmVjdCBPbkNvbXBsZXRlPyBEaWQgeW91IHNldCB5b3VyIGFwcCBJRD8KCWVycgoKLy8gaW5jcmVtZW50Q291bnRlcihpOiB1aW50NjQpOiB2b2lkCmluY3JlbWVudENvdW50ZXI6Cglwcm90byAxIDAKCgkvLyBleGFtcGxlcy9zaW1wbGUvc2ltcGxlLmFsZ28udHM6NwoJLy8gdGhpcy5jb3VudGVyLnZhbHVlID0gdGhpcy5jb3VudGVyLnZhbHVlICsgaQoJYnl0ZWMgMCAvLyAgImNvdW50ZXIiCglkdXAKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgLTEgLy8gaTogdWludDY0CgkrCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBpbmNyKHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfaW5jcjoKCS8vIGk6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgaW5jcih1aW50NjQpdm9pZAoJY2FsbHN1YiBpbmNyCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBpbmNyKGk6IHVpbnQ2NCk6IHZvaWQKaW5jcjoKCXByb3RvIDEgMAoKCS8vIGV4YW1wbGVzL3NpbXBsZS9zaW1wbGUuYWxnby50czoxMQoJLy8gdGhpcy5pbmNyZW1lbnRDb3VudGVyKGkpCglmcmFtZV9kaWcgLTEgLy8gaTogdWludDY0CgljYWxsc3ViIGluY3JlbWVudENvdW50ZXIKCXJldHN1YgoKLy8gZGVjcih1aW50NjQpdm9pZAoqYWJpX3JvdXRlX2RlY3I6CgkvLyBpOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGRlY3IodWludDY0KXZvaWQKCWNhbGxzdWIgZGVjcgoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZGVjcihpOiB1aW50NjQpOiB2b2lkCmRlY3I6Cglwcm90byAxIDAKCgkvLyBleGFtcGxlcy9zaW1wbGUvc2ltcGxlLmFsZ28udHM6MTUKCS8vIHRoaXMuY291bnRlci52YWx1ZSA9IHRoaXMuY291bnRlci52YWx1ZSAtIGkKCWJ5dGVjIDAgLy8gICJjb3VudGVyIgoJZHVwCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0xIC8vIGk6IHVpbnQ2NAoJLQoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gYWRkKHVpbnQyNTYsdWludDI1Nil1aW50MjU2CiphYmlfcm91dGVfYWRkOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyBiOiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAwIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGIpIGZvciBhZGQgbXVzdCBiZSBhIHVpbnQyNTYKCWFzc2VydAoKCS8vIGE6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDAgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMSAoYSkgZm9yIGFkZCBtdXN0IGJlIGEgdWludDI1NgoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBhZGQodWludDI1Nix1aW50MjU2KXVpbnQyNTYKCWNhbGxzdWIgYWRkCglkdXAKCWJpdGxlbgoJaW50YyAyIC8vIDI1NgoJPD0KCgkvLyBhZGQgcmV0dXJuIHZhbHVlIG92ZXJmbG93ZWQgMjU2IGJpdHMKCWFzc2VydAoJYnl0ZWMgMSAvLyAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnRjIDAgLy8gMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBhZGQoYTogdWludDI1NiwgYjogdWludDI1Nik6IHVpbnQyNTYKYWRkOgoJcHJvdG8gMiAxCgoJLy8gZXhhbXBsZXMvc2ltcGxlL3NpbXBsZS5hbGdvLnRzOjE5CgkvLyByZXR1cm4gYSArIGI7CglmcmFtZV9kaWcgLTEgLy8gYTogdWludDI1NgoJZnJhbWVfZGlnIC0yIC8vIGI6IHVpbnQyNTYKCWIrCglyZXRzdWIKCi8vIHN1Yih1aW50MjU2LHVpbnQyNTYpdWludDI1NgoqYWJpX3JvdXRlX3N1YjoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gYjogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMCAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChiKSBmb3Igc3ViIG11c3QgYmUgYSB1aW50MjU2Cglhc3NlcnQKCgkvLyBhOiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50YyAwIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDEgKGEpIGZvciBzdWIgbXVzdCBiZSBhIHVpbnQyNTYKCWFzc2VydAoKCS8vIGV4ZWN1dGUgc3ViKHVpbnQyNTYsdWludDI1Nil1aW50MjU2CgljYWxsc3ViIHN1YgoJZHVwCgliaXRsZW4KCWludGMgMiAvLyAyNTYKCTw9CgoJLy8gc3ViIHJldHVybiB2YWx1ZSBvdmVyZmxvd2VkIDI1NiBiaXRzCglhc3NlcnQKCWJ5dGVjIDEgLy8gMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50YyAwIC8vIDMyCgktCglzd2FwCglzdWJzdHJpbmczCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gc3ViKGE6IHVpbnQyNTYsIGI6IHVpbnQyNTYpOiB1aW50MjU2CnN1YjoKCXByb3RvIDIgMQoKCS8vIGV4YW1wbGVzL3NpbXBsZS9zaW1wbGUuYWxnby50czoyMwoJLy8gcmV0dXJuIGEgLSBiOwoJZnJhbWVfZGlnIC0xIC8vIGE6IHVpbnQyNTYKCWZyYW1lX2RpZyAtMiAvLyBiOiB1aW50MjU2CgliLQoJcmV0c3ViCgoqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uOgoJaW50YyAxIC8vIDEKCXJldHVybgoKKmNyZWF0ZV9Ob09wOgoJcHVzaGJ5dGVzIDB4Yjg0NDdiMzYgLy8gbWV0aG9kICJjcmVhdGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY3JlYXRlIE5vT3AKCWVycgoKKmNhbGxfTm9PcDoKCXB1c2hieXRlcyAweDlmYWI4NjEwIC8vIG1ldGhvZCAiaW5jcih1aW50NjQpdm9pZCIKCXB1c2hieXRlcyAweDJlMGM1YTQ3IC8vIG1ldGhvZCAiZGVjcih1aW50NjQpdm9pZCIKCXB1c2hieXRlcyAweGFjOTc2ZTAyIC8vIG1ldGhvZCAiYWRkKHVpbnQyNTYsdWludDI1Nil1aW50MjU2IgoJcHVzaGJ5dGVzIDB4MDkxYjMyYTcgLy8gbWV0aG9kICJzdWIodWludDI1Nix1aW50MjU2KXVpbnQyNTYiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2luY3IgKmFiaV9yb3V0ZV9kZWNyICphYmlfcm91dGVfYWRkICphYmlfcm91dGVfc3ViCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNhbGwgTm9PcAoJZXJy",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBleGFtcGxlcy9zaW1wbGUvc2ltcGxlLmFsZ28udHM6MjcKLy8gdGhpcy5pbmNyZW1lbnRDb3VudGVyKDEpCmludGNibG9jayAxCmJ5dGVjYmxvY2sgMHg2MzZmNzU2ZTc0NjU3MgppbnRjIDAgLy8gMQpjYWxsc3ViIGluY3JlbWVudENvdW50ZXIKaW50YyAwIC8vIDEKcmV0dXJuCgovLyBpbmNyZW1lbnRDb3VudGVyKGk6IHVpbnQ2NCk6IHZvaWQKaW5jcmVtZW50Q291bnRlcjoKCXByb3RvIDEgMAoKCS8vIGV4YW1wbGVzL3NpbXBsZS9zaW1wbGUuYWxnby50czo3CgkvLyB0aGlzLmNvdW50ZXIudmFsdWUgPSB0aGlzLmNvdW50ZXIudmFsdWUgKyBpCglieXRlYyAwIC8vICAiY291bnRlciIKCWR1cAoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMSAvLyBpOiB1aW50NjQKCSsKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWI=",
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 1,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples ContactsApp Artifacts Generates TEAL 1`] = `
"#pragma version 10
intcblock 1 0 2 32
bytecblock 0x 0x0004

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// setMyContact(string,string)void
*abi_route_setMyContact:
	// company: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute setMyContact(string,string)void
	callsub setMyContact
	intc 0 // 1
	return

// setMyContact(name: string, company: string): void
setMyContact:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/tuple_in_box/app.algo.ts:12
	// contact: Contact = { name: name, company: company }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 1 //  initial head offset
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -2 // company: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // contact: Contact

	// examples/tuple_in_box/app.algo.ts:14
	// this.myContact.value = contact
	pushbytes 0x6d79436f6e74616374 // "myContact"
	frame_dig 0 // contact: Contact
	app_global_put

	// examples/tuple_in_box/app.algo.ts:15
	// this.contacts(this.txn.sender).value = contact
	txn Sender
	dup
	box_del
	pop
	frame_dig 0 // contact: Contact
	box_put
	retsub

// addContact(string,string,address)void
*abi_route_addContact:
	// address: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for addContact must be a address
	assert

	// company: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute addContact(string,string,address)void
	callsub addContact
	intc 0 // 1
	return

// addContact(name: string, company: string, address: Address): void
addContact:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/tuple_in_box/app.algo.ts:19
	// contact: Contact = { name: name, company: company }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 1 //  initial head offset
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -2 // company: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // contact: Contact

	// examples/tuple_in_box/app.algo.ts:20
	// this.contacts(address).value = contact
	frame_dig -3 // address: Address
	dup
	box_del
	pop
	frame_dig 0 // contact: Contact
	box_put
	retsub

// updateContactField(string,string,address)void
*abi_route_updateContactField:
	// address: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for updateContactField must be a address
	assert

	// value: string
	txna ApplicationArgs 2
	extract 2 0

	// field: string
	txna ApplicationArgs 1
	extract 2 0

	// execute updateContactField(string,string,address)void
	callsub updateContactField
	intc 0 // 1
	return

// updateContactField(field: string, value: string, address: Address): void
updateContactField:
	proto 3 0

	// *if0_condition
	// examples/tuple_in_box/app.algo.ts:24
	// field === 'name'
	frame_dig -1 // field: string
	pushbytes 0x6e616d65 // "name"
	==
	bz *if0_elseif1_condition

	// *if0_consequent
	// examples/tuple_in_box/app.algo.ts:25
	// this.contacts(address).value.name = value
	frame_dig -3 // address: Address
	box_get

	// box value does not exist: this.contacts(address).value
	assert
	store 255 // full array
	intc 1 // 0
	dup
	store 251 // element head offset
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup
	store 254 // element start
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 0 //  get type length
	* // multiply by type length
	intc 2 // 2
	+ // add two for length
	store 253 // element length
	load 255 // full array
	intc 1 // 0
	load 254 // element start
	substring3
	frame_dig -2 // value: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	store 252 // new element
	load 255 // full array
	load 254 // element start
	load 253 // element length
	+ // get end of Element
	load 255 // full array
	len
	substring3
	concat
	concat
	store 255 // full array
	callsub *get_length_difference
	load 250 // length difference
	load 251 // element head offset
	intc 2 // 2
	+ // head ofset
	callsub *update_dynamic_head
	load 255 // full array
	frame_dig -3 // address: Address
	dup
	box_del
	pop
	swap
	box_put
	b *if0_end

*if0_elseif1_condition:
	// examples/tuple_in_box/app.algo.ts:26
	// field === 'company'
	frame_dig -1 // field: string
	pushbytes 0x636f6d70616e79 // "company"
	==
	bz *if0_else

	// *if0_elseif1_consequent
	// examples/tuple_in_box/app.algo.ts:27
	// this.contacts(address).value.company = value
	frame_dig -3 // address: Address
	box_get

	// box value does not exist: this.contacts(address).value
	assert
	store 255 // full array
	intc 2 // 2
	dup
	store 251 // element head offset
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup
	store 254 // element start
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 0 //  get type length
	* // multiply by type length
	intc 2 // 2
	+ // add two for length
	store 253 // element length
	load 255 // full array
	intc 1 // 0
	load 254 // element start
	substring3
	frame_dig -2 // value: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	store 252 // new element
	load 255 // full array
	load 254 // element start
	load 253 // element length
	+ // get end of Element
	load 255 // full array
	len
	substring3
	concat
	concat
	store 255 // full array
	callsub *get_length_difference
	load 255 // full array
	frame_dig -3 // address: Address
	dup
	box_del
	pop
	swap
	box_put
	b *if0_end

*if0_else:
	// Invalid field
	err

*if0_end:
	retsub

// verifyContactName(string,address)void
*abi_route_verifyContactName:
	// address: address
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for verifyContactName must be a address
	assert

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute verifyContactName(string,address)void
	callsub verifyContactName
	intc 0 // 1
	return

// verifyContactName(name: string, address: Address): void
verifyContactName:
	proto 2 0

	// examples/tuple_in_box/app.algo.ts:32
	// assert(this.contacts(address).value.name === name)
	frame_dig -2 // address: Address
	box_get

	// box value does not exist: this.contacts(address).value
	assert
	store 255 // full array
	intc 1 // 0
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 0 //  get type length
	* // multiply by type length
	intc 2 // 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -1 // name: string
	==
	assert
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x92ccf99b // method "setMyContact(string,string)void"
	pushbytes 0x495acbf7 // method "addContact(string,string,address)void"
	pushbytes 0xfa4e8f93 // method "updateContactField(string,string,address)void"
	pushbytes 0x8a30b87e // method "verifyContactName(string,address)void"
	txna ApplicationArgs 0
	match *abi_route_setMyContact *abi_route_addContact *abi_route_updateContactField *abi_route_verifyContactName

	// this contract does not implement the given ABI method for call NoOp
	err

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*update_dynamic_head:
	proto 2 0
	frame_dig -2 // length difference
	load 255 // full array
	frame_dig -1 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 249 // subtract head difference
	bz *subtract_head_difference
	+ // add difference to offset
	b *end_calc_new_head

*subtract_head_difference:
	swap
	- // subtract difference from offet

*end_calc_new_head:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 255 // full array
	swap
	frame_dig -1 // offset
	swap
	replace3 // update offset
	store 255 // full array
	retsub

*get_length_difference:
	load 252 // new element
	len // length of new element
	load 253 // element length
	<
	bnz *swapped_difference
	load 252 // new element
	len // length of new element
	load 253 // element length
	intc 0 // 1
	store 249 // subtract head difference
	b *get_difference

*swapped_difference:
	load 253 // element length
	load 252 // new element
	len // length of new element
	intc 1 // 0
	store 249 // subtract head difference

*get_difference:
	- // get length difference
	store 250 // length difference
	retsub"
`;

exports[`Examples ContactsApp Artifacts Maintains program size 1`] = `635`;

exports[`Examples ContactsApp Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [
        {
          "desc": undefined,
          "name": "name",
          "type": "string",
        },
        {
          "desc": undefined,
          "name": "company",
          "type": "string",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "setMyContact",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "name",
          "type": "string",
        },
        {
          "desc": undefined,
          "name": "company",
          "type": "string",
        },
        {
          "desc": undefined,
          "name": "address",
          "type": "address",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "addContact",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "field",
          "type": "string",
        },
        {
          "desc": undefined,
          "name": "value",
          "type": "string",
        },
        {
          "desc": undefined,
          "name": "address",
          "type": "address",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "updateContactField",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "name",
          "type": "string",
        },
        {
          "desc": undefined,
          "name": "address",
          "type": "address",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "verifyContactName",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
  ],
  "name": "ContactsApp",
}
`;

exports[`Examples ContactsApp Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [
          {
            "desc": undefined,
            "name": "name",
            "type": "string",
          },
          {
            "desc": undefined,
            "name": "company",
            "type": "string",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "setMyContact",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "name",
            "type": "string",
          },
          {
            "desc": undefined,
            "name": "company",
            "type": "string",
          },
          {
            "desc": undefined,
            "name": "address",
            "type": "address",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "addContact",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "field",
            "type": "string",
          },
          {
            "desc": undefined,
            "name": "value",
            "type": "string",
          },
          {
            "desc": undefined,
            "name": "address",
            "type": "address",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "updateContactField",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "name",
            "type": "string",
          },
          {
            "desc": undefined,
            "name": "address",
            "type": "address",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "verifyContactName",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
    ],
    "name": "ContactsApp",
  },
  "hints": {
    "addContact(string,string,address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "setMyContact(string,string)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "updateContactField(string,string,address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "verifyContactName(string,address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {
        "myContact": {
          "key": "myContact",
          "type": "bytes",
        },
      },
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAxIDAgMiAzMgpieXRlY2Jsb2NrIDB4IDB4MDAwNAoKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCnB1c2hpbnQgNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggKmNhbGxfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKmNyZWF0ZV9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRAoKKk5PVF9JTVBMRU1FTlRFRDoKCS8vIFRoZSByZXF1ZXN0ZWQgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIGNvbnRyYWN0LiBBcmUgeW91IHVzaW5nIHRoZSBjb3JyZWN0IE9uQ29tcGxldGU/IERpZCB5b3Ugc2V0IHlvdXIgYXBwIElEPwoJZXJyCgovLyBzZXRNeUNvbnRhY3Qoc3RyaW5nLHN0cmluZyl2b2lkCiphYmlfcm91dGVfc2V0TXlDb250YWN0OgoJLy8gY29tcGFueTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIG5hbWU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIHNldE15Q29udGFjdChzdHJpbmcsc3RyaW5nKXZvaWQKCWNhbGxzdWIgc2V0TXlDb250YWN0CglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBzZXRNeUNvbnRhY3QobmFtZTogc3RyaW5nLCBjb21wYW55OiBzdHJpbmcpOiB2b2lkCnNldE15Q29udGFjdDoKCXByb3RvIDIgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gZXhhbXBsZXMvdHVwbGVfaW5fYm94L2FwcC5hbGdvLnRzOjEyCgkvLyBjb250YWN0OiBDb250YWN0ID0geyBuYW1lOiBuYW1lLCBjb21wYW55OiBjb21wYW55IH0KCWJ5dGVjIDAgLy8gIGluaXRpYWwgaGVhZAoJYnl0ZWMgMCAvLyAgaW5pdGlhbCB0YWlsCglieXRlYyAxIC8vICBpbml0aWFsIGhlYWQgb2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gbmFtZTogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMiAvLyBjb21wYW55OiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CgljYWxsc3ViICpwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCglmcmFtZV9idXJ5IDAgLy8gY29udGFjdDogQ29udGFjdAoKCS8vIGV4YW1wbGVzL3R1cGxlX2luX2JveC9hcHAuYWxnby50czoxNAoJLy8gdGhpcy5teUNvbnRhY3QudmFsdWUgPSBjb250YWN0CglwdXNoYnl0ZXMgMHg2ZDc5NDM2ZjZlNzQ2MTYzNzQgLy8gIm15Q29udGFjdCIKCWZyYW1lX2RpZyAwIC8vIGNvbnRhY3Q6IENvbnRhY3QKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvdHVwbGVfaW5fYm94L2FwcC5hbGdvLnRzOjE1CgkvLyB0aGlzLmNvbnRhY3RzKHRoaXMudHhuLnNlbmRlcikudmFsdWUgPSBjb250YWN0Cgl0eG4gU2VuZGVyCglkdXAKCWJveF9kZWwKCXBvcAoJZnJhbWVfZGlnIDAgLy8gY29udGFjdDogQ29udGFjdAoJYm94X3B1dAoJcmV0c3ViCgovLyBhZGRDb250YWN0KHN0cmluZyxzdHJpbmcsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfYWRkQ29udGFjdDoKCS8vIGFkZHJlc3M6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnRjIDMgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMCAoYWRkcmVzcykgZm9yIGFkZENvbnRhY3QgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGNvbXBhbnk6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyBuYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBhZGRDb250YWN0KHN0cmluZyxzdHJpbmcsYWRkcmVzcyl2b2lkCgljYWxsc3ViIGFkZENvbnRhY3QKCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGFkZENvbnRhY3QobmFtZTogc3RyaW5nLCBjb21wYW55OiBzdHJpbmcsIGFkZHJlc3M6IEFkZHJlc3MpOiB2b2lkCmFkZENvbnRhY3Q6Cglwcm90byAzIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoKCS8vIGV4YW1wbGVzL3R1cGxlX2luX2JveC9hcHAuYWxnby50czoxOQoJLy8gY29udGFjdDogQ29udGFjdCA9IHsgbmFtZTogbmFtZSwgY29tcGFueTogY29tcGFueSB9CglieXRlYyAwIC8vICBpbml0aWFsIGhlYWQKCWJ5dGVjIDAgLy8gIGluaXRpYWwgdGFpbAoJYnl0ZWMgMSAvLyAgaW5pdGlhbCBoZWFkIG9mZnNldAoJZnJhbWVfZGlnIC0xIC8vIG5hbWU6IHN0cmluZwoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTIgLy8gY29tcGFueTogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJZnJhbWVfYnVyeSAwIC8vIGNvbnRhY3Q6IENvbnRhY3QKCgkvLyBleGFtcGxlcy90dXBsZV9pbl9ib3gvYXBwLmFsZ28udHM6MjAKCS8vIHRoaXMuY29udGFjdHMoYWRkcmVzcykudmFsdWUgPSBjb250YWN0CglmcmFtZV9kaWcgLTMgLy8gYWRkcmVzczogQWRkcmVzcwoJZHVwCglib3hfZGVsCglwb3AKCWZyYW1lX2RpZyAwIC8vIGNvbnRhY3Q6IENvbnRhY3QKCWJveF9wdXQKCXJldHN1YgoKLy8gdXBkYXRlQ29udGFjdEZpZWxkKHN0cmluZyxzdHJpbmcsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfdXBkYXRlQ29udGFjdEZpZWxkOgoJLy8gYWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChhZGRyZXNzKSBmb3IgdXBkYXRlQ29udGFjdEZpZWxkIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyB2YWx1ZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIGZpZWxkOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSB1cGRhdGVDb250YWN0RmllbGQoc3RyaW5nLHN0cmluZyxhZGRyZXNzKXZvaWQKCWNhbGxzdWIgdXBkYXRlQ29udGFjdEZpZWxkCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyB1cGRhdGVDb250YWN0RmllbGQoZmllbGQ6IHN0cmluZywgdmFsdWU6IHN0cmluZywgYWRkcmVzczogQWRkcmVzcyk6IHZvaWQKdXBkYXRlQ29udGFjdEZpZWxkOgoJcHJvdG8gMyAwCgoJLy8gKmlmMF9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3R1cGxlX2luX2JveC9hcHAuYWxnby50czoyNAoJLy8gZmllbGQgPT09ICduYW1lJwoJZnJhbWVfZGlnIC0xIC8vIGZpZWxkOiBzdHJpbmcKCXB1c2hieXRlcyAweDZlNjE2ZDY1IC8vICJuYW1lIgoJPT0KCWJ6ICppZjBfZWxzZWlmMV9jb25kaXRpb24KCgkvLyAqaWYwX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3R1cGxlX2luX2JveC9hcHAuYWxnby50czoyNQoJLy8gdGhpcy5jb250YWN0cyhhZGRyZXNzKS52YWx1ZS5uYW1lID0gdmFsdWUKCWZyYW1lX2RpZyAtMyAvLyBhZGRyZXNzOiBBZGRyZXNzCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmNvbnRhY3RzKGFkZHJlc3MpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDEgLy8gMAoJZHVwCglzdG9yZSAyNTEgLy8gZWxlbWVudCBoZWFkIG9mZnNldAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJZHVwCglzdG9yZSAyNTQgLy8gZWxlbWVudCBzdGFydAoJZHVwIC8vIGR1cGxpY2F0ZSBzdGFydCBvZiBlbGVtZW50Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglzd2FwCglleHRyYWN0X3VpbnQxNiAvLyBnZXQgbnVtYmVyIG9mIGVsZW1lbnRzCglpbnRjIDAgLy8gIGdldCB0eXBlIGxlbmd0aAoJKiAvLyBtdWx0aXBseSBieSB0eXBlIGxlbmd0aAoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglzdG9yZSAyNTMgLy8gZWxlbWVudCBsZW5ndGgKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMSAvLyAwCglsb2FkIDI1NCAvLyBlbGVtZW50IHN0YXJ0CglzdWJzdHJpbmczCglmcmFtZV9kaWcgLTIgLy8gdmFsdWU6IHN0cmluZwoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWR1cAoJc3RvcmUgMjUyIC8vIG5ldyBlbGVtZW50Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NCAvLyBlbGVtZW50IHN0YXJ0Cglsb2FkIDI1MyAvLyBlbGVtZW50IGxlbmd0aAoJKyAvLyBnZXQgZW5kIG9mIEVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWxlbgoJc3Vic3RyaW5nMwoJY29uY2F0Cgljb25jYXQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CgljYWxsc3ViICpnZXRfbGVuZ3RoX2RpZmZlcmVuY2UKCWxvYWQgMjUwIC8vIGxlbmd0aCBkaWZmZXJlbmNlCglsb2FkIDI1MSAvLyBlbGVtZW50IGhlYWQgb2Zmc2V0CglpbnRjIDIgLy8gMgoJKyAvLyBoZWFkIG9mc2V0CgljYWxsc3ViICp1cGRhdGVfZHluYW1pY19oZWFkCglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglmcmFtZV9kaWcgLTMgLy8gYWRkcmVzczogQWRkcmVzcwoJZHVwCglib3hfZGVsCglwb3AKCXN3YXAKCWJveF9wdXQKCWIgKmlmMF9lbmQKCippZjBfZWxzZWlmMV9jb25kaXRpb246CgkvLyBleGFtcGxlcy90dXBsZV9pbl9ib3gvYXBwLmFsZ28udHM6MjYKCS8vIGZpZWxkID09PSAnY29tcGFueScKCWZyYW1lX2RpZyAtMSAvLyBmaWVsZDogc3RyaW5nCglwdXNoYnl0ZXMgMHg2MzZmNmQ3MDYxNmU3OSAvLyAiY29tcGFueSIKCT09CglieiAqaWYwX2Vsc2UKCgkvLyAqaWYwX2Vsc2VpZjFfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvdHVwbGVfaW5fYm94L2FwcC5hbGdvLnRzOjI3CgkvLyB0aGlzLmNvbnRhY3RzKGFkZHJlc3MpLnZhbHVlLmNvbXBhbnkgPSB2YWx1ZQoJZnJhbWVfZGlnIC0zIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuY29udGFjdHMoYWRkcmVzcykudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMiAvLyAyCglkdXAKCXN0b3JlIDI1MSAvLyBlbGVtZW50IGhlYWQgb2Zmc2V0Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cgl1bmNvdmVyIDIKCWV4dHJhY3RfdWludDE2CglkdXAKCXN0b3JlIDI1NCAvLyBlbGVtZW50IHN0YXJ0CglkdXAgLy8gZHVwbGljYXRlIHN0YXJ0IG9mIGVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXN3YXAKCWV4dHJhY3RfdWludDE2IC8vIGdldCBudW1iZXIgb2YgZWxlbWVudHMKCWludGMgMCAvLyAgZ2V0IHR5cGUgbGVuZ3RoCgkqIC8vIG11bHRpcGx5IGJ5IHR5cGUgbGVuZ3RoCglpbnRjIDIgLy8gMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCXN0b3JlIDI1MyAvLyBlbGVtZW50IGxlbmd0aAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAxIC8vIDAKCWxvYWQgMjU0IC8vIGVsZW1lbnQgc3RhcnQKCXN1YnN0cmluZzMKCWZyYW1lX2RpZyAtMiAvLyB2YWx1ZTogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJZHVwCglzdG9yZSAyNTIgLy8gbmV3IGVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU0IC8vIGVsZW1lbnQgc3RhcnQKCWxvYWQgMjUzIC8vIGVsZW1lbnQgbGVuZ3RoCgkrIC8vIGdldCBlbmQgb2YgRWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbGVuCglzdWJzdHJpbmczCgljb25jYXQKCWNvbmNhdAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWNhbGxzdWIgKmdldF9sZW5ndGhfZGlmZmVyZW5jZQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZnJhbWVfZGlnIC0zIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWR1cAoJYm94X2RlbAoJcG9wCglzd2FwCglib3hfcHV0CgliICppZjBfZW5kCgoqaWYwX2Vsc2U6CgkvLyBJbnZhbGlkIGZpZWxkCgllcnIKCippZjBfZW5kOgoJcmV0c3ViCgovLyB2ZXJpZnlDb250YWN0TmFtZShzdHJpbmcsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfdmVyaWZ5Q29udGFjdE5hbWU6CgkvLyBhZGRyZXNzOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGFkZHJlc3MpIGZvciB2ZXJpZnlDb250YWN0TmFtZSBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gbmFtZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgdmVyaWZ5Q29udGFjdE5hbWUoc3RyaW5nLGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiB2ZXJpZnlDb250YWN0TmFtZQoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gdmVyaWZ5Q29udGFjdE5hbWUobmFtZTogc3RyaW5nLCBhZGRyZXNzOiBBZGRyZXNzKTogdm9pZAp2ZXJpZnlDb250YWN0TmFtZToKCXByb3RvIDIgMAoKCS8vIGV4YW1wbGVzL3R1cGxlX2luX2JveC9hcHAuYWxnby50czozMgoJLy8gYXNzZXJ0KHRoaXMuY29udGFjdHMoYWRkcmVzcykudmFsdWUubmFtZSA9PT0gbmFtZSkKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzOiBBZGRyZXNzCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmNvbnRhY3RzKGFkZHJlc3MpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDEgLy8gMAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJZHVwIC8vIGR1cGxpY2F0ZSBzdGFydCBvZiBlbGVtZW50Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglzd2FwCglleHRyYWN0X3VpbnQxNiAvLyBnZXQgbnVtYmVyIG9mIGVsZW1lbnRzCglpbnRjIDAgLy8gIGdldCB0eXBlIGxlbmd0aAoJKiAvLyBtdWx0aXBseSBieSB0eXBlIGxlbmd0aAoJaW50YyAyIC8vIDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglleHRyYWN0MwoJZXh0cmFjdCAyIDAKCWZyYW1lX2RpZyAtMSAvLyBuYW1lOiBzdHJpbmcKCT09Cglhc3NlcnQKCXJldHN1YgoKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCWludGMgMCAvLyAxCglyZXR1cm4KCipjcmVhdGVfTm9PcDoKCXB1c2hieXRlcyAweGI4NDQ3YjM2IC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNyZWF0ZSBOb09wCgllcnIKCipjYWxsX05vT3A6CglwdXNoYnl0ZXMgMHg5MmNjZjk5YiAvLyBtZXRob2QgInNldE15Q29udGFjdChzdHJpbmcsc3RyaW5nKXZvaWQiCglwdXNoYnl0ZXMgMHg0OTVhY2JmNyAvLyBtZXRob2QgImFkZENvbnRhY3Qoc3RyaW5nLHN0cmluZyxhZGRyZXNzKXZvaWQiCglwdXNoYnl0ZXMgMHhmYTRlOGY5MyAvLyBtZXRob2QgInVwZGF0ZUNvbnRhY3RGaWVsZChzdHJpbmcsc3RyaW5nLGFkZHJlc3Mpdm9pZCIKCXB1c2hieXRlcyAweDhhMzBiODdlIC8vIG1ldGhvZCAidmVyaWZ5Q29udGFjdE5hbWUoc3RyaW5nLGFkZHJlc3Mpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfc2V0TXlDb250YWN0ICphYmlfcm91dGVfYWRkQ29udGFjdCAqYWJpX3JvdXRlX3VwZGF0ZUNvbnRhY3RGaWVsZCAqYWJpX3JvdXRlX3ZlcmlmeUNvbnRhY3ROYW1lCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNhbGwgTm9PcAoJZXJyCgoqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQ6Cglwcm90byA0IDMKCWZyYW1lX2RpZyAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCWNvbmNhdAoJZnJhbWVfYnVyeSAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTEgLy8gZWxlbWVudAoJZHVwCglsZW4KCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJYnRvaQoJKwoJaXRvYgoJZXh0cmFjdCA2IDIKCWZyYW1lX2J1cnkgLTIgLy8gaGVhZCBvZmZzZXQKCWZyYW1lX2RpZyAtMyAvLyB0dXBsZSB0YWlsCglzd2FwCgljb25jYXQKCWZyYW1lX2J1cnkgLTMgLy8gdHVwbGUgdGFpbAoJZnJhbWVfZGlnIC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMyAvLyB0dXBsZSB0YWlsCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCXJldHN1YgoKKnVwZGF0ZV9keW5hbWljX2hlYWQ6Cglwcm90byAyIDAKCWZyYW1lX2RpZyAtMiAvLyBsZW5ndGggZGlmZmVyZW5jZQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZnJhbWVfZGlnIC0xIC8vIGR5bmFtaWMgYXJyYXkgb2Zmc2V0CglleHRyYWN0X3VpbnQxNiAvLyBleHRyYWN0IGR5bmFtaWMgYXJyYXkgb2Zmc2V0Cglsb2FkIDI0OSAvLyBzdWJ0cmFjdCBoZWFkIGRpZmZlcmVuY2UKCWJ6ICpzdWJ0cmFjdF9oZWFkX2RpZmZlcmVuY2UKCSsgLy8gYWRkIGRpZmZlcmVuY2UgdG8gb2Zmc2V0CgliICplbmRfY2FsY19uZXdfaGVhZAoKKnN1YnRyYWN0X2hlYWRfZGlmZmVyZW5jZToKCXN3YXAKCS0gLy8gc3VidHJhY3QgZGlmZmVyZW5jZSBmcm9tIG9mZmV0CgoqZW5kX2NhbGNfbmV3X2hlYWQ6CglpdG9iIC8vIGNvbnZlcnQgdG8gYnl0ZXMKCWV4dHJhY3QgNiAyIC8vIGNvbnZlcnQgdG8gdWludDE2Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglzd2FwCglmcmFtZV9kaWcgLTEgLy8gb2Zmc2V0Cglzd2FwCglyZXBsYWNlMyAvLyB1cGRhdGUgb2Zmc2V0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJcmV0c3ViCgoqZ2V0X2xlbmd0aF9kaWZmZXJlbmNlOgoJbG9hZCAyNTIgLy8gbmV3IGVsZW1lbnQKCWxlbiAvLyBsZW5ndGggb2YgbmV3IGVsZW1lbnQKCWxvYWQgMjUzIC8vIGVsZW1lbnQgbGVuZ3RoCgk8CglibnogKnN3YXBwZWRfZGlmZmVyZW5jZQoJbG9hZCAyNTIgLy8gbmV3IGVsZW1lbnQKCWxlbiAvLyBsZW5ndGggb2YgbmV3IGVsZW1lbnQKCWxvYWQgMjUzIC8vIGVsZW1lbnQgbGVuZ3RoCglpbnRjIDAgLy8gMQoJc3RvcmUgMjQ5IC8vIHN1YnRyYWN0IGhlYWQgZGlmZmVyZW5jZQoJYiAqZ2V0X2RpZmZlcmVuY2UKCipzd2FwcGVkX2RpZmZlcmVuY2U6Cglsb2FkIDI1MyAvLyBlbGVtZW50IGxlbmd0aAoJbG9hZCAyNTIgLy8gbmV3IGVsZW1lbnQKCWxlbiAvLyBsZW5ndGggb2YgbmV3IGVsZW1lbnQKCWludGMgMSAvLyAwCglzdG9yZSAyNDkgLy8gc3VidHJhY3QgaGVhZCBkaWZmZXJlbmNlCgoqZ2V0X2RpZmZlcmVuY2U6CgktIC8vIGdldCBsZW5ndGggZGlmZmVyZW5jZQoJc3RvcmUgMjUwIC8vIGxlbmd0aCBkaWZmZXJlbmNlCglyZXRzdWI=",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  "state": {
    "global": {
      "num_byte_slices": 1,
      "num_uints": 0,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples ValidatorRegistry Artifacts Generates TEAL 1`] = `
"#pragma version 11
intcblock 0 1 8 24 18 268 32 6 3 242 2 10 252 260 700 4 100000 900 16 200 40 72 192 244 1000000 4096 5 226 TMPL_nfdRegistryAppId 300 432 892 1000 28500 50000 11 80 145 153 209
bytecblock 0x76 0x 0x151f7c75 0x737073 0x7374616b6564 0x00 0x6e756d5374616b657273 0x0000000000000000 0x0a8101 0x706f6f6c54656d706c617465417070726f76616c4279746573 0x692e6f776e65722e61 0x6e756d56 0x696e6974 0x63f3f28b 0x12f4bd4b

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 7 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// examples/reti/validatorRegistry.algo.ts:82
	// this.stakingPoolInitialized.value = false
	bytec 12 //  "init"
	intc 0 // 0
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// examples/reti/validatorRegistry.algo.ts:83
	// this.numValidators.value = 0
	bytec 11 //  "numV"
	intc 0 // 0
	app_global_put

	// examples/reti/validatorRegistry.algo.ts:84
	// this.numStakers.value = 0
	bytec 6 //  "numStakers"
	intc 0 // 0
	app_global_put

	// examples/reti/validatorRegistry.algo.ts:85
	// this.totalAlgoStaked.value = 0
	bytec 4 //  "staked"
	intc 0 // 0
	app_global_put
	retsub

// initStakingContract(uint64)void
*abi_route_initStakingContract:
	// approvalProgramSize: uint64
	txna ApplicationArgs 1
	btoi

	// execute initStakingContract(uint64)void
	callsub initStakingContract
	intc 1 // 1
	return

// initStakingContract(approvalProgramSize: uint64): void
initStakingContract:
	proto 1 0

	// examples/reti/validatorRegistry.algo.ts:90
	// this.stakingPoolApprovalProgram.create(approvalProgramSize)
	bytec 9 //  "poolTemplateApprovalBytes"
	frame_dig -1 // approvalProgramSize: uint64
	box_create
	pop
	retsub

// loadStakingContractData(uint64,byte[])void
*abi_route_loadStakingContractData:
	// data: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// offset: uint64
	txna ApplicationArgs 1
	btoi

	// execute loadStakingContractData(uint64,byte[])void
	callsub loadStakingContractData
	intc 1 // 1
	return

// loadStakingContractData(offset: uint64, data: bytes): void
loadStakingContractData:
	proto 2 0

	// examples/reti/validatorRegistry.algo.ts:94
	// assert(!this.stakingPoolInitialized.value)
	bytec 12 //  "init"
	app_global_get
	intc 0 // 0
	getbit
	!
	assert

	// examples/reti/validatorRegistry.algo.ts:95
	// this.stakingPoolApprovalProgram.replace(offset, data)
	bytec 9 //  "poolTemplateApprovalBytes"
	frame_dig -1 // offset: uint64
	frame_dig -2 // data: bytes
	box_replace
	retsub

// finalizeStakingContract()void
*abi_route_finalizeStakingContract:
	// execute finalizeStakingContract()void
	callsub finalizeStakingContract
	intc 1 // 1
	return

// finalizeStakingContract(): void
finalizeStakingContract:
	proto 0 0

	// examples/reti/validatorRegistry.algo.ts:99
	// this.stakingPoolInitialized.value = true
	bytec 12 //  "init"
	intc 1 // 1
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// gas()void
*abi_route_gas:
	// execute gas()void
	callsub gas
	intc 1 // 1
	return

// gas(): void
//
// gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
gas:
	proto 0 0
	retsub

// getMbrAmounts()(uint64,uint64,uint64,uint64)
*abi_route_getMbrAmounts:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute getMbrAmounts()(uint64,uint64,uint64,uint64)
	callsub getMbrAmounts
	concat
	log
	intc 1 // 1
	return

// getMbrAmounts(): MbrAmounts
//
// Returns the MBR amounts needed for various actions:
// [
// addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
// addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
// poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
// addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
// ]
getMbrAmounts:
	proto 0 1

	// examples/reti/validatorRegistry.algo.ts:120
	// return {
	//       addValidatorMbr: this.costForBoxStorage(1 /* v prefix */ + len<ValidatorIdType>() + len<ValidatorInfo>()),
	//       addPoolMbr: this.minBalanceForAccount(
	//         1,
	//         // we could calculate this directly by referencing the size of stakingPoolApprovalProgram but it would
	//         // mean our callers would have to reference the box AND buy up i/o - so just go max on extra pages
	//         3,
	//         0,
	//         0,
	//         0,
	//         StakingPool.schema.global.numUint,
	//         StakingPool.schema.global.numByteSlice
	//       ),
	//       poolInitMbr:
	//         ALGORAND_ACCOUNT_MIN_BALANCE +
	//         this.costForBoxStorage(7 /* 'stakers' name */ + len<StakedInfo>() * MAX_STAKERS_PER_POOL),
	//       addStakerMbr:
	//         // how much to charge for first time a staker adds stake - since we add a tracking box per staker
	//         this.costForBoxStorage(3 /* 'sps' prefix */ + len<Address>() + len<ValidatorPoolKey>() * MAX_POOLS_PER_STAKER), // size of key + all values
	//     };
	pushint 1101
	callsub costForBoxStorage
	itob
	intc 8 // 3
	intc 35 // 11
	intc 0 // 0
	dupn 2
	intc 8 // 3
	intc 1 // 1
	callsub minBalanceForAccount
	itob
	concat
	intc 16 // 100000
	pushint 12807
	callsub costForBoxStorage
	+
	itob
	concat
	pushint 179
	callsub costForBoxStorage
	itob
	concat
	retsub

// getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
*abi_route_getProtocolConstraints:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	callsub getProtocolConstraints
	concat
	log
	intc 1 // 1
	return

// getProtocolConstraints(): Constraints
//
// Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
getProtocolConstraints:
	proto 0 1

	// examples/reti/validatorRegistry.algo.ts:147
	// return {
	//       epochPayoutRoundsMin: MIN_EPOCH_LENGTH,
	//       epochPayoutRoundsMax: MAX_EPOCH_LENGTH,
	//       minPctToValidatorWFourDecimals: MIN_PCT_TO_VALIDATOR,
	//       maxPctToValidatorWFourDecimals: MAX_PCT_TO_VALIDATOR,
	//       minEntryStake: MIN_ALGO_STAKE_PER_POOL,
	//       maxAlgoPerPool: this.maxAlgoAllowedPerPool(),
	//       maxAlgoPerValidator: this.maxAllowedStake(),
	//       amtConsideredSaturated: this.algoSaturationLevel(),
	//       maxNodes: MAX_NODES,
	//       maxPoolsPerNode: MAX_POOLS_PER_NODE,
	//       maxStakersPerPool: MAX_STAKERS_PER_POOL,
	//     };
	pushbytes 0x000000000000000100000000000f4240000000000000000000000000000f424000000000000f4240
	callsub maxAlgoAllowedPerPool
	itob
	concat
	callsub maxAllowedStake
	itob
	concat
	callsub algoSaturationLevel
	itob
	concat
	pushbytes 0x0000000000000008
	concat
	pushbytes 0x0000000000000003
	concat
	pushbytes 0x00000000000000c8
	concat
	retsub

// getNumValidators()uint64
*abi_route_getNumValidators:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute getNumValidators()uint64
	callsub getNumValidators
	itob
	concat
	log
	intc 1 // 1
	return

// getNumValidators(): uint64
//
// Returns the current number of validators
getNumValidators:
	proto 0 1

	// examples/reti/validatorRegistry.algo.ts:167
	// return this.numValidators.value;
	bytec 11 //  "numV"
	app_global_get
	retsub

// getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
*abi_route_getValidatorConfig:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	callsub getValidatorConfig
	concat
	log
	intc 1 // 1
	return

// getValidatorConfig(validatorId: ValidatorIdType): ValidatorConfig
getValidatorConfig:
	proto 1 1

	// examples/reti/validatorRegistry.algo.ts:172
	// return this.validatorList(validatorId).value.config;
	intc 0 // 0
	intc 9 // 242
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	retsub

// getValidatorState(uint64)(uint16,uint64,uint64,uint64)
*abi_route_getValidatorState:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorState(uint64)(uint16,uint64,uint64,uint64)
	callsub getValidatorState
	concat
	log
	intc 1 // 1
	return

// getValidatorState(validatorId: ValidatorIdType): ValidatorCurState
getValidatorState:
	proto 1 1

	// examples/reti/validatorRegistry.algo.ts:177
	// return this.validatorList(validatorId).value.state;
	intc 9 //  headOffset
	pushint 26
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	retsub

// getValidatorOwnerAndManager(uint64)(address,address)
*abi_route_getValidatorOwnerAndManager:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorOwnerAndManager(uint64)(address,address)
	callsub getValidatorOwnerAndManager
	concat
	log
	intc 1 // 1
	return

// getValidatorOwnerAndManager(validatorId: ValidatorIdType): [Address, Address]
getValidatorOwnerAndManager:
	proto 1 1

	// examples/reti/validatorRegistry.algo.ts:182
	// return [this.validatorList(validatorId).value.config.owner, this.validatorList(validatorId).value.config.manager];
	intc 2 // 8
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	intc 20 // 40
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	concat
	retsub

// getPools(uint64)(uint64,uint16,uint64)[]
*abi_route_getPools:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPools(uint64)(uint64,uint16,uint64)[]
	callsub getPools
	dup
	len
	intc 4 // 18
	/
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 1 // 1
	return

// getPools(validatorId: ValidatorIdType): PoolInfo[]
//
// Return list of all pools for this validator.
// @param {uint64} validatorId
// @return {PoolInfo[]} - array of pools
// Not callable from other contracts because >1K return but can be called w/ simulate which bumps log returns
getPools:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// examples/reti/validatorRegistry.algo.ts:193
	// retData: PoolInfo[] = []
	bytec 1 // 0x
	frame_bury 0 // retData: PoolInfo[]

	// examples/reti/validatorRegistry.algo.ts:194
	// poolSet = clone(this.validatorList(validatorId).value.pools)
	intc 5 //  headOffset
	intc 30 // 432
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_bury 1 // poolSet: (uint64,uint16,uint64)[24]

	// examples/reti/validatorRegistry.algo.ts:195
	// for (let i = 0; i < poolSet.length; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_0:
	// examples/reti/validatorRegistry.algo.ts:195
	// i < poolSet.length
	frame_dig 2 // i: uint64
	intc 3 // 24
	<
	bz *for_0_end

	// *if0_condition
	// examples/reti/validatorRegistry.algo.ts:196
	// poolSet[i].poolAppId === 0
	frame_dig 1 // poolSet: (uint64,uint16,uint64)[24]
	frame_dig 2 // i: uint64
	intc 4 // 18
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	intc 0 // 0
	==
	bz *if0_end

	// *if0_consequent
	b *for_0_end

*if0_end:
	// examples/reti/validatorRegistry.algo.ts:200
	// retData.push(poolSet[i])
	frame_dig 0 // retData: PoolInfo[]
	frame_dig 1 // poolSet: (uint64,uint16,uint64)[24]
	frame_dig 2 // i: uint64
	intc 4 // 18
	* // acc * typeLength
	intc 4 // 18
	extract3
	concat
	frame_bury 0 // retData: PoolInfo[]

*for_0_continue:
	// examples/reti/validatorRegistry.algo.ts:195
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_0

*for_0_end:
	// examples/reti/validatorRegistry.algo.ts:202
	// return retData;
	frame_dig 0 // retData: PoolInfo[]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// getPoolAppId(uint64,uint64)uint64
*abi_route_getPoolAppId:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// poolId: uint64
	txna ApplicationArgs 2
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPoolAppId(uint64,uint64)uint64
	callsub getPoolAppId
	itob
	concat
	log
	intc 1 // 1
	return

// getPoolAppId(validatorId: uint64, poolId: uint64): uint64
//
// getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
// want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
// (which contains reward tokens if being used) so that the amount available can be determined.
getPoolAppId:
	proto 2 1

	// examples/reti/validatorRegistry.algo.ts:212
	// assert(
	//       poolId !== 0 && poolId <= this.validatorList(validatorId).value.pools.length,
	//       'pool id must be between 1 and number of pools for this validator'
	//     )
	frame_dig -2 // poolId: uint64
	intc 0 // 0
	!=
	dup
	bz *skip_and0
	frame_dig -2 // poolId: uint64
	intc 3 // 24
	<=
	&&

*skip_and0:
	// pool id must be between 1 and number of pools for this validator
	assert

	// examples/reti/validatorRegistry.algo.ts:216
	// return this.validatorList(validatorId).value.pools[poolId - 1].poolAppId;
	intc 5 //  headOffset
	frame_dig -2 // poolId: uint64
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 0 // 0
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: uint64
	itob
	concat
	cover 2
	box_extract
	btoi
	retsub

// getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)
*abi_route_getPoolInfo:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 24
	==

	// argument 0 (poolKey) for getPoolInfo must be a (uint64,uint64,uint64)
	assert

	// execute getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)
	callsub getPoolInfo
	concat
	log
	intc 1 // 1
	return

// getPoolInfo(poolKey: ValidatorPoolKey): PoolInfo
getPoolInfo:
	proto 1 1

	// examples/reti/validatorRegistry.algo.ts:221
	// return this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1];
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 4 // 18
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	retsub

// getCurMaxStakePerPool(uint64)uint64
*abi_route_getCurMaxStakePerPool:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCurMaxStakePerPool(uint64)uint64
	callsub getCurMaxStakePerPool
	itob
	concat
	log
	intc 1 // 1
	return

// getCurMaxStakePerPool(validatorId: ValidatorIdType): uint64
//
// Calculate the maximum stake per pool for a given validator.
// Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
// as pools are added the max allowed per pool can reduce.
//
// @param {ValidatorIdType} validatorId - The id of the validator.
getCurMaxStakePerPool:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// examples/reti/validatorRegistry.algo.ts:233
	// numPools = this.validatorList(validatorId).value.state.numPools as uint64
	intc 9 // 242
	intc 10 // 2
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // numPools: uint64

	// examples/reti/validatorRegistry.algo.ts:234
	// hardMaxDividedBetweenPools = this.maxAllowedStake() / numPools
	callsub maxAllowedStake
	frame_dig 0 // numPools: uint64
	/
	frame_bury 1 // hardMaxDividedBetweenPools: uint64

	// examples/reti/validatorRegistry.algo.ts:235
	// maxPerPool: uint64 = this.validatorList(validatorId).value.config.maxAlgoPerPool
	pushint 217
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 2 // maxPerPool: uint64

	// *if1_condition
	// examples/reti/validatorRegistry.algo.ts:236
	// maxPerPool === 0
	frame_dig 2 // maxPerPool: uint64
	intc 0 // 0
	==
	bz *if1_end

	// *if1_consequent
	// examples/reti/validatorRegistry.algo.ts:237
	// maxPerPool = this.maxAlgoAllowedPerPool()
	callsub maxAlgoAllowedPerPool
	frame_bury 2 // maxPerPool: uint64

*if1_end:
	// *if2_condition
	// examples/reti/validatorRegistry.algo.ts:239
	// hardMaxDividedBetweenPools < maxPerPool
	frame_dig 1 // hardMaxDividedBetweenPools: uint64
	frame_dig 2 // maxPerPool: uint64
	<
	bz *if2_end

	// *if2_consequent
	// examples/reti/validatorRegistry.algo.ts:240
	// maxPerPool = hardMaxDividedBetweenPools
	frame_dig 1 // hardMaxDividedBetweenPools: uint64
	frame_bury 2 // maxPerPool: uint64

*if2_end:
	// examples/reti/validatorRegistry.algo.ts:242
	// return maxPerPool;
	frame_dig 2 // maxPerPool: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// doesStakerNeedToPayMBR(address)bool
*abi_route_doesStakerNeedToPayMBR:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// staker: address
	txna ApplicationArgs 1
	dup
	len
	intc 6 // 32
	==

	// argument 0 (staker) for doesStakerNeedToPayMBR must be a address
	assert

	// execute doesStakerNeedToPayMBR(address)bool
	callsub doesStakerNeedToPayMBR
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// doesStakerNeedToPayMBR(staker: Address): boolean
//
// Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
// @param staker
doesStakerNeedToPayMBR:
	proto 1 1

	// examples/reti/validatorRegistry.algo.ts:251
	// return !this.stakerPoolSet(staker).exists;
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	box_len
	swap
	pop
	!
	retsub

// getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]
*abi_route_getStakedPoolsForAccount:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// staker: address
	txna ApplicationArgs 1
	dup
	len
	intc 6 // 32
	==

	// argument 0 (staker) for getStakedPoolsForAccount must be a address
	assert

	// execute getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]
	callsub getStakedPoolsForAccount
	dup
	len
	intc 3 // 24
	/
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 1 // 1
	return

// getStakedPoolsForAccount(staker: Address): ValidatorPoolKey[]
//
// Retrieves the staked pools for an account.
//
// @param {Address} staker - The account to retrieve staked pools for.
// @return {ValidatorPoolKey[]} - The array of staked pools for the account.
getStakedPoolsForAccount:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// *if3_condition
	// examples/reti/validatorRegistry.algo.ts:262
	// !this.stakerPoolSet(staker).exists
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	box_len
	swap
	pop
	!
	bz *if3_end

	// *if3_consequent
	// examples/reti/validatorRegistry.algo.ts:263
	// return [];
	bytec 1 // 0x
	b *getStakedPoolsForAccount*return

*if3_end:
	// examples/reti/validatorRegistry.algo.ts:265
	// retData: ValidatorPoolKey[] = []
	bytec 1 // 0x
	frame_bury 0 // retData: ValidatorPoolKey[]

	// examples/reti/validatorRegistry.algo.ts:266
	// poolSet = clone(this.stakerPoolSet(staker).value)
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	box_get

	// box value does not exist: this.stakerPoolSet(staker).value
	assert
	frame_bury 1 // poolSet: (uint64,uint64,uint64)[6]

	// examples/reti/validatorRegistry.algo.ts:267
	// for (let i = 0; i < poolSet.length; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_1:
	// examples/reti/validatorRegistry.algo.ts:267
	// i < poolSet.length
	frame_dig 2 // i: uint64
	intc 7 // 6
	<
	bz *for_1_end

	// *if4_condition
	// examples/reti/validatorRegistry.algo.ts:268
	// poolSet[i].id !== 0
	frame_dig 1 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 2 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	intc 0 // 0
	!=
	bz *if4_end

	// *if4_consequent
	// examples/reti/validatorRegistry.algo.ts:269
	// retData.push(poolSet[i])
	frame_dig 0 // retData: ValidatorPoolKey[]
	frame_dig 1 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 2 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 3 // 24
	extract3
	concat
	frame_bury 0 // retData: ValidatorPoolKey[]

*if4_end:

*for_1_continue:
	// examples/reti/validatorRegistry.algo.ts:267
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_1

*for_1_end:
	// examples/reti/validatorRegistry.algo.ts:272
	// return retData;
	frame_dig 0 // retData: ValidatorPoolKey[]

*getStakedPoolsForAccount*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// getTokenPayoutRatio(uint64)(uint64[24],uint64)
*abi_route_getTokenPayoutRatio:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getTokenPayoutRatio(uint64)(uint64[24],uint64)
	callsub getTokenPayoutRatio
	concat
	log
	intc 1 // 1
	return

// getTokenPayoutRatio(validatorId: ValidatorIdType): PoolTokenPayoutRatio
//
// Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
// payouts across pools can be based on a stable snaphost of stake.
//
// @param {ValidatorIdType} validatorId - The id of the validator.
// @return {PoolTokenPayoutRatio} - The token payout ratio for the validator.
getTokenPayoutRatio:
	proto 1 1

	// examples/reti/validatorRegistry.algo.ts:284
	// return this.validatorList(validatorId).value.tokenPayoutRatio;
	intc 14 //  headOffset
	intc 19 // 200
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	retsub

// getNodePoolAssignments(uint64)((uint64[3])[8])
*abi_route_getNodePoolAssignments:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getNodePoolAssignments(uint64)((uint64[3])[8])
	callsub getNodePoolAssignments
	concat
	log
	intc 1 // 1
	return

// getNodePoolAssignments(validatorId: uint64): NodePoolAssignmentConfig
getNodePoolAssignments:
	proto 1 1

	// examples/reti/validatorRegistry.algo.ts:289
	// assert(this.validatorList(validatorId).exists, "the specified validator id doesn't exist")
	bytec 0 //  "v"
	frame_dig -1 // validatorId: uint64
	itob
	concat
	box_len
	swap
	pop

	// the specified validator id doesn't exist
	assert

	// examples/reti/validatorRegistry.algo.ts:291
	// return this.validatorList(validatorId).value.nodePoolAssignments;
	intc 17 //  headOffset
	intc 22 // 192
	bytec 0 //  "v"
	frame_dig -1 // validatorId: uint64
	itob
	concat
	cover 2
	box_extract
	retsub

// getNFDRegistryID()uint64
*abi_route_getNFDRegistryID:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute getNFDRegistryID()uint64
	callsub getNFDRegistryID
	itob
	concat
	log
	intc 1 // 1
	return

// getNFDRegistryID(): uint64
getNFDRegistryID:
	proto 0 1

	// examples/reti/validatorRegistry.algo.ts:296
	// return this.nfdRegistryAppId;
	intc 28 // TMPL_nfdRegistryAppId
	retsub

// addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64
*abi_route_addValidator:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// config: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	txna ApplicationArgs 2
	dup
	len
	intc 9 // 242
	==

	// argument 0 (config) for addValidator must be a (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	assert

	// nfdName: string
	txna ApplicationArgs 1
	extract 2 0

	// mbrPayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 2 (mbrPayment) for addValidator must be a pay transaction
	assert

	// execute addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64
	callsub addValidator
	itob
	concat
	log
	intc 1 // 1
	return

// addValidator(mbrPayment: PayTxn, nfdName: string, config: ValidatorConfig): uint64
//
// Adds a new validator
// Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.
//
// @param {PayTxn} mbrPayment payment from caller which covers mbr increase of new validator storage
// @param {string} nfdName (Optional) Name of nfd (used as double-check against id specified in config)
// @param {ValidatorConfig} config ValidatorConfig struct
// @returns {uint64} validator id
addValidator:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// examples/reti/validatorRegistry.algo.ts:308
	// this.validateConfig(config)
	frame_dig -3 // config: ValidatorConfig
	callsub validateConfig

	// examples/reti/validatorRegistry.algo.ts:310
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: this.getMbrAmounts().addValidatorMbr })
	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	callsub getMbrAmounts
	extract 0 8
	btoi
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"this.getMbrAmounts().addValidatorMbr"}
	assert

	// examples/reti/validatorRegistry.algo.ts:312
	// assert(mbrPayment.fee > 10 * 1000000, 'fee must be 10 ALGO or more to prevent spamming of validators')
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Fee
	pushint 10000000
	>

	// fee must be 10 ALGO or more to prevent spamming of validators
	assert

	// examples/reti/validatorRegistry.algo.ts:315
	// validatorId = this.numValidators.value + 1
	bytec 11 //  "numV"
	app_global_get
	intc 1 // 1
	+
	frame_bury 0 // validatorId: uint64

	// examples/reti/validatorRegistry.algo.ts:316
	// this.numValidators.value = validatorId
	bytec 11 //  "numV"
	frame_dig 0 // validatorId: uint64
	app_global_put

	// examples/reti/validatorRegistry.algo.ts:318
	// this.validatorList(validatorId).create()
	bytec 0 //  "v"
	frame_dig 0 // validatorId: uint64
	itob
	concat
	pushint 1092
	box_create
	pop

	// examples/reti/validatorRegistry.algo.ts:319
	// this.validatorList(validatorId).value.config = config
	intc 0 // 0
	frame_dig -3 // config: ValidatorConfig
	bytec 0 //  "v"
	frame_dig 0 // validatorId: uint64
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:320
	// this.validatorList(validatorId).value.config.id = validatorId
	intc 0 // 0
	frame_dig 0 // validatorId: uint64
	itob
	bytec 0 //  "v"
	frame_dig 0 // validatorId: uint64
	itob
	concat
	cover 2
	box_replace

	// *if5_condition
	// examples/reti/validatorRegistry.algo.ts:323
	// config.nfdForInfo !== 0
	frame_dig -3 // config: ValidatorConfig
	extract 72 8
	btoi
	intc 0 // 0
	!=
	bz *if5_end

	// *if5_consequent
	// examples/reti/validatorRegistry.algo.ts:325
	// assert(this.isNFDAppIDValid(config.nfdForInfo), 'provided NFD must be valid')
	frame_dig -3 // config: ValidatorConfig
	extract 72 8
	btoi
	callsub isNFDAppIDValid

	// provided NFD must be valid
	assert

	// examples/reti/validatorRegistry.algo.ts:327
	// assert(
	//         this.txn.sender === (AppID.fromUint64(config.nfdForInfo).globalState('i.owner.a') as Address),
	//         'If specifying NFD, account adding validator must be owner'
	//       )
	txn Sender
	frame_dig -3 // config: ValidatorConfig
	extract 72 8
	btoi
	bytec 10 //  "i.owner.a"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(config.nfdForInfo).globalState('i.owner.a')
	assert
	==

	// If specifying NFD, account adding validator must be owner
	assert

*if5_end:
	// *if6_condition
	// examples/reti/validatorRegistry.algo.ts:333
	// config.entryGatingType === GATING_TYPE_CREATED_BY_NFD_ADDRESSES ||
	//       config.entryGatingType === GATING_TYPE_SEGMENT_OF_NFD
	frame_dig -3 // config: ValidatorConfig
	extract 80 1
	btoi
	intc 8 // 3
	==
	dup
	bnz *skip_or0
	frame_dig -3 // config: ValidatorConfig
	extract 80 1
	btoi
	intc 15 // 4
	==
	||

*skip_or0:
	bz *if6_end

	// *if6_consequent
	// examples/reti/validatorRegistry.algo.ts:337
	// assert(this.isNFDAppIDValid(config.entryGatingAssets[0]), 'provided NFD App id for gating must be valid NFD')
	frame_dig -3 // config: ValidatorConfig
	extract 113 8
	btoi
	callsub isNFDAppIDValid

	// provided NFD App id for gating must be valid NFD
	assert

*if6_end:
	// examples/reti/validatorRegistry.algo.ts:339
	// this.retiOP_addedValidator.log({ id: validatorId, owner: config.owner, manager: config.manager })
	pushbytes 0xa8dd21cb // retiOP_addedValidator(uint64,address,address)
	frame_dig 0 // validatorId: uint64
	itob
	frame_dig -3 // config: ValidatorConfig
	extract 8 32
	concat
	frame_dig -3 // config: ValidatorConfig
	extract 40 32
	concat
	concat
	log

	// examples/reti/validatorRegistry.algo.ts:340
	// return validatorId;
	frame_dig 0 // validatorId: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// changeValidatorManager(uint64,address)void
*abi_route_changeValidatorManager:
	// manager: address
	txna ApplicationArgs 2
	dup
	len
	intc 6 // 32
	==

	// argument 0 (manager) for changeValidatorManager must be a address
	assert

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorManager(uint64,address)void
	callsub changeValidatorManager
	intc 1 // 1
	return

// changeValidatorManager(validatorId: ValidatorIdType, manager: Address): void
//
// Changes the Validator manager for a specific Validator id.
// [ ONLY OWNER CAN CHANGE ]
//
// @param {ValidatorIdType} validatorId - The id of the validator to change the manager for.
// @param {Address} manager - The new manager address.
changeValidatorManager:
	proto 2 0

	// examples/reti/validatorRegistry.algo.ts:351
	// this.callerMustBeOwner(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwner

	// examples/reti/validatorRegistry.algo.ts:352
	// assert(manager !== globals.zeroAddress, 'needs to at least be valid address')
	frame_dig -2 // manager: Address
	global ZeroAddress
	!=

	// needs to at least be valid address
	assert

	// examples/reti/validatorRegistry.algo.ts:353
	// this.validatorList(validatorId).value.config.manager = manager
	intc 20 // 40
	frame_dig -2 // manager: Address
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace
	retsub

// changeValidatorSunsetInfo(uint64,uint64,uint64)void
*abi_route_changeValidatorSunsetInfo:
	// sunsettingTo: uint64
	txna ApplicationArgs 3
	btoi

	// sunsettingOn: uint64
	txna ApplicationArgs 2
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorSunsetInfo(uint64,uint64,uint64)void
	callsub changeValidatorSunsetInfo
	intc 1 // 1
	return

// changeValidatorSunsetInfo(validatorId: ValidatorIdType, sunsettingOn: uint64, sunsettingTo: ValidatorIdType): void
//
// Updates the sunset information for a given validator.
// [ ONLY OWNER CAN CHANGE ]
//
// @param {ValidatorIdType} validatorId - The id of the validator to update.
// @param {uint64} sunsettingOn - The new sunset timestamp.
// @param {uint64} sunsettingTo - The new sunset to validator id.
changeValidatorSunsetInfo:
	proto 3 0

	// examples/reti/validatorRegistry.algo.ts:365
	// this.callerMustBeOwner(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwner

	// examples/reti/validatorRegistry.algo.ts:366
	// this.validatorList(validatorId).value.config.sunsettingOn = sunsettingOn
	intc 27 // 226
	frame_dig -2 // sunsettingOn: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:367
	// this.validatorList(validatorId).value.config.sunsettingTo = sunsettingTo
	pushint 234
	frame_dig -3 // sunsettingTo: ValidatorIdType
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace
	retsub

// changeValidatorNFD(uint64,uint64,string)void
*abi_route_changeValidatorNFD:
	// nfdName: string
	txna ApplicationArgs 3
	extract 2 0

	// nfdAppID: uint64
	txna ApplicationArgs 2
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorNFD(uint64,uint64,string)void
	callsub changeValidatorNFD
	intc 1 // 1
	return

// changeValidatorNFD(validatorId: ValidatorIdType, nfdAppID: uint64, nfdName: string): void
//
// Changes the NFD for a validator in the validatorList contract.
// [ ONLY OWNER CAN CHANGE ]
//
// @param {ValidatorIdType} validatorId - The id of the validator to update.
// @param {uint64} nfdAppID - The application id of the NFD to assign to the validator.
// @param {string} nfdName - The name of the NFD (which must match)
changeValidatorNFD:
	proto 3 0

	// examples/reti/validatorRegistry.algo.ts:379
	// this.callerMustBeOwner(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwner

	// examples/reti/validatorRegistry.algo.ts:381
	// assert(this.isNFDAppIDValid(nfdAppID), 'provided NFD must be valid')
	frame_dig -2 // nfdAppID: uint64
	callsub isNFDAppIDValid

	// provided NFD must be valid
	assert

	// examples/reti/validatorRegistry.algo.ts:383
	// assert(
	//       this.txn.sender === (AppID.fromUint64(nfdAppID).globalState('i.owner.a') as Address),
	//       'If specifying NFD, account adding validator must be owner'
	//     )
	txn Sender
	frame_dig -2 // nfdAppID: uint64
	bytec 10 //  "i.owner.a"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(nfdAppID).globalState('i.owner.a')
	assert
	==

	// If specifying NFD, account adding validator must be owner
	assert

	// examples/reti/validatorRegistry.algo.ts:387
	// this.validatorList(validatorId).value.config.nfdForInfo = nfdAppID
	intc 21 // 72
	frame_dig -2 // nfdAppID: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace
	retsub

// changeValidatorCommissionAddress(uint64,address)void
*abi_route_changeValidatorCommissionAddress:
	// commissionAddress: address
	txna ApplicationArgs 2
	dup
	len
	intc 6 // 32
	==

	// argument 0 (commissionAddress) for changeValidatorCommissionAddress must be a address
	assert

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorCommissionAddress(uint64,address)void
	callsub changeValidatorCommissionAddress
	intc 1 // 1
	return

// changeValidatorCommissionAddress(validatorId: ValidatorIdType, commissionAddress: Address): void
//
// Change the commission address that validator rewards are sent to.
// [ ONLY OWNER CAN CHANGE ]
changeValidatorCommissionAddress:
	proto 2 0

	// examples/reti/validatorRegistry.algo.ts:395
	// this.callerMustBeOwner(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwner

	// examples/reti/validatorRegistry.algo.ts:396
	// assert(commissionAddress !== Address.zeroAddress)
	frame_dig -2 // commissionAddress: Address
	global ZeroAddress
	!=
	assert

	// examples/reti/validatorRegistry.algo.ts:397
	// this.validatorList(validatorId).value.config.validatorCommissionAddress = commissionAddress
	pushint 177
	frame_dig -2 // commissionAddress: Address
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace
	retsub

// changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void
*abi_route_changeValidatorRewardInfo:
	// RewardPerPayout: uint64
	txna ApplicationArgs 6
	btoi

	// GatingAssetMinBalance: uint64
	txna ApplicationArgs 5
	btoi

	// EntryGatingAssets: uint64[4]
	txna ApplicationArgs 4
	dup
	len
	intc 6 // 32
	==

	// argument 2 (EntryGatingAssets) for changeValidatorRewardInfo must be a uint64[4]
	assert

	// EntryGatingAddress: address
	txna ApplicationArgs 3
	dup
	len
	intc 6 // 32
	==

	// argument 3 (EntryGatingAddress) for changeValidatorRewardInfo must be a address
	assert

	// EntryGatingType: uint8
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 4 (EntryGatingType) for changeValidatorRewardInfo must be a uint8
	assert
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void
	callsub changeValidatorRewardInfo
	intc 1 // 1
	return

// changeValidatorRewardInfo(validatorId: ValidatorIdType, EntryGatingType: uint8, EntryGatingAddress: Address, EntryGatingAssets: StaticArray<uint64, 4>, GatingAssetMinBalance: uint64, RewardPerPayout: uint64): void
//
// Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
// [ ONLY OWNER CAN CHANGE ]
changeValidatorRewardInfo:
	proto 6 0

	// examples/reti/validatorRegistry.algo.ts:412
	// this.callerMustBeOwner(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwner

	// examples/reti/validatorRegistry.algo.ts:414
	// assert(EntryGatingType >= GATING_TYPE_NONE && EntryGatingType < GATING_TYPE_CONST_MAX, 'invalid Entry gating type')
	frame_dig -2 // EntryGatingType: uint8
	intc 0 // 0
	>=
	dup
	bz *skip_and1
	frame_dig -2 // EntryGatingType: uint8
	intc 15 // 4
	<
	&&

*skip_and1:
	// invalid Entry gating type
	assert

	// *if7_condition
	// examples/reti/validatorRegistry.algo.ts:415
	// EntryGatingType === GATING_TYPE_ASSETS_CREATED_BY
	frame_dig -2 // EntryGatingType: uint8
	intc 1 // 1
	==
	bz *if7_end

	// *if7_consequent
	// examples/reti/validatorRegistry.algo.ts:416
	// assert(EntryGatingAddress !== globals.zeroAddress)
	frame_dig -3 // EntryGatingAddress: Address
	global ZeroAddress
	!=
	assert

*if7_end:
	// *if8_condition
	// examples/reti/validatorRegistry.algo.ts:418
	// EntryGatingType === GATING_TYPE_CREATED_BY_NFD_ADDRESSES || EntryGatingType === GATING_TYPE_SEGMENT_OF_NFD
	frame_dig -2 // EntryGatingType: uint8
	intc 8 // 3
	==
	dup
	bnz *skip_or1
	frame_dig -2 // EntryGatingType: uint8
	intc 15 // 4
	==
	||

*skip_or1:
	bz *if8_end

	// *if8_consequent
	// examples/reti/validatorRegistry.algo.ts:419
	// assert(this.isNFDAppIDValid(EntryGatingAssets[0]), 'provided NFD App id for gating must be valid NFD')
	frame_dig -4 // EntryGatingAssets: StaticArray<uint64, 4>
	extract 0 8
	btoi
	callsub isNFDAppIDValid

	// provided NFD App id for gating must be valid NFD
	assert

*if8_end:
	// examples/reti/validatorRegistry.algo.ts:421
	// this.validatorList(validatorId).value.config.entryGatingType = EntryGatingType
	intc 36 // 80
	frame_dig -2 // EntryGatingType: uint8
	itob
	extract 7 1
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:422
	// this.validatorList(validatorId).value.config.entryGatingAddress = EntryGatingAddress
	pushint 81
	frame_dig -3 // EntryGatingAddress: Address
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:423
	// this.validatorList(validatorId).value.config.entryGatingAssets = EntryGatingAssets
	pushint 113
	frame_dig -4 // EntryGatingAssets: StaticArray<uint64, 4>
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:424
	// this.validatorList(validatorId).value.config.gatingAssetMinBalance = GatingAssetMinBalance
	intc 37 // 145
	frame_dig -5 // GatingAssetMinBalance: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:425
	// this.validatorList(validatorId).value.config.rewardPerPayout = RewardPerPayout
	pushint 161
	frame_dig -6 // RewardPerPayout: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace
	retsub

// addPool(pay,uint64,uint64)(uint64,uint64,uint64)
*abi_route_addPool:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// nodeNum: uint64
	txna ApplicationArgs 2
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// mbrPayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 2 (mbrPayment) for addPool must be a pay transaction
	assert

	// execute addPool(pay,uint64,uint64)(uint64,uint64,uint64)
	callsub addPool
	concat
	log
	intc 1 // 1
	return

// addPool(mbrPayment: PayTxn, validatorId: ValidatorIdType, nodeNum: uint64): ValidatorPoolKey
//
// Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
// The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
//
// [ ONLY OWNER OR MANAGER CAN call ]
// @param {PayTxn} mbrPayment payment from caller which covers mbr increase of adding a new pool
// @param {uint64} validatorId is id of validator to pool to (must be owner or manager)
// @param {uint64} nodeNum is node number to add to
// @returns {ValidatorPoolKey} pool key to created pool
addPool:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// examples/reti/validatorRegistry.algo.ts:440
	// this.callerMustBeOwnerOrManager(validatorId)
	frame_dig -2 // validatorId: ValidatorIdType
	callsub callerMustBeOwnerOrManager

	// examples/reti/validatorRegistry.algo.ts:443
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: this.getMbrAmounts().addPoolMbr })
	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	callsub getMbrAmounts
	extract 8 8
	btoi
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"this.getMbrAmounts().addPoolMbr"}
	assert

	// examples/reti/validatorRegistry.algo.ts:445
	// assert(this.validatorList(validatorId).exists, "specified validator id isn't valid")
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	box_len
	swap
	pop

	// specified validator id isn't valid
	assert

	// examples/reti/validatorRegistry.algo.ts:447
	// numPools: uint64 = this.validatorList(validatorId).value.state.numPools as uint64
	intc 9 // 242
	intc 10 // 2
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // numPools: uint64

	// *if9_condition
	// examples/reti/validatorRegistry.algo.ts:448
	// (numPools as uint64) >= MAX_POOLS
	frame_dig 0 // numPools: uint64
	intc 3 // 24
	>=
	bz *if9_end

	// *if9_consequent
	// already at max pool size
	err

*if9_end:
	// examples/reti/validatorRegistry.algo.ts:451
	// numPools += 1
	frame_dig 0 // numPools: uint64
	intc 1 // 1
	+
	frame_bury 0 // numPools: uint64

	// examples/reti/validatorRegistry.algo.ts:454
	// sendAppCall({
	//       onCompletion: OnCompletion.NoOp,
	//       approvalProgram: [
	//         this.stakingPoolApprovalProgram.extract(0, 4096),
	//         this.stakingPoolApprovalProgram.extract(4096, this.stakingPoolApprovalProgram.size - 4096),
	//       ],
	//       clearStateProgram: StakingPool.clearProgram(),
	//       globalNumUint: StakingPool.schema.global.numUint,
	//       globalNumByteSlice: StakingPool.schema.global.numByteSlice,
	//       extraProgramPages: 3,
	//       applicationArgs: [
	//         // creatingContractID, validatorId, poolId, minEntryStake
	//         method('createApplication(uint64,uint64,uint64,uint64)void'),
	//         itob(this.app.id),
	//         itob(validatorId),
	//         itob(numPools as uint64),
	//         itob(this.validatorList(validatorId).value.config.minEntryStake),
	//       ],
	//     })
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum

	// examples/reti/validatorRegistry.algo.ts:455
	// onCompletion: OnCompletion.NoOp
	intc 0 //  NoOp
	itxn_field OnCompletion

	// examples/reti/validatorRegistry.algo.ts:456
	// approvalProgram: [
	//         this.stakingPoolApprovalProgram.extract(0, 4096),
	//         this.stakingPoolApprovalProgram.extract(4096, this.stakingPoolApprovalProgram.size - 4096),
	//       ]
	bytec 9 //  "poolTemplateApprovalBytes"
	intc 0 // 0
	intc 25 // 4096
	box_extract
	itxn_field ApprovalProgramPages
	bytec 9 //  "poolTemplateApprovalBytes"
	intc 25 // 4096
	bytec 9 //  "poolTemplateApprovalBytes"
	box_len

	// box value does not exist: this.stakingPoolApprovalProgram.size
	assert
	intc 25 // 4096
	-
	box_extract
	itxn_field ApprovalProgramPages

	// examples/reti/validatorRegistry.algo.ts:460
	// clearStateProgram: StakingPool.clearProgram()
	pushbytes 0x0b
	itxn_field ClearStateProgram

	// examples/reti/validatorRegistry.algo.ts:461
	// globalNumUint: StakingPool.schema.global.numUint
	intc 35 // 11
	itxn_field GlobalNumUint

	// examples/reti/validatorRegistry.algo.ts:462
	// globalNumByteSlice: StakingPool.schema.global.numByteSlice
	intc 8 // 3
	itxn_field GlobalNumByteSlice

	// examples/reti/validatorRegistry.algo.ts:463
	// extraProgramPages: 3
	intc 8 // 3
	itxn_field ExtraProgramPages

	// examples/reti/validatorRegistry.algo.ts:464
	// applicationArgs: [
	//         // creatingContractID, validatorId, poolId, minEntryStake
	//         method('createApplication(uint64,uint64,uint64,uint64)void'),
	//         itob(this.app.id),
	//         itob(validatorId),
	//         itob(numPools as uint64),
	//         itob(this.validatorList(validatorId).value.config.minEntryStake),
	//       ]
	pushbytes 0x59e90aa6 // method "createApplication(uint64,uint64,uint64,uint64)void"
	itxn_field ApplicationArgs
	txna Applications 0
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	itxn_field ApplicationArgs
	frame_dig 0 // numPools: uint64
	itob
	itxn_field ApplicationArgs
	intc 39 // 209
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/reti/validatorRegistry.algo.ts:474
	// this.validatorList(validatorId).value.state.numPools = numPools as uint16
	intc 9 // 242
	frame_dig 0 // numPools: uint64
	itob
	extract 6 2
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:477
	// poolAppId = this.itxn.createdApplicationID.id
	itxn CreatedApplicationID
	frame_bury 1 // poolAppId: uint64

	// examples/reti/validatorRegistry.algo.ts:478
	// this.validatorList(validatorId).value.pools[numPools - 1].poolAppId = poolAppId
	intc 5 //  headOffset
	frame_dig 0 // numPools: uint64
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 0 // 0
	+
	frame_dig 1 // poolAppId: uint64
	itob
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:479
	// this.addPoolToNode(validatorId, poolAppId, nodeNum)
	frame_dig -3 // nodeNum: uint64
	frame_dig 1 // poolAppId: uint64
	frame_dig -2 // validatorId: ValidatorIdType
	callsub addPoolToNode

	// examples/reti/validatorRegistry.algo.ts:481
	// this.retiOP_validatorAddedPool.log({
	//       id: validatorId,
	//       num: numPools as uint16,
	//       poolAppId: AppID.fromUint64(poolAppId),
	//     })
	pushbytes 0xfbcc0f6b // retiOP_validatorAddedPool(uint64,uint16,uint64)
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	frame_dig 0 // numPools: uint64
	itob
	dup
	bitlen
	intc 18 // 16
	<=

	// numPools as uint16 overflowed 16 bits
	assert
	extract 6 2
	concat
	frame_dig 1 // poolAppId: uint64
	itob
	concat
	concat
	log

	// examples/reti/validatorRegistry.algo.ts:487
	// return { id: validatorId, poolId: numPools as uint64, poolAppId: this.itxn!.createdApplicationID.id };
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	frame_dig 0 // numPools: uint64
	itob
	concat
	itxn CreatedApplicationID
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// addStake(pay,uint64,uint64)(uint64,uint64,uint64)
*abi_route_addStake:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// valueToVerify: uint64
	txna ApplicationArgs 2
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// stakedAmountPayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 2 (stakedAmountPayment) for addStake must be a pay transaction
	assert

	// execute addStake(pay,uint64,uint64)(uint64,uint64,uint64)
	callsub addStake
	concat
	log
	intc 1 // 1
	return

// addStake(stakedAmountPayment: PayTxn, validatorId: ValidatorIdType, valueToVerify: uint64): ValidatorPoolKey
//
// Adds stake to a validator pool.
//
// @param {PayTxn} stakedAmountPayment - payment coming from staker to place into a pool
// @param {ValidatorIdType} validatorId - The id of the validator.
// @param {uint64} valueToVerify - only if validator has gating to enter - this is asset id or nfd id that corresponds to gating.
// Txn sender is factored in as well if that is part of gating.
// * @returns {ValidatorPoolKey} - The key of the validator pool.
addStake:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 5

	// examples/reti/validatorRegistry.algo.ts:500
	// assert(this.validatorList(validatorId).exists, "specified validator id isn't valid")
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	box_len
	swap
	pop

	// specified validator id isn't valid
	assert

	// *if10_condition
	// examples/reti/validatorRegistry.algo.ts:503
	// this.validatorList(validatorId).value.config.sunsettingOn > 0
	intc 27 // 226
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 0
	>
	bz *if10_end

	// *if10_consequent
	// examples/reti/validatorRegistry.algo.ts:505
	// assert(
	//         this.validatorList(validatorId).value.config.sunsettingOn > globals.latestTimestamp,
	//         "can't stake with a validator that is past its sunsetting time"
	//       )
	intc 27 // 226
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	global LatestTimestamp
	>

	// can't stake with a validator that is past its sunsetting time
	assert

*if10_end:
	// examples/reti/validatorRegistry.algo.ts:511
	// staker = this.txn.sender
	txn Sender
	frame_bury 0 // staker: address

	// examples/reti/validatorRegistry.algo.ts:515
	// verifyPayTxn(stakedAmountPayment, {
	//       sender: staker,
	//       receiver: this.app.address,
	//     })
	// verify sender
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Sender
	frame_dig 0 // staker: address
	==

	// transaction verification failed: {"txn":"stakedAmountPayment","field":"sender","expected":"staker"}
	assert

	// verify receiver
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"stakedAmountPayment","field":"receiver","expected":"this.app.address"}
	assert

	// examples/reti/validatorRegistry.algo.ts:523
	// this.doesStakerMeetGating(validatorId, valueToVerify)
	frame_dig -3 // valueToVerify: uint64
	frame_dig -2 // validatorId: ValidatorIdType
	callsub doesStakerMeetGating

	// examples/reti/validatorRegistry.algo.ts:525
	// realAmount = stakedAmountPayment.amount
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_bury 1 // realAmount: uint64

	// examples/reti/validatorRegistry.algo.ts:526
	// mbrAmtLeftBehind: uint64 = 0
	intc 0 // 0
	frame_bury 2 // mbrAmtLeftBehind: uint64

	// *if11_condition
	// examples/reti/validatorRegistry.algo.ts:528
	// this.doesStakerNeedToPayMBR(staker)
	frame_dig 0 // staker: address
	callsub doesStakerNeedToPayMBR
	bz *if11_end

	// *if11_consequent
	// examples/reti/validatorRegistry.algo.ts:531
	// mbrAmtLeftBehind = this.getMbrAmounts().addStakerMbr
	callsub getMbrAmounts
	extract 24 8
	btoi
	frame_bury 2 // mbrAmtLeftBehind: uint64

	// examples/reti/validatorRegistry.algo.ts:532
	// realAmount -= mbrAmtLeftBehind
	frame_dig 1 // realAmount: uint64
	frame_dig 2 // mbrAmtLeftBehind: uint64
	-
	frame_bury 1 // realAmount: uint64

	// examples/reti/validatorRegistry.algo.ts:533
	// this.stakerPoolSet(staker).create()
	bytec 3 //  "sps"
	frame_dig 0 // staker: address
	concat
	pushint 144
	box_create
	pop

*if11_end:
	// examples/reti/validatorRegistry.algo.ts:537
	// assert(
	//       this.validatorList(validatorId).value.state.totalAlgoStaked + realAmount < this.maxAllowedStake(),
	//       'total staked for all of a validators pools may not exceed hard cap'
	//     )
	intc 12 // 252
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig 1 // realAmount: uint64
	+
	callsub maxAllowedStake
	<

	// total staked for all of a validators pools may not exceed hard cap
	assert

	// examples/reti/validatorRegistry.algo.ts:544
	// findRet = this.findPoolForStaker(validatorId, staker, realAmount)
	frame_dig 1 // realAmount: uint64
	frame_dig 0 // staker: address
	frame_dig -2 // validatorId: ValidatorIdType
	callsub findPoolForStaker
	frame_bury 3 // findRet: ((uint64,uint64,uint64),bool,bool)

	// examples/reti/validatorRegistry.algo.ts:545
	// poolKey = findRet[0]
	// examples/reti/validatorRegistry.algo.ts:546
	// isNewStakerToValidator = findRet[1]
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	intc 22 // 192
	getbit
	frame_bury 4 // isNewStakerToValidator: bool

	// examples/reti/validatorRegistry.algo.ts:547
	// isNewStakerToProtocol = findRet[2]
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	pushint 193
	getbit
	frame_bury 5 // isNewStakerToProtocol: bool

	// *if12_condition
	// examples/reti/validatorRegistry.algo.ts:548
	// poolKey.poolId === 0
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	intc 0 // 0
	==
	bz *if12_end

	// *if12_consequent
	// No pool available with free stake.  Validator needs to add another pool
	err

*if12_end:
	// examples/reti/validatorRegistry.algo.ts:553
	// this.updateStakerPoolSet(staker, poolKey)
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 0 24
	frame_dig 0 // staker: address
	callsub updateStakerPoolSet

	// examples/reti/validatorRegistry.algo.ts:556
	// this.callPoolAddStake(
	//       stakedAmountPayment,
	//       poolKey,
	//       mbrAmtLeftBehind,
	//       isNewStakerToValidator,
	//       isNewStakerToProtocol
	//     )
	frame_dig 5 // isNewStakerToProtocol: bool
	frame_dig 4 // isNewStakerToValidator: bool
	frame_dig 2 // mbrAmtLeftBehind: uint64
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 0 24
	frame_dig -1 // stakedAmountPayment: PayTxn
	callsub callPoolAddStake

	// examples/reti/validatorRegistry.algo.ts:563
	// this.retiOP_stakeAdded.log({
	//       id: validatorId,
	//       poolNum: poolKey.poolId as uint16,
	//       poolAppId: AppID.fromUint64(poolKey.poolAppId),
	//       amountStaked: realAmount,
	//       staker: staker,
	//     })
	pushbytes 0x962b4143 // retiOP_stakeAdded(uint64,uint16,uint64,address,uint64)
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itob
	dup
	bitlen
	intc 18 // 16
	<=

	// poolKey.poolId as uint16 overflowed 16 bits
	assert
	extract 6 2
	concat
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	itob
	concat
	frame_dig 0 // staker: address
	concat
	frame_dig 1 // realAmount: uint64
	itob
	concat
	concat
	log

	// examples/reti/validatorRegistry.algo.ts:571
	// return poolKey;
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 0 24

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 5
	retsub

// setTokenPayoutRatio(uint64)(uint64[24],uint64)
*abi_route_setTokenPayoutRatio:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute setTokenPayoutRatio(uint64)(uint64[24],uint64)
	callsub setTokenPayoutRatio
	concat
	log
	intc 1 // 1
	return

// setTokenPayoutRatio(validatorId: ValidatorIdType): PoolTokenPayoutRatio
//
// setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
// of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
// in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
// pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
// It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
// their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
// during the epoch updates across pools)
//
// Multiple pools will call us via pool 1 (pool2->pool1->validator, etc.) so don't assert on pool1 calling multiple
// times in same epoch.  Just return.
//
// @param validatorId - validator id (and thus pool) calling us.  Verified so that sender MUST be pool 1 of this validator.
// @returns PoolTokenPayoutRatio - the finished ratio data
setTokenPayoutRatio:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 8

	// examples/reti/validatorRegistry.algo.ts:591
	// pool1AppID = this.validatorList(validatorId).value.pools[0].poolAppId
	intc 5 // 268
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // pool1AppID: uint64

	// examples/reti/validatorRegistry.algo.ts:592
	// assert(pool1AppID !== 0)
	frame_dig 0 // pool1AppID: uint64
	intc 0 // 0
	!=
	assert

	// *if13_condition
	// examples/reti/validatorRegistry.algo.ts:594
	// this.txn.sender !== AppID.fromUint64(pool1AppID).address
	txn Sender
	frame_dig 0 // pool1AppID: uint64
	app_params_get AppAddress
	pop
	!=
	bz *if13_end

	// *if13_consequent
	// examples/reti/validatorRegistry.algo.ts:595
	// return this.validatorList(validatorId).value.tokenPayoutRatio;
	intc 14 //  headOffset
	intc 19 // 200
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	b *setTokenPayoutRatio*return

*if13_end:
	// examples/reti/validatorRegistry.algo.ts:601
	// curRound = globals.round
	global Round
	frame_bury 1 // curRound: uint64

	// examples/reti/validatorRegistry.algo.ts:602
	// lastPayoutUpdate = this.validatorList(validatorId).value.tokenPayoutRatio.updatedForPayout
	intc 31 // 892
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 2 // lastPayoutUpdate: uint64

	// *if14_condition
	// examples/reti/validatorRegistry.algo.ts:603
	// lastPayoutUpdate !== 0
	frame_dig 2 // lastPayoutUpdate: uint64
	intc 0 // 0
	!=
	bz *if14_end

	// *if14_consequent
	// *if15_condition
	// examples/reti/validatorRegistry.algo.ts:605
	// (AppID.fromUint64(pool1AppID).globalState('lastPayout') as uint64) === lastPayoutUpdate
	frame_dig 0 // pool1AppID: uint64
	pushbytes 0x6c6173745061796f7574 // "lastPayout"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(pool1AppID).globalState('lastPayout')
	assert
	frame_dig 2 // lastPayoutUpdate: uint64
	==
	bz *if15_end

	// *if15_consequent
	// examples/reti/validatorRegistry.algo.ts:606
	// return this.validatorList(validatorId).value.tokenPayoutRatio;
	intc 14 //  headOffset
	intc 19 // 200
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	b *setTokenPayoutRatio*return

*if15_end:
	// examples/reti/validatorRegistry.algo.ts:608
	// epochRoundLength = this.validatorList(validatorId).value.config.epochRoundLength as uint64
	pushint 169
	intc 15 // 4
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 3 // epochRoundLength: uint64

	// examples/reti/validatorRegistry.algo.ts:609
	// thisEpochBegin = curRound - (curRound % epochRoundLength)
	frame_dig 1 // curRound: uint64
	frame_dig 1 // curRound: uint64
	frame_dig 3 // epochRoundLength: uint64
	%
	-
	frame_bury 4 // thisEpochBegin: uint64

	// *if16_condition
	// examples/reti/validatorRegistry.algo.ts:611
	// lastPayoutUpdate - (lastPayoutUpdate % epochRoundLength) === thisEpochBegin
	frame_dig 2 // lastPayoutUpdate: uint64
	frame_dig 2 // lastPayoutUpdate: uint64
	frame_dig 3 // epochRoundLength: uint64
	%
	-
	frame_dig 4 // thisEpochBegin: uint64
	==
	bz *if16_end

	// *if16_consequent
	// examples/reti/validatorRegistry.algo.ts:612
	// return this.validatorList(validatorId).value.tokenPayoutRatio;
	intc 14 //  headOffset
	intc 19 // 200
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	b *setTokenPayoutRatio*return

*if16_end:

*if14_end:
	// examples/reti/validatorRegistry.algo.ts:615
	// this.validatorList(validatorId).value.tokenPayoutRatio.updatedForPayout = curRound
	intc 31 // 892
	frame_dig 1 // curRound: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:617
	// curNumPools = this.validatorList(validatorId).value.state.numPools as uint64
	intc 9 // 242
	intc 10 // 2
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 5 // curNumPools: uint64

	// examples/reti/validatorRegistry.algo.ts:618
	// totalStakeForValidator = this.validatorList(validatorId).value.state.totalAlgoStaked
	intc 12 // 252
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 6 // totalStakeForValidator: uint64

	// examples/reti/validatorRegistry.algo.ts:619
	// for (let i = 0; i < curNumPools; i += 1)
	intc 0 // 0
	frame_bury 7 // i: uint64

*for_2:
	// examples/reti/validatorRegistry.algo.ts:619
	// i < curNumPools
	frame_dig 7 // i: uint64
	frame_dig 5 // curNumPools: uint64
	<
	bz *for_2_end

	// examples/reti/validatorRegistry.algo.ts:624
	// ourPoolPctOfWhole = wideRatio(
	//         [this.validatorList(validatorId).value.pools[i].totalAlgoStaked, 1_000_000],
	//         [totalStakeForValidator]
	//       )
	intc 5 //  headOffset
	frame_dig 7 // i: uint64
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	pushint 1_000_000
	mulw
	intc 0 // 0
	frame_dig 6 // totalStakeForValidator: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 8 // ourPoolPctOfWhole: uint64

	// examples/reti/validatorRegistry.algo.ts:628
	// this.validatorList(validatorId).value.tokenPayoutRatio.poolPctOfWhole[i] = ourPoolPctOfWhole
	intc 14 // 700
	frame_dig 7 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	frame_dig 8 // ourPoolPctOfWhole: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

*for_2_continue:
	// examples/reti/validatorRegistry.algo.ts:619
	// i += 1
	frame_dig 7 // i: uint64
	intc 1 // 1
	+
	frame_bury 7 // i: uint64
	b *for_2

*for_2_end:
	// examples/reti/validatorRegistry.algo.ts:630
	// return this.validatorList(validatorId).value.tokenPayoutRatio;
	intc 14 //  headOffset
	intc 19 // 200
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract

*setTokenPayoutRatio*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

// stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void
*abi_route_stakeUpdatedViaRewards:
	// saturatedBurnToFeeSink: uint64
	txna ApplicationArgs 5
	btoi

	// validatorCommission: uint64
	txna ApplicationArgs 4
	btoi

	// rewardTokenAmountReserved: uint64
	txna ApplicationArgs 3
	btoi

	// algoToAdd: uint64
	txna ApplicationArgs 2
	btoi

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 24
	==

	// argument 4 (poolKey) for stakeUpdatedViaRewards must be a (uint64,uint64,uint64)
	assert

	// execute stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void
	callsub stakeUpdatedViaRewards
	intc 1 // 1
	return

// stakeUpdatedViaRewards(poolKey: ValidatorPoolKey, algoToAdd: uint64, rewardTokenAmountReserved: uint64, validatorCommission: uint64, saturatedBurnToFeeSink: uint64): void
//
// stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
// stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
// The calling App id is validated against our pool list as well.
// @param {ValidatorPoolKey} poolKey - ValidatorPoolKey type
// @param {uint64} algoToAdd - amount this validator's total stake increased via rewards
// @param {uint64} rewardTokenAmountReserved - amount this validator's total stake increased via rewards (that should be
// @param {uint64} validatorCommission - the commission amount the validator was paid, if any
// @param {uint64} saturatedBurnToFeeSink - if the pool was in saturated state, the amount sent back to the fee sink.
// seen as 'accounted for/pending spent')
stakeUpdatedViaRewards:
	proto 5 0

	// examples/reti/validatorRegistry.algo.ts:651
	// this.verifyPoolKeyCaller(poolKey)
	frame_dig -1 // poolKey: ValidatorPoolKey
	callsub verifyPoolKeyCaller

	// examples/reti/validatorRegistry.algo.ts:654
	// this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].totalAlgoStaked += algoToAdd
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -2 // algoToAdd: uint64
	+
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:655
	// this.validatorList(poolKey.id).value.state.totalAlgoStaked += algoToAdd
	intc 12 // 252
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -2 // algoToAdd: uint64
	+
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:656
	// this.validatorList(poolKey.id).value.state.rewardTokenHeldBack += rewardTokenAmountReserved
	intc 13 // 260
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // rewardTokenAmountReserved: uint64
	+
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:658
	// this.totalAlgoStaked.value += algoToAdd
	bytec 4 //  "staked"
	app_global_get
	frame_dig -2 // algoToAdd: uint64
	+
	bytec 4 //  "staked"
	swap
	app_global_put

	// examples/reti/validatorRegistry.algo.ts:661
	// this.reverifyNFDOwnership(poolKey.id)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	callsub reverifyNFDOwnership

	// examples/reti/validatorRegistry.algo.ts:663
	// this.retiOP_epochRewardUpdate.log({
	//       id: poolKey.id,
	//       poolNum: poolKey.poolId as uint16,
	//       poolAppId: AppID.fromUint64(poolKey.poolAppId),
	//       algoAdded: algoToAdd,
	//       rewardTokenHeldBack: rewardTokenAmountReserved,
	//       saturatedBurnToFeeSink: saturatedBurnToFeeSink,
	//       validatorCommission: validatorCommission,
	//     })
	pushbytes 0xb3e47c3d // retiOP_epochRewardUpdate(uint64,uint16,uint64,uint64,uint64,uint64,uint64)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	itob
	dup
	bitlen
	intc 18 // 16
	<=

	// poolKey.poolId as uint16 overflowed 16 bits
	assert
	extract 6 2
	concat
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	itob
	concat
	frame_dig -4 // validatorCommission: uint64
	itob
	concat
	frame_dig -5 // saturatedBurnToFeeSink: uint64
	itob
	concat
	frame_dig -2 // algoToAdd: uint64
	itob
	concat
	frame_dig -3 // rewardTokenAmountReserved: uint64
	itob
	concat
	concat
	log
	retsub

// stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void
*abi_route_stakeRemoved:
	// stakerRemoved: bool
	txna ApplicationArgs 5
	dup
	len
	intc 1 // 1
	==

	// argument 0 (stakerRemoved) for stakeRemoved must be a bool
	assert
	intc 0 // 0
	getbit

	// rewardRemoved: uint64
	txna ApplicationArgs 4
	btoi

	// amountRemoved: uint64
	txna ApplicationArgs 3
	btoi

	// staker: address
	txna ApplicationArgs 2
	dup
	len
	intc 6 // 32
	==

	// argument 3 (staker) for stakeRemoved must be a address
	assert

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 24
	==

	// argument 4 (poolKey) for stakeRemoved must be a (uint64,uint64,uint64)
	assert

	// execute stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void
	callsub stakeRemoved
	intc 1 // 1
	return

// stakeRemoved(poolKey: ValidatorPoolKey, staker: Address, amountRemoved: uint64, rewardRemoved: uint64, stakerRemoved: boolean): void
//
// stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
// from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
// If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
// The calling App id is validated against our pool list as well.
//
// @param {ValidatorPoolKey} poolKey calling us from which stake was removed
// @param {Address} staker
// @param {uint64} amountRemoved - algo amount removed
// @param {uint64} rewardRemoved - if applicable, amount of token reward removed (by pool 1 caller) or TO remove and pay out (via pool 1 from different pool caller)
// @param {boolean} stakerRemoved
stakeRemoved:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 3

	// *if17_condition
	// examples/reti/validatorRegistry.algo.ts:693
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 29 // 300
	<
	bz *if17_end

	// *if17_consequent
	// examples/reti/validatorRegistry.algo.ts:694
	// increaseOpcodeBudget()
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 8 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 26 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if17_end:
	// examples/reti/validatorRegistry.algo.ts:696
	// this.verifyPoolKeyCaller(poolKey)
	frame_dig -1 // poolKey: ValidatorPoolKey
	callsub verifyPoolKeyCaller

	// examples/reti/validatorRegistry.algo.ts:700
	// assert(amountRemoved > 0 || rewardRemoved > 0, 'should only be called if algo or reward was removed')
	frame_dig -3 // amountRemoved: uint64
	intc 0 // 0
	>
	dup
	bnz *skip_or2
	frame_dig -4 // rewardRemoved: uint64
	intc 0 // 0
	>
	||

*skip_or2:
	// should only be called if algo or reward was removed
	assert

	// examples/reti/validatorRegistry.algo.ts:703
	// this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].totalAlgoStaked -= amountRemoved
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // amountRemoved: uint64
	-
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:704
	// this.validatorList(poolKey.id).value.state.totalAlgoStaked -= amountRemoved
	intc 12 // 252
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // amountRemoved: uint64
	-
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:705
	// this.totalAlgoStaked.value -= amountRemoved
	bytec 4 //  "staked"
	app_global_get
	frame_dig -3 // amountRemoved: uint64
	-
	bytec 4 //  "staked"
	swap
	app_global_put

	// *if18_condition
	// examples/reti/validatorRegistry.algo.ts:707
	// rewardRemoved > 0
	frame_dig -4 // rewardRemoved: uint64
	intc 0 // 0
	>
	bz *if18_else

	// *if18_consequent
	// examples/reti/validatorRegistry.algo.ts:708
	// rewardTokenID = this.validatorList(poolKey.id).value.config.rewardTokenId
	intc 38 // 153
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // rewardTokenID: uint64

	// examples/reti/validatorRegistry.algo.ts:709
	// assert(rewardTokenID !== 0, "rewardRemoved can't be set if validator doesn't have reward token!")
	frame_dig 0 // rewardTokenID: uint64
	intc 0 // 0
	!=

	// rewardRemoved can't be set if validator doesn't have reward token!
	assert

	// examples/reti/validatorRegistry.algo.ts:710
	// assert(
	//         this.validatorList(poolKey.id).value.state.rewardTokenHeldBack >= rewardRemoved,
	//         'reward being removed must be covered by hold back amount'
	//       )
	intc 13 // 260
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -4 // rewardRemoved: uint64
	>=

	// reward being removed must be covered by hold back amount
	assert

	// examples/reti/validatorRegistry.algo.ts:716
	// this.validatorList(poolKey.id).value.state.rewardTokenHeldBack -= rewardRemoved
	intc 13 // 260
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -4 // rewardRemoved: uint64
	-
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// *if19_condition
	// examples/reti/validatorRegistry.algo.ts:721
	// poolKey.poolId !== 1
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	!=
	bz *if19_end

	// *if19_consequent
	// examples/reti/validatorRegistry.algo.ts:722
	// sendMethodCall<typeof StakingPool.prototype.payTokenReward>({
	//           applicationID: AppID.fromUint64(this.validatorList(poolKey.id).value.pools[0].poolAppId),
	//           methodArgs: [staker, rewardTokenID, rewardRemoved],
	//         })
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	bytec 13 //  method "payTokenReward(address,uint64,uint64)void"
	itxn_field ApplicationArgs

	// examples/reti/validatorRegistry.algo.ts:723
	// applicationID: AppID.fromUint64(this.validatorList(poolKey.id).value.pools[0].poolAppId)
	intc 5 // 268
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	itxn_field ApplicationID

	// examples/reti/validatorRegistry.algo.ts:724
	// methodArgs: [staker, rewardTokenID, rewardRemoved]
	frame_dig -2 // staker: Address
	itxn_field ApplicationArgs
	frame_dig 0 // rewardTokenID: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -4 // rewardRemoved: uint64
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if19_end:
	// examples/reti/validatorRegistry.algo.ts:727
	// this.retiOP_stakeRemoved.log({
	//         id: poolKey.id,
	//         poolNum: poolKey.poolId as uint16,
	//         poolAppId: AppID.fromUint64(poolKey.poolAppId),
	//         staker: staker,
	//         amountUnstaked: amountRemoved,
	//         rewardTokenAssetId: AssetID.fromUint64(rewardTokenID),
	//         rewardTokensReceived: rewardRemoved,
	//       })
	bytec 14 //  retiOP_stakeRemoved(uint64,uint16,uint64,address,uint64,uint64,uint64)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	itob
	dup
	bitlen
	intc 18 // 16
	<=

	// poolKey.poolId as uint16 overflowed 16 bits
	assert
	extract 6 2
	concat
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	itob
	concat
	frame_dig -2 // staker: Address
	concat
	frame_dig -3 // amountRemoved: uint64
	itob
	concat
	frame_dig -4 // rewardRemoved: uint64
	itob
	concat
	frame_dig 0 // rewardTokenID: uint64
	itob
	concat
	concat
	log
	b *if18_end

*if18_else:
	// examples/reti/validatorRegistry.algo.ts:737
	// this.retiOP_stakeRemoved.log({
	//         id: poolKey.id,
	//         poolNum: poolKey.poolId as uint16,
	//         poolAppId: AppID.fromUint64(poolKey.poolAppId),
	//         staker: staker,
	//         amountUnstaked: amountRemoved,
	//         // no tokens rewarded..
	//         rewardTokenAssetId: AssetID.zeroIndex,
	//         rewardTokensReceived: 0,
	//       })
	bytec 14 //  retiOP_stakeRemoved(uint64,uint16,uint64,address,uint64,uint64,uint64)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	itob
	dup
	bitlen
	intc 18 // 16
	<=

	// poolKey.poolId as uint16 overflowed 16 bits
	assert
	extract 6 2
	concat
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	itob
	concat
	frame_dig -2 // staker: Address
	concat
	frame_dig -3 // amountRemoved: uint64
	itob
	concat
	bytec 7 // 0x0000000000000000
	concat
	bytec 7 // 0x0000000000000000
	concat
	concat
	log

*if18_end:
	// *if20_condition
	// examples/reti/validatorRegistry.algo.ts:749
	// stakerRemoved
	frame_dig -5 // stakerRemoved: boolean
	bz *if20_end

	// *if20_consequent
	// examples/reti/validatorRegistry.algo.ts:751
	// this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].totalStakers -= 1
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 2 //  headOffset
	+
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 2 //  headOffset
	+
	intc 10 // 2
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	itob
	extract 6 2
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:753
	// removeRet = this.removeFromStakerPoolSet(staker, <ValidatorPoolKey>{
	//         id: poolKey.id,
	//         poolId: poolKey.poolId,
	//         poolAppId: poolKey.poolAppId,
	//       })
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	itob
	concat
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	itob
	concat
	frame_dig -2 // staker: Address
	callsub removeFromStakerPoolSet
	frame_bury 1 // removeRet: (bool,bool)

	// examples/reti/validatorRegistry.algo.ts:758
	// stakerOutOfThisValidator = removeRet[0]
	frame_dig 1 // removeRet: (bool,bool)
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	frame_bury 2 // stakerOutOfThisValidator: bool

	// examples/reti/validatorRegistry.algo.ts:759
	// stakerOutOfProtocol = removeRet[1]
	frame_dig 1 // removeRet: (bool,bool)
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	getbit
	frame_bury 3 // stakerOutOfProtocol: bool

	// *if21_condition
	// examples/reti/validatorRegistry.algo.ts:761
	// stakerOutOfThisValidator
	frame_dig 2 // stakerOutOfThisValidator: bool
	bz *if21_end

	// *if21_consequent
	// examples/reti/validatorRegistry.algo.ts:762
	// this.validatorList(poolKey.id).value.state.totalStakers -= 1
	intc 23 // 244
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

*if21_end:
	// *if22_condition
	// examples/reti/validatorRegistry.algo.ts:765
	// stakerOutOfProtocol
	frame_dig 3 // stakerOutOfProtocol: bool
	bz *if22_end

	// *if22_consequent
	// examples/reti/validatorRegistry.algo.ts:766
	// this.numStakers.value -= 1
	bytec 6 //  "numStakers"
	app_global_get
	intc 1 // 1
	-
	bytec 6 //  "numStakers"
	swap
	app_global_put

*if22_end:

*if20_end:
	retsub

// findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)
*abi_route_findPoolForStaker:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// amountToStake: uint64
	txna ApplicationArgs 3
	btoi

	// staker: address
	txna ApplicationArgs 2
	dup
	len
	intc 6 // 32
	==

	// argument 1 (staker) for findPoolForStaker must be a address
	assert

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)
	callsub findPoolForStaker
	concat
	log
	intc 1 // 1
	return

// findPoolForStaker(validatorId: ValidatorIdType, staker: Address, amountToStake: uint64): [ValidatorPoolKey, boolean, boolean]
//
// Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
// First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
// to new pool if necessary.
//
// @param {ValidatorIdType} validatorId - The id of the validator.
// @param {Address} staker - The address of the staker.
// @param {uint64} amountToStake - The amount to stake.
// @returns {ValidatorPoolKey, boolean, boolean} - The pool for the staker, true/false on whether the staker is 'new'
// to this VALIDATOR, and true/false if staker is new to the protocol.
findPoolForStaker:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 7

	// examples/reti/validatorRegistry.algo.ts:788
	// isNewStakerToValidator = true
	intc 1 // 1
	frame_bury 0 // isNewStakerToValidator: bool

	// examples/reti/validatorRegistry.algo.ts:789
	// isNewStakerToProtocol = true
	intc 1 // 1
	frame_bury 1 // isNewStakerToProtocol: bool

	// examples/reti/validatorRegistry.algo.ts:797
	// maxPerPool = this.getCurMaxStakePerPool(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub getCurMaxStakePerPool
	frame_bury 2 // maxPerPool: uint64

	// *if23_condition
	// examples/reti/validatorRegistry.algo.ts:800
	// this.stakerPoolSet(staker).exists
	bytec 3 //  "sps"
	frame_dig -2 // staker: Address
	concat
	box_len
	swap
	pop
	bz *if23_end

	// *if23_consequent
	// examples/reti/validatorRegistry.algo.ts:801
	// poolSet = clone(this.stakerPoolSet(staker).value)
	bytec 3 //  "sps"
	frame_dig -2 // staker: Address
	concat
	box_get

	// box value does not exist: this.stakerPoolSet(staker).value
	assert
	frame_bury 3 // poolSet: (uint64,uint64,uint64)[6]

	// examples/reti/validatorRegistry.algo.ts:802
	// assert(validatorId !== 0)
	frame_dig -1 // validatorId: ValidatorIdType
	intc 0 // 0
	!=
	assert

	// examples/reti/validatorRegistry.algo.ts:803
	// for (let i = 0; i < poolSet.length; i += 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_3:
	// examples/reti/validatorRegistry.algo.ts:803
	// i < poolSet.length
	frame_dig 4 // i: uint64
	intc 7 // 6
	<
	bz *for_3_end

	// *if24_condition
	// examples/reti/validatorRegistry.algo.ts:804
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 29 // 300
	<
	bz *if24_end

	// *if24_consequent
	// examples/reti/validatorRegistry.algo.ts:805
	// increaseOpcodeBudget()
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 8 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 26 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if24_end:
	// *if25_condition
	// examples/reti/validatorRegistry.algo.ts:807
	// poolSet[i].id === 0
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	intc 0 // 0
	==
	bz *if25_end

	// *if25_consequent
	b *for_3_continue

*if25_end:
	// examples/reti/validatorRegistry.algo.ts:810
	// isNewStakerToProtocol = false
	intc 0 // 0
	frame_bury 1 // isNewStakerToProtocol: bool

	// *if26_condition
	// examples/reti/validatorRegistry.algo.ts:811
	// poolSet[i].id === validatorId
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	frame_dig -1 // validatorId: ValidatorIdType
	==
	bz *if26_end

	// *if26_consequent
	// examples/reti/validatorRegistry.algo.ts:813
	// isNewStakerToValidator = false
	intc 0 // 0
	frame_bury 0 // isNewStakerToValidator: bool

	// *if27_condition
	// examples/reti/validatorRegistry.algo.ts:815
	// this.validatorList(validatorId).value.pools[poolSet[i].poolId - 1].totalAlgoStaked + amountToStake <=
	//             maxPerPool
	intc 5 //  headOffset
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 2 //  headOffset
	+
	intc 2 // 8
	extract3
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // amountToStake: uint64
	+
	frame_dig 2 // maxPerPool: uint64
	<=
	bz *if27_end

	// *if27_consequent
	// examples/reti/validatorRegistry.algo.ts:818
	// return [poolSet[i], isNewStakerToValidator, isNewStakerToProtocol];
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 3 // 24
	extract3
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 0 // isNewStakerToValidator: bool
	setbit
	intc 1 // 1
	frame_dig 1 // isNewStakerToProtocol: bool
	setbit
	concat
	b *findPoolForStaker*return

*if27_end:

*if26_end:

*for_3_continue:
	// examples/reti/validatorRegistry.algo.ts:803
	// i += 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_3

*for_3_end:

*if23_end:
	// examples/reti/validatorRegistry.algo.ts:825
	// assert(
	//       amountToStake >= this.validatorList(validatorId).value.config.minEntryStake,
	//       'must stake at least the minimum for this pool'
	//     )
	frame_dig -3 // amountToStake: uint64
	intc 39 // 209
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	>=

	// must stake at least the minimum for this pool
	assert

	// examples/reti/validatorRegistry.algo.ts:831
	// pools = clone(this.validatorList(validatorId).value.pools)
	intc 5 //  headOffset
	intc 30 // 432
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_bury 5 // pools: (uint64,uint16,uint64)[24]

	// examples/reti/validatorRegistry.algo.ts:832
	// curNumPools = this.validatorList(validatorId).value.state.numPools as uint64
	intc 9 // 242
	intc 10 // 2
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 6 // curNumPools: uint64

	// examples/reti/validatorRegistry.algo.ts:833
	// for (let i = 0; i < curNumPools; i += 1)
	intc 0 // 0
	frame_bury 7 // i: uint64

*for_4:
	// examples/reti/validatorRegistry.algo.ts:833
	// i < curNumPools
	frame_dig 7 // i: uint64
	frame_dig 6 // curNumPools: uint64
	<
	bz *for_4_end

	// *if28_condition
	// examples/reti/validatorRegistry.algo.ts:834
	// pools[i].totalAlgoStaked + amountToStake <= maxPerPool
	frame_dig 5 // pools: (uint64,uint16,uint64)[24]
	frame_dig 7 // i: uint64
	intc 4 // 18
	* // acc * typeLength
	intc 11 //  headOffset
	+
	intc 2 // 8
	extract3
	btoi
	frame_dig -3 // amountToStake: uint64
	+
	frame_dig 2 // maxPerPool: uint64
	<=
	bz *if28_end

	// *if28_consequent
	// examples/reti/validatorRegistry.algo.ts:835
	// return [
	//           { id: validatorId, poolId: i + 1, poolAppId: pools[i].poolAppId },
	//           isNewStakerToValidator,
	//           isNewStakerToProtocol,
	//         ];
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	frame_dig 7 // i: uint64
	intc 1 // 1
	+
	itob
	concat
	frame_dig 5 // pools: (uint64,uint16,uint64)[24]
	frame_dig 7 // i: uint64
	intc 4 // 18
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	itob
	concat
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 0 // isNewStakerToValidator: bool
	setbit
	intc 1 // 1
	frame_dig 1 // isNewStakerToProtocol: bool
	setbit
	concat
	b *findPoolForStaker*return

*if28_end:

*for_4_continue:
	// examples/reti/validatorRegistry.algo.ts:833
	// i += 1
	frame_dig 7 // i: uint64
	intc 1 // 1
	+
	frame_bury 7 // i: uint64
	b *for_4

*for_4_end:
	// examples/reti/validatorRegistry.algo.ts:843
	// return [{ id: validatorId, poolId: 0, poolAppId: 0 }, isNewStakerToValidator, isNewStakerToProtocol];
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	bytec 7 // 0x0000000000000000
	concat
	bytec 7 // 0x0000000000000000
	concat
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 0 // isNewStakerToValidator: bool
	setbit
	intc 1 // 1
	frame_dig 1 // isNewStakerToProtocol: bool
	setbit
	concat

*findPoolForStaker*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// movePoolToNode(uint64,uint64,uint64)void
*abi_route_movePoolToNode:
	// nodeNum: uint64
	txna ApplicationArgs 3
	btoi

	// poolAppId: uint64
	txna ApplicationArgs 2
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute movePoolToNode(uint64,uint64,uint64)void
	callsub movePoolToNode
	intc 1 // 1
	return

// movePoolToNode(validatorId: ValidatorIdType, poolAppId: uint64, nodeNum: uint64): void
//
// Find the specified pool (in any node number) and move it to the specified node.
// The pool account is forced offline if moved so prior node will still run for 320 rounds but
// new key goes online on new node soon after (320 rounds after it goes online)
// No-op if success, asserts if not found or can't move  (no space in target)
// [ ONLY OWNER OR MANAGER CAN CHANGE ]
//
// @param {ValidatorIdType} validatorId - The id of the validator.
// @param {uint64} poolAppId
// @param {uint64} nodeNum
movePoolToNode:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// examples/reti/validatorRegistry.algo.ts:858
	// this.callerMustBeOwnerOrManager(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwnerOrManager

	// examples/reti/validatorRegistry.algo.ts:860
	// nodePoolAssignments = clone(this.validatorList(validatorId).value.nodePoolAssignments)
	intc 17 //  headOffset
	intc 22 // 192
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_bury 0 // nodePoolAssignments: ((uint64[3])[8])

	// examples/reti/validatorRegistry.algo.ts:861
	// assert(nodeNum >= 1 && nodeNum <= MAX_NODES, 'node number out of allowable range')
	frame_dig -3 // nodeNum: uint64
	intc 1 // 1
	>=
	dup
	bz *skip_and2
	frame_dig -3 // nodeNum: uint64
	intc 2 // 8
	<=
	&&

*skip_and2:
	// node number out of allowable range
	assert

	// examples/reti/validatorRegistry.algo.ts:863
	// for (let srcNodeIdx = 0; srcNodeIdx < MAX_NODES; srcNodeIdx += 1)
	intc 0 // 0
	frame_bury 1 // srcNodeIdx: uint64

*for_5:
	// examples/reti/validatorRegistry.algo.ts:863
	// srcNodeIdx < MAX_NODES
	frame_dig 1 // srcNodeIdx: uint64
	intc 2 // 8
	<
	bz *for_5_end

	// examples/reti/validatorRegistry.algo.ts:864
	// for (let i = 0; i < MAX_POOLS_PER_NODE; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_6:
	// examples/reti/validatorRegistry.algo.ts:864
	// i < MAX_POOLS_PER_NODE
	frame_dig 2 // i: uint64
	intc 8 // 3
	<
	bz *for_6_end

	// *if29_condition
	// examples/reti/validatorRegistry.algo.ts:865
	// nodePoolAssignments.nodes[srcNodeIdx].poolAppIds[i] === poolAppId
	frame_dig 0 // nodePoolAssignments: ((uint64[3])[8])
	intc 0 // 0
	frame_dig 1 // srcNodeIdx: uint64
	intc 3 // 24
	* // acc * typeLength
	+
	intc 0 // 0
	+
	frame_dig 2 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	intc 2 // 8
	extract3
	btoi
	frame_dig -2 // poolAppId: uint64
	==
	bz *if29_end

	// *if29_consequent
	// examples/reti/validatorRegistry.algo.ts:866
	// assert(nodeNum - 1 !== srcNodeIdx, "can't move to same node")
	frame_dig -3 // nodeNum: uint64
	intc 1 // 1
	-
	frame_dig 1 // srcNodeIdx: uint64
	!=

	// can't move to same node
	assert

	// examples/reti/validatorRegistry.algo.ts:868
	// this.validatorList(validatorId).value.nodePoolAssignments.nodes[srcNodeIdx].poolAppIds[i] = 0
	intc 17 // 900
	frame_dig 1 // srcNodeIdx: uint64
	intc 3 // 24
	* // acc * typeLength
	+
	intc 0 // 0
	+
	frame_dig 2 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	bytec 7 // 0x0000000000000000
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:871
	// sendMethodCall<typeof StakingPool.prototype.goOffline>({
	//             applicationID: AppID.fromUint64(poolAppId),
	//           })
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	pushbytes 0x51ef3b21 // method "goOffline()void"
	itxn_field ApplicationArgs

	// examples/reti/validatorRegistry.algo.ts:872
	// applicationID: AppID.fromUint64(poolAppId)
	frame_dig -2 // poolAppId: uint64
	itxn_field ApplicationID

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/reti/validatorRegistry.algo.ts:876
	// this.addPoolToNode(validatorId, poolAppId, nodeNum)
	frame_dig -3 // nodeNum: uint64
	frame_dig -2 // poolAppId: uint64
	frame_dig -1 // validatorId: ValidatorIdType
	callsub addPoolToNode

	// examples/reti/validatorRegistry.algo.ts:877
	// return;
	retsub

*if29_end:

*for_6_continue:
	// examples/reti/validatorRegistry.algo.ts:864
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_6

*for_6_end:

*for_5_continue:
	// examples/reti/validatorRegistry.algo.ts:863
	// srcNodeIdx += 1
	frame_dig 1 // srcNodeIdx: uint64
	intc 1 // 1
	+
	frame_bury 1 // srcNodeIdx: uint64
	b *for_5

*for_5_end:
	// couldn't find pool app id in nodes to move
	err
	retsub

// emptyTokenRewards(uint64,address)uint64
*abi_route_emptyTokenRewards:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// receiver: address
	txna ApplicationArgs 2
	dup
	len
	intc 6 // 32
	==

	// argument 0 (receiver) for emptyTokenRewards must be a address
	assert

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute emptyTokenRewards(uint64,address)uint64
	callsub emptyTokenRewards
	itob
	concat
	log
	intc 1 // 1
	return

// emptyTokenRewards(validatorId: ValidatorIdType, receiver: Address): uint64
//
// Sends the reward tokens held in pool 1 to specified receiver.
// This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
// the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
// NOT be sent as they must be held back for stakers to later claim.
// [ ONLY OWNER CAN CALL]
//
// @param {ValidatorIdType} validatorId - The id of the validator.
// @param {Address} receiver - the account to send the tokens to (must already be opted-in to the reward token)
// @returns {uint64} the amount of reward token sent
emptyTokenRewards:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 3

	// examples/reti/validatorRegistry.algo.ts:896
	// this.callerMustBeOwner(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwner

	// examples/reti/validatorRegistry.algo.ts:897
	// rewardTokenId = this.validatorList(validatorId).value.config.rewardTokenId
	intc 38 // 153
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // rewardTokenId: uint64

	// examples/reti/validatorRegistry.algo.ts:898
	// rewardTokenHeldBack = this.validatorList(validatorId).value.state.rewardTokenHeldBack
	intc 13 // 260
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // rewardTokenHeldBack: uint64

	// examples/reti/validatorRegistry.algo.ts:899
	// assert(rewardTokenId !== 0, "this validator doesn't have a reward token defined")
	frame_dig 0 // rewardTokenId: uint64
	intc 0 // 0
	!=

	// this validator doesn't have a reward token defined
	assert

	// examples/reti/validatorRegistry.algo.ts:900
	// poolOneAppId = AppID.fromUint64(this.validatorList(validatorId).value.pools[0].poolAppId)
	intc 5 // 268
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 2 // poolOneAppId: uint64

	// examples/reti/validatorRegistry.algo.ts:902
	// tokenRewardBal = poolOneAppId.address.assetBalance(AssetID.fromUint64(rewardTokenId)) - rewardTokenHeldBack
	frame_dig 2 // poolOneAppId: uint64
	app_params_get AppAddress
	pop
	frame_dig 0 // rewardTokenId: uint64
	asset_holding_get AssetBalance
	pop
	frame_dig 1 // rewardTokenHeldBack: uint64
	-
	frame_bury 3 // tokenRewardBal: uint64

	// examples/reti/validatorRegistry.algo.ts:905
	// sendMethodCall<typeof StakingPool.prototype.payTokenReward>({
	//       applicationID: poolOneAppId,
	//       methodArgs: [receiver, rewardTokenId, tokenRewardBal],
	//     })
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	bytec 13 //  method "payTokenReward(address,uint64,uint64)void"
	itxn_field ApplicationArgs

	// examples/reti/validatorRegistry.algo.ts:906
	// applicationID: poolOneAppId
	frame_dig 2 // poolOneAppId: uint64
	itxn_field ApplicationID

	// examples/reti/validatorRegistry.algo.ts:907
	// methodArgs: [receiver, rewardTokenId, tokenRewardBal]
	frame_dig -2 // receiver: Address
	itxn_field ApplicationArgs
	frame_dig 0 // rewardTokenId: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig 3 // tokenRewardBal: uint64
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/reti/validatorRegistry.algo.ts:909
	// assert(
	//       poolOneAppId.address.assetBalance(AssetID.fromUint64(rewardTokenId)) === rewardTokenHeldBack,
	//       'balance of remaining reward tokens should match the held back amount'
	//     )
	frame_dig 2 // poolOneAppId: uint64
	app_params_get AppAddress
	pop
	frame_dig 0 // rewardTokenId: uint64
	asset_holding_get AssetBalance
	pop
	frame_dig 1 // rewardTokenHeldBack: uint64
	==

	// balance of remaining reward tokens should match the held back amount
	assert

	// examples/reti/validatorRegistry.algo.ts:913
	// return tokenRewardBal;
	frame_dig 3 // tokenRewardBal: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// callerMustBeOwner(validatorId: ValidatorIdType): void
callerMustBeOwner:
	proto 1 0

	// examples/reti/validatorRegistry.algo.ts:1006
	// assert(
	//       this.txn.sender === this.validatorList(validatorId).value.config.owner,
	//       'can only be called by validator owner'
	//     )
	txn Sender
	intc 2 // 8
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	==

	// can only be called by validator owner
	assert
	retsub

// callerMustBeOwnerOrManager(validatorId: ValidatorIdType): void
callerMustBeOwnerOrManager:
	proto 1 0

	// examples/reti/validatorRegistry.algo.ts:1013
	// assert(
	//       this.txn.sender === this.validatorList(validatorId).value.config.owner ||
	//         this.txn.sender === this.validatorList(validatorId).value.config.manager,
	//       'can only be called by owner or manager of validator'
	//     )
	txn Sender
	intc 2 // 8
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	==
	dup
	bnz *skip_or3
	txn Sender
	intc 20 // 40
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	==
	||

*skip_or3:
	// can only be called by owner or manager of validator
	assert
	retsub

// verifyPoolKeyCaller(poolKey: ValidatorPoolKey): void
//
// verifyPoolKeyCaller verifies the passed in key (from a staking pool calling us to update metrics) is valid
// and matches the information we have in our state.  'Fake' pools could call us to update our data, but they
// can't fake the ids and most importantly application id(!) of the caller that has to match.
verifyPoolKeyCaller:
	proto 1 0

	// examples/reti/validatorRegistry.algo.ts:1026
	// assert(this.validatorList(poolKey.id).exists, "the specified validator id isn't valid")
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	box_len
	swap
	pop

	// the specified validator id isn't valid
	assert

	// examples/reti/validatorRegistry.algo.ts:1027
	// assert(poolKey.poolId <= MAX_POOLS, 'pool id not in valid range')
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 3 // 24
	<=

	// pool id not in valid range
	assert

	// examples/reti/validatorRegistry.algo.ts:1028
	// assert(
	//       poolKey.poolId > 0 && (poolKey.poolId as uint16) <= this.validatorList(poolKey.id).value.state.numPools,
	//       'pool id outside of range of pools created for this validator'
	//     )
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 0 // 0
	>
	dup
	bz *skip_and3
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 9 // 242
	intc 10 // 2
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	<=
	&&

*skip_and3:
	// pool id outside of range of pools created for this validator
	assert

	// examples/reti/validatorRegistry.algo.ts:1034
	// assert(
	//       poolKey.poolAppId === this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].poolAppId,
	//       "The passed in app id doesn't match the passed in ids"
	//     )
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 0 // 0
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	==

	// The passed in app id doesn't match the passed in ids
	assert

	// examples/reti/validatorRegistry.algo.ts:1039
	// assert(this.txn.sender === AppID.fromUint64(poolKey.poolAppId).address)
	txn Sender
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	app_params_get AppAddress
	pop
	==
	assert

	// examples/reti/validatorRegistry.algo.ts:1041
	// assert(poolKey.id === (AppID.fromUint64(poolKey.poolAppId).globalState('validatorId') as uint64))
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	pushbytes 0x76616c696461746f724964 // "validatorId"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(poolKey.poolAppId).globalState('validatorId')
	assert
	==
	assert

	// examples/reti/validatorRegistry.algo.ts:1042
	// assert(poolKey.poolId === (AppID.fromUint64(poolKey.poolAppId).globalState('poolId') as uint64))
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	pushbytes 0x706f6f6c4964 // "poolId"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(poolKey.poolAppId).globalState('poolId')
	assert
	==
	assert
	retsub

// reverifyNFDOwnership(validatorId: ValidatorIdType): void
//
// This method verifies the ownership of NFD (Named Function Data) by a validator.
// If the ownership is no longer valid, it removes the NFD from the validator's configuration.
//
// @param {ValidatorIdType} validatorId - The id of the validator whose data should be re-evaluated.
reverifyNFDOwnership:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// examples/reti/validatorRegistry.algo.ts:1052
	// validatorConfig = this.validatorList(validatorId).value.config
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	frame_bury 0 // storage key//validatorConfig

	// *if30_condition
	// examples/reti/validatorRegistry.algo.ts:1053
	// validatorConfig.nfdForInfo !== 0
	intc 21 // 72
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 0
	!=
	bz *if30_end

	// *if30_consequent
	// examples/reti/validatorRegistry.algo.ts:1056
	// nfdOwner = AppID.fromUint64(validatorConfig.nfdForInfo).globalState('i.owner.a') as Address
	intc 21 // 72
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	bytec 10 //  "i.owner.a"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(validatorConfig.nfdForInfo).globalState('i.owner.a')
	assert
	frame_bury 1 // nfdOwner: address

	// *if31_condition
	// examples/reti/validatorRegistry.algo.ts:1058
	// validatorConfig.owner !== nfdOwner && validatorConfig.manager !== nfdOwner
	intc 2 // 8
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_dig 1 // nfdOwner: address
	!=
	dup
	bz *skip_and4
	intc 20 // 40
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_dig 1 // nfdOwner: address
	!=
	&&

*skip_and4:
	bz *if31_end

	// *if31_consequent
	// examples/reti/validatorRegistry.algo.ts:1060
	// this.validatorList(validatorId).value.config.nfdForInfo = 0
	intc 21 // 72
	bytec 7 // 0x0000000000000000
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

*if31_end:

*if30_end:
	retsub

// validateConfig(config: ValidatorConfig): void
validateConfig:
	proto 1 0

	// examples/reti/validatorRegistry.algo.ts:1067
	// assert(config.owner !== Address.zeroAddress)
	frame_dig -1 // config: ValidatorConfig
	extract 8 32
	global ZeroAddress
	!=
	assert

	// examples/reti/validatorRegistry.algo.ts:1068
	// assert(config.manager !== Address.zeroAddress)
	frame_dig -1 // config: ValidatorConfig
	extract 40 32
	global ZeroAddress
	!=
	assert

	// examples/reti/validatorRegistry.algo.ts:1069
	// assert(this.txn.sender === config.owner, 'sender must be owner to add new validator')
	txn Sender
	frame_dig -1 // config: ValidatorConfig
	extract 8 32
	==

	// sender must be owner to add new validator
	assert

	// examples/reti/validatorRegistry.algo.ts:1071
	// assert(
	//       config.entryGatingType >= GATING_TYPE_NONE && config.entryGatingType <= GATING_TYPE_CONST_MAX,
	//       'gating type not valid'
	//     )
	frame_dig -1 // config: ValidatorConfig
	extract 80 1
	btoi
	intc 0 // 0
	>=
	dup
	bz *skip_and5
	frame_dig -1 // config: ValidatorConfig
	extract 80 1
	btoi
	intc 15 // 4
	<=
	&&

*skip_and5:
	// gating type not valid
	assert

	// examples/reti/validatorRegistry.algo.ts:1075
	// assert(
	//       config.epochRoundLength >= MIN_EPOCH_LENGTH && config.epochRoundLength <= MAX_EPOCH_LENGTH,
	//       'epoch length not in allowable range'
	//     )
	frame_dig -1 // config: ValidatorConfig
	extract 169 4
	btoi
	intc 1 // 1
	>=
	dup
	bz *skip_and6
	frame_dig -1 // config: ValidatorConfig
	extract 169 4
	btoi
	intc 24 // 1000000
	<=
	&&

*skip_and6:
	// epoch length not in allowable range
	assert

	// examples/reti/validatorRegistry.algo.ts:1079
	// assert(
	//       config.percentToValidator >= MIN_PCT_TO_VALIDATOR && config.percentToValidator <= MAX_PCT_TO_VALIDATOR,
	//       'commission percentage not valid'
	//     )
	frame_dig -1 // config: ValidatorConfig
	extract 173 4
	btoi
	intc 0 // 0
	>=
	dup
	bz *skip_and7
	frame_dig -1 // config: ValidatorConfig
	extract 173 4
	btoi
	intc 24 // 1000000
	<=
	&&

*skip_and7:
	// commission percentage not valid
	assert

	// *if32_condition
	// examples/reti/validatorRegistry.algo.ts:1083
	// config.percentToValidator !== 0
	frame_dig -1 // config: ValidatorConfig
	extract 173 4
	btoi
	intc 0 // 0
	!=
	bz *if32_end

	// *if32_consequent
	// examples/reti/validatorRegistry.algo.ts:1084
	// assert(
	//         config.validatorCommissionAddress !== Address.zeroAddress,
	//         'validatorCommissionAddress must be set if percent to validator is not 0'
	//       )
	frame_dig -1 // config: ValidatorConfig
	extract 177 32
	global ZeroAddress
	!=

	// validatorCommissionAddress must be set if percent to validator is not 0
	assert

*if32_end:
	// examples/reti/validatorRegistry.algo.ts:1089
	// assert(config.minEntryStake >= MIN_ALGO_STAKE_PER_POOL, 'staking pool must have minimum entry of 1 algo')
	frame_dig -1 // config: ValidatorConfig
	extract 209 8
	btoi
	intc 24 // 1000000
	>=

	// staking pool must have minimum entry of 1 algo
	assert

	// examples/reti/validatorRegistry.algo.ts:1091
	// assert(
	//       config.poolsPerNode > 0 && config.poolsPerNode <= MAX_POOLS_PER_NODE,
	//       'number of pools per node must be be between 1 and the maximum allowed number'
	//     )
	frame_dig -1 // config: ValidatorConfig
	extract 225 1
	btoi
	intc 0 // 0
	>
	dup
	bz *skip_and8
	frame_dig -1 // config: ValidatorConfig
	extract 225 1
	btoi
	intc 8 // 3
	<=
	&&

*skip_and8:
	// number of pools per node must be be between 1 and the maximum allowed number
	assert

	// *if33_condition
	// examples/reti/validatorRegistry.algo.ts:1095
	// config.sunsettingOn !== 0
	frame_dig -1 // config: ValidatorConfig
	extract 226 8
	btoi
	intc 0 // 0
	!=
	bz *if33_end

	// *if33_consequent
	// examples/reti/validatorRegistry.algo.ts:1096
	// assert(config.sunsettingOn > globals.latestTimestamp, 'sunsettingOn must be later than now if set')
	frame_dig -1 // config: ValidatorConfig
	extract 226 8
	btoi
	global LatestTimestamp
	>

	// sunsettingOn must be later than now if set
	assert

*if33_end:
	retsub

// callPoolAddStake(stakedAmountPayment: PayTxn, poolKey: ValidatorPoolKey, mbrAmtPaid: uint64, isNewStakerToValidator: boolean, isNewStakerToProtocol: boolean): void
//
// Adds a stakers amount of algo to a validator pool, transferring the algo we received from them (already verified
// by our caller) to the staking pool account, and then telling it about the amount being added for the specified
// staker.
//
// @param {PayTxn} stakedAmountPayment - payment coming from staker to place into a pool
// @param {ValidatorPoolKey} poolKey - The key of the validator pool.
// @param {uint64} mbrAmtPaid - Amount the user is leaving behind in the validator to pay for their staker MBR cost
// @param {boolean} isNewStakerToValidator - if this is a new, first-time staker to the validator
// @param {boolean} isNewStakerToProtocol - if this is a new, first-time staker to the protocol
callPoolAddStake:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// examples/reti/validatorRegistry.algo.ts:1118
	// poolAppId = this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].poolAppId
	intc 5 //  headOffset
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 0 // 0
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // poolAppId: uint64

	// examples/reti/validatorRegistry.algo.ts:1122
	// sendMethodCall<typeof StakingPool.prototype.addStake, uint64>({
	//       applicationID: AppID.fromUint64(poolAppId),
	//       methodArgs: [
	//         // =======
	//         // THIS IS A SEND of the amount received right back out and into the staking pool contract account.
	//         { amount: stakedAmountPayment.amount - mbrAmtPaid, receiver: AppID.fromUint64(poolAppId).address },
	//         // =======
	//         stakedAmountPayment.sender,
	//       ],
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// examples/reti/validatorRegistry.algo.ts:1127
	// amount: stakedAmountPayment.amount - mbrAmtPaid
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig -3 // mbrAmtPaid: uint64
	-
	itxn_field Amount

	// examples/reti/validatorRegistry.algo.ts:1127
	// receiver: AppID.fromUint64(poolAppId).address
	frame_dig 0 // poolAppId: uint64
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 7 //  appl
	itxn_field TypeEnum
	pushbytes 0xf9c70cbd // method "addStake(pay,address)uint64"
	itxn_field ApplicationArgs

	// examples/reti/validatorRegistry.algo.ts:1123
	// applicationID: AppID.fromUint64(poolAppId)
	frame_dig 0 // poolAppId: uint64
	itxn_field ApplicationID

	// examples/reti/validatorRegistry.algo.ts:1124
	// methodArgs: [
	//         // =======
	//         // THIS IS A SEND of the amount received right back out and into the staking pool contract account.
	//         { amount: stakedAmountPayment.amount - mbrAmtPaid, receiver: AppID.fromUint64(poolAppId).address },
	//         // =======
	//         stakedAmountPayment.sender,
	//       ]
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Sender
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	btoi

	// *if34_condition
	// examples/reti/validatorRegistry.algo.ts:1132
	// globals.opcodeBudget < 500
	global OpcodeBudget
	pushint 500
	<
	bz *if34_end

	// *if34_consequent
	// examples/reti/validatorRegistry.algo.ts:1133
	// increaseOpcodeBudget()
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 8 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 26 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if34_end:
	// examples/reti/validatorRegistry.algo.ts:1137
	// poolNumStakers = AppID.fromUint64(poolAppId).globalState('numStakers') as uint64
	frame_dig 0 // poolAppId: uint64
	bytec 6 //  "numStakers"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(poolAppId).globalState('numStakers')
	assert
	frame_bury 1 // poolNumStakers: uint64

	// examples/reti/validatorRegistry.algo.ts:1138
	// poolAlgoStaked = AppID.fromUint64(poolAppId).globalState('staked') as uint64
	frame_dig 0 // poolAppId: uint64
	bytec 4 //  "staked"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(poolAppId).globalState('staked')
	assert
	frame_bury 2 // poolAlgoStaked: uint64

	// examples/reti/validatorRegistry.algo.ts:1139
	// this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].totalStakers = poolNumStakers as uint16
	intc 5 //  headOffset
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 2 //  headOffset
	+
	frame_dig 1 // poolNumStakers: uint64
	itob
	extract 6 2
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:1140
	// this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].totalAlgoStaked = poolAlgoStaked
	intc 5 //  headOffset
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	frame_dig 2 // poolAlgoStaked: uint64
	itob
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// *if35_condition
	// examples/reti/validatorRegistry.algo.ts:1143
	// isNewStakerToValidator
	frame_dig -4 // isNewStakerToValidator: boolean
	bz *if35_end

	// *if35_consequent
	// examples/reti/validatorRegistry.algo.ts:1144
	// this.validatorList(poolKey.id).value.state.totalStakers += 1
	intc 23 // 244
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	itob
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

*if35_end:
	// *if36_condition
	// examples/reti/validatorRegistry.algo.ts:1146
	// isNewStakerToProtocol
	frame_dig -5 // isNewStakerToProtocol: boolean
	bz *if36_end

	// *if36_consequent
	// examples/reti/validatorRegistry.algo.ts:1147
	// this.numStakers.value += 1
	bytec 6 //  "numStakers"
	app_global_get
	intc 1 // 1
	+
	bytec 6 //  "numStakers"
	swap
	app_global_put

*if36_end:
	// examples/reti/validatorRegistry.algo.ts:1149
	// this.validatorList(poolKey.id).value.state.totalAlgoStaked += stakedAmountPayment.amount - mbrAmtPaid
	intc 12 // 252
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig -3 // mbrAmtPaid: uint64
	-
	+
	itob
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:1150
	// this.totalAlgoStaked.value += stakedAmountPayment.amount - mbrAmtPaid
	bytec 4 //  "staked"
	app_global_get
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig -3 // mbrAmtPaid: uint64
	-
	+
	bytec 4 //  "staked"
	swap
	app_global_put
	retsub

// updateStakerPoolSet(staker: Address, poolKey: ValidatorPoolKey): void
updateStakerPoolSet:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// examples/reti/validatorRegistry.algo.ts:1154
	// assert(this.stakerPoolSet(staker).exists)
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	box_len
	swap
	pop
	assert

	// examples/reti/validatorRegistry.algo.ts:1156
	// poolSet = clone(this.stakerPoolSet(staker).value)
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	box_get

	// box value does not exist: this.stakerPoolSet(staker).value
	assert
	frame_bury 0 // poolSet: (uint64,uint64,uint64)[6]

	// examples/reti/validatorRegistry.algo.ts:1157
	// firstEmpty = 0
	intc 0 // 0
	frame_bury 1 // firstEmpty: uint64

	// examples/reti/validatorRegistry.algo.ts:1158
	// for (let i = 0; i < this.stakerPoolSet(staker).value.length; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_7:
	// examples/reti/validatorRegistry.algo.ts:1158
	// i < this.stakerPoolSet(staker).value.length
	frame_dig 2 // i: uint64
	intc 7 // 6
	<
	bz *for_7_end

	// *if37_condition
	// examples/reti/validatorRegistry.algo.ts:1159
	// poolSet[i] === poolKey
	frame_dig 0 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 2 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 3 // 24
	extract3
	frame_dig -2 // poolKey: ValidatorPoolKey
	==
	bz *if37_end

	// *if37_consequent
	// examples/reti/validatorRegistry.algo.ts:1161
	// return;
	retsub

*if37_end:
	// *if38_condition
	// examples/reti/validatorRegistry.algo.ts:1163
	// firstEmpty === 0 && poolSet[i].id === 0
	frame_dig 1 // firstEmpty: uint64
	intc 0 // 0
	==
	dup
	bz *skip_and9
	frame_dig 0 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 2 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	intc 0 // 0
	==
	&&

*skip_and9:
	bz *if38_end

	// *if38_consequent
	// examples/reti/validatorRegistry.algo.ts:1164
	// firstEmpty = i + 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 1 // firstEmpty: uint64

*if38_end:

*for_7_continue:
	// examples/reti/validatorRegistry.algo.ts:1158
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_7

*for_7_end:
	// *if39_condition
	// examples/reti/validatorRegistry.algo.ts:1167
	// firstEmpty === 0
	frame_dig 1 // firstEmpty: uint64
	intc 0 // 0
	==
	bz *if39_end

	// *if39_consequent
	// No empty slot available in the staker pool set
	err

*if39_end:
	// examples/reti/validatorRegistry.algo.ts:1170
	// this.stakerPoolSet(staker).value[firstEmpty - 1] = poolKey
	frame_dig 1 // firstEmpty: uint64
	intc 1 // 1
	-
	intc 3 // 24
	* // acc * typeLength
	frame_dig -2 // poolKey: ValidatorPoolKey
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	cover 2
	box_replace
	retsub

// removeFromStakerPoolSet(staker: Address, poolKey: ValidatorPoolKey): [boolean, boolean]
//
// Removes a pool key from the staker's active pool set - fails if not found (!)
//
// @param {Address} staker - The address of the staker.
// @param {ValidatorPoolKey} poolKey - The pool key they should be stored in
//
// @return [boolean, boolean] [is the staker gone from ALL pools of the given VALIDATOR, and is staker gone from ALL pools]
removeFromStakerPoolSet:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 4

	// examples/reti/validatorRegistry.algo.ts:1183
	// inSameValidatorPoolCount = 0
	intc 0 // 0
	frame_bury 0 // inSameValidatorPoolCount: uint64

	// examples/reti/validatorRegistry.algo.ts:1184
	// inAnyPoolCount = 0
	intc 0 // 0
	frame_bury 1 // inAnyPoolCount: uint64

	// examples/reti/validatorRegistry.algo.ts:1185
	// found = false
	intc 0 // 0
	frame_bury 2 // found: bool

	// examples/reti/validatorRegistry.algo.ts:1187
	// poolSet = clone(this.stakerPoolSet(staker).value)
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	box_get

	// box value does not exist: this.stakerPoolSet(staker).value
	assert
	frame_bury 3 // poolSet: (uint64,uint64,uint64)[6]

	// examples/reti/validatorRegistry.algo.ts:1188
	// for (let i = 0; i < this.stakerPoolSet(staker).value.length; i += 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_8:
	// examples/reti/validatorRegistry.algo.ts:1188
	// i < this.stakerPoolSet(staker).value.length
	frame_dig 4 // i: uint64
	intc 7 // 6
	<
	bz *for_8_end

	// *if40_condition
	// examples/reti/validatorRegistry.algo.ts:1189
	// poolSet[i].id === 0
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	intc 0 // 0
	==
	bz *if40_end

	// *if40_consequent
	b *for_8_continue

*if40_end:
	// examples/reti/validatorRegistry.algo.ts:1192
	// inAnyPoolCount += 1
	frame_dig 1 // inAnyPoolCount: uint64
	intc 1 // 1
	+
	frame_bury 1 // inAnyPoolCount: uint64

	// *if41_condition
	// examples/reti/validatorRegistry.algo.ts:1193
	// poolSet[i].id === poolKey.id
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	==
	bz *if41_end

	// *if41_consequent
	// *if42_condition
	// examples/reti/validatorRegistry.algo.ts:1194
	// poolSet[i] === poolKey
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 3 // 24
	extract3
	frame_dig -2 // poolKey: ValidatorPoolKey
	==
	bz *if42_else

	// *if42_consequent
	// examples/reti/validatorRegistry.algo.ts:1195
	// found = true
	intc 1 // 1
	frame_bury 2 // found: bool

	// examples/reti/validatorRegistry.algo.ts:1197
	// this.stakerPoolSet(staker).value[i] = { id: 0, poolId: 0, poolAppId: 0 }
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	pushbytes 0x000000000000000000000000000000000000000000000000
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	cover 2
	box_replace
	b *if42_end

*if42_else:
	// examples/reti/validatorRegistry.algo.ts:1199
	// inSameValidatorPoolCount += 1
	frame_dig 0 // inSameValidatorPoolCount: uint64
	intc 1 // 1
	+
	frame_bury 0 // inSameValidatorPoolCount: uint64

*if42_end:

*if41_end:

*for_8_continue:
	// examples/reti/validatorRegistry.algo.ts:1188
	// i += 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_8

*for_8_end:
	// *if43_condition
	// examples/reti/validatorRegistry.algo.ts:1203
	// !found
	frame_dig 2 // found: bool
	!
	bz *if43_end

	// *if43_consequent
	// No matching slot found when told to remove a pool from the stakers set
	err

*if43_end:
	// examples/reti/validatorRegistry.algo.ts:1207
	// return [inSameValidatorPoolCount === 0, inAnyPoolCount === 0];
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 0 // inSameValidatorPoolCount: uint64
	intc 0 // 0
	==
	setbit
	intc 1 // 1
	frame_dig 1 // inAnyPoolCount: uint64
	intc 0 // 0
	==
	setbit

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// addPoolToNode(validatorId: ValidatorIdType, poolAppId: uint64, nodeNum: uint64): void
addPoolToNode:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// examples/reti/validatorRegistry.algo.ts:1211
	// nodePoolAssignments = clone(this.validatorList(validatorId).value.nodePoolAssignments)
	intc 17 //  headOffset
	intc 22 // 192
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_bury 0 // nodePoolAssignments: ((uint64[3])[8])

	// examples/reti/validatorRegistry.algo.ts:1212
	// maxPoolsPerNodeForThisValidator = this.validatorList(validatorId).value.config.poolsPerNode as uint64
	pushint 225
	intc 1 // 1
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // maxPoolsPerNodeForThisValidator: uint64

	// examples/reti/validatorRegistry.algo.ts:1214
	// assert(nodeNum >= 1 && nodeNum <= MAX_NODES, 'node number not in valid range')
	frame_dig -3 // nodeNum: uint64
	intc 1 // 1
	>=
	dup
	bz *skip_and10
	frame_dig -3 // nodeNum: uint64
	intc 2 // 8
	<=
	&&

*skip_and10:
	// node number not in valid range
	assert

	// examples/reti/validatorRegistry.algo.ts:1216
	// for (let i = 0; i < maxPoolsPerNodeForThisValidator; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_9:
	// examples/reti/validatorRegistry.algo.ts:1216
	// i < maxPoolsPerNodeForThisValidator
	frame_dig 2 // i: uint64
	frame_dig 1 // maxPoolsPerNodeForThisValidator: uint64
	<
	bz *for_9_end

	// *if44_condition
	// examples/reti/validatorRegistry.algo.ts:1217
	// nodePoolAssignments.nodes[nodeNum - 1].poolAppIds[i] === 0
	frame_dig 0 // nodePoolAssignments: ((uint64[3])[8])
	intc 0 // 0
	frame_dig -3 // nodeNum: uint64
	intc 1 // 1
	-
	intc 3 // 24
	* // acc * typeLength
	+
	intc 0 // 0
	+
	frame_dig 2 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	intc 2 // 8
	extract3
	btoi
	intc 0 // 0
	==
	bz *if44_end

	// *if44_consequent
	// examples/reti/validatorRegistry.algo.ts:1219
	// this.validatorList(validatorId).value.nodePoolAssignments.nodes[nodeNum - 1].poolAppIds[i] = poolAppId
	intc 17 // 900
	frame_dig -3 // nodeNum: uint64
	intc 1 // 1
	-
	intc 3 // 24
	* // acc * typeLength
	+
	intc 0 // 0
	+
	frame_dig 2 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	frame_dig -2 // poolAppId: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// examples/reti/validatorRegistry.algo.ts:1220
	// return;
	retsub

*if44_end:

*for_9_continue:
	// examples/reti/validatorRegistry.algo.ts:1216
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_9

*for_9_end:
	// no available space in specified node for this pool
	err
	retsub

// doesStakerMeetGating(validatorId: ValidatorIdType, valueToVerify: uint64): void
//
// Checks if a staker meets the gating requirements specified by the validator.
//
// @param {ValidatorIdType} validatorId - The id of the validator.
// @param {uint64} valueToVerify - The value to verify against the gating requirements.
// @returns {void} or asserts if requirements not met.
doesStakerMeetGating:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 8

	// examples/reti/validatorRegistry.algo.ts:1234
	// type = this.validatorList(validatorId).value.config.entryGatingType
	intc 36 // 80
	intc 1 // 1
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // type: uint8

	// *if45_condition
	// examples/reti/validatorRegistry.algo.ts:1235
	// type === GATING_TYPE_NONE
	frame_dig 0 // type: uint8
	intc 0 // 0
	==
	bz *if45_end

	// *if45_consequent
	// examples/reti/validatorRegistry.algo.ts:1236
	// return;
	retsub

*if45_end:
	// examples/reti/validatorRegistry.algo.ts:1238
	// staker = this.txn.sender
	txn Sender
	frame_bury 1 // staker: address

	// examples/reti/validatorRegistry.algo.ts:1239
	// config = clone(this.validatorList(validatorId).value.config)
	intc 0 // 0
	intc 9 // 242
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_bury 2 // config: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)

	// *if46_condition
	// examples/reti/validatorRegistry.algo.ts:1243
	// type === GATING_TYPE_ASSETS_CREATED_BY ||
	//       type === GATING_TYPE_ASSET_ID ||
	//       type === GATING_TYPE_CREATED_BY_NFD_ADDRESSES
	frame_dig 0 // type: uint8
	intc 1 // 1
	==
	dup
	bnz *skip_or4
	frame_dig 0 // type: uint8
	intc 10 // 2
	==
	||

*skip_or4:
	dup
	bnz *skip_or5
	frame_dig 0 // type: uint8
	intc 8 // 3
	==
	||

*skip_or5:
	bz *if46_end

	// *if46_consequent
	// examples/reti/validatorRegistry.algo.ts:1247
	// assert(valueToVerify !== 0)
	frame_dig -2 // valueToVerify: uint64
	intc 0 // 0
	!=
	assert

	// examples/reti/validatorRegistry.algo.ts:1248
	// balRequired = this.validatorList(validatorId).value.config.gatingAssetMinBalance
	intc 37 // 145
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 3 // balRequired: uint64

	// *if47_condition
	// examples/reti/validatorRegistry.algo.ts:1249
	// balRequired === 0
	frame_dig 3 // balRequired: uint64
	intc 0 // 0
	==
	bz *if47_end

	// *if47_consequent
	// examples/reti/validatorRegistry.algo.ts:1250
	// balRequired = 1
	intc 1 // 1
	frame_bury 3 // balRequired: uint64

*if47_end:
	// examples/reti/validatorRegistry.algo.ts:1252
	// assert(
	//         staker.assetBalance(AssetID.fromUint64(valueToVerify)) >= balRequired,
	//         'must have required minimum balance of validator defined token to add stake'
	//       )
	frame_dig 1 // staker: address
	frame_dig -2 // valueToVerify: uint64
	asset_holding_get AssetBalance
	pop
	frame_dig 3 // balRequired: uint64
	>=

	// must have required minimum balance of validator defined token to add stake
	assert

*if46_end:
	// *if48_condition
	// examples/reti/validatorRegistry.algo.ts:1257
	// type === GATING_TYPE_ASSETS_CREATED_BY
	frame_dig 0 // type: uint8
	intc 1 // 1
	==
	bz *if48_end

	// *if48_consequent
	// examples/reti/validatorRegistry.algo.ts:1258
	// assert(
	//         AssetID.fromUint64(valueToVerify).creator === config.entryGatingAddress,
	//         'specified asset must be created by creator that the validator defined as a requirement to stake'
	//       )
	frame_dig -2 // valueToVerify: uint64
	asset_params_get AssetCreator
	pop
	frame_dig 2 // config: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 81 32
	==

	// specified asset must be created by creator that the validator defined as a requirement to stake
	assert

*if48_end:
	// *if49_condition
	// examples/reti/validatorRegistry.algo.ts:1263
	// type === GATING_TYPE_ASSET_ID
	frame_dig 0 // type: uint8
	intc 10 // 2
	==
	bz *if49_end

	// *if49_consequent
	// examples/reti/validatorRegistry.algo.ts:1264
	// found = false
	intc 0 // 0
	frame_bury 4 // found: bool

	// examples/reti/validatorRegistry.algo.ts:1265
	// config.entryGatingAssets
	frame_dig 2 // config: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 113 32
	dup
	frame_bury 5 // copy of the array we are iterating over
	extract 0 8
	btoi
	frame_bury 6 // assetId: uint64
	intc 0 // 0
	frame_bury 7 // the offset we are extracting the next element from

*forOf_0:
	// *if50_condition
	// examples/reti/validatorRegistry.algo.ts:1266
	// valueToVerify === assetId
	frame_dig -2 // valueToVerify: uint64
	frame_dig 6 // assetId: uint64
	==
	bz *if50_end

	// *if50_consequent
	// examples/reti/validatorRegistry.algo.ts:1267
	// found = true
	intc 1 // 1
	frame_bury 4 // found: bool
	b *forOf_0_end

*if50_end:

*forOf_0_continue:
	// increment offset and loop if not out of bounds
	frame_dig 7 // the offset we are extracting the next element from
	intc 2 // 8
	+
	dup
	intc 6 //  offset of last element
	<
	bz *forOf_0_end
	frame_bury 7 // the offset we are extracting the next element from
	frame_dig 5 // copy of the array we are iterating over
	frame_dig 7 // the offset we are extracting the next element from
	intc 2 // 8
	extract
	btoi
	frame_bury 6 // assetId: uint64
	b *forOf_0

*forOf_0_end:
	// examples/reti/validatorRegistry.algo.ts:1271
	// assert(found, 'specified asset must be identical to the asset id defined as a requirement to stake')
	frame_dig 4 // found: bool

	// specified asset must be identical to the asset id defined as a requirement to stake
	assert

*if49_end:
	// *if51_condition
	// examples/reti/validatorRegistry.algo.ts:1273
	// type === GATING_TYPE_CREATED_BY_NFD_ADDRESSES
	frame_dig 0 // type: uint8
	intc 8 // 3
	==
	bz *if51_end

	// *if51_consequent
	// examples/reti/validatorRegistry.algo.ts:1276
	// assert(
	//         this.isAddressInNFDCAAlgoList(config.entryGatingAssets[0], AssetID.fromUint64(valueToVerify).creator),
	//         'specified asset must be created by creator that is one of the linked addresses in an nfd'
	//       )
	frame_dig -2 // valueToVerify: uint64
	asset_params_get AssetCreator
	pop
	frame_dig 2 // config: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 113 8
	btoi
	callsub isAddressInNFDCAAlgoList

	// specified asset must be created by creator that is one of the linked addresses in an nfd
	assert

*if51_end:
	// *if52_condition
	// examples/reti/validatorRegistry.algo.ts:1281
	// type === GATING_TYPE_SEGMENT_OF_NFD
	frame_dig 0 // type: uint8
	intc 15 // 4
	==
	bz *if52_end

	// *if52_consequent
	// examples/reti/validatorRegistry.algo.ts:1283
	// userOfferedNFDAppID = valueToVerify
	frame_dig -2 // valueToVerify: uint64
	frame_bury 8 // userOfferedNFDAppID: uint64

	// examples/reti/validatorRegistry.algo.ts:1284
	// assert(this.isNFDAppIDValid(userOfferedNFDAppID), 'provided NFD must be valid')
	frame_dig 8 // userOfferedNFDAppID: uint64
	callsub isNFDAppIDValid

	// provided NFD must be valid
	assert

	// examples/reti/validatorRegistry.algo.ts:1287
	// assert(
	//         rawBytes(AppID.fromUint64(userOfferedNFDAppID).globalState('i.owner.a') as Address) === rawBytes(staker) ||
	//           this.isAddressInNFDCAAlgoList(userOfferedNFDAppID, staker),
	//         "provided nfd for entry isn't owned or linked to the staker"
	//       )
	frame_dig 8 // userOfferedNFDAppID: uint64
	bytec 10 //  "i.owner.a"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(userOfferedNFDAppID).globalState('i.owner.a')
	assert
	frame_dig 1 // staker: address
	==
	dup
	bnz *skip_or6
	frame_dig 1 // staker: address
	frame_dig 8 // userOfferedNFDAppID: uint64
	callsub isAddressInNFDCAAlgoList
	||

*skip_or6:
	// provided nfd for entry isn't owned or linked to the staker
	assert

	// examples/reti/validatorRegistry.algo.ts:1294
	// assert(
	//         btoi(AppID.fromUint64(userOfferedNFDAppID).globalState('i.parentAppID') as bytes) ===
	//           config.entryGatingAssets[0],
	//         'specified nfd must be a segment of the nfd the validator specified as a requirement'
	//       )
	frame_dig 8 // userOfferedNFDAppID: uint64
	pushbytes 0x692e706172656e744170704944 // "i.parentAppID"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(userOfferedNFDAppID).globalState('i.parentAppID')
	assert
	btoi
	frame_dig 2 // config: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 113 8
	btoi
	==

	// specified nfd must be a segment of the nfd the validator specified as a requirement
	assert

*if52_end:
	retsub

// isNFDAppIDValid(nfdAppID: uint64): boolean
//
// Checks if the given NFD App id is valid.  Using only the App id there's no validation against the name (ie: that nfd X is name Y)
// So it's assumed for the caller, the app id alone is fine.  The name is fetched from the specified app id and the two
// together are used for validity check call to the nfd registry.
//
// @param {uint64} nfdAppID - The NFD App id to verify.
//
// @returns {boolean} - Returns true if the NFD App id is valid, otherwise false.
isNFDAppIDValid:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// examples/reti/validatorRegistry.algo.ts:1313
	// userOfferedNFDName = AppID.fromUint64(nfdAppID).globalState('i.name') as string
	frame_dig -1 // nfdAppID: uint64
	pushbytes 0x692e6e616d65 // "i.name"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(nfdAppID).globalState('i.name')
	assert
	frame_bury 0 // userOfferedNFDName: string

	// examples/reti/validatorRegistry.algo.ts:1315
	// return sendMethodCall<[string, uint64], boolean>({
	//       applicationID: AppID.fromUint64(this.nfdRegistryAppId),
	//       name: 'isValidNfdAppId',
	//       methodArgs: [userOfferedNFDName, nfdAppID],
	//     });
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	pushbytes 0x4be22fc6 // method "isValidNfdAppId(string,uint64)bool"
	itxn_field ApplicationArgs

	// examples/reti/validatorRegistry.algo.ts:1316
	// applicationID: AppID.fromUint64(this.nfdRegistryAppId)
	intc 28 // TMPL_nfdRegistryAppId
	itxn_field ApplicationID

	// examples/reti/validatorRegistry.algo.ts:1318
	// methodArgs: [userOfferedNFDName, nfdAppID]
	frame_dig 0 // userOfferedNFDName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -1 // nfdAppID: uint64
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit

	// set the subroutine return value
	frame_bury 0
	retsub

// isAddressInNFDCAAlgoList(nfdAppID: uint64, addrToFind: Address): boolean
//
// Checks if the specified address is present in an NFDs list of verified addresses.
// The NFD is assumed to have already been validated as official.
//
// @param {uint64} nfdAppID - The NFD application id.
// @param {Address} addrToFind - The address to find in the v.caAlgo.0.as property
// @return {boolean} - \`true\` if the address is present, \`false\` otherwise.
isAddressInNFDCAAlgoList:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// examples/reti/validatorRegistry.algo.ts:1331
	// sendAppCall({
	//       applicationID: AppID.fromUint64(nfdAppID),
	//       applicationArgs: ['read_property', 'v.caAlgo.0.as'],
	//     })
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum

	// examples/reti/validatorRegistry.algo.ts:1332
	// applicationID: AppID.fromUint64(nfdAppID)
	frame_dig -1 // nfdAppID: uint64
	itxn_field ApplicationID

	// examples/reti/validatorRegistry.algo.ts:1333
	// applicationArgs: ['read_property', 'v.caAlgo.0.as']
	pushbytes 0x726561645f70726f7065727479 // "read_property"
	itxn_field ApplicationArgs
	pushbytes 0x762e6361416c676f2e302e6173 // "v.caAlgo.0.as"
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/reti/validatorRegistry.algo.ts:1335
	// caAlgoData = this.itxn.lastLog
	itxn LastLog
	frame_bury 0 // caAlgoData: byte[]

	// examples/reti/validatorRegistry.algo.ts:1336
	// for (let i = 0; i < caAlgoData.length; i += 32)
	intc 0 // 0
	frame_bury 1 // i: uint64

*for_10:
	// examples/reti/validatorRegistry.algo.ts:1336
	// i < caAlgoData.length
	frame_dig 1 // i: uint64
	frame_dig 0 // caAlgoData: byte[]
	len
	<
	bz *for_10_end

	// examples/reti/validatorRegistry.algo.ts:1337
	// addr = extract3(caAlgoData, i, 32)
	frame_dig 0 // caAlgoData: byte[]
	frame_dig 1 // i: uint64
	intc 6 // 32
	extract3
	frame_bury 2 // addr: byte[]

	// *if53_condition
	// examples/reti/validatorRegistry.algo.ts:1338
	// addr !== rawBytes(globals.zeroAddress) && addr === rawBytes(addrToFind)
	frame_dig 2 // addr: byte[]
	global ZeroAddress
	!=
	dup
	bz *skip_and11
	frame_dig 2 // addr: byte[]
	frame_dig -2 // addrToFind: Address
	==
	&&

*skip_and11:
	bz *if53_end

	// *if53_consequent
	// examples/reti/validatorRegistry.algo.ts:1339
	// return true;
	intc 1 // 1
	b *isAddressInNFDCAAlgoList*return

*if53_end:

*for_10_continue:
	// examples/reti/validatorRegistry.algo.ts:1336
	// i += 32
	frame_dig 1 // i: uint64
	intc 6 // 32
	+
	frame_bury 1 // i: uint64
	b *for_10

*for_10_end:
	// examples/reti/validatorRegistry.algo.ts:1342
	// return false;
	intc 0 // 0

*isAddressInNFDCAAlgoList*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// algoSaturationLevel(): uint64
//
// Returns the maximum allowed stake per validator based on a percentage of all current online stake before
// the validator is considered saturated - where rewards are diminished.
// NOTE: this function is defined twice - here and in staking pool contract.  Both must be identical.
algoSaturationLevel:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// examples/reti/validatorRegistry.algo.ts:1351
	// online = this.getCurrentOnlineStake()
	callsub getCurrentOnlineStake
	frame_bury 0 // online: uint64

	// examples/reti/validatorRegistry.algo.ts:1353
	// return wideRatio([online, MAX_VALIDATOR_SOFT_PCT_OF_ONLINE_1DECIMAL], [1000]);
	frame_dig 0 // online: uint64
	pushint 100
	mulw
	intc 0 // 0
	intc 32 // 1000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert

	// set the subroutine return value
	frame_bury 0
	retsub

// maxAllowedStake(): uint64
//
// Returns the MAXIMUM allowed stake per validator based on a percentage of all current online stake.
// Adding stake is completely blocked at this amount.
maxAllowedStake:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// examples/reti/validatorRegistry.algo.ts:1361
	// online = this.getCurrentOnlineStake()
	callsub getCurrentOnlineStake
	frame_bury 0 // online: uint64

	// examples/reti/validatorRegistry.algo.ts:1363
	// return wideRatio([online, MAX_VALIDATOR_HARD_PCT_OF_ONLINE_1DECIMAL], [1000]);
	frame_dig 0 // online: uint64
	pushint 150
	mulw
	intc 0 // 0
	intc 32 // 1000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert

	// set the subroutine return value
	frame_bury 0
	retsub

// maxAlgoAllowedPerPool(): uint64
//
// Returns the MAXIMUM allowed stake per pool and still receive incentives - we'll treat this as the 'max per pool'
maxAlgoAllowedPerPool:
	proto 0 1

	// examples/reti/validatorRegistry.algo.ts:1370
	// return globals.payoutsMaxBalance;
	global PayoutsMaxBalance
	retsub

// getCurrentOnlineStake(): uint64
getCurrentOnlineStake:
	proto 0 1

	// examples/reti/validatorRegistry.algo.ts:1374
	// return onlineStake();
	online_stake
	retsub

// minBalanceForAccount(contracts: uint64, extraPages: uint64, assets: uint64, localInts: uint64, localBytes: uint64, globalInts: uint64, globalBytes: uint64): uint64
minBalanceForAccount:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// examples/reti/validatorRegistry.algo.ts:1386
	// minBal = ALGORAND_ACCOUNT_MIN_BALANCE
	intc 16 // 100000
	frame_bury 0 // minBal: uint64

	// examples/reti/validatorRegistry.algo.ts:1387
	// minBal += contracts * APPLICATION_BASE_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -1 // contracts: uint64
	intc 16 // 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// examples/reti/validatorRegistry.algo.ts:1388
	// minBal += extraPages * APPLICATION_BASE_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -2 // extraPages: uint64
	intc 16 // 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// examples/reti/validatorRegistry.algo.ts:1389
	// minBal += assets * ASSET_HOLDING_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -3 // assets: uint64
	intc 16 // 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// examples/reti/validatorRegistry.algo.ts:1390
	// minBal += localInts * SSC_VALUE_UINT
	frame_dig 0 // minBal: uint64
	frame_dig -4 // localInts: uint64
	intc 33 // 28500
	*
	+
	frame_bury 0 // minBal: uint64

	// examples/reti/validatorRegistry.algo.ts:1391
	// minBal += globalInts * SSC_VALUE_UINT
	frame_dig 0 // minBal: uint64
	frame_dig -6 // globalInts: uint64
	intc 33 // 28500
	*
	+
	frame_bury 0 // minBal: uint64

	// examples/reti/validatorRegistry.algo.ts:1392
	// minBal += localBytes * SSC_VALUE_BYTES
	frame_dig 0 // minBal: uint64
	frame_dig -5 // localBytes: uint64
	intc 34 // 50000
	*
	+
	frame_bury 0 // minBal: uint64

	// examples/reti/validatorRegistry.algo.ts:1393
	// minBal += globalBytes * SSC_VALUE_BYTES
	frame_dig 0 // minBal: uint64
	frame_dig -7 // globalBytes: uint64
	intc 34 // 50000
	*
	+
	frame_bury 0 // minBal: uint64

	// examples/reti/validatorRegistry.algo.ts:1394
	// return minBal;
	frame_dig 0 // minBal: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// costForBoxStorage(totalNumBytes: uint64): uint64
costForBoxStorage:
	proto 1 1

	// examples/reti/validatorRegistry.algo.ts:1401
	// return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE;
	pushint 2500
	frame_dig -1 // totalNumBytes: uint64
	pushint 400
	*
	+
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x1b5e82c6 // method "initStakingContract(uint64)void"
	pushbytes 0x79472d83 // method "loadStakingContractData(uint64,byte[])void"
	pushbytes 0x5f7acfd9 // method "finalizeStakingContract()void"
	pushbytes 0x3172ca9d // method "gas()void"
	pushbytes 0x8a87142d // method "getMbrAmounts()(uint64,uint64,uint64,uint64)"
	pushbytes 0xd1366cc3 // method "getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"
	pushbytes 0x3b045c5c // method "getNumValidators()uint64"
	pushbytes 0x75aff61d // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
	pushbytes 0x1f2f0109 // method "getValidatorState(uint64)(uint16,uint64,uint64,uint64)"
	pushbytes 0x2fa22c4b // method "getValidatorOwnerAndManager(uint64)(address,address)"
	pushbytes 0x910e94ac // method "getPools(uint64)(uint64,uint16,uint64)[]"
	pushbytes 0x572767d1 // method "getPoolAppId(uint64,uint64)uint64"
	pushbytes 0x9b504aaf // method "getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)"
	pushbytes 0xfbc63178 // method "getCurMaxStakePerPool(uint64)uint64"
	pushbytes 0x24498cf4 // method "doesStakerNeedToPayMBR(address)bool"
	pushbytes 0xf846dd7a // method "getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]"
	pushbytes 0x83050501 // method "getTokenPayoutRatio(uint64)(uint64[24],uint64)"
	pushbytes 0x7bbb6c8d // method "getNodePoolAssignments(uint64)((uint64[3])[8])"
	pushbytes 0xf839414a // method "getNFDRegistryID()uint64"
	pushbytes 0x0c317cfb // method "addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64"
	pushbytes 0x3e288972 // method "changeValidatorManager(uint64,address)void"
	pushbytes 0xdd5faada // method "changeValidatorSunsetInfo(uint64,uint64,uint64)void"
	pushbytes 0x18aac7a7 // method "changeValidatorNFD(uint64,uint64,string)void"
	pushbytes 0xf99ef54d // method "changeValidatorCommissionAddress(uint64,address)void"
	pushbytes 0x10809d4d // method "changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void"
	pushbytes 0xe778dd5a // method "addPool(pay,uint64,uint64)(uint64,uint64,uint64)"
	pushbytes 0xbf5259d0 // method "addStake(pay,uint64,uint64)(uint64,uint64,uint64)"
	pushbytes 0x4df8d86e // method "setTokenPayoutRatio(uint64)(uint64[24],uint64)"
	pushbytes 0x418fcefc // method "stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void"
	pushbytes 0xa2dc51b5 // method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void"
	pushbytes 0x2873f504 // method "findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)"
	pushbytes 0x0547f4fe // method "movePoolToNode(uint64,uint64,uint64)void"
	pushbytes 0xcb668358 // method "emptyTokenRewards(uint64,address)uint64"
	txna ApplicationArgs 0
	match *abi_route_initStakingContract *abi_route_loadStakingContractData *abi_route_finalizeStakingContract *abi_route_gas *abi_route_getMbrAmounts *abi_route_getProtocolConstraints *abi_route_getNumValidators *abi_route_getValidatorConfig *abi_route_getValidatorState *abi_route_getValidatorOwnerAndManager *abi_route_getPools *abi_route_getPoolAppId *abi_route_getPoolInfo *abi_route_getCurMaxStakePerPool *abi_route_doesStakerNeedToPayMBR *abi_route_getStakedPoolsForAccount *abi_route_getTokenPayoutRatio *abi_route_getNodePoolAssignments *abi_route_getNFDRegistryID *abi_route_addValidator *abi_route_changeValidatorManager *abi_route_changeValidatorSunsetInfo *abi_route_changeValidatorNFD *abi_route_changeValidatorCommissionAddress *abi_route_changeValidatorRewardInfo *abi_route_addPool *abi_route_addStake *abi_route_setTokenPayoutRatio *abi_route_stakeUpdatedViaRewards *abi_route_stakeRemoved *abi_route_findPoolForStaker *abi_route_movePoolToNode *abi_route_emptyTokenRewards

	// this contract does not implement the given ABI method for call NoOp
	err"
`;

exports[`Examples ValidatorRegistry Artifacts Maintains program size 1`] = `6327`;

exports[`Examples ValidatorRegistry Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": [
    {
      "args": [
        {
          "desc": undefined,
          "name": "id",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "owner",
          "type": "address",
        },
        {
          "desc": undefined,
          "name": "manager",
          "type": "address",
        },
      ],
      "desc": "Logs the addition of a new validator to the system, its initial owner and manager",
      "name": "retiOP_addedValidator",
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "id",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "num",
          "type": "uint16",
        },
        {
          "desc": undefined,
          "name": "poolAppId",
          "type": "uint64",
        },
      ],
      "desc": "Logs the addition of a new pool to a particular validator ID",
      "name": "retiOP_validatorAddedPool",
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "id",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "poolNum",
          "type": "uint16",
        },
        {
          "desc": undefined,
          "name": "poolAppId",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "staker",
          "type": "address",
        },
        {
          "desc": undefined,
          "name": "amountStaked",
          "type": "uint64",
        },
      ],
      "desc": "Logs how much stake was added by a staker to a particular staking pool",
      "name": "retiOP_stakeAdded",
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "id",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "poolNum",
          "type": "uint16",
        },
        {
          "desc": undefined,
          "name": "poolAppId",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "validatorCommission",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "saturatedBurnToFeeSink",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "algoAdded",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "rewardTokenHeldBack",
          "type": "uint64",
        },
      ],
      "desc": 
"Logs how much algo was detected as being added to a staking pool as part of epoch reward calculations.
Commission amount to validator, excess burned if pool is saturated, and the amount of tokens held back are logged as well."
,
      "name": "retiOP_epochRewardUpdate",
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "id",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "poolNum",
          "type": "uint16",
        },
        {
          "desc": undefined,
          "name": "poolAppId",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "staker",
          "type": "address",
        },
        {
          "desc": undefined,
          "name": "amountUnstaked",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "rewardTokensReceived",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "rewardTokenAssetId",
          "type": "uint64",
        },
      ],
      "desc": "Logs how much stake was removed by a staker from a particular staking pool",
      "name": "retiOP_stakeRemoved",
    },
  ],
  "methods": [
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "approvalProgramSize",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "initStakingContract",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "offset",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "data",
          "type": "byte[]",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "loadStakingContractData",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "finalizeStakingContract",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": "gas is a dummy no-op call that can be used to pool-up resource references and opcode cost",
      "events": undefined,
      "name": "gas",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": 
"Returns the MBR amounts needed for various actions:
[
 addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
 addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
 poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
 addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
]"
,
      "events": undefined,
      "name": "getMbrAmounts",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "(uint64,uint64,uint64,uint64)",
      },
    },
    {
      "args": [],
      "desc": "Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.",
      "events": undefined,
      "name": "getProtocolConstraints",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)",
      },
    },
    {
      "args": [],
      "desc": "Returns the current number of validators",
      "events": undefined,
      "name": "getNumValidators",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "uint64",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "validatorId",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "getValidatorConfig",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "validatorId",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "getValidatorState",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "(uint16,uint64,uint64,uint64)",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "validatorId",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "getValidatorOwnerAndManager",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "(address,address)",
      },
    },
    {
      "args": [
        {
          "desc": 
"PoolInfo[] - array of pools
Not callable from other contracts because 1K return but can be called w/ simulate which bumps log returns"
,
          "name": "validatorId",
          "type": "uint64",
        },
      ],
      "desc": "Return list of all pools for this validator.",
      "events": undefined,
      "name": "getPools",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "(uint64,uint16,uint64)[]",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "validatorId",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "poolId",
          "type": "uint64",
        },
      ],
      "desc": 
"getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
(which contains reward tokens if being used) so that the amount available can be determined."
,
      "events": undefined,
      "name": "getPoolAppId",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "uint64",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "poolKey",
          "type": "(uint64,uint64,uint64)",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "getPoolInfo",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "(uint64,uint16,uint64)",
      },
    },
    {
      "args": [
        {
          "desc": "The id of the validator.",
          "name": "validatorId",
          "type": "uint64",
        },
      ],
      "desc": 
"Calculate the maximum stake per pool for a given validator.
Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
as pools are added the max allowed per pool can reduce."
,
      "events": undefined,
      "name": "getCurMaxStakePerPool",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "uint64",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "staker",
          "type": "address",
        },
      ],
      "desc": "Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount",
      "events": undefined,
      "name": "doesStakerNeedToPayMBR",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "bool",
      },
    },
    {
      "args": [
        {
          "desc": 
"The account to retrieve staked pools for.
 ValidatorPoolKey[] - The array of staked pools for the account."
,
          "name": "staker",
          "type": "address",
        },
      ],
      "desc": "Retrieves the staked pools for an account.",
      "events": undefined,
      "name": "getStakedPoolsForAccount",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "(uint64,uint64,uint64)[]",
      },
    },
    {
      "args": [
        {
          "desc": 
"The id of the validator.
 PoolTokenPayoutRatio - The token payout ratio for the validator."
,
          "name": "validatorId",
          "type": "uint64",
        },
      ],
      "desc": 
"Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
payouts across pools can be based on a stable snaphost of stake."
,
      "events": undefined,
      "name": "getTokenPayoutRatio",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "(uint64[24],uint64)",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "validatorId",
          "type": "uint64",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "getNodePoolAssignments",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "((uint64[3])[8])",
      },
    },
    {
      "args": [],
      "desc": undefined,
      "events": undefined,
      "name": "getNFDRegistryID",
      "readonly": true,
      "returns": {
        "desc": undefined,
        "type": "uint64",
      },
    },
    {
      "args": [
        {
          "desc": "payment from caller which covers mbr increase of new validator storage",
          "name": "mbrPayment",
          "type": "pay",
        },
        {
          "desc": "(Optional) Name of nfd (used as double-check against id specified in config)",
          "name": "nfdName",
          "type": "string",
        },
        {
          "desc": "ValidatorConfig struct",
          "name": "config",
          "type": "(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)",
        },
      ],
      "desc": 
"Adds a new validator
Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds."
,
      "events": [
        {
          "args": [
            {
              "desc": undefined,
              "name": "id",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "owner",
              "type": "address",
            },
            {
              "desc": undefined,
              "name": "manager",
              "type": "address",
            },
          ],
          "desc": "Logs the addition of a new validator to the system, its initial owner and manager",
          "name": "retiOP_addedValidator",
        },
      ],
      "name": "addValidator",
      "readonly": undefined,
      "returns": {
        "desc": "uint64 validator id",
        "type": "uint64",
      },
    },
    {
      "args": [
        {
          "desc": "The id of the validator to change the manager for.",
          "name": "validatorId",
          "type": "uint64",
        },
        {
          "desc": "The new manager address.",
          "name": "manager",
          "type": "address",
        },
      ],
      "desc": 
"Changes the Validator manager for a specific Validator id.
[ ONLY OWNER CAN CHANGE ]"
,
      "events": undefined,
      "name": "changeValidatorManager",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The id of the validator to update.",
          "name": "validatorId",
          "type": "uint64",
        },
        {
          "desc": "The new sunset timestamp.",
          "name": "sunsettingOn",
          "type": "uint64",
        },
        {
          "desc": "The new sunset to validator id.",
          "name": "sunsettingTo",
          "type": "uint64",
        },
      ],
      "desc": 
"Updates the sunset information for a given validator.
[ ONLY OWNER CAN CHANGE ]"
,
      "events": undefined,
      "name": "changeValidatorSunsetInfo",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The id of the validator to update.",
          "name": "validatorId",
          "type": "uint64",
        },
        {
          "desc": "The application id of the NFD to assign to the validator.",
          "name": "nfdAppID",
          "type": "uint64",
        },
        {
          "desc": "The name of the NFD (which must match)",
          "name": "nfdName",
          "type": "string",
        },
      ],
      "desc": 
"Changes the NFD for a validator in the validatorList contract.
[ ONLY OWNER CAN CHANGE ]"
,
      "events": undefined,
      "name": "changeValidatorNFD",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "validatorId",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "commissionAddress",
          "type": "address",
        },
      ],
      "desc": 
"Change the commission address that validator rewards are sent to.
     [ ONLY OWNER CAN CHANGE ]"
,
      "events": undefined,
      "name": "changeValidatorCommissionAddress",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "validatorId",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "EntryGatingType",
          "type": "uint8",
        },
        {
          "desc": undefined,
          "name": "EntryGatingAddress",
          "type": "address",
        },
        {
          "desc": undefined,
          "name": "EntryGatingAssets",
          "type": "uint64[4]",
        },
        {
          "desc": undefined,
          "name": "GatingAssetMinBalance",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "RewardPerPayout",
          "type": "uint64",
        },
      ],
      "desc": 
"Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
[ ONLY OWNER CAN CHANGE ]"
,
      "events": undefined,
      "name": "changeValidatorRewardInfo",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "payment from caller which covers mbr increase of adding a new pool",
          "name": "mbrPayment",
          "type": "pay",
        },
        {
          "desc": "is id of validator to pool to (must be owner or manager)",
          "name": "validatorId",
          "type": "uint64",
        },
        {
          "desc": "is node number to add to",
          "name": "nodeNum",
          "type": "uint64",
        },
      ],
      "desc": 
"Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.


[ ONLY OWNER OR MANAGER CAN call ]"
,
      "events": [
        {
          "args": [
            {
              "desc": undefined,
              "name": "id",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "num",
              "type": "uint16",
            },
            {
              "desc": undefined,
              "name": "poolAppId",
              "type": "uint64",
            },
          ],
          "desc": "Logs the addition of a new pool to a particular validator ID",
          "name": "retiOP_validatorAddedPool",
        },
      ],
      "name": "addPool",
      "readonly": undefined,
      "returns": {
        "desc": "ValidatorPoolKey pool key to created pool",
        "type": "(uint64,uint64,uint64)",
      },
    },
    {
      "args": [
        {
          "desc": "payment coming from staker to place into a pool",
          "name": "stakedAmountPayment",
          "type": "pay",
        },
        {
          "desc": "The id of the validator.",
          "name": "validatorId",
          "type": "uint64",
        },
        {
          "desc": 
"only if validator has gating to enter - this is asset id or nfd id that corresponds to gating.
Txn sender is factored in as well if that is part of gating.
*"
,
          "name": "valueToVerify",
          "type": "uint64",
        },
      ],
      "desc": "Adds stake to a validator pool.",
      "events": [
        {
          "args": [
            {
              "desc": undefined,
              "name": "id",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "poolNum",
              "type": "uint16",
            },
            {
              "desc": undefined,
              "name": "poolAppId",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "staker",
              "type": "address",
            },
            {
              "desc": undefined,
              "name": "amountStaked",
              "type": "uint64",
            },
          ],
          "desc": "Logs how much stake was added by a staker to a particular staking pool",
          "name": "retiOP_stakeAdded",
        },
      ],
      "name": "addStake",
      "readonly": undefined,
      "returns": {
        "desc": "ValidatorPoolKey - The key of the validator pool.",
        "type": "(uint64,uint64,uint64)",
      },
    },
    {
      "args": [
        {
          "desc": "validator id (and thus pool) calling us.  Verified so that sender MUST be pool 1 of this validator.",
          "name": "validatorId",
          "type": "uint64",
        },
      ],
      "desc": 
"setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
during the epoch updates across pools)


Multiple pools will call us via pool 1 (pool2-pool1-validator, etc.) so don't assert on pool1 calling multiple
times in same epoch.  Just return."
,
      "events": undefined,
      "name": "setTokenPayoutRatio",
      "readonly": undefined,
      "returns": {
        "desc": "PoolTokenPayoutRatio - the finished ratio data",
        "type": "(uint64[24],uint64)",
      },
    },
    {
      "args": [
        {
          "desc": "ValidatorPoolKey type",
          "name": "poolKey",
          "type": "(uint64,uint64,uint64)",
        },
        {
          "desc": "amount this validator's total stake increased via rewards",
          "name": "algoToAdd",
          "type": "uint64",
        },
        {
          "desc": "amount this validator's total stake increased via rewards (that should be",
          "name": "rewardTokenAmountReserved",
          "type": "uint64",
        },
        {
          "desc": "the commission amount the validator was paid, if any",
          "name": "validatorCommission",
          "type": "uint64",
        },
        {
          "desc": 
"if the pool was in saturated state, the amount sent back to the fee sink.
seen as 'accounted for/pending spent')"
,
          "name": "saturatedBurnToFeeSink",
          "type": "uint64",
        },
      ],
      "desc": 
"stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
The calling App id is validated against our pool list as well."
,
      "events": [
        {
          "args": [
            {
              "desc": undefined,
              "name": "id",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "poolNum",
              "type": "uint16",
            },
            {
              "desc": undefined,
              "name": "poolAppId",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "validatorCommission",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "saturatedBurnToFeeSink",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "algoAdded",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "rewardTokenHeldBack",
              "type": "uint64",
            },
          ],
          "desc": 
"Logs how much algo was detected as being added to a staking pool as part of epoch reward calculations.
Commission amount to validator, excess burned if pool is saturated, and the amount of tokens held back are logged as well."
,
          "name": "retiOP_epochRewardUpdate",
        },
      ],
      "name": "stakeUpdatedViaRewards",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "calling us from which stake was removed",
          "name": "poolKey",
          "type": "(uint64,uint64,uint64)",
        },
        {
          "desc": undefined,
          "name": "staker",
          "type": "address",
        },
        {
          "desc": "algo amount removed",
          "name": "amountRemoved",
          "type": "uint64",
        },
        {
          "desc": "if applicable, amount of token reward removed (by pool 1 caller) or TO remove and pay out (via pool 1 from different pool caller)",
          "name": "rewardRemoved",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "stakerRemoved",
          "type": "bool",
        },
      ],
      "desc": 
"stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
The calling App id is validated against our pool list as well."
,
      "events": [
        {
          "args": [
            {
              "desc": undefined,
              "name": "id",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "poolNum",
              "type": "uint16",
            },
            {
              "desc": undefined,
              "name": "poolAppId",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "staker",
              "type": "address",
            },
            {
              "desc": undefined,
              "name": "amountUnstaked",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "rewardTokensReceived",
              "type": "uint64",
            },
            {
              "desc": undefined,
              "name": "rewardTokenAssetId",
              "type": "uint64",
            },
          ],
          "desc": "Logs how much stake was removed by a staker from a particular staking pool",
          "name": "retiOP_stakeRemoved",
        },
      ],
      "name": "stakeRemoved",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The id of the validator.",
          "name": "validatorId",
          "type": "uint64",
        },
        {
          "desc": "The address of the staker.",
          "name": "staker",
          "type": "address",
        },
        {
          "desc": "The amount to stake.",
          "name": "amountToStake",
          "type": "uint64",
        },
      ],
      "desc": 
"Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
to new pool if necessary."
,
      "events": undefined,
      "name": "findPoolForStaker",
      "readonly": true,
      "returns": {
        "desc": 
"ValidatorPoolKey, boolean, boolean - The pool for the staker, true/false on whether the staker is 'new'
to this VALIDATOR, and true/false if staker is new to the protocol."
,
        "type": "((uint64,uint64,uint64),bool,bool)",
      },
    },
    {
      "args": [
        {
          "desc": "The id of the validator.",
          "name": "validatorId",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "poolAppId",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "nodeNum",
          "type": "uint64",
        },
      ],
      "desc": 
"Find the specified pool (in any node number) and move it to the specified node.
The pool account is forced offline if moved so prior node will still run for 320 rounds but
new key goes online on new node soon after (320 rounds after it goes online)
No-op if success, asserts if not found or can't move  (no space in target)
[ ONLY OWNER OR MANAGER CAN CHANGE ]"
,
      "events": undefined,
      "name": "movePoolToNode",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The id of the validator.",
          "name": "validatorId",
          "type": "uint64",
        },
        {
          "desc": "the account to send the tokens to (must already be opted-in to the reward token)",
          "name": "receiver",
          "type": "address",
        },
      ],
      "desc": 
"Sends the reward tokens held in pool 1 to specified receiver.
This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
NOT be sent as they must be held back for stakers to later claim.
[ ONLY OWNER CAN CALL]"
,
      "events": undefined,
      "name": "emptyTokenRewards",
      "readonly": undefined,
      "returns": {
        "desc": "uint64 the amount of reward token sent",
        "type": "uint64",
      },
    },
  ],
  "name": "ValidatorRegistry",
}
`;

exports[`Examples ValidatorRegistry Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": [
      {
        "args": [
          {
            "desc": undefined,
            "name": "id",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "owner",
            "type": "address",
          },
          {
            "desc": undefined,
            "name": "manager",
            "type": "address",
          },
        ],
        "desc": "Logs the addition of a new validator to the system, its initial owner and manager",
        "name": "retiOP_addedValidator",
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "id",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "num",
            "type": "uint16",
          },
          {
            "desc": undefined,
            "name": "poolAppId",
            "type": "uint64",
          },
        ],
        "desc": "Logs the addition of a new pool to a particular validator ID",
        "name": "retiOP_validatorAddedPool",
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "id",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "poolNum",
            "type": "uint16",
          },
          {
            "desc": undefined,
            "name": "poolAppId",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "staker",
            "type": "address",
          },
          {
            "desc": undefined,
            "name": "amountStaked",
            "type": "uint64",
          },
        ],
        "desc": "Logs how much stake was added by a staker to a particular staking pool",
        "name": "retiOP_stakeAdded",
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "id",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "poolNum",
            "type": "uint16",
          },
          {
            "desc": undefined,
            "name": "poolAppId",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "validatorCommission",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "saturatedBurnToFeeSink",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "algoAdded",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "rewardTokenHeldBack",
            "type": "uint64",
          },
        ],
        "desc": 
"Logs how much algo was detected as being added to a staking pool as part of epoch reward calculations.
Commission amount to validator, excess burned if pool is saturated, and the amount of tokens held back are logged as well."
,
        "name": "retiOP_epochRewardUpdate",
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "id",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "poolNum",
            "type": "uint16",
          },
          {
            "desc": undefined,
            "name": "poolAppId",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "staker",
            "type": "address",
          },
          {
            "desc": undefined,
            "name": "amountUnstaked",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "rewardTokensReceived",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "rewardTokenAssetId",
            "type": "uint64",
          },
        ],
        "desc": "Logs how much stake was removed by a staker from a particular staking pool",
        "name": "retiOP_stakeRemoved",
      },
    ],
    "methods": [
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "approvalProgramSize",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "initStakingContract",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "offset",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "data",
            "type": "byte[]",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "loadStakingContractData",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "finalizeStakingContract",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": "gas is a dummy no-op call that can be used to pool-up resource references and opcode cost",
        "events": undefined,
        "name": "gas",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": 
"Returns the MBR amounts needed for various actions:
[
 addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
 addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
 poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
 addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
]"
,
        "events": undefined,
        "name": "getMbrAmounts",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "(uint64,uint64,uint64,uint64)",
        },
      },
      {
        "args": [],
        "desc": "Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.",
        "events": undefined,
        "name": "getProtocolConstraints",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)",
        },
      },
      {
        "args": [],
        "desc": "Returns the current number of validators",
        "events": undefined,
        "name": "getNumValidators",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "uint64",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "validatorId",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "getValidatorConfig",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "validatorId",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "getValidatorState",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "(uint16,uint64,uint64,uint64)",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "validatorId",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "getValidatorOwnerAndManager",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "(address,address)",
        },
      },
      {
        "args": [
          {
            "desc": 
"PoolInfo[] - array of pools
Not callable from other contracts because 1K return but can be called w/ simulate which bumps log returns"
,
            "name": "validatorId",
            "type": "uint64",
          },
        ],
        "desc": "Return list of all pools for this validator.",
        "events": undefined,
        "name": "getPools",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "(uint64,uint16,uint64)[]",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "validatorId",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "poolId",
            "type": "uint64",
          },
        ],
        "desc": 
"getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
(which contains reward tokens if being used) so that the amount available can be determined."
,
        "events": undefined,
        "name": "getPoolAppId",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "uint64",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "poolKey",
            "type": "(uint64,uint64,uint64)",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "getPoolInfo",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "(uint64,uint16,uint64)",
        },
      },
      {
        "args": [
          {
            "desc": "The id of the validator.",
            "name": "validatorId",
            "type": "uint64",
          },
        ],
        "desc": 
"Calculate the maximum stake per pool for a given validator.
Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
as pools are added the max allowed per pool can reduce."
,
        "events": undefined,
        "name": "getCurMaxStakePerPool",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "uint64",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "staker",
            "type": "address",
          },
        ],
        "desc": "Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount",
        "events": undefined,
        "name": "doesStakerNeedToPayMBR",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "bool",
        },
      },
      {
        "args": [
          {
            "desc": 
"The account to retrieve staked pools for.
 ValidatorPoolKey[] - The array of staked pools for the account."
,
            "name": "staker",
            "type": "address",
          },
        ],
        "desc": "Retrieves the staked pools for an account.",
        "events": undefined,
        "name": "getStakedPoolsForAccount",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "(uint64,uint64,uint64)[]",
        },
      },
      {
        "args": [
          {
            "desc": 
"The id of the validator.
 PoolTokenPayoutRatio - The token payout ratio for the validator."
,
            "name": "validatorId",
            "type": "uint64",
          },
        ],
        "desc": 
"Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
payouts across pools can be based on a stable snaphost of stake."
,
        "events": undefined,
        "name": "getTokenPayoutRatio",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "(uint64[24],uint64)",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "validatorId",
            "type": "uint64",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "getNodePoolAssignments",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "((uint64[3])[8])",
        },
      },
      {
        "args": [],
        "desc": undefined,
        "events": undefined,
        "name": "getNFDRegistryID",
        "readonly": true,
        "returns": {
          "desc": undefined,
          "type": "uint64",
        },
      },
      {
        "args": [
          {
            "desc": "payment from caller which covers mbr increase of new validator storage",
            "name": "mbrPayment",
            "type": "pay",
          },
          {
            "desc": "(Optional) Name of nfd (used as double-check against id specified in config)",
            "name": "nfdName",
            "type": "string",
          },
          {
            "desc": "ValidatorConfig struct",
            "name": "config",
            "type": "(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)",
          },
        ],
        "desc": 
"Adds a new validator
Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds."
,
        "events": [
          {
            "args": [
              {
                "desc": undefined,
                "name": "id",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "owner",
                "type": "address",
              },
              {
                "desc": undefined,
                "name": "manager",
                "type": "address",
              },
            ],
            "desc": "Logs the addition of a new validator to the system, its initial owner and manager",
            "name": "retiOP_addedValidator",
          },
        ],
        "name": "addValidator",
        "readonly": undefined,
        "returns": {
          "desc": "uint64 validator id",
          "type": "uint64",
        },
      },
      {
        "args": [
          {
            "desc": "The id of the validator to change the manager for.",
            "name": "validatorId",
            "type": "uint64",
          },
          {
            "desc": "The new manager address.",
            "name": "manager",
            "type": "address",
          },
        ],
        "desc": 
"Changes the Validator manager for a specific Validator id.
[ ONLY OWNER CAN CHANGE ]"
,
        "events": undefined,
        "name": "changeValidatorManager",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The id of the validator to update.",
            "name": "validatorId",
            "type": "uint64",
          },
          {
            "desc": "The new sunset timestamp.",
            "name": "sunsettingOn",
            "type": "uint64",
          },
          {
            "desc": "The new sunset to validator id.",
            "name": "sunsettingTo",
            "type": "uint64",
          },
        ],
        "desc": 
"Updates the sunset information for a given validator.
[ ONLY OWNER CAN CHANGE ]"
,
        "events": undefined,
        "name": "changeValidatorSunsetInfo",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The id of the validator to update.",
            "name": "validatorId",
            "type": "uint64",
          },
          {
            "desc": "The application id of the NFD to assign to the validator.",
            "name": "nfdAppID",
            "type": "uint64",
          },
          {
            "desc": "The name of the NFD (which must match)",
            "name": "nfdName",
            "type": "string",
          },
        ],
        "desc": 
"Changes the NFD for a validator in the validatorList contract.
[ ONLY OWNER CAN CHANGE ]"
,
        "events": undefined,
        "name": "changeValidatorNFD",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "validatorId",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "commissionAddress",
            "type": "address",
          },
        ],
        "desc": 
"Change the commission address that validator rewards are sent to.
     [ ONLY OWNER CAN CHANGE ]"
,
        "events": undefined,
        "name": "changeValidatorCommissionAddress",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "validatorId",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "EntryGatingType",
            "type": "uint8",
          },
          {
            "desc": undefined,
            "name": "EntryGatingAddress",
            "type": "address",
          },
          {
            "desc": undefined,
            "name": "EntryGatingAssets",
            "type": "uint64[4]",
          },
          {
            "desc": undefined,
            "name": "GatingAssetMinBalance",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "RewardPerPayout",
            "type": "uint64",
          },
        ],
        "desc": 
"Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
[ ONLY OWNER CAN CHANGE ]"
,
        "events": undefined,
        "name": "changeValidatorRewardInfo",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "payment from caller which covers mbr increase of adding a new pool",
            "name": "mbrPayment",
            "type": "pay",
          },
          {
            "desc": "is id of validator to pool to (must be owner or manager)",
            "name": "validatorId",
            "type": "uint64",
          },
          {
            "desc": "is node number to add to",
            "name": "nodeNum",
            "type": "uint64",
          },
        ],
        "desc": 
"Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.


[ ONLY OWNER OR MANAGER CAN call ]"
,
        "events": [
          {
            "args": [
              {
                "desc": undefined,
                "name": "id",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "num",
                "type": "uint16",
              },
              {
                "desc": undefined,
                "name": "poolAppId",
                "type": "uint64",
              },
            ],
            "desc": "Logs the addition of a new pool to a particular validator ID",
            "name": "retiOP_validatorAddedPool",
          },
        ],
        "name": "addPool",
        "readonly": undefined,
        "returns": {
          "desc": "ValidatorPoolKey pool key to created pool",
          "type": "(uint64,uint64,uint64)",
        },
      },
      {
        "args": [
          {
            "desc": "payment coming from staker to place into a pool",
            "name": "stakedAmountPayment",
            "type": "pay",
          },
          {
            "desc": "The id of the validator.",
            "name": "validatorId",
            "type": "uint64",
          },
          {
            "desc": 
"only if validator has gating to enter - this is asset id or nfd id that corresponds to gating.
Txn sender is factored in as well if that is part of gating.
*"
,
            "name": "valueToVerify",
            "type": "uint64",
          },
        ],
        "desc": "Adds stake to a validator pool.",
        "events": [
          {
            "args": [
              {
                "desc": undefined,
                "name": "id",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "poolNum",
                "type": "uint16",
              },
              {
                "desc": undefined,
                "name": "poolAppId",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "staker",
                "type": "address",
              },
              {
                "desc": undefined,
                "name": "amountStaked",
                "type": "uint64",
              },
            ],
            "desc": "Logs how much stake was added by a staker to a particular staking pool",
            "name": "retiOP_stakeAdded",
          },
        ],
        "name": "addStake",
        "readonly": undefined,
        "returns": {
          "desc": "ValidatorPoolKey - The key of the validator pool.",
          "type": "(uint64,uint64,uint64)",
        },
      },
      {
        "args": [
          {
            "desc": "validator id (and thus pool) calling us.  Verified so that sender MUST be pool 1 of this validator.",
            "name": "validatorId",
            "type": "uint64",
          },
        ],
        "desc": 
"setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
during the epoch updates across pools)


Multiple pools will call us via pool 1 (pool2-pool1-validator, etc.) so don't assert on pool1 calling multiple
times in same epoch.  Just return."
,
        "events": undefined,
        "name": "setTokenPayoutRatio",
        "readonly": undefined,
        "returns": {
          "desc": "PoolTokenPayoutRatio - the finished ratio data",
          "type": "(uint64[24],uint64)",
        },
      },
      {
        "args": [
          {
            "desc": "ValidatorPoolKey type",
            "name": "poolKey",
            "type": "(uint64,uint64,uint64)",
          },
          {
            "desc": "amount this validator's total stake increased via rewards",
            "name": "algoToAdd",
            "type": "uint64",
          },
          {
            "desc": "amount this validator's total stake increased via rewards (that should be",
            "name": "rewardTokenAmountReserved",
            "type": "uint64",
          },
          {
            "desc": "the commission amount the validator was paid, if any",
            "name": "validatorCommission",
            "type": "uint64",
          },
          {
            "desc": 
"if the pool was in saturated state, the amount sent back to the fee sink.
seen as 'accounted for/pending spent')"
,
            "name": "saturatedBurnToFeeSink",
            "type": "uint64",
          },
        ],
        "desc": 
"stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
The calling App id is validated against our pool list as well."
,
        "events": [
          {
            "args": [
              {
                "desc": undefined,
                "name": "id",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "poolNum",
                "type": "uint16",
              },
              {
                "desc": undefined,
                "name": "poolAppId",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "validatorCommission",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "saturatedBurnToFeeSink",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "algoAdded",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "rewardTokenHeldBack",
                "type": "uint64",
              },
            ],
            "desc": 
"Logs how much algo was detected as being added to a staking pool as part of epoch reward calculations.
Commission amount to validator, excess burned if pool is saturated, and the amount of tokens held back are logged as well."
,
            "name": "retiOP_epochRewardUpdate",
          },
        ],
        "name": "stakeUpdatedViaRewards",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "calling us from which stake was removed",
            "name": "poolKey",
            "type": "(uint64,uint64,uint64)",
          },
          {
            "desc": undefined,
            "name": "staker",
            "type": "address",
          },
          {
            "desc": "algo amount removed",
            "name": "amountRemoved",
            "type": "uint64",
          },
          {
            "desc": "if applicable, amount of token reward removed (by pool 1 caller) or TO remove and pay out (via pool 1 from different pool caller)",
            "name": "rewardRemoved",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "stakerRemoved",
            "type": "bool",
          },
        ],
        "desc": 
"stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
The calling App id is validated against our pool list as well."
,
        "events": [
          {
            "args": [
              {
                "desc": undefined,
                "name": "id",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "poolNum",
                "type": "uint16",
              },
              {
                "desc": undefined,
                "name": "poolAppId",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "staker",
                "type": "address",
              },
              {
                "desc": undefined,
                "name": "amountUnstaked",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "rewardTokensReceived",
                "type": "uint64",
              },
              {
                "desc": undefined,
                "name": "rewardTokenAssetId",
                "type": "uint64",
              },
            ],
            "desc": "Logs how much stake was removed by a staker from a particular staking pool",
            "name": "retiOP_stakeRemoved",
          },
        ],
        "name": "stakeRemoved",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The id of the validator.",
            "name": "validatorId",
            "type": "uint64",
          },
          {
            "desc": "The address of the staker.",
            "name": "staker",
            "type": "address",
          },
          {
            "desc": "The amount to stake.",
            "name": "amountToStake",
            "type": "uint64",
          },
        ],
        "desc": 
"Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
to new pool if necessary."
,
        "events": undefined,
        "name": "findPoolForStaker",
        "readonly": true,
        "returns": {
          "desc": 
"ValidatorPoolKey, boolean, boolean - The pool for the staker, true/false on whether the staker is 'new'
to this VALIDATOR, and true/false if staker is new to the protocol."
,
          "type": "((uint64,uint64,uint64),bool,bool)",
        },
      },
      {
        "args": [
          {
            "desc": "The id of the validator.",
            "name": "validatorId",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "poolAppId",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "nodeNum",
            "type": "uint64",
          },
        ],
        "desc": 
"Find the specified pool (in any node number) and move it to the specified node.
The pool account is forced offline if moved so prior node will still run for 320 rounds but
new key goes online on new node soon after (320 rounds after it goes online)
No-op if success, asserts if not found or can't move  (no space in target)
[ ONLY OWNER OR MANAGER CAN CHANGE ]"
,
        "events": undefined,
        "name": "movePoolToNode",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The id of the validator.",
            "name": "validatorId",
            "type": "uint64",
          },
          {
            "desc": "the account to send the tokens to (must already be opted-in to the reward token)",
            "name": "receiver",
            "type": "address",
          },
        ],
        "desc": 
"Sends the reward tokens held in pool 1 to specified receiver.
This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
NOT be sent as they must be held back for stakers to later claim.
[ ONLY OWNER CAN CALL]"
,
        "events": undefined,
        "name": "emptyTokenRewards",
        "readonly": undefined,
        "returns": {
          "desc": "uint64 the amount of reward token sent",
          "type": "uint64",
        },
      },
    ],
    "name": "ValidatorRegistry",
  },
  "hints": {
    "addPool(pay,uint64,uint64)(uint64,uint64,uint64)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "addStake(pay,uint64,uint64)(uint64,uint64,uint64)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "changeValidatorCommissionAddress(uint64,address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "changeValidatorManager(uint64,address)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "changeValidatorNFD(uint64,uint64,string)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "changeValidatorSunsetInfo(uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "doesStakerNeedToPayMBR(address)bool": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "emptyTokenRewards(uint64,address)uint64": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "finalizeStakingContract()void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "gas()void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getCurMaxStakePerPool(uint64)uint64": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getMbrAmounts()(uint64,uint64,uint64,uint64)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getNFDRegistryID()uint64": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getNodePoolAssignments(uint64)((uint64[3])[8])": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getNumValidators()uint64": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getPoolAppId(uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getPools(uint64)(uint64,uint16,uint64)[]": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getTokenPayoutRatio(uint64)(uint64[24],uint64)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getValidatorOwnerAndManager(uint64)(address,address)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getValidatorState(uint64)(uint16,uint64,uint64,uint64)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "initStakingContract(uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "loadStakingContractData(uint64,byte[])void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "movePoolToNode(uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "setTokenPayoutRatio(uint64)(uint64[24],uint64)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {
        "numStakers": {
          "key": "numStakers",
          "type": "uint64",
        },
        "numValidators": {
          "key": "numV",
          "type": "uint64",
        },
        "stakingPoolInitialized": {
          "key": "init",
          "type": "bytes",
        },
        "totalAlgoStaked": {
          "key": "staked",
          "type": "uint64",
        },
      },
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCmludGNibG9jayAwIDEgOCAyNCAxOCAyNjggMzIgNiAzIDI0MiAyIDEwIDI1MiAyNjAgNzAwIDQgMTAwMDAwIDkwMCAxNiAyMDAgNDAgNzIgMTkyIDI0NCAxMDAwMDAwIDQwOTYgNSAyMjYgVE1QTF9uZmRSZWdpc3RyeUFwcElkIDMwMCA0MzIgODkyIDEwMDAgMjg1MDAgNTAwMDAgMTEgODAgMTQ1IDE1MyAyMDkKYnl0ZWNibG9jayAweDc2IDB4IDB4MTUxZjdjNzUgMHg3MzcwNzMgMHg3Mzc0NjE2YjY1NjQgMHgwMCAweDZlNzU2ZDUzNzQ2MTZiNjU3MjczIDB4MDAwMDAwMDAwMDAwMDAwMCAweDBhODEwMSAweDcwNmY2ZjZjNTQ2NTZkNzA2YzYxNzQ2NTQxNzA3MDcyNmY3NjYxNmM0Mjc5NzQ2NTczIDB4NjkyZTZmNzc2ZTY1NzIyZTYxIDB4NmU3NTZkNTYgMHg2OTZlNjk3NCAweDYzZjNmMjhiIDB4MTJmNGJkNGIKCi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZGZvdW5kYXRpb24vVEVBTFNjcmlwdAoKLy8gVGhpcyBjb250cmFjdCBpcyBjb21wbGlhbnQgd2l0aCBhbmQvb3IgaW1wbGVtZW50cyB0aGUgZm9sbG93aW5nIEFSQ3M6IFsgQVJDNCBdCgovLyBUaGUgZm9sbG93aW5nIHRlbiBsaW5lcyBvZiBURUFMIGhhbmRsZSBpbml0aWFsIHByb2dyYW0gZmxvdwovLyBUaGlzIHBhdHRlcm4gaXMgdXNlZCB0byBtYWtlIGl0IGVhc3kgZm9yIGFueW9uZSB0byBwYXJzZSB0aGUgc3RhcnQgb2YgdGhlIHByb2dyYW0gYW5kIGRldGVybWluZSBpZiBhIHNwZWNpZmljIGFjdGlvbiBpcyBhbGxvd2VkCi8vIEhlcmUsIGFjdGlvbiByZWZlcnMgdG8gdGhlIE9uQ29tcGxldGUgaW4gY29tYmluYXRpb24gd2l0aCB3aGV0aGVyIHRoZSBhcHAgaXMgYmVpbmcgY3JlYXRlZCBvciBjYWxsZWQKLy8gRXZlcnkgcG9zc2libGUgYWN0aW9uIGZvciB0aGlzIGNvbnRyYWN0IGlzIHJlcHJlc2VudGVkIGluIHRoZSBzd2l0Y2ggc3RhdGVtZW50Ci8vIElmIHRoZSBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBjb250cmFjdCwgaXRzIHJlc3BlY3RpdmUgYnJhbmNoIHdpbGwgYmUgIipOT1RfSU1QTEVNRU5URUQiIHdoaWNoIGp1c3QgY29udGFpbnMgImVyciIKdHhuIEFwcGxpY2F0aW9uSUQKIQppbnRjIDcgLy8gNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggKmNhbGxfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKmNyZWF0ZV9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRAoKKk5PVF9JTVBMRU1FTlRFRDoKCS8vIFRoZSByZXF1ZXN0ZWQgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIGNvbnRyYWN0LiBBcmUgeW91IHVzaW5nIHRoZSBjb3JyZWN0IE9uQ29tcGxldGU/IERpZCB5b3Ugc2V0IHlvdXIgYXBwIElEPwoJZXJyCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uOgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoJY2FsbHN1YiBjcmVhdGVBcHBsaWNhdGlvbgoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gY3JlYXRlQXBwbGljYXRpb24oKTogdm9pZApjcmVhdGVBcHBsaWNhdGlvbjoKCXByb3RvIDAgMAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MgoJLy8gdGhpcy5zdGFraW5nUG9vbEluaXRpYWxpemVkLnZhbHVlID0gZmFsc2UKCWJ5dGVjIDEyIC8vICAiaW5pdCIKCWludGMgMCAvLyAwCglieXRlYyA1IC8vIDB4MDAKCWludGMgMCAvLyAwCgl1bmNvdmVyIDIKCXNldGJpdAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODMKCS8vIHRoaXMubnVtVmFsaWRhdG9ycy52YWx1ZSA9IDAKCWJ5dGVjIDExIC8vICAibnVtViIKCWludGMgMCAvLyAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4NAoJLy8gdGhpcy5udW1TdGFrZXJzLnZhbHVlID0gMAoJYnl0ZWMgNiAvLyAgIm51bVN0YWtlcnMiCglpbnRjIDAgLy8gMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODUKCS8vIHRoaXMudG90YWxBbGdvU3Rha2VkLnZhbHVlID0gMAoJYnl0ZWMgNCAvLyAgInN0YWtlZCIKCWludGMgMCAvLyAwCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBpbml0U3Rha2luZ0NvbnRyYWN0KHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfaW5pdFN0YWtpbmdDb250cmFjdDoKCS8vIGFwcHJvdmFsUHJvZ3JhbVNpemU6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgaW5pdFN0YWtpbmdDb250cmFjdCh1aW50NjQpdm9pZAoJY2FsbHN1YiBpbml0U3Rha2luZ0NvbnRyYWN0CglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBpbml0U3Rha2luZ0NvbnRyYWN0KGFwcHJvdmFsUHJvZ3JhbVNpemU6IHVpbnQ2NCk6IHZvaWQKaW5pdFN0YWtpbmdDb250cmFjdDoKCXByb3RvIDEgMAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MAoJLy8gdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5jcmVhdGUoYXBwcm92YWxQcm9ncmFtU2l6ZSkKCWJ5dGVjIDkgLy8gICJwb29sVGVtcGxhdGVBcHByb3ZhbEJ5dGVzIgoJZnJhbWVfZGlnIC0xIC8vIGFwcHJvdmFsUHJvZ3JhbVNpemU6IHVpbnQ2NAoJYm94X2NyZWF0ZQoJcG9wCglyZXRzdWIKCi8vIGxvYWRTdGFraW5nQ29udHJhY3REYXRhKHVpbnQ2NCxieXRlW10pdm9pZAoqYWJpX3JvdXRlX2xvYWRTdGFraW5nQ29udHJhY3REYXRhOgoJLy8gZGF0YTogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIG9mZnNldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBsb2FkU3Rha2luZ0NvbnRyYWN0RGF0YSh1aW50NjQsYnl0ZVtdKXZvaWQKCWNhbGxzdWIgbG9hZFN0YWtpbmdDb250cmFjdERhdGEKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGxvYWRTdGFraW5nQ29udHJhY3REYXRhKG9mZnNldDogdWludDY0LCBkYXRhOiBieXRlcyk6IHZvaWQKbG9hZFN0YWtpbmdDb250cmFjdERhdGE6Cglwcm90byAyIDAKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTQKCS8vIGFzc2VydCghdGhpcy5zdGFraW5nUG9vbEluaXRpYWxpemVkLnZhbHVlKQoJYnl0ZWMgMTIgLy8gICJpbml0IgoJYXBwX2dsb2JhbF9nZXQKCWludGMgMCAvLyAwCglnZXRiaXQKCSEKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5NQoJLy8gdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5yZXBsYWNlKG9mZnNldCwgZGF0YSkKCWJ5dGVjIDkgLy8gICJwb29sVGVtcGxhdGVBcHByb3ZhbEJ5dGVzIgoJZnJhbWVfZGlnIC0xIC8vIG9mZnNldDogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gZGF0YTogYnl0ZXMKCWJveF9yZXBsYWNlCglyZXRzdWIKCi8vIGZpbmFsaXplU3Rha2luZ0NvbnRyYWN0KCl2b2lkCiphYmlfcm91dGVfZmluYWxpemVTdGFraW5nQ29udHJhY3Q6CgkvLyBleGVjdXRlIGZpbmFsaXplU3Rha2luZ0NvbnRyYWN0KCl2b2lkCgljYWxsc3ViIGZpbmFsaXplU3Rha2luZ0NvbnRyYWN0CglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBmaW5hbGl6ZVN0YWtpbmdDb250cmFjdCgpOiB2b2lkCmZpbmFsaXplU3Rha2luZ0NvbnRyYWN0OgoJcHJvdG8gMCAwCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk5CgkvLyB0aGlzLnN0YWtpbmdQb29sSW5pdGlhbGl6ZWQudmFsdWUgPSB0cnVlCglieXRlYyAxMiAvLyAgImluaXQiCglpbnRjIDEgLy8gMQoJYnl0ZWMgNSAvLyAweDAwCglpbnRjIDAgLy8gMAoJdW5jb3ZlciAyCglzZXRiaXQKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGdhcygpdm9pZAoqYWJpX3JvdXRlX2dhczoKCS8vIGV4ZWN1dGUgZ2FzKCl2b2lkCgljYWxsc3ViIGdhcwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2FzKCk6IHZvaWQKLy8KLy8gZ2FzIGlzIGEgZHVtbXkgbm8tb3AgY2FsbCB0aGF0IGNhbiBiZSB1c2VkIHRvIHBvb2wtdXAgcmVzb3VyY2UgcmVmZXJlbmNlcyBhbmQgb3Bjb2RlIGNvc3QKZ2FzOgoJcHJvdG8gMCAwCglyZXRzdWIKCi8vIGdldE1ickFtb3VudHMoKSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCiphYmlfcm91dGVfZ2V0TWJyQW1vdW50czoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBnZXRNYnJBbW91bnRzKCkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJY2FsbHN1YiBnZXRNYnJBbW91bnRzCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2V0TWJyQW1vdW50cygpOiBNYnJBbW91bnRzCi8vCi8vIFJldHVybnMgdGhlIE1CUiBhbW91bnRzIG5lZWRlZCBmb3IgdmFyaW91cyBhY3Rpb25zOgovLyBbCi8vIGFkZFZhbGlkYXRvck1icjogdWludDY0IC0gbWJyIG5lZWRlZCB0byBhZGQgYSBuZXcgdmFsaWRhdG9yIC0gcGFpZCB0byB2YWxpZGF0b3IgY29udHJhY3QKLy8gYWRkUG9vbE1icjogdWludDY0IC0gbWJyIG5lZWRlZCB0byBhZGQgYSBuZXcgcG9vbCAtIHBhaWQgdG8gdmFsaWRhdG9yCi8vIHBvb2xJbml0TWJyOiB1aW50NjQgLSBtYnIgbmVlZGVkIHRvIGluaXRTdG9yYWdlKCkgb2YgcG9vbCAtIHBhaWQgdG8gcG9vbCBpdHNlbGYKLy8gYWRkU3Rha2VyTWJyOiB1aW50NjQgLSBtYnIgc3Rha2VyIG5lZWRzIHRvIGFkZCB0byBmaXJzdCBzdGFraW5nIHBheW1lbnQgKHN0YXlzIHcvIHZhbGlkYXRvcikKLy8gXQpnZXRNYnJBbW91bnRzOgoJcHJvdG8gMCAxCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMAoJLy8gcmV0dXJuIHsKCS8vICAgICAgIGFkZFZhbGlkYXRvck1icjogdGhpcy5jb3N0Rm9yQm94U3RvcmFnZSgxIC8qIHYgcHJlZml4ICovICsgbGVuPFZhbGlkYXRvcklkVHlwZT4oKSArIGxlbjxWYWxpZGF0b3JJbmZvPigpKSwKCS8vICAgICAgIGFkZFBvb2xNYnI6IHRoaXMubWluQmFsYW5jZUZvckFjY291bnQoCgkvLyAgICAgICAgIDEsCgkvLyAgICAgICAgIC8vIHdlIGNvdWxkIGNhbGN1bGF0ZSB0aGlzIGRpcmVjdGx5IGJ5IHJlZmVyZW5jaW5nIHRoZSBzaXplIG9mIHN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtIGJ1dCBpdCB3b3VsZAoJLy8gICAgICAgICAvLyBtZWFuIG91ciBjYWxsZXJzIHdvdWxkIGhhdmUgdG8gcmVmZXJlbmNlIHRoZSBib3ggQU5EIGJ1eSB1cCBpL28gLSBzbyBqdXN0IGdvIG1heCBvbiBleHRyYSBwYWdlcwoJLy8gICAgICAgICAzLAoJLy8gICAgICAgICAwLAoJLy8gICAgICAgICAwLAoJLy8gICAgICAgICAwLAoJLy8gICAgICAgICBTdGFraW5nUG9vbC5zY2hlbWEuZ2xvYmFsLm51bVVpbnQsCgkvLyAgICAgICAgIFN0YWtpbmdQb29sLnNjaGVtYS5nbG9iYWwubnVtQnl0ZVNsaWNlCgkvLyAgICAgICApLAoJLy8gICAgICAgcG9vbEluaXRNYnI6CgkvLyAgICAgICAgIEFMR09SQU5EX0FDQ09VTlRfTUlOX0JBTEFOQ0UgKwoJLy8gICAgICAgICB0aGlzLmNvc3RGb3JCb3hTdG9yYWdlKDcgLyogJ3N0YWtlcnMnIG5hbWUgKi8gKyBsZW48U3Rha2VkSW5mbz4oKSAqIE1BWF9TVEFLRVJTX1BFUl9QT09MKSwKCS8vICAgICAgIGFkZFN0YWtlck1icjoKCS8vICAgICAgICAgLy8gaG93IG11Y2ggdG8gY2hhcmdlIGZvciBmaXJzdCB0aW1lIGEgc3Rha2VyIGFkZHMgc3Rha2UgLSBzaW5jZSB3ZSBhZGQgYSB0cmFja2luZyBib3ggcGVyIHN0YWtlcgoJLy8gICAgICAgICB0aGlzLmNvc3RGb3JCb3hTdG9yYWdlKDMgLyogJ3NwcycgcHJlZml4ICovICsgbGVuPEFkZHJlc3M+KCkgKyBsZW48VmFsaWRhdG9yUG9vbEtleT4oKSAqIE1BWF9QT09MU19QRVJfU1RBS0VSKSwgLy8gc2l6ZSBvZiBrZXkgKyBhbGwgdmFsdWVzCgkvLyAgICAgfTsKCXB1c2hpbnQgMTEwMQoJY2FsbHN1YiBjb3N0Rm9yQm94U3RvcmFnZQoJaXRvYgoJaW50YyA4IC8vIDMKCWludGMgMzUgLy8gMTEKCWludGMgMCAvLyAwCglkdXBuIDIKCWludGMgOCAvLyAzCglpbnRjIDEgLy8gMQoJY2FsbHN1YiBtaW5CYWxhbmNlRm9yQWNjb3VudAoJaXRvYgoJY29uY2F0CglpbnRjIDE2IC8vIDEwMDAwMAoJcHVzaGludCAxMjgwNwoJY2FsbHN1YiBjb3N0Rm9yQm94U3RvcmFnZQoJKwoJaXRvYgoJY29uY2F0CglwdXNoaW50IDE3OQoJY2FsbHN1YiBjb3N0Rm9yQm94U3RvcmFnZQoJaXRvYgoJY29uY2F0CglyZXRzdWIKCi8vIGdldFByb3RvY29sQ29uc3RyYWludHMoKSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoqYWJpX3JvdXRlX2dldFByb3RvY29sQ29uc3RyYWludHM6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgZ2V0UHJvdG9jb2xDb25zdHJhaW50cygpKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCgljYWxsc3ViIGdldFByb3RvY29sQ29uc3RyYWludHMKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBnZXRQcm90b2NvbENvbnN0cmFpbnRzKCk6IENvbnN0cmFpbnRzCi8vCi8vIFJldHVybnMgdGhlIHByb3RvY29sIGNvbnN0cmFpbnRzIHNvIHRoYXQgVUlzIGNhbiBsaW1pdCB3aGF0IHVzZXJzIHNwZWNpZnkgZm9yIHZhbGlkYXRvciBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMuCmdldFByb3RvY29sQ29uc3RyYWludHM6Cglwcm90byAwIDEKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTQ3CgkvLyByZXR1cm4gewoJLy8gICAgICAgZXBvY2hQYXlvdXRSb3VuZHNNaW46IE1JTl9FUE9DSF9MRU5HVEgsCgkvLyAgICAgICBlcG9jaFBheW91dFJvdW5kc01heDogTUFYX0VQT0NIX0xFTkdUSCwKCS8vICAgICAgIG1pblBjdFRvVmFsaWRhdG9yV0ZvdXJEZWNpbWFsczogTUlOX1BDVF9UT19WQUxJREFUT1IsCgkvLyAgICAgICBtYXhQY3RUb1ZhbGlkYXRvcldGb3VyRGVjaW1hbHM6IE1BWF9QQ1RfVE9fVkFMSURBVE9SLAoJLy8gICAgICAgbWluRW50cnlTdGFrZTogTUlOX0FMR09fU1RBS0VfUEVSX1BPT0wsCgkvLyAgICAgICBtYXhBbGdvUGVyUG9vbDogdGhpcy5tYXhBbGdvQWxsb3dlZFBlclBvb2woKSwKCS8vICAgICAgIG1heEFsZ29QZXJWYWxpZGF0b3I6IHRoaXMubWF4QWxsb3dlZFN0YWtlKCksCgkvLyAgICAgICBhbXRDb25zaWRlcmVkU2F0dXJhdGVkOiB0aGlzLmFsZ29TYXR1cmF0aW9uTGV2ZWwoKSwKCS8vICAgICAgIG1heE5vZGVzOiBNQVhfTk9ERVMsCgkvLyAgICAgICBtYXhQb29sc1Blck5vZGU6IE1BWF9QT09MU19QRVJfTk9ERSwKCS8vICAgICAgIG1heFN0YWtlcnNQZXJQb29sOiBNQVhfU1RBS0VSU19QRVJfUE9PTCwKCS8vICAgICB9OwoJcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwZjQyNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmNDI0MDAwMDAwMDAwMDAwZjQyNDAKCWNhbGxzdWIgbWF4QWxnb0FsbG93ZWRQZXJQb29sCglpdG9iCgljb25jYXQKCWNhbGxzdWIgbWF4QWxsb3dlZFN0YWtlCglpdG9iCgljb25jYXQKCWNhbGxzdWIgYWxnb1NhdHVyYXRpb25MZXZlbAoJaXRvYgoJY29uY2F0CglwdXNoYnl0ZXMgMHgwMDAwMDAwMDAwMDAwMDA4Cgljb25jYXQKCXB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDMKCWNvbmNhdAoJcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDBjOAoJY29uY2F0CglyZXRzdWIKCi8vIGdldE51bVZhbGlkYXRvcnMoKXVpbnQ2NAoqYWJpX3JvdXRlX2dldE51bVZhbGlkYXRvcnM6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgZ2V0TnVtVmFsaWRhdG9ycygpdWludDY0CgljYWxsc3ViIGdldE51bVZhbGlkYXRvcnMKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBnZXROdW1WYWxpZGF0b3JzKCk6IHVpbnQ2NAovLwovLyBSZXR1cm5zIHRoZSBjdXJyZW50IG51bWJlciBvZiB2YWxpZGF0b3JzCmdldE51bVZhbGlkYXRvcnM6Cglwcm90byAwIDEKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTY3CgkvLyByZXR1cm4gdGhpcy5udW1WYWxpZGF0b3JzLnZhbHVlOwoJYnl0ZWMgMTEgLy8gICJudW1WIgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gZ2V0VmFsaWRhdG9yQ29uZmlnKHVpbnQ2NCkodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkKKmFiaV9yb3V0ZV9nZXRWYWxpZGF0b3JDb25maWc6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIHZhbGlkYXRvcklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGdldFZhbGlkYXRvckNvbmZpZyh1aW50NjQpKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCgljYWxsc3ViIGdldFZhbGlkYXRvckNvbmZpZwoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdldFZhbGlkYXRvckNvbmZpZyh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlKTogVmFsaWRhdG9yQ29uZmlnCmdldFZhbGlkYXRvckNvbmZpZzoKCXByb3RvIDEgMQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxNzIKCS8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZzsKCWludGMgMCAvLyAwCglpbnRjIDkgLy8gMjQyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglyZXRzdWIKCi8vIGdldFZhbGlkYXRvclN0YXRlKHVpbnQ2NCkodWludDE2LHVpbnQ2NCx1aW50NjQsdWludDY0KQoqYWJpX3JvdXRlX2dldFZhbGlkYXRvclN0YXRlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBnZXRWYWxpZGF0b3JTdGF0ZSh1aW50NjQpKHVpbnQxNix1aW50NjQsdWludDY0LHVpbnQ2NCkKCWNhbGxzdWIgZ2V0VmFsaWRhdG9yU3RhdGUKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBnZXRWYWxpZGF0b3JTdGF0ZSh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlKTogVmFsaWRhdG9yQ3VyU3RhdGUKZ2V0VmFsaWRhdG9yU3RhdGU6Cglwcm90byAxIDEKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTc3CgkvLyByZXR1cm4gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5zdGF0ZTsKCWludGMgOSAvLyAgaGVhZE9mZnNldAoJcHVzaGludCAyNgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJcmV0c3ViCgovLyBnZXRWYWxpZGF0b3JPd25lckFuZE1hbmFnZXIodWludDY0KShhZGRyZXNzLGFkZHJlc3MpCiphYmlfcm91dGVfZ2V0VmFsaWRhdG9yT3duZXJBbmRNYW5hZ2VyOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBnZXRWYWxpZGF0b3JPd25lckFuZE1hbmFnZXIodWludDY0KShhZGRyZXNzLGFkZHJlc3MpCgljYWxsc3ViIGdldFZhbGlkYXRvck93bmVyQW5kTWFuYWdlcgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdldFZhbGlkYXRvck93bmVyQW5kTWFuYWdlcih2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlKTogW0FkZHJlc3MsIEFkZHJlc3NdCmdldFZhbGlkYXRvck93bmVyQW5kTWFuYWdlcjoKCXByb3RvIDEgMQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxODIKCS8vIHJldHVybiBbdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcub3duZXIsIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1hbmFnZXJdOwoJaW50YyAyIC8vIDgKCWludGMgNiAvLyAzMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJaW50YyAyMCAvLyA0MAoJaW50YyA2IC8vIDMyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0Cgljb25jYXQKCXJldHN1YgoKLy8gZ2V0UG9vbHModWludDY0KSh1aW50NjQsdWludDE2LHVpbnQ2NClbXQoqYWJpX3JvdXRlX2dldFBvb2xzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBnZXRQb29scyh1aW50NjQpKHVpbnQ2NCx1aW50MTYsdWludDY0KVtdCgljYWxsc3ViIGdldFBvb2xzCglkdXAKCWxlbgoJaW50YyA0IC8vIDE4CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2V0UG9vbHModmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSk6IFBvb2xJbmZvW10KLy8KLy8gUmV0dXJuIGxpc3Qgb2YgYWxsIHBvb2xzIGZvciB0aGlzIHZhbGlkYXRvci4KLy8gQHBhcmFtIHt1aW50NjR9IHZhbGlkYXRvcklkCi8vIEByZXR1cm4ge1Bvb2xJbmZvW119IC0gYXJyYXkgb2YgcG9vbHMKLy8gTm90IGNhbGxhYmxlIGZyb20gb3RoZXIgY29udHJhY3RzIGJlY2F1c2UgPjFLIHJldHVybiBidXQgY2FuIGJlIGNhbGxlZCB3LyBzaW11bGF0ZSB3aGljaCBidW1wcyBsb2cgcmV0dXJucwpnZXRQb29sczoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CglkdXBuIDIKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTkzCgkvLyByZXREYXRhOiBQb29sSW5mb1tdID0gW10KCWJ5dGVjIDEgLy8gMHgKCWZyYW1lX2J1cnkgMCAvLyByZXREYXRhOiBQb29sSW5mb1tdCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE5NAoJLy8gcG9vbFNldCA9IGNsb25lKHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUucG9vbHMpCglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWludGMgMzAgLy8gNDMyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglmcmFtZV9idXJ5IDEgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50MTYsdWludDY0KVsyNF0KCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTk1CgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IHBvb2xTZXQubGVuZ3RoOyBpICs9IDEpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoKKmZvcl8wOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE5NQoJLy8gaSA8IHBvb2xTZXQubGVuZ3RoCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgMyAvLyAyNAoJPAoJYnogKmZvcl8wX2VuZAoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTk2CgkvLyBwb29sU2V0W2ldLnBvb2xBcHBJZCA9PT0gMAoJZnJhbWVfZGlnIDEgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50MTYsdWludDY0KVsyNF0KCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyA0IC8vIDE4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMCAvLyAwCgkrCglpbnRjIDIgLy8gOAoJZXh0cmFjdDMKCWJ0b2kKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmMF9lbmQKCgkvLyAqaWYwX2NvbnNlcXVlbnQKCWIgKmZvcl8wX2VuZAoKKmlmMF9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjAwCgkvLyByZXREYXRhLnB1c2gocG9vbFNldFtpXSkKCWZyYW1lX2RpZyAwIC8vIHJldERhdGE6IFBvb2xJbmZvW10KCWZyYW1lX2RpZyAxIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDE2LHVpbnQ2NClbMjRdCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDQgLy8gMTgKCWV4dHJhY3QzCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyByZXREYXRhOiBQb29sSW5mb1tdCgoqZm9yXzBfY29udGludWU6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTk1CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCWIgKmZvcl8wCgoqZm9yXzBfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIwMgoJLy8gcmV0dXJuIHJldERhdGE7CglmcmFtZV9kaWcgMCAvLyByZXREYXRhOiBQb29sSW5mb1tdCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMgoJcmV0c3ViCgovLyBnZXRQb29sQXBwSWQodWludDY0LHVpbnQ2NCl1aW50NjQKKmFiaV9yb3V0ZV9nZXRQb29sQXBwSWQ6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIHBvb2xJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgZ2V0UG9vbEFwcElkKHVpbnQ2NCx1aW50NjQpdWludDY0CgljYWxsc3ViIGdldFBvb2xBcHBJZAoJaXRvYgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdldFBvb2xBcHBJZCh2YWxpZGF0b3JJZDogdWludDY0LCBwb29sSWQ6IHVpbnQ2NCk6IHVpbnQ2NAovLwovLyBnZXRQb29sQXBwSWQgaXMgdXNlZnVsIGZvciBjYWxsZXJzIHRvIGRldGVybWluZSBhcHAgdG8gY2FsbCBmb3IgcmVtb3Zpbmcgc3Rha2UgaWYgdGhleSBkb24ndCBoYXZlIHN0YWtpbmcgb3IKLy8gd2FudCB0byBnZXQgc3Rha2VyIGxpc3QgZm9yIGFuIGFjY291bnQuICBUaGUgc3Rha2luZyBwb29sIGFsc28gdXNlcyBpdCB0byBnZXQgdGhlIGFwcCBpZCBvZiBzdGFraW5nIHBvb2wgMQovLyAod2hpY2ggY29udGFpbnMgcmV3YXJkIHRva2VucyBpZiBiZWluZyB1c2VkKSBzbyB0aGF0IHRoZSBhbW91bnQgYXZhaWxhYmxlIGNhbiBiZSBkZXRlcm1pbmVkLgpnZXRQb29sQXBwSWQ6Cglwcm90byAyIDEKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjEyCgkvLyBhc3NlcnQoCgkvLyAgICAgICBwb29sSWQgIT09IDAgJiYgcG9vbElkIDw9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUucG9vbHMubGVuZ3RoLAoJLy8gICAgICAgJ3Bvb2wgaWQgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIG51bWJlciBvZiBwb29scyBmb3IgdGhpcyB2YWxpZGF0b3InCgkvLyAgICAgKQoJZnJhbWVfZGlnIC0yIC8vIHBvb2xJZDogdWludDY0CglpbnRjIDAgLy8gMAoJIT0KCWR1cAoJYnogKnNraXBfYW5kMAoJZnJhbWVfZGlnIC0yIC8vIHBvb2xJZDogdWludDY0CglpbnRjIDMgLy8gMjQKCTw9CgkmJgoKKnNraXBfYW5kMDoKCS8vIHBvb2wgaWQgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIG51bWJlciBvZiBwb29scyBmb3IgdGhpcyB2YWxpZGF0b3IKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMTYKCS8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnBvb2xzW3Bvb2xJZCAtIDFdLnBvb2xBcHBJZDsKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIC0yIC8vIHBvb2xJZDogdWludDY0CglpbnRjIDEgLy8gMQoJLQoJaW50YyA0IC8vIDE4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMCAvLyAwCgkrCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJcmV0c3ViCgovLyBnZXRQb29sSW5mbygodWludDY0LHVpbnQ2NCx1aW50NjQpKSh1aW50NjQsdWludDE2LHVpbnQ2NCkKKmFiaV9yb3V0ZV9nZXRQb29sSW5mbzoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gcG9vbEtleTogKHVpbnQ2NCx1aW50NjQsdWludDY0KQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgMyAvLyAyNAoJPT0KCgkvLyBhcmd1bWVudCAwIChwb29sS2V5KSBmb3IgZ2V0UG9vbEluZm8gbXVzdCBiZSBhICh1aW50NjQsdWludDY0LHVpbnQ2NCkKCWFzc2VydAoKCS8vIGV4ZWN1dGUgZ2V0UG9vbEluZm8oKHVpbnQ2NCx1aW50NjQsdWludDY0KSkodWludDY0LHVpbnQxNix1aW50NjQpCgljYWxsc3ViIGdldFBvb2xJbmZvCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2V0UG9vbEluZm8ocG9vbEtleTogVmFsaWRhdG9yUG9vbEtleSk6IFBvb2xJbmZvCmdldFBvb2xJbmZvOgoJcHJvdG8gMSAxCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIyMQoJLy8gcmV0dXJuIHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5wb29sc1twb29sS2V5LnBvb2xJZCAtIDFdOwoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyA0IC8vIDE4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJcmV0c3ViCgovLyBnZXRDdXJNYXhTdGFrZVBlclBvb2wodWludDY0KXVpbnQ2NAoqYWJpX3JvdXRlX2dldEN1ck1heFN0YWtlUGVyUG9vbDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgZ2V0Q3VyTWF4U3Rha2VQZXJQb29sKHVpbnQ2NCl1aW50NjQKCWNhbGxzdWIgZ2V0Q3VyTWF4U3Rha2VQZXJQb29sCglpdG9iCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2V0Q3VyTWF4U3Rha2VQZXJQb29sKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUpOiB1aW50NjQKLy8KLy8gQ2FsY3VsYXRlIHRoZSBtYXhpbXVtIHN0YWtlIHBlciBwb29sIGZvciBhIGdpdmVuIHZhbGlkYXRvci4KLy8gTm9ybWFsbHkgdGhpcyB3b3VsZCBiZSBtYXhBbGdvUGVyUG9vbCwgYnV0IGl0IHNob3VsZCBhbHNvIG5ldmVyIGdvIGFib3ZlIE1heEFsbG93ZWRTdGFrZSAvIG51bVBvb2xzIHNvCi8vIGFzIHBvb2xzIGFyZSBhZGRlZCB0aGUgbWF4IGFsbG93ZWQgcGVyIHBvb2wgY2FuIHJlZHVjZS4KLy8KLy8gQHBhcmFtIHtWYWxpZGF0b3JJZFR5cGV9IHZhbGlkYXRvcklkIC0gVGhlIGlkIG9mIHRoZSB2YWxpZGF0b3IuCmdldEN1ck1heFN0YWtlUGVyUG9vbDoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CglkdXBuIDIKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjMzCgkvLyBudW1Qb29scyA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuc3RhdGUubnVtUG9vbHMgYXMgdWludDY0CglpbnRjIDkgLy8gMjQyCglpbnRjIDEwIC8vIDIKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgMCAvLyBudW1Qb29sczogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIzNAoJLy8gaGFyZE1heERpdmlkZWRCZXR3ZWVuUG9vbHMgPSB0aGlzLm1heEFsbG93ZWRTdGFrZSgpIC8gbnVtUG9vbHMKCWNhbGxzdWIgbWF4QWxsb3dlZFN0YWtlCglmcmFtZV9kaWcgMCAvLyBudW1Qb29sczogdWludDY0CgkvCglmcmFtZV9idXJ5IDEgLy8gaGFyZE1heERpdmlkZWRCZXR3ZWVuUG9vbHM6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMzUKCS8vIG1heFBlclBvb2w6IHVpbnQ2NCA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1heEFsZ29QZXJQb29sCglwdXNoaW50IDIxNwoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgMiAvLyBtYXhQZXJQb29sOiB1aW50NjQKCgkvLyAqaWYxX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIzNgoJLy8gbWF4UGVyUG9vbCA9PT0gMAoJZnJhbWVfZGlnIDIgLy8gbWF4UGVyUG9vbDogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjFfZW5kCgoJLy8gKmlmMV9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjM3CgkvLyBtYXhQZXJQb29sID0gdGhpcy5tYXhBbGdvQWxsb3dlZFBlclBvb2woKQoJY2FsbHN1YiBtYXhBbGdvQWxsb3dlZFBlclBvb2wKCWZyYW1lX2J1cnkgMiAvLyBtYXhQZXJQb29sOiB1aW50NjQKCippZjFfZW5kOgoJLy8gKmlmMl9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMzkKCS8vIGhhcmRNYXhEaXZpZGVkQmV0d2VlblBvb2xzIDwgbWF4UGVyUG9vbAoJZnJhbWVfZGlnIDEgLy8gaGFyZE1heERpdmlkZWRCZXR3ZWVuUG9vbHM6IHVpbnQ2NAoJZnJhbWVfZGlnIDIgLy8gbWF4UGVyUG9vbDogdWludDY0Cgk8CglieiAqaWYyX2VuZAoKCS8vICppZjJfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI0MAoJLy8gbWF4UGVyUG9vbCA9IGhhcmRNYXhEaXZpZGVkQmV0d2VlblBvb2xzCglmcmFtZV9kaWcgMSAvLyBoYXJkTWF4RGl2aWRlZEJldHdlZW5Qb29sczogdWludDY0CglmcmFtZV9idXJ5IDIgLy8gbWF4UGVyUG9vbDogdWludDY0CgoqaWYyX2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNDIKCS8vIHJldHVybiBtYXhQZXJQb29sOwoJZnJhbWVfZGlnIDIgLy8gbWF4UGVyUG9vbDogdWludDY0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMgoJcmV0c3ViCgovLyBkb2VzU3Rha2VyTmVlZFRvUGF5TUJSKGFkZHJlc3MpYm9vbAoqYWJpX3JvdXRlX2RvZXNTdGFrZXJOZWVkVG9QYXlNQlI6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIHN0YWtlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgNiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChzdGFrZXIpIGZvciBkb2VzU3Rha2VyTmVlZFRvUGF5TUJSIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIGRvZXNTdGFrZXJOZWVkVG9QYXlNQlIoYWRkcmVzcylib29sCgljYWxsc3ViIGRvZXNTdGFrZXJOZWVkVG9QYXlNQlIKCWJ5dGVjIDUgLy8gMHgwMAoJaW50YyAwIC8vIDAKCXVuY292ZXIgMgoJc2V0Yml0Cgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZG9lc1N0YWtlck5lZWRUb1BheU1CUihzdGFrZXI6IEFkZHJlc3MpOiBib29sZWFuCi8vCi8vIEhlbHBlciBjYWxsZXJzIGNhbiBjYWxsIHcvIHNpbXVsYXRlIHRvIGRldGVybWluZSBpZiAnQWRkU3Rha2VyJyBNQlIgc2hvdWxkIGJlIGluY2x1ZGVkIHcvIHN0YWtpbmcgYW1vdW50Ci8vIEBwYXJhbSBzdGFrZXIKZG9lc1N0YWtlck5lZWRUb1BheU1CUjoKCXByb3RvIDEgMQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNTEKCS8vIHJldHVybiAhdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikuZXhpc3RzOwoJYnl0ZWMgMyAvLyAgInNwcyIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglyZXRzdWIKCi8vIGdldFN0YWtlZFBvb2xzRm9yQWNjb3VudChhZGRyZXNzKSh1aW50NjQsdWludDY0LHVpbnQ2NClbXQoqYWJpX3JvdXRlX2dldFN0YWtlZFBvb2xzRm9yQWNjb3VudDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gc3Rha2VyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50YyA2IC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKHN0YWtlcikgZm9yIGdldFN0YWtlZFBvb2xzRm9yQWNjb3VudCBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBnZXRTdGFrZWRQb29sc0ZvckFjY291bnQoYWRkcmVzcykodWludDY0LHVpbnQ2NCx1aW50NjQpW10KCWNhbGxzdWIgZ2V0U3Rha2VkUG9vbHNGb3JBY2NvdW50CglkdXAKCWxlbgoJaW50YyAzIC8vIDI0CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2V0U3Rha2VkUG9vbHNGb3JBY2NvdW50KHN0YWtlcjogQWRkcmVzcyk6IFZhbGlkYXRvclBvb2xLZXlbXQovLwovLyBSZXRyaWV2ZXMgdGhlIHN0YWtlZCBwb29scyBmb3IgYW4gYWNjb3VudC4KLy8KLy8gQHBhcmFtIHtBZGRyZXNzfSBzdGFrZXIgLSBUaGUgYWNjb3VudCB0byByZXRyaWV2ZSBzdGFrZWQgcG9vbHMgZm9yLgovLyBAcmV0dXJuIHtWYWxpZGF0b3JQb29sS2V5W119IC0gVGhlIGFycmF5IG9mIHN0YWtlZCBwb29scyBmb3IgdGhlIGFjY291bnQuCmdldFN0YWtlZFBvb2xzRm9yQWNjb3VudDoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CglkdXBuIDIKCgkvLyAqaWYzX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI2MgoJLy8gIXRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLmV4aXN0cwoJYnl0ZWMgMyAvLyAgInNwcyIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglieiAqaWYzX2VuZAoKCS8vICppZjNfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI2MwoJLy8gcmV0dXJuIFtdOwoJYnl0ZWMgMSAvLyAweAoJYiAqZ2V0U3Rha2VkUG9vbHNGb3JBY2NvdW50KnJldHVybgoKKmlmM19lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjY1CgkvLyByZXREYXRhOiBWYWxpZGF0b3JQb29sS2V5W10gPSBbXQoJYnl0ZWMgMSAvLyAweAoJZnJhbWVfYnVyeSAwIC8vIHJldERhdGE6IFZhbGlkYXRvclBvb2xLZXlbXQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNjYKCS8vIHBvb2xTZXQgPSBjbG9uZSh0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZSkKCWJ5dGVjIDMgLy8gICJzcHMiCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VyOiBBZGRyZXNzCgljb25jYXQKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlCglhc3NlcnQKCWZyYW1lX2J1cnkgMSAvLyBwb29sU2V0OiAodWludDY0LHVpbnQ2NCx1aW50NjQpWzZdCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI2NwoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBwb29sU2V0Lmxlbmd0aDsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCipmb3JfMToKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNjcKCS8vIGkgPCBwb29sU2V0Lmxlbmd0aAoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDcgLy8gNgoJPAoJYnogKmZvcl8xX2VuZAoKCS8vICppZjRfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjY4CgkvLyBwb29sU2V0W2ldLmlkICE9PSAwCglmcmFtZV9kaWcgMSAvLyBwb29sU2V0OiAodWludDY0LHVpbnQ2NCx1aW50NjQpWzZdCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgMyAvLyAyNAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDAgLy8gMAoJKwoJaW50YyAyIC8vIDgKCWV4dHJhY3QzCglidG9pCglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjRfZW5kCgoJLy8gKmlmNF9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjY5CgkvLyByZXREYXRhLnB1c2gocG9vbFNldFtpXSkKCWZyYW1lX2RpZyAwIC8vIHJldERhdGE6IFZhbGlkYXRvclBvb2xLZXlbXQoJZnJhbWVfZGlnIDEgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQsdWludDY0KVs2XQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDMgLy8gMjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAzIC8vIDI0CglleHRyYWN0MwoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8gcmV0RGF0YTogVmFsaWRhdG9yUG9vbEtleVtdCgoqaWY0X2VuZDoKCipmb3JfMV9jb250aW51ZToKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNjcKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzEKCipmb3JfMV9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjcyCgkvLyByZXR1cm4gcmV0RGF0YTsKCWZyYW1lX2RpZyAwIC8vIHJldERhdGE6IFZhbGlkYXRvclBvb2xLZXlbXQoKKmdldFN0YWtlZFBvb2xzRm9yQWNjb3VudCpyZXR1cm46CgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAyCglyZXRzdWIKCi8vIGdldFRva2VuUGF5b3V0UmF0aW8odWludDY0KSh1aW50NjRbMjRdLHVpbnQ2NCkKKmFiaV9yb3V0ZV9nZXRUb2tlblBheW91dFJhdGlvOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBnZXRUb2tlblBheW91dFJhdGlvKHVpbnQ2NCkodWludDY0WzI0XSx1aW50NjQpCgljYWxsc3ViIGdldFRva2VuUGF5b3V0UmF0aW8KCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBnZXRUb2tlblBheW91dFJhdGlvKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUpOiBQb29sVG9rZW5QYXlvdXRSYXRpbwovLwovLyBSZXRyaWV2ZXMgdGhlIHRva2VuIHBheW91dCByYXRpbyBmb3IgYSBnaXZlbiB2YWxpZGF0b3IgLSByZXR1cm5pbmcgdGhlIHBvb2wgcmF0aW9zIG9mIHdob2xlIHNvIHRoYXQgdG9rZW4KLy8gcGF5b3V0cyBhY3Jvc3MgcG9vbHMgY2FuIGJlIGJhc2VkIG9uIGEgc3RhYmxlIHNuYXBob3N0IG9mIHN0YWtlLgovLwovLyBAcGFyYW0ge1ZhbGlkYXRvcklkVHlwZX0gdmFsaWRhdG9ySWQgLSBUaGUgaWQgb2YgdGhlIHZhbGlkYXRvci4KLy8gQHJldHVybiB7UG9vbFRva2VuUGF5b3V0UmF0aW99IC0gVGhlIHRva2VuIHBheW91dCByYXRpbyBmb3IgdGhlIHZhbGlkYXRvci4KZ2V0VG9rZW5QYXlvdXRSYXRpbzoKCXByb3RvIDEgMQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyODQKCS8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnRva2VuUGF5b3V0UmF0aW87CglpbnRjIDE0IC8vICBoZWFkT2Zmc2V0CglpbnRjIDE5IC8vIDIwMAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJcmV0c3ViCgovLyBnZXROb2RlUG9vbEFzc2lnbm1lbnRzKHVpbnQ2NCkoKHVpbnQ2NFszXSlbOF0pCiphYmlfcm91dGVfZ2V0Tm9kZVBvb2xBc3NpZ25tZW50czoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgZ2V0Tm9kZVBvb2xBc3NpZ25tZW50cyh1aW50NjQpKCh1aW50NjRbM10pWzhdKQoJY2FsbHN1YiBnZXROb2RlUG9vbEFzc2lnbm1lbnRzCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2V0Tm9kZVBvb2xBc3NpZ25tZW50cyh2YWxpZGF0b3JJZDogdWludDY0KTogTm9kZVBvb2xBc3NpZ25tZW50Q29uZmlnCmdldE5vZGVQb29sQXNzaWdubWVudHM6Cglwcm90byAxIDEKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Mjg5CgkvLyBhc3NlcnQodGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS5leGlzdHMsICJ0aGUgc3BlY2lmaWVkIHZhbGlkYXRvciBpZCBkb2Vzbid0IGV4aXN0IikKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCgoJLy8gdGhlIHNwZWNpZmllZCB2YWxpZGF0b3IgaWQgZG9lc24ndCBleGlzdAoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI5MQoJLy8gcmV0dXJuIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUubm9kZVBvb2xBc3NpZ25tZW50czsKCWludGMgMTcgLy8gIGhlYWRPZmZzZXQKCWludGMgMjIgLy8gMTkyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogdWludDY0CglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglyZXRzdWIKCi8vIGdldE5GRFJlZ2lzdHJ5SUQoKXVpbnQ2NAoqYWJpX3JvdXRlX2dldE5GRFJlZ2lzdHJ5SUQ6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgZ2V0TkZEUmVnaXN0cnlJRCgpdWludDY0CgljYWxsc3ViIGdldE5GRFJlZ2lzdHJ5SUQKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBnZXRORkRSZWdpc3RyeUlEKCk6IHVpbnQ2NApnZXRORkRSZWdpc3RyeUlEOgoJcHJvdG8gMCAxCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI5NgoJLy8gcmV0dXJuIHRoaXMubmZkUmVnaXN0cnlBcHBJZDsKCWludGMgMjggLy8gVE1QTF9uZmRSZWdpc3RyeUFwcElkCglyZXRzdWIKCi8vIGFkZFZhbGlkYXRvcihwYXksc3RyaW5nLCh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KSl1aW50NjQKKmFiaV9yb3V0ZV9hZGRWYWxpZGF0b3I6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIgLy8gMHgxNTFmN2M3NQoKCS8vIGNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyA5IC8vIDI0MgoJPT0KCgkvLyBhcmd1bWVudCAwIChjb25maWcpIGZvciBhZGRWYWxpZGF0b3IgbXVzdCBiZSBhICh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KQoJYXNzZXJ0CgoJLy8gbmZkTmFtZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIG1iclBheW1lbnQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludGMgMSAvLyAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnRjIDEgLy8gIHBheQoJPT0KCgkvLyBhcmd1bWVudCAyIChtYnJQYXltZW50KSBmb3IgYWRkVmFsaWRhdG9yIG11c3QgYmUgYSBwYXkgdHJhbnNhY3Rpb24KCWFzc2VydAoKCS8vIGV4ZWN1dGUgYWRkVmFsaWRhdG9yKHBheSxzdHJpbmcsKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpKXVpbnQ2NAoJY2FsbHN1YiBhZGRWYWxpZGF0b3IKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBhZGRWYWxpZGF0b3IobWJyUGF5bWVudDogUGF5VHhuLCBuZmROYW1lOiBzdHJpbmcsIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnKTogdWludDY0Ci8vCi8vIEFkZHMgYSBuZXcgdmFsaWRhdG9yCi8vIFJlcXVpcmVzIGF0IGxlYXN0IDEwIEFMR08gYXMgdGhlICdmZWUnIGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gaGVscCBkaXNzdWFkZSBzcGFtbWVkIHZhbGlkYXRvciBhZGRzLgovLwovLyBAcGFyYW0ge1BheVR4bn0gbWJyUGF5bWVudCBwYXltZW50IGZyb20gY2FsbGVyIHdoaWNoIGNvdmVycyBtYnIgaW5jcmVhc2Ugb2YgbmV3IHZhbGlkYXRvciBzdG9yYWdlCi8vIEBwYXJhbSB7c3RyaW5nfSBuZmROYW1lIChPcHRpb25hbCkgTmFtZSBvZiBuZmQgKHVzZWQgYXMgZG91YmxlLWNoZWNrIGFnYWluc3QgaWQgc3BlY2lmaWVkIGluIGNvbmZpZykKLy8gQHBhcmFtIHtWYWxpZGF0b3JDb25maWd9IGNvbmZpZyBWYWxpZGF0b3JDb25maWcgc3RydWN0Ci8vIEByZXR1cm5zIHt1aW50NjR9IHZhbGlkYXRvciBpZAphZGRWYWxpZGF0b3I6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMDgKCS8vIHRoaXMudmFsaWRhdGVDb25maWcoY29uZmlnKQoJZnJhbWVfZGlnIC0zIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCgljYWxsc3ViIHZhbGlkYXRlQ29uZmlnCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMxMAoJLy8gdmVyaWZ5UGF5VHhuKG1iclBheW1lbnQsIHsgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsIGFtb3VudDogdGhpcy5nZXRNYnJBbW91bnRzKCkuYWRkVmFsaWRhdG9yTWJyIH0pCgkvLyB2ZXJpZnkgcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyBtYnJQYXltZW50OiBQYXlUeG4KCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6Im1iclBheW1lbnQiLCJmaWVsZCI6InJlY2VpdmVyIiwiZXhwZWN0ZWQiOiJ0aGlzLmFwcC5hZGRyZXNzIn0KCWFzc2VydAoKCS8vIHZlcmlmeSBhbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBtYnJQYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJY2FsbHN1YiBnZXRNYnJBbW91bnRzCglleHRyYWN0IDAgOAoJYnRvaQoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6Im1iclBheW1lbnQiLCJmaWVsZCI6ImFtb3VudCIsImV4cGVjdGVkIjoidGhpcy5nZXRNYnJBbW91bnRzKCkuYWRkVmFsaWRhdG9yTWJyIn0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMTIKCS8vIGFzc2VydChtYnJQYXltZW50LmZlZSA+IDEwICogMTAwMDAwMCwgJ2ZlZSBtdXN0IGJlIDEwIEFMR08gb3IgbW9yZSB0byBwcmV2ZW50IHNwYW1taW5nIG9mIHZhbGlkYXRvcnMnKQoJZnJhbWVfZGlnIC0xIC8vIG1iclBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgRmVlCglwdXNoaW50IDEwMDAwMDAwCgk+CgoJLy8gZmVlIG11c3QgYmUgMTAgQUxHTyBvciBtb3JlIHRvIHByZXZlbnQgc3BhbW1pbmcgb2YgdmFsaWRhdG9ycwoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMxNQoJLy8gdmFsaWRhdG9ySWQgPSB0aGlzLm51bVZhbGlkYXRvcnMudmFsdWUgKyAxCglieXRlYyAxMSAvLyAgIm51bVYiCglhcHBfZ2xvYmFsX2dldAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMCAvLyB2YWxpZGF0b3JJZDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMxNgoJLy8gdGhpcy5udW1WYWxpZGF0b3JzLnZhbHVlID0gdmFsaWRhdG9ySWQKCWJ5dGVjIDExIC8vICAibnVtViIKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvcklkOiB1aW50NjQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMxOAoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS5jcmVhdGUoKQoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JJZDogdWludDY0CglpdG9iCgljb25jYXQKCXB1c2hpbnQgMTA5MgoJYm94X2NyZWF0ZQoJcG9wCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMxOQoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcgPSBjb25maWcKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgLTMgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMjAKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLmlkID0gdmFsaWRhdG9ySWQKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JJZDogdWludDY0CglpdG9iCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvcklkOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyAqaWY1X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMyMwoJLy8gY29uZmlnLm5mZEZvckluZm8gIT09IDAKCWZyYW1lX2RpZyAtMyAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCA3MiA4CglidG9pCglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjVfZW5kCgoJLy8gKmlmNV9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzI1CgkvLyBhc3NlcnQodGhpcy5pc05GREFwcElEVmFsaWQoY29uZmlnLm5mZEZvckluZm8pLCAncHJvdmlkZWQgTkZEIG11c3QgYmUgdmFsaWQnKQoJZnJhbWVfZGlnIC0zIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDcyIDgKCWJ0b2kKCWNhbGxzdWIgaXNORkRBcHBJRFZhbGlkCgoJLy8gcHJvdmlkZWQgTkZEIG11c3QgYmUgdmFsaWQKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMjcKCS8vIGFzc2VydCgKCS8vICAgICAgICAgdGhpcy50eG4uc2VuZGVyID09PSAoQXBwSUQuZnJvbVVpbnQ2NChjb25maWcubmZkRm9ySW5mbykuZ2xvYmFsU3RhdGUoJ2kub3duZXIuYScpIGFzIEFkZHJlc3MpLAoJLy8gICAgICAgICAnSWYgc3BlY2lmeWluZyBORkQsIGFjY291bnQgYWRkaW5nIHZhbGlkYXRvciBtdXN0IGJlIG93bmVyJwoJLy8gICAgICAgKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0zIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDcyIDgKCWJ0b2kKCWJ5dGVjIDEwIC8vICAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXRfZXgKCgkvLyBnbG9iYWwgc3RhdGUgdmFsdWUgZG9lcyBub3QgZXhpc3Q6IEFwcElELmZyb21VaW50NjQoY29uZmlnLm5mZEZvckluZm8pLmdsb2JhbFN0YXRlKCdpLm93bmVyLmEnKQoJYXNzZXJ0Cgk9PQoKCS8vIElmIHNwZWNpZnlpbmcgTkZELCBhY2NvdW50IGFkZGluZyB2YWxpZGF0b3IgbXVzdCBiZSBvd25lcgoJYXNzZXJ0CgoqaWY1X2VuZDoKCS8vICppZjZfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzMzCgkvLyBjb25maWcuZW50cnlHYXRpbmdUeXBlID09PSBHQVRJTkdfVFlQRV9DUkVBVEVEX0JZX05GRF9BRERSRVNTRVMgfHwKCS8vICAgICAgIGNvbmZpZy5lbnRyeUdhdGluZ1R5cGUgPT09IEdBVElOR19UWVBFX1NFR01FTlRfT0ZfTkZECglmcmFtZV9kaWcgLTMgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgODAgMQoJYnRvaQoJaW50YyA4IC8vIDMKCT09CglkdXAKCWJueiAqc2tpcF9vcjAKCWZyYW1lX2RpZyAtMyAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCA4MCAxCglidG9pCglpbnRjIDE1IC8vIDQKCT09Cgl8fAoKKnNraXBfb3IwOgoJYnogKmlmNl9lbmQKCgkvLyAqaWY2X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMzcKCS8vIGFzc2VydCh0aGlzLmlzTkZEQXBwSURWYWxpZChjb25maWcuZW50cnlHYXRpbmdBc3NldHNbMF0pLCAncHJvdmlkZWQgTkZEIEFwcCBpZCBmb3IgZ2F0aW5nIG11c3QgYmUgdmFsaWQgTkZEJykKCWZyYW1lX2RpZyAtMyAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAxMTMgOAoJYnRvaQoJY2FsbHN1YiBpc05GREFwcElEVmFsaWQKCgkvLyBwcm92aWRlZCBORkQgQXBwIGlkIGZvciBnYXRpbmcgbXVzdCBiZSB2YWxpZCBORkQKCWFzc2VydAoKKmlmNl9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzM5CgkvLyB0aGlzLnJldGlPUF9hZGRlZFZhbGlkYXRvci5sb2coeyBpZDogdmFsaWRhdG9ySWQsIG93bmVyOiBjb25maWcub3duZXIsIG1hbmFnZXI6IGNvbmZpZy5tYW5hZ2VyIH0pCglwdXNoYnl0ZXMgMHhhOGRkMjFjYiAvLyByZXRpT1BfYWRkZWRWYWxpZGF0b3IodWludDY0LGFkZHJlc3MsYWRkcmVzcykKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvcklkOiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAtMyAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCA4IDMyCgljb25jYXQKCWZyYW1lX2RpZyAtMyAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCA0MCAzMgoJY29uY2F0Cgljb25jYXQKCWxvZwoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNDAKCS8vIHJldHVybiB2YWxpZGF0b3JJZDsKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvcklkOiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gY2hhbmdlVmFsaWRhdG9yTWFuYWdlcih1aW50NjQsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfY2hhbmdlVmFsaWRhdG9yTWFuYWdlcjoKCS8vIG1hbmFnZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDYgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMCAobWFuYWdlcikgZm9yIGNoYW5nZVZhbGlkYXRvck1hbmFnZXIgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIHZhbGlkYXRvcklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGNoYW5nZVZhbGlkYXRvck1hbmFnZXIodWludDY0LGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBjaGFuZ2VWYWxpZGF0b3JNYW5hZ2VyCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBjaGFuZ2VWYWxpZGF0b3JNYW5hZ2VyKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIG1hbmFnZXI6IEFkZHJlc3MpOiB2b2lkCi8vCi8vIENoYW5nZXMgdGhlIFZhbGlkYXRvciBtYW5hZ2VyIGZvciBhIHNwZWNpZmljIFZhbGlkYXRvciBpZC4KLy8gWyBPTkxZIE9XTkVSIENBTiBDSEFOR0UgXQovLwovLyBAcGFyYW0ge1ZhbGlkYXRvcklkVHlwZX0gdmFsaWRhdG9ySWQgLSBUaGUgaWQgb2YgdGhlIHZhbGlkYXRvciB0byBjaGFuZ2UgdGhlIG1hbmFnZXIgZm9yLgovLyBAcGFyYW0ge0FkZHJlc3N9IG1hbmFnZXIgLSBUaGUgbmV3IG1hbmFnZXIgYWRkcmVzcy4KY2hhbmdlVmFsaWRhdG9yTWFuYWdlcjoKCXByb3RvIDIgMAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNTEKCS8vIHRoaXMuY2FsbGVyTXVzdEJlT3duZXIodmFsaWRhdG9ySWQpCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJY2FsbHN1YiBjYWxsZXJNdXN0QmVPd25lcgoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNTIKCS8vIGFzc2VydChtYW5hZ2VyICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzLCAnbmVlZHMgdG8gYXQgbGVhc3QgYmUgdmFsaWQgYWRkcmVzcycpCglmcmFtZV9kaWcgLTIgLy8gbWFuYWdlcjogQWRkcmVzcwoJZ2xvYmFsIFplcm9BZGRyZXNzCgkhPQoKCS8vIG5lZWRzIHRvIGF0IGxlYXN0IGJlIHZhbGlkIGFkZHJlc3MKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNTMKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1hbmFnZXIgPSBtYW5hZ2VyCglpbnRjIDIwIC8vIDQwCglmcmFtZV9kaWcgLTIgLy8gbWFuYWdlcjogQWRkcmVzcwoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBjaGFuZ2VWYWxpZGF0b3JTdW5zZXRJbmZvKHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9jaGFuZ2VWYWxpZGF0b3JTdW5zZXRJbmZvOgoJLy8gc3Vuc2V0dGluZ1RvOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyBzdW5zZXR0aW5nT246IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHZhbGlkYXRvcklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGNoYW5nZVZhbGlkYXRvclN1bnNldEluZm8odWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBjaGFuZ2VWYWxpZGF0b3JTdW5zZXRJbmZvCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBjaGFuZ2VWYWxpZGF0b3JTdW5zZXRJbmZvKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIHN1bnNldHRpbmdPbjogdWludDY0LCBzdW5zZXR0aW5nVG86IFZhbGlkYXRvcklkVHlwZSk6IHZvaWQKLy8KLy8gVXBkYXRlcyB0aGUgc3Vuc2V0IGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIHZhbGlkYXRvci4KLy8gWyBPTkxZIE9XTkVSIENBTiBDSEFOR0UgXQovLwovLyBAcGFyYW0ge1ZhbGlkYXRvcklkVHlwZX0gdmFsaWRhdG9ySWQgLSBUaGUgaWQgb2YgdGhlIHZhbGlkYXRvciB0byB1cGRhdGUuCi8vIEBwYXJhbSB7dWludDY0fSBzdW5zZXR0aW5nT24gLSBUaGUgbmV3IHN1bnNldCB0aW1lc3RhbXAuCi8vIEBwYXJhbSB7dWludDY0fSBzdW5zZXR0aW5nVG8gLSBUaGUgbmV3IHN1bnNldCB0byB2YWxpZGF0b3IgaWQuCmNoYW5nZVZhbGlkYXRvclN1bnNldEluZm86Cglwcm90byAzIDAKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzY1CgkvLyB0aGlzLmNhbGxlck11c3RCZU93bmVyKHZhbGlkYXRvcklkKQoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWNhbGxzdWIgY2FsbGVyTXVzdEJlT3duZXIKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzY2CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5zdW5zZXR0aW5nT24gPSBzdW5zZXR0aW5nT24KCWludGMgMjcgLy8gMjI2CglmcmFtZV9kaWcgLTIgLy8gc3Vuc2V0dGluZ09uOiB1aW50NjQKCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzY3CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5zdW5zZXR0aW5nVG8gPSBzdW5zZXR0aW5nVG8KCXB1c2hpbnQgMjM0CglmcmFtZV9kaWcgLTMgLy8gc3Vuc2V0dGluZ1RvOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCXJldHN1YgoKLy8gY2hhbmdlVmFsaWRhdG9yTkZEKHVpbnQ2NCx1aW50NjQsc3RyaW5nKXZvaWQKKmFiaV9yb3V0ZV9jaGFuZ2VWYWxpZGF0b3JORkQ6CgkvLyBuZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWV4dHJhY3QgMiAwCgoJLy8gbmZkQXBwSUQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHZhbGlkYXRvcklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGNoYW5nZVZhbGlkYXRvck5GRCh1aW50NjQsdWludDY0LHN0cmluZyl2b2lkCgljYWxsc3ViIGNoYW5nZVZhbGlkYXRvck5GRAoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gY2hhbmdlVmFsaWRhdG9yTkZEKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIG5mZEFwcElEOiB1aW50NjQsIG5mZE5hbWU6IHN0cmluZyk6IHZvaWQKLy8KLy8gQ2hhbmdlcyB0aGUgTkZEIGZvciBhIHZhbGlkYXRvciBpbiB0aGUgdmFsaWRhdG9yTGlzdCBjb250cmFjdC4KLy8gWyBPTkxZIE9XTkVSIENBTiBDSEFOR0UgXQovLwovLyBAcGFyYW0ge1ZhbGlkYXRvcklkVHlwZX0gdmFsaWRhdG9ySWQgLSBUaGUgaWQgb2YgdGhlIHZhbGlkYXRvciB0byB1cGRhdGUuCi8vIEBwYXJhbSB7dWludDY0fSBuZmRBcHBJRCAtIFRoZSBhcHBsaWNhdGlvbiBpZCBvZiB0aGUgTkZEIHRvIGFzc2lnbiB0byB0aGUgdmFsaWRhdG9yLgovLyBAcGFyYW0ge3N0cmluZ30gbmZkTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBORkQgKHdoaWNoIG11c3QgbWF0Y2gpCmNoYW5nZVZhbGlkYXRvck5GRDoKCXByb3RvIDMgMAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNzkKCS8vIHRoaXMuY2FsbGVyTXVzdEJlT3duZXIodmFsaWRhdG9ySWQpCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJY2FsbHN1YiBjYWxsZXJNdXN0QmVPd25lcgoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozODEKCS8vIGFzc2VydCh0aGlzLmlzTkZEQXBwSURWYWxpZChuZmRBcHBJRCksICdwcm92aWRlZCBORkQgbXVzdCBiZSB2YWxpZCcpCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSUQ6IHVpbnQ2NAoJY2FsbHN1YiBpc05GREFwcElEVmFsaWQKCgkvLyBwcm92aWRlZCBORkQgbXVzdCBiZSB2YWxpZAoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM4MwoJLy8gYXNzZXJ0KAoJLy8gICAgICAgdGhpcy50eG4uc2VuZGVyID09PSAoQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJRCkuZ2xvYmFsU3RhdGUoJ2kub3duZXIuYScpIGFzIEFkZHJlc3MpLAoJLy8gICAgICAgJ0lmIHNwZWNpZnlpbmcgTkZELCBhY2NvdW50IGFkZGluZyB2YWxpZGF0b3IgbXVzdCBiZSBvd25lcicKCS8vICAgICApCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSUQ6IHVpbnQ2NAoJYnl0ZWMgMTAgLy8gICJpLm93bmVyLmEiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJRCkuZ2xvYmFsU3RhdGUoJ2kub3duZXIuYScpCglhc3NlcnQKCT09CgoJLy8gSWYgc3BlY2lmeWluZyBORkQsIGFjY291bnQgYWRkaW5nIHZhbGlkYXRvciBtdXN0IGJlIG93bmVyCglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Mzg3CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5uZmRGb3JJbmZvID0gbmZkQXBwSUQKCWludGMgMjEgLy8gNzIKCWZyYW1lX2RpZyAtMiAvLyBuZmRBcHBJRDogdWludDY0CglpdG9iCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCglyZXRzdWIKCi8vIGNoYW5nZVZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzKHVpbnQ2NCxhZGRyZXNzKXZvaWQKKmFiaV9yb3V0ZV9jaGFuZ2VWYWxpZGF0b3JDb21taXNzaW9uQWRkcmVzczoKCS8vIGNvbW1pc3Npb25BZGRyZXNzOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyA2IC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGNvbW1pc3Npb25BZGRyZXNzKSBmb3IgY2hhbmdlVmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3MgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIHZhbGlkYXRvcklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGNoYW5nZVZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzKHVpbnQ2NCxhZGRyZXNzKXZvaWQKCWNhbGxzdWIgY2hhbmdlVmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3MKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGNoYW5nZVZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIGNvbW1pc3Npb25BZGRyZXNzOiBBZGRyZXNzKTogdm9pZAovLwovLyBDaGFuZ2UgdGhlIGNvbW1pc3Npb24gYWRkcmVzcyB0aGF0IHZhbGlkYXRvciByZXdhcmRzIGFyZSBzZW50IHRvLgovLyBbIE9OTFkgT1dORVIgQ0FOIENIQU5HRSBdCmNoYW5nZVZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzOgoJcHJvdG8gMiAwCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM5NQoJLy8gdGhpcy5jYWxsZXJNdXN0QmVPd25lcih2YWxpZGF0b3JJZCkKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCgljYWxsc3ViIGNhbGxlck11c3RCZU93bmVyCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM5NgoJLy8gYXNzZXJ0KGNvbW1pc3Npb25BZGRyZXNzICE9PSBBZGRyZXNzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC0yIC8vIGNvbW1pc3Npb25BZGRyZXNzOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Mzk3CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy52YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyA9IGNvbW1pc3Npb25BZGRyZXNzCglwdXNoaW50IDE3NwoJZnJhbWVfZGlnIC0yIC8vIGNvbW1pc3Npb25BZGRyZXNzOiBBZGRyZXNzCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCglyZXRzdWIKCi8vIGNoYW5nZVZhbGlkYXRvclJld2FyZEluZm8odWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX2NoYW5nZVZhbGlkYXRvclJld2FyZEluZm86CgkvLyBSZXdhcmRQZXJQYXlvdXQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgoJYnRvaQoKCS8vIEdhdGluZ0Fzc2V0TWluQmFsYW5jZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglidG9pCgoJLy8gRW50cnlHYXRpbmdBc3NldHM6IHVpbnQ2NFs0XQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZHVwCglsZW4KCWludGMgNiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAyIChFbnRyeUdhdGluZ0Fzc2V0cykgZm9yIGNoYW5nZVZhbGlkYXRvclJld2FyZEluZm8gbXVzdCBiZSBhIHVpbnQ2NFs0XQoJYXNzZXJ0CgoJLy8gRW50cnlHYXRpbmdBZGRyZXNzOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglkdXAKCWxlbgoJaW50YyA2IC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDMgKEVudHJ5R2F0aW5nQWRkcmVzcykgZm9yIGNoYW5nZVZhbGlkYXRvclJld2FyZEluZm8gbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIEVudHJ5R2F0aW5nVHlwZTogdWludDgKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDEgLy8gMQoJPT0KCgkvLyBhcmd1bWVudCA0IChFbnRyeUdhdGluZ1R5cGUpIGZvciBjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvIG11c3QgYmUgYSB1aW50OAoJYXNzZXJ0CglidG9pCgoJLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgY2hhbmdlVmFsaWRhdG9yUmV3YXJkSW5mbyh1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCl2b2lkCgljYWxsc3ViIGNoYW5nZVZhbGlkYXRvclJld2FyZEluZm8KCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGNoYW5nZVZhbGlkYXRvclJld2FyZEluZm8odmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSwgRW50cnlHYXRpbmdUeXBlOiB1aW50OCwgRW50cnlHYXRpbmdBZGRyZXNzOiBBZGRyZXNzLCBFbnRyeUdhdGluZ0Fzc2V0czogU3RhdGljQXJyYXk8dWludDY0LCA0PiwgR2F0aW5nQXNzZXRNaW5CYWxhbmNlOiB1aW50NjQsIFJld2FyZFBlclBheW91dDogdWludDY0KTogdm9pZAovLwovLyBBbGxvdyB0aGUgYWRkaXRpb25hbCByZXdhcmRzIChnYXRpbmcgZW50cnksIGFkZGl0aW9uYWwgdG9rZW4gcmV3YXJkcykgaW5mb3JtYXRpb24gYmUgY2hhbmdlZCBhdCB3aWxsLgovLyBbIE9OTFkgT1dORVIgQ0FOIENIQU5HRSBdCmNoYW5nZVZhbGlkYXRvclJld2FyZEluZm86Cglwcm90byA2IDAKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDEyCgkvLyB0aGlzLmNhbGxlck11c3RCZU93bmVyKHZhbGlkYXRvcklkKQoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWNhbGxzdWIgY2FsbGVyTXVzdEJlT3duZXIKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDE0CgkvLyBhc3NlcnQoRW50cnlHYXRpbmdUeXBlID49IEdBVElOR19UWVBFX05PTkUgJiYgRW50cnlHYXRpbmdUeXBlIDwgR0FUSU5HX1RZUEVfQ09OU1RfTUFYLCAnaW52YWxpZCBFbnRyeSBnYXRpbmcgdHlwZScpCglmcmFtZV9kaWcgLTIgLy8gRW50cnlHYXRpbmdUeXBlOiB1aW50OAoJaW50YyAwIC8vIDAKCT49CglkdXAKCWJ6ICpza2lwX2FuZDEKCWZyYW1lX2RpZyAtMiAvLyBFbnRyeUdhdGluZ1R5cGU6IHVpbnQ4CglpbnRjIDE1IC8vIDQKCTwKCSYmCgoqc2tpcF9hbmQxOgoJLy8gaW52YWxpZCBFbnRyeSBnYXRpbmcgdHlwZQoJYXNzZXJ0CgoJLy8gKmlmN19jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MTUKCS8vIEVudHJ5R2F0aW5nVHlwZSA9PT0gR0FUSU5HX1RZUEVfQVNTRVRTX0NSRUFURURfQlkKCWZyYW1lX2RpZyAtMiAvLyBFbnRyeUdhdGluZ1R5cGU6IHVpbnQ4CglpbnRjIDEgLy8gMQoJPT0KCWJ6ICppZjdfZW5kCgoJLy8gKmlmN19jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDE2CgkvLyBhc3NlcnQoRW50cnlHYXRpbmdBZGRyZXNzICE9PSBnbG9iYWxzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC0zIC8vIEVudHJ5R2F0aW5nQWRkcmVzczogQWRkcmVzcwoJZ2xvYmFsIFplcm9BZGRyZXNzCgkhPQoJYXNzZXJ0CgoqaWY3X2VuZDoKCS8vICppZjhfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDE4CgkvLyBFbnRyeUdhdGluZ1R5cGUgPT09IEdBVElOR19UWVBFX0NSRUFURURfQllfTkZEX0FERFJFU1NFUyB8fCBFbnRyeUdhdGluZ1R5cGUgPT09IEdBVElOR19UWVBFX1NFR01FTlRfT0ZfTkZECglmcmFtZV9kaWcgLTIgLy8gRW50cnlHYXRpbmdUeXBlOiB1aW50OAoJaW50YyA4IC8vIDMKCT09CglkdXAKCWJueiAqc2tpcF9vcjEKCWZyYW1lX2RpZyAtMiAvLyBFbnRyeUdhdGluZ1R5cGU6IHVpbnQ4CglpbnRjIDE1IC8vIDQKCT09Cgl8fAoKKnNraXBfb3IxOgoJYnogKmlmOF9lbmQKCgkvLyAqaWY4X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MTkKCS8vIGFzc2VydCh0aGlzLmlzTkZEQXBwSURWYWxpZChFbnRyeUdhdGluZ0Fzc2V0c1swXSksICdwcm92aWRlZCBORkQgQXBwIGlkIGZvciBnYXRpbmcgbXVzdCBiZSB2YWxpZCBORkQnKQoJZnJhbWVfZGlnIC00IC8vIEVudHJ5R2F0aW5nQXNzZXRzOiBTdGF0aWNBcnJheTx1aW50NjQsIDQ+CglleHRyYWN0IDAgOAoJYnRvaQoJY2FsbHN1YiBpc05GREFwcElEVmFsaWQKCgkvLyBwcm92aWRlZCBORkQgQXBwIGlkIGZvciBnYXRpbmcgbXVzdCBiZSB2YWxpZCBORkQKCWFzc2VydAoKKmlmOF9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDIxCgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5lbnRyeUdhdGluZ1R5cGUgPSBFbnRyeUdhdGluZ1R5cGUKCWludGMgMzYgLy8gODAKCWZyYW1lX2RpZyAtMiAvLyBFbnRyeUdhdGluZ1R5cGU6IHVpbnQ4CglpdG9iCglleHRyYWN0IDcgMQoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MjIKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLmVudHJ5R2F0aW5nQWRkcmVzcyA9IEVudHJ5R2F0aW5nQWRkcmVzcwoJcHVzaGludCA4MQoJZnJhbWVfZGlnIC0zIC8vIEVudHJ5R2F0aW5nQWRkcmVzczogQWRkcmVzcwoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MjMKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLmVudHJ5R2F0aW5nQXNzZXRzID0gRW50cnlHYXRpbmdBc3NldHMKCXB1c2hpbnQgMTEzCglmcmFtZV9kaWcgLTQgLy8gRW50cnlHYXRpbmdBc3NldHM6IFN0YXRpY0FycmF5PHVpbnQ2NCwgND4KCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDI0CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5nYXRpbmdBc3NldE1pbkJhbGFuY2UgPSBHYXRpbmdBc3NldE1pbkJhbGFuY2UKCWludGMgMzcgLy8gMTQ1CglmcmFtZV9kaWcgLTUgLy8gR2F0aW5nQXNzZXRNaW5CYWxhbmNlOiB1aW50NjQKCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDI1CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5yZXdhcmRQZXJQYXlvdXQgPSBSZXdhcmRQZXJQYXlvdXQKCXB1c2hpbnQgMTYxCglmcmFtZV9kaWcgLTYgLy8gUmV3YXJkUGVyUGF5b3V0OiB1aW50NjQKCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCXJldHN1YgoKLy8gYWRkUG9vbChwYXksdWludDY0LHVpbnQ2NCkodWludDY0LHVpbnQ2NCx1aW50NjQpCiphYmlfcm91dGVfYWRkUG9vbDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gbm9kZU51bTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIG1iclBheW1lbnQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludGMgMSAvLyAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnRjIDEgLy8gIHBheQoJPT0KCgkvLyBhcmd1bWVudCAyIChtYnJQYXltZW50KSBmb3IgYWRkUG9vbCBtdXN0IGJlIGEgcGF5IHRyYW5zYWN0aW9uCglhc3NlcnQKCgkvLyBleGVjdXRlIGFkZFBvb2wocGF5LHVpbnQ2NCx1aW50NjQpKHVpbnQ2NCx1aW50NjQsdWludDY0KQoJY2FsbHN1YiBhZGRQb29sCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gYWRkUG9vbChtYnJQYXltZW50OiBQYXlUeG4sIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIG5vZGVOdW06IHVpbnQ2NCk6IFZhbGlkYXRvclBvb2xLZXkKLy8KLy8gQWRkcyBhIG5ldyBwb29sIHRvIGEgdmFsaWRhdG9yJ3MgcG9vbCBzZXQsIHJldHVybmluZyB0aGUgJ2tleScgdG8gcmVmZXJlbmNlIHRoZSBwb29sIGluIHRoZSBmdXR1cmUgZm9yIHN0YWtpbmcsIGV0Yy4KLy8gVGhlIGNhbGxlciBtdXN0IHBheSB0aGUgY29zdCBvZiB0aGUgdmFsaWRhdG9ycyBNQlIgaW5jcmVhc2UgYXMgd2VsbCBhcyB0aGUgTUJSIHRoYXQgd2lsbCBiZSBuZWVkZWQgZm9yIHRoZSBwb29sIGl0c2VsZi4KLy8KLy8gWyBPTkxZIE9XTkVSIE9SIE1BTkFHRVIgQ0FOIGNhbGwgXQovLyBAcGFyYW0ge1BheVR4bn0gbWJyUGF5bWVudCBwYXltZW50IGZyb20gY2FsbGVyIHdoaWNoIGNvdmVycyBtYnIgaW5jcmVhc2Ugb2YgYWRkaW5nIGEgbmV3IHBvb2wKLy8gQHBhcmFtIHt1aW50NjR9IHZhbGlkYXRvcklkIGlzIGlkIG9mIHZhbGlkYXRvciB0byBwb29sIHRvIChtdXN0IGJlIG93bmVyIG9yIG1hbmFnZXIpCi8vIEBwYXJhbSB7dWludDY0fSBub2RlTnVtIGlzIG5vZGUgbnVtYmVyIHRvIGFkZCB0bwovLyBAcmV0dXJucyB7VmFsaWRhdG9yUG9vbEtleX0gcG9vbCBrZXkgdG8gY3JlYXRlZCBwb29sCmFkZFBvb2w6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ0MAoJLy8gdGhpcy5jYWxsZXJNdXN0QmVPd25lck9yTWFuYWdlcih2YWxpZGF0b3JJZCkKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCgljYWxsc3ViIGNhbGxlck11c3RCZU93bmVyT3JNYW5hZ2VyCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ0MwoJLy8gdmVyaWZ5UGF5VHhuKG1iclBheW1lbnQsIHsgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsIGFtb3VudDogdGhpcy5nZXRNYnJBbW91bnRzKCkuYWRkUG9vbE1iciB9KQoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gbWJyUGF5bWVudDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJtYnJQYXltZW50IiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gbWJyUGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWNhbGxzdWIgZ2V0TWJyQW1vdW50cwoJZXh0cmFjdCA4IDgKCWJ0b2kKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJtYnJQYXltZW50IiwiZmllbGQiOiJhbW91bnQiLCJleHBlY3RlZCI6InRoaXMuZ2V0TWJyQW1vdW50cygpLmFkZFBvb2xNYnIifQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ0NQoJLy8gYXNzZXJ0KHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkuZXhpc3RzLCAic3BlY2lmaWVkIHZhbGlkYXRvciBpZCBpc24ndCB2YWxpZCIpCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWJveF9sZW4KCXN3YXAKCXBvcAoKCS8vIHNwZWNpZmllZCB2YWxpZGF0b3IgaWQgaXNuJ3QgdmFsaWQKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NDcKCS8vIG51bVBvb2xzOiB1aW50NjQgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnN0YXRlLm51bVBvb2xzIGFzIHVpbnQ2NAoJaW50YyA5IC8vIDI0MgoJaW50YyAxMCAvLyAyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDAgLy8gbnVtUG9vbHM6IHVpbnQ2NAoKCS8vICppZjlfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDQ4CgkvLyAobnVtUG9vbHMgYXMgdWludDY0KSA+PSBNQVhfUE9PTFMKCWZyYW1lX2RpZyAwIC8vIG51bVBvb2xzOiB1aW50NjQKCWludGMgMyAvLyAyNAoJPj0KCWJ6ICppZjlfZW5kCgoJLy8gKmlmOV9jb25zZXF1ZW50CgkvLyBhbHJlYWR5IGF0IG1heCBwb29sIHNpemUKCWVycgoKKmlmOV9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDUxCgkvLyBudW1Qb29scyArPSAxCglmcmFtZV9kaWcgMCAvLyBudW1Qb29sczogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAwIC8vIG51bVBvb2xzOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDU0CgkvLyBzZW5kQXBwQ2FsbCh7CgkvLyAgICAgICBvbkNvbXBsZXRpb246IE9uQ29tcGxldGlvbi5Ob09wLAoJLy8gICAgICAgYXBwcm92YWxQcm9ncmFtOiBbCgkvLyAgICAgICAgIHRoaXMuc3Rha2luZ1Bvb2xBcHByb3ZhbFByb2dyYW0uZXh0cmFjdCgwLCA0MDk2KSwKCS8vICAgICAgICAgdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5leHRyYWN0KDQwOTYsIHRoaXMuc3Rha2luZ1Bvb2xBcHByb3ZhbFByb2dyYW0uc2l6ZSAtIDQwOTYpLAoJLy8gICAgICAgXSwKCS8vICAgICAgIGNsZWFyU3RhdGVQcm9ncmFtOiBTdGFraW5nUG9vbC5jbGVhclByb2dyYW0oKSwKCS8vICAgICAgIGdsb2JhbE51bVVpbnQ6IFN0YWtpbmdQb29sLnNjaGVtYS5nbG9iYWwubnVtVWludCwKCS8vICAgICAgIGdsb2JhbE51bUJ5dGVTbGljZTogU3Rha2luZ1Bvb2wuc2NoZW1hLmdsb2JhbC5udW1CeXRlU2xpY2UsCgkvLyAgICAgICBleHRyYVByb2dyYW1QYWdlczogMywKCS8vICAgICAgIGFwcGxpY2F0aW9uQXJnczogWwoJLy8gICAgICAgICAvLyBjcmVhdGluZ0NvbnRyYWN0SUQsIHZhbGlkYXRvcklkLCBwb29sSWQsIG1pbkVudHJ5U3Rha2UKCS8vICAgICAgICAgbWV0aG9kKCdjcmVhdGVBcHBsaWNhdGlvbih1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCcpLAoJLy8gICAgICAgICBpdG9iKHRoaXMuYXBwLmlkKSwKCS8vICAgICAgICAgaXRvYih2YWxpZGF0b3JJZCksCgkvLyAgICAgICAgIGl0b2IobnVtUG9vbHMgYXMgdWludDY0KSwKCS8vICAgICAgICAgaXRvYih0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5taW5FbnRyeVN0YWtlKSwKCS8vICAgICAgIF0sCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NTUKCS8vIG9uQ29tcGxldGlvbjogT25Db21wbGV0aW9uLk5vT3AKCWludGMgMCAvLyAgTm9PcAoJaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDU2CgkvLyBhcHByb3ZhbFByb2dyYW06IFsKCS8vICAgICAgICAgdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5leHRyYWN0KDAsIDQwOTYpLAoJLy8gICAgICAgICB0aGlzLnN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtLmV4dHJhY3QoNDA5NiwgdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5zaXplIC0gNDA5NiksCgkvLyAgICAgICBdCglieXRlYyA5IC8vICAicG9vbFRlbXBsYXRlQXBwcm92YWxCeXRlcyIKCWludGMgMCAvLyAwCglpbnRjIDI1IC8vIDQwOTYKCWJveF9leHRyYWN0CglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbVBhZ2VzCglieXRlYyA5IC8vICAicG9vbFRlbXBsYXRlQXBwcm92YWxCeXRlcyIKCWludGMgMjUgLy8gNDA5NgoJYnl0ZWMgOSAvLyAgInBvb2xUZW1wbGF0ZUFwcHJvdmFsQnl0ZXMiCglib3hfbGVuCgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtLnNpemUKCWFzc2VydAoJaW50YyAyNSAvLyA0MDk2CgktCglib3hfZXh0cmFjdAoJaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW1QYWdlcwoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NjAKCS8vIGNsZWFyU3RhdGVQcm9ncmFtOiBTdGFraW5nUG9vbC5jbGVhclByb2dyYW0oKQoJcHVzaGJ5dGVzIDB4MGIKCWl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDYxCgkvLyBnbG9iYWxOdW1VaW50OiBTdGFraW5nUG9vbC5zY2hlbWEuZ2xvYmFsLm51bVVpbnQKCWludGMgMzUgLy8gMTEKCWl0eG5fZmllbGQgR2xvYmFsTnVtVWludAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NjIKCS8vIGdsb2JhbE51bUJ5dGVTbGljZTogU3Rha2luZ1Bvb2wuc2NoZW1hLmdsb2JhbC5udW1CeXRlU2xpY2UKCWludGMgOCAvLyAzCglpdHhuX2ZpZWxkIEdsb2JhbE51bUJ5dGVTbGljZQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NjMKCS8vIGV4dHJhUHJvZ3JhbVBhZ2VzOiAzCglpbnRjIDggLy8gMwoJaXR4bl9maWVsZCBFeHRyYVByb2dyYW1QYWdlcwoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NjQKCS8vIGFwcGxpY2F0aW9uQXJnczogWwoJLy8gICAgICAgICAvLyBjcmVhdGluZ0NvbnRyYWN0SUQsIHZhbGlkYXRvcklkLCBwb29sSWQsIG1pbkVudHJ5U3Rha2UKCS8vICAgICAgICAgbWV0aG9kKCdjcmVhdGVBcHBsaWNhdGlvbih1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCcpLAoJLy8gICAgICAgICBpdG9iKHRoaXMuYXBwLmlkKSwKCS8vICAgICAgICAgaXRvYih2YWxpZGF0b3JJZCksCgkvLyAgICAgICAgIGl0b2IobnVtUG9vbHMgYXMgdWludDY0KSwKCS8vICAgICAgICAgaXRvYih0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5taW5FbnRyeVN0YWtlKSwKCS8vICAgICAgIF0KCXB1c2hieXRlcyAweDU5ZTkwYWE2IC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24odWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDAgLy8gbnVtUG9vbHM6IHVpbnQ2NAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWludGMgMzkgLy8gMjA5CglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ3NAoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5zdGF0ZS5udW1Qb29scyA9IG51bVBvb2xzIGFzIHVpbnQxNgoJaW50YyA5IC8vIDI0MgoJZnJhbWVfZGlnIDAgLy8gbnVtUG9vbHM6IHVpbnQ2NAoJaXRvYgoJZXh0cmFjdCA2IDIKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDc3CgkvLyBwb29sQXBwSWQgPSB0aGlzLml0eG4uY3JlYXRlZEFwcGxpY2F0aW9uSUQuaWQKCWl0eG4gQ3JlYXRlZEFwcGxpY2F0aW9uSUQKCWZyYW1lX2J1cnkgMSAvLyBwb29sQXBwSWQ6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NzgKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUucG9vbHNbbnVtUG9vbHMgLSAxXS5wb29sQXBwSWQgPSBwb29sQXBwSWQKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIDAgLy8gbnVtUG9vbHM6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCS0KCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnRjIDAgLy8gMAoJKwoJZnJhbWVfZGlnIDEgLy8gcG9vbEFwcElkOiB1aW50NjQKCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDc5CgkvLyB0aGlzLmFkZFBvb2xUb05vZGUodmFsaWRhdG9ySWQsIHBvb2xBcHBJZCwgbm9kZU51bSkKCWZyYW1lX2RpZyAtMyAvLyBub2RlTnVtOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIHBvb2xBcHBJZDogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJY2FsbHN1YiBhZGRQb29sVG9Ob2RlCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ4MQoJLy8gdGhpcy5yZXRpT1BfdmFsaWRhdG9yQWRkZWRQb29sLmxvZyh7CgkvLyAgICAgICBpZDogdmFsaWRhdG9ySWQsCgkvLyAgICAgICBudW06IG51bVBvb2xzIGFzIHVpbnQxNiwKCS8vICAgICAgIHBvb2xBcHBJZDogQXBwSUQuZnJvbVVpbnQ2NChwb29sQXBwSWQpLAoJLy8gICAgIH0pCglwdXNoYnl0ZXMgMHhmYmNjMGY2YiAvLyByZXRpT1BfdmFsaWRhdG9yQWRkZWRQb29sKHVpbnQ2NCx1aW50MTYsdWludDY0KQoJZnJhbWVfZGlnIC0yIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWZyYW1lX2RpZyAwIC8vIG51bVBvb2xzOiB1aW50NjQKCWl0b2IKCWR1cAoJYml0bGVuCglpbnRjIDE4IC8vIDE2Cgk8PQoKCS8vIG51bVBvb2xzIGFzIHVpbnQxNiBvdmVyZmxvd2VkIDE2IGJpdHMKCWFzc2VydAoJZXh0cmFjdCA2IDIKCWNvbmNhdAoJZnJhbWVfZGlnIDEgLy8gcG9vbEFwcElkOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJY29uY2F0Cglsb2cKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDg3CgkvLyByZXR1cm4geyBpZDogdmFsaWRhdG9ySWQsIHBvb2xJZDogbnVtUG9vbHMgYXMgdWludDY0LCBwb29sQXBwSWQ6IHRoaXMuaXR4biEuY3JlYXRlZEFwcGxpY2F0aW9uSUQuaWQgfTsKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCglmcmFtZV9kaWcgMCAvLyBudW1Qb29sczogdWludDY0CglpdG9iCgljb25jYXQKCWl0eG4gQ3JlYXRlZEFwcGxpY2F0aW9uSUQKCWl0b2IKCWNvbmNhdAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gYWRkU3Rha2UocGF5LHVpbnQ2NCx1aW50NjQpKHVpbnQ2NCx1aW50NjQsdWludDY0KQoqYWJpX3JvdXRlX2FkZFN0YWtlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyB2YWx1ZVRvVmVyaWZ5OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gc3Rha2VkQW1vdW50UGF5bWVudDogcGF5Cgl0eG4gR3JvdXBJbmRleAoJaW50YyAxIC8vIDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludGMgMSAvLyAgcGF5Cgk9PQoKCS8vIGFyZ3VtZW50IDIgKHN0YWtlZEFtb3VudFBheW1lbnQpIGZvciBhZGRTdGFrZSBtdXN0IGJlIGEgcGF5IHRyYW5zYWN0aW9uCglhc3NlcnQKCgkvLyBleGVjdXRlIGFkZFN0YWtlKHBheSx1aW50NjQsdWludDY0KSh1aW50NjQsdWludDY0LHVpbnQ2NCkKCWNhbGxzdWIgYWRkU3Rha2UKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBhZGRTdGFrZShzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4sIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIHZhbHVlVG9WZXJpZnk6IHVpbnQ2NCk6IFZhbGlkYXRvclBvb2xLZXkKLy8KLy8gQWRkcyBzdGFrZSB0byBhIHZhbGlkYXRvciBwb29sLgovLwovLyBAcGFyYW0ge1BheVR4bn0gc3Rha2VkQW1vdW50UGF5bWVudCAtIHBheW1lbnQgY29taW5nIGZyb20gc3Rha2VyIHRvIHBsYWNlIGludG8gYSBwb29sCi8vIEBwYXJhbSB7VmFsaWRhdG9ySWRUeXBlfSB2YWxpZGF0b3JJZCAtIFRoZSBpZCBvZiB0aGUgdmFsaWRhdG9yLgovLyBAcGFyYW0ge3VpbnQ2NH0gdmFsdWVUb1ZlcmlmeSAtIG9ubHkgaWYgdmFsaWRhdG9yIGhhcyBnYXRpbmcgdG8gZW50ZXIgLSB0aGlzIGlzIGFzc2V0IGlkIG9yIG5mZCBpZCB0aGF0IGNvcnJlc3BvbmRzIHRvIGdhdGluZy4KLy8gVHhuIHNlbmRlciBpcyBmYWN0b3JlZCBpbiBhcyB3ZWxsIGlmIHRoYXQgaXMgcGFydCBvZiBnYXRpbmcuCi8vICogQHJldHVybnMge1ZhbGlkYXRvclBvb2xLZXl9IC0gVGhlIGtleSBvZiB0aGUgdmFsaWRhdG9yIHBvb2wuCmFkZFN0YWtlOgoJcHJvdG8gMyAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDEgLy8gMHgKCWR1cG4gNQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MDAKCS8vIGFzc2VydCh0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLmV4aXN0cywgInNwZWNpZmllZCB2YWxpZGF0b3IgaWQgaXNuJ3QgdmFsaWQiKQoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cglib3hfbGVuCglzd2FwCglwb3AKCgkvLyBzcGVjaWZpZWQgdmFsaWRhdG9yIGlkIGlzbid0IHZhbGlkCglhc3NlcnQKCgkvLyAqaWYxMF9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MDMKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLnN1bnNldHRpbmdPbiA+IDAKCWludGMgMjcgLy8gMjI2CglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJaW50YyAwIC8vIDAKCT4KCWJ6ICppZjEwX2VuZAoKCS8vICppZjEwX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MDUKCS8vIGFzc2VydCgKCS8vICAgICAgICAgdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcuc3Vuc2V0dGluZ09uID4gZ2xvYmFscy5sYXRlc3RUaW1lc3RhbXAsCgkvLyAgICAgICAgICJjYW4ndCBzdGFrZSB3aXRoIGEgdmFsaWRhdG9yIHRoYXQgaXMgcGFzdCBpdHMgc3Vuc2V0dGluZyB0aW1lIgoJLy8gICAgICAgKQoJaW50YyAyNyAvLyAyMjYKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCgk+CgoJLy8gY2FuJ3Qgc3Rha2Ugd2l0aCBhIHZhbGlkYXRvciB0aGF0IGlzIHBhc3QgaXRzIHN1bnNldHRpbmcgdGltZQoJYXNzZXJ0CgoqaWYxMF9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTExCgkvLyBzdGFrZXIgPSB0aGlzLnR4bi5zZW5kZXIKCXR4biBTZW5kZXIKCWZyYW1lX2J1cnkgMCAvLyBzdGFrZXI6IGFkZHJlc3MKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTE1CgkvLyB2ZXJpZnlQYXlUeG4oc3Rha2VkQW1vdW50UGF5bWVudCwgewoJLy8gICAgICAgc2VuZGVyOiBzdGFrZXIsCgkvLyAgICAgICByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCglmcmFtZV9kaWcgMCAvLyBzdGFrZXI6IGFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJzdGFrZWRBbW91bnRQYXltZW50IiwiZmllbGQiOiJzZW5kZXIiLCJleHBlY3RlZCI6InN0YWtlciJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InN0YWtlZEFtb3VudFBheW1lbnQiLCJmaWVsZCI6InJlY2VpdmVyIiwiZXhwZWN0ZWQiOiJ0aGlzLmFwcC5hZGRyZXNzIn0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MjMKCS8vIHRoaXMuZG9lc1N0YWtlck1lZXRHYXRpbmcodmFsaWRhdG9ySWQsIHZhbHVlVG9WZXJpZnkpCglmcmFtZV9kaWcgLTMgLy8gdmFsdWVUb1ZlcmlmeTogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJY2FsbHN1YiBkb2VzU3Rha2VyTWVldEdhdGluZwoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MjUKCS8vIHJlYWxBbW91bnQgPSBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9idXJ5IDEgLy8gcmVhbEFtb3VudDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUyNgoJLy8gbWJyQW10TGVmdEJlaGluZDogdWludDY0ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMiAvLyBtYnJBbXRMZWZ0QmVoaW5kOiB1aW50NjQKCgkvLyAqaWYxMV9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MjgKCS8vIHRoaXMuZG9lc1N0YWtlck5lZWRUb1BheU1CUihzdGFrZXIpCglmcmFtZV9kaWcgMCAvLyBzdGFrZXI6IGFkZHJlc3MKCWNhbGxzdWIgZG9lc1N0YWtlck5lZWRUb1BheU1CUgoJYnogKmlmMTFfZW5kCgoJLy8gKmlmMTFfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUzMQoJLy8gbWJyQW10TGVmdEJlaGluZCA9IHRoaXMuZ2V0TWJyQW1vdW50cygpLmFkZFN0YWtlck1icgoJY2FsbHN1YiBnZXRNYnJBbW91bnRzCglleHRyYWN0IDI0IDgKCWJ0b2kKCWZyYW1lX2J1cnkgMiAvLyBtYnJBbXRMZWZ0QmVoaW5kOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTMyCgkvLyByZWFsQW1vdW50IC09IG1ickFtdExlZnRCZWhpbmQKCWZyYW1lX2RpZyAxIC8vIHJlYWxBbW91bnQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDIgLy8gbWJyQW10TGVmdEJlaGluZDogdWludDY0CgktCglmcmFtZV9idXJ5IDEgLy8gcmVhbEFtb3VudDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUzMwoJLy8gdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikuY3JlYXRlKCkKCWJ5dGVjIDMgLy8gICJzcHMiCglmcmFtZV9kaWcgMCAvLyBzdGFrZXI6IGFkZHJlc3MKCWNvbmNhdAoJcHVzaGludCAxNDQKCWJveF9jcmVhdGUKCXBvcAoKKmlmMTFfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUzNwoJLy8gYXNzZXJ0KAoJLy8gICAgICAgdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5zdGF0ZS50b3RhbEFsZ29TdGFrZWQgKyByZWFsQW1vdW50IDwgdGhpcy5tYXhBbGxvd2VkU3Rha2UoKSwKCS8vICAgICAgICd0b3RhbCBzdGFrZWQgZm9yIGFsbCBvZiBhIHZhbGlkYXRvcnMgcG9vbHMgbWF5IG5vdCBleGNlZWQgaGFyZCBjYXAnCgkvLyAgICAgKQoJaW50YyAxMiAvLyAyNTIKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgMSAvLyByZWFsQW1vdW50OiB1aW50NjQKCSsKCWNhbGxzdWIgbWF4QWxsb3dlZFN0YWtlCgk8CgoJLy8gdG90YWwgc3Rha2VkIGZvciBhbGwgb2YgYSB2YWxpZGF0b3JzIHBvb2xzIG1heSBub3QgZXhjZWVkIGhhcmQgY2FwCglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTQ0CgkvLyBmaW5kUmV0ID0gdGhpcy5maW5kUG9vbEZvclN0YWtlcih2YWxpZGF0b3JJZCwgc3Rha2VyLCByZWFsQW1vdW50KQoJZnJhbWVfZGlnIDEgLy8gcmVhbEFtb3VudDogdWludDY0CglmcmFtZV9kaWcgMCAvLyBzdGFrZXI6IGFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCgljYWxsc3ViIGZpbmRQb29sRm9yU3Rha2VyCglmcmFtZV9idXJ5IDMgLy8gZmluZFJldDogKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxib29sKQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1NDUKCS8vIHBvb2xLZXkgPSBmaW5kUmV0WzBdCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTQ2CgkvLyBpc05ld1N0YWtlclRvVmFsaWRhdG9yID0gZmluZFJldFsxXQoJZnJhbWVfZGlnIDMgLy8gZmluZFJldDogKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxib29sKQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMjIgLy8gMTkyCglnZXRiaXQKCWZyYW1lX2J1cnkgNCAvLyBpc05ld1N0YWtlclRvVmFsaWRhdG9yOiBib29sCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU0NwoJLy8gaXNOZXdTdGFrZXJUb1Byb3RvY29sID0gZmluZFJldFsyXQoJZnJhbWVfZGlnIDMgLy8gZmluZFJldDogKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxib29sKQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXB1c2hpbnQgMTkzCglnZXRiaXQKCWZyYW1lX2J1cnkgNSAvLyBpc05ld1N0YWtlclRvUHJvdG9jb2w6IGJvb2wKCgkvLyAqaWYxMl9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1NDgKCS8vIHBvb2xLZXkucG9vbElkID09PSAwCglmcmFtZV9kaWcgMyAvLyBmaW5kUmV0OiAoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxib29sLGJvb2wpCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmMTJfZW5kCgoJLy8gKmlmMTJfY29uc2VxdWVudAoJLy8gTm8gcG9vbCBhdmFpbGFibGUgd2l0aCBmcmVlIHN0YWtlLiAgVmFsaWRhdG9yIG5lZWRzIHRvIGFkZCBhbm90aGVyIHBvb2wKCWVycgoKKmlmMTJfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU1MwoJLy8gdGhpcy51cGRhdGVTdGFrZXJQb29sU2V0KHN0YWtlciwgcG9vbEtleSkKCWZyYW1lX2RpZyAzIC8vIGZpbmRSZXQ6ICgodWludDY0LHVpbnQ2NCx1aW50NjQpLGJvb2wsYm9vbCkKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDAgMjQKCWZyYW1lX2RpZyAwIC8vIHN0YWtlcjogYWRkcmVzcwoJY2FsbHN1YiB1cGRhdGVTdGFrZXJQb29sU2V0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU1NgoJLy8gdGhpcy5jYWxsUG9vbEFkZFN0YWtlKAoJLy8gICAgICAgc3Rha2VkQW1vdW50UGF5bWVudCwKCS8vICAgICAgIHBvb2xLZXksCgkvLyAgICAgICBtYnJBbXRMZWZ0QmVoaW5kLAoJLy8gICAgICAgaXNOZXdTdGFrZXJUb1ZhbGlkYXRvciwKCS8vICAgICAgIGlzTmV3U3Rha2VyVG9Qcm90b2NvbAoJLy8gICAgICkKCWZyYW1lX2RpZyA1IC8vIGlzTmV3U3Rha2VyVG9Qcm90b2NvbDogYm9vbAoJZnJhbWVfZGlnIDQgLy8gaXNOZXdTdGFrZXJUb1ZhbGlkYXRvcjogYm9vbAoJZnJhbWVfZGlnIDIgLy8gbWJyQW10TGVmdEJlaGluZDogdWludDY0CglmcmFtZV9kaWcgMyAvLyBmaW5kUmV0OiAoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxib29sLGJvb2wpCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAwIDI0CglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCgljYWxsc3ViIGNhbGxQb29sQWRkU3Rha2UKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTYzCgkvLyB0aGlzLnJldGlPUF9zdGFrZUFkZGVkLmxvZyh7CgkvLyAgICAgICBpZDogdmFsaWRhdG9ySWQsCgkvLyAgICAgICBwb29sTnVtOiBwb29sS2V5LnBvb2xJZCBhcyB1aW50MTYsCgkvLyAgICAgICBwb29sQXBwSWQ6IEFwcElELmZyb21VaW50NjQocG9vbEtleS5wb29sQXBwSWQpLAoJLy8gICAgICAgYW1vdW50U3Rha2VkOiByZWFsQW1vdW50LAoJLy8gICAgICAgc3Rha2VyOiBzdGFrZXIsCgkvLyAgICAgfSkKCXB1c2hieXRlcyAweDk2MmI0MTQzIC8vIHJldGlPUF9zdGFrZUFkZGVkKHVpbnQ2NCx1aW50MTYsdWludDY0LGFkZHJlc3MsdWludDY0KQoJZnJhbWVfZGlnIC0yIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWZyYW1lX2RpZyAzIC8vIGZpbmRSZXQ6ICgodWludDY0LHVpbnQ2NCx1aW50NjQpLGJvb2wsYm9vbCkKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDggOAoJYnRvaQoJaXRvYgoJZHVwCgliaXRsZW4KCWludGMgMTggLy8gMTYKCTw9CgoJLy8gcG9vbEtleS5wb29sSWQgYXMgdWludDE2IG92ZXJmbG93ZWQgMTYgYml0cwoJYXNzZXJ0CglleHRyYWN0IDYgMgoJY29uY2F0CglmcmFtZV9kaWcgMyAvLyBmaW5kUmV0OiAoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxib29sLGJvb2wpCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAxNiA4CglidG9pCglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAwIC8vIHN0YWtlcjogYWRkcmVzcwoJY29uY2F0CglmcmFtZV9kaWcgMSAvLyByZWFsQW1vdW50OiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJY29uY2F0Cglsb2cKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTcxCgkvLyByZXR1cm4gcG9vbEtleTsKCWZyYW1lX2RpZyAzIC8vIGZpbmRSZXQ6ICgodWludDY0LHVpbnQ2NCx1aW50NjQpLGJvb2wsYm9vbCkKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDAgMjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiA1CglyZXRzdWIKCi8vIHNldFRva2VuUGF5b3V0UmF0aW8odWludDY0KSh1aW50NjRbMjRdLHVpbnQ2NCkKKmFiaV9yb3V0ZV9zZXRUb2tlblBheW91dFJhdGlvOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBzZXRUb2tlblBheW91dFJhdGlvKHVpbnQ2NCkodWludDY0WzI0XSx1aW50NjQpCgljYWxsc3ViIHNldFRva2VuUGF5b3V0UmF0aW8KCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBzZXRUb2tlblBheW91dFJhdGlvKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUpOiBQb29sVG9rZW5QYXlvdXRSYXRpbwovLwovLyBzZXRUb2tlblBheW91dFJhdGlvIGlzIGNhbGxlZCBieSBTdGFraW5nIFBvb2wgIyAxIChPTkxZKSB0byBhc2sgdGhlIHZhbGlkYXRvciAodXMpIHRvIGNhbGN1bGF0ZSB0aGUgcmF0aW9zCi8vIG9mIHN0YWtlIGluIHRoZSBwb29scyBmb3Igc3Vic2VxdWVudCB0b2tlbiBwYXlvdXRzIChpZTogMiBwb29scywgJzEwMCcgYWxnbyB0b3RhbCBzdGFrZWQsIDYwIGluIHBvb2wgMSwgYW5kIDQwCi8vIGluIHBvb2wgMikgIFRoaXMgaXMgZG9uZSBzbyB3ZSBoYXZlIGEgc3RhYmxlIHNuYXBzaG90IG9mIHN0YWtlIC0gdGFrZW4gb25jZSBwZXIgZXBvY2ggLSBvbmx5IHRyaWdnZXJlZCBieQovLyBwb29sIDEgZG9pbmcgcGF5b3V0LiAgcG9vbHMgb3RoZXIgdGhhbiAxIGRvaW5nIHBheW91dCBjYWxsIHBvb2wgMSB0byBhc2sgaXQgZG8gaXQgZmlyc3QuCi8vIEl0IHdvdWxkIGJlIDYwLzQwJSBpbiB0aGUgcG9vbFBjdE9mV2hvbGUgdmFsdWVzLiAgVGhlIHRva2VuIHJld2FyZCBwYXlvdXRzIHRoZW4gdXNlIHRoZXNlIHZhbHVlcyBpbnN0ZWFkIG9mCi8vIHRoZWlyICdjdXJyZW50JyBzdGFrZSB3aGljaCBjaGFuZ2VzIGFzIHBhcnQgb2YgdGhlIHBheW91dHMgdGhlbXNlbHZlcyAoYW5kIHBlb3BsZSBjb3VsZCBiZSBjaGFuZ2luZyBzdGFrZQovLyBkdXJpbmcgdGhlIGVwb2NoIHVwZGF0ZXMgYWNyb3NzIHBvb2xzKQovLwovLyBNdWx0aXBsZSBwb29scyB3aWxsIGNhbGwgdXMgdmlhIHBvb2wgMSAocG9vbDItPnBvb2wxLT52YWxpZGF0b3IsIGV0Yy4pIHNvIGRvbid0IGFzc2VydCBvbiBwb29sMSBjYWxsaW5nIG11bHRpcGxlCi8vIHRpbWVzIGluIHNhbWUgZXBvY2guICBKdXN0IHJldHVybi4KLy8KLy8gQHBhcmFtIHZhbGlkYXRvcklkIC0gdmFsaWRhdG9yIGlkIChhbmQgdGh1cyBwb29sKSBjYWxsaW5nIHVzLiAgVmVyaWZpZWQgc28gdGhhdCBzZW5kZXIgTVVTVCBiZSBwb29sIDEgb2YgdGhpcyB2YWxpZGF0b3IuCi8vIEByZXR1cm5zIFBvb2xUb2tlblBheW91dFJhdGlvIC0gdGhlIGZpbmlzaGVkIHJhdGlvIGRhdGEKc2V0VG9rZW5QYXlvdXRSYXRpbzoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CglkdXBuIDgKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTkxCgkvLyBwb29sMUFwcElEID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29sc1swXS5wb29sQXBwSWQKCWludGMgNSAvLyAyNjgKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDAgLy8gcG9vbDFBcHBJRDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU5MgoJLy8gYXNzZXJ0KHBvb2wxQXBwSUQgIT09IDApCglmcmFtZV9kaWcgMCAvLyBwb29sMUFwcElEOiB1aW50NjQKCWludGMgMCAvLyAwCgkhPQoJYXNzZXJ0CgoJLy8gKmlmMTNfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTk0CgkvLyB0aGlzLnR4bi5zZW5kZXIgIT09IEFwcElELmZyb21VaW50NjQocG9vbDFBcHBJRCkuYWRkcmVzcwoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIDAgLy8gcG9vbDFBcHBJRDogdWludDY0CglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCSE9CglieiAqaWYxM19lbmQKCgkvLyAqaWYxM19jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTk1CgkvLyByZXR1cm4gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS50b2tlblBheW91dFJhdGlvOwoJaW50YyAxNCAvLyAgaGVhZE9mZnNldAoJaW50YyAxOSAvLyAyMDAKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWIgKnNldFRva2VuUGF5b3V0UmF0aW8qcmV0dXJuCgoqaWYxM19lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjAxCgkvLyBjdXJSb3VuZCA9IGdsb2JhbHMucm91bmQKCWdsb2JhbCBSb3VuZAoJZnJhbWVfYnVyeSAxIC8vIGN1clJvdW5kOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjAyCgkvLyBsYXN0UGF5b3V0VXBkYXRlID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS50b2tlblBheW91dFJhdGlvLnVwZGF0ZWRGb3JQYXlvdXQKCWludGMgMzEgLy8gODkyCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAyIC8vIGxhc3RQYXlvdXRVcGRhdGU6IHVpbnQ2NAoKCS8vICppZjE0X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYwMwoJLy8gbGFzdFBheW91dFVwZGF0ZSAhPT0gMAoJZnJhbWVfZGlnIDIgLy8gbGFzdFBheW91dFVwZGF0ZTogdWludDY0CglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjE0X2VuZAoKCS8vICppZjE0X2NvbnNlcXVlbnQKCS8vICppZjE1X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYwNQoJLy8gKEFwcElELmZyb21VaW50NjQocG9vbDFBcHBJRCkuZ2xvYmFsU3RhdGUoJ2xhc3RQYXlvdXQnKSBhcyB1aW50NjQpID09PSBsYXN0UGF5b3V0VXBkYXRlCglmcmFtZV9kaWcgMCAvLyBwb29sMUFwcElEOiB1aW50NjQKCXB1c2hieXRlcyAweDZjNjE3Mzc0NTA2MTc5NmY3NTc0IC8vICJsYXN0UGF5b3V0IgoJYXBwX2dsb2JhbF9nZXRfZXgKCgkvLyBnbG9iYWwgc3RhdGUgdmFsdWUgZG9lcyBub3QgZXhpc3Q6IEFwcElELmZyb21VaW50NjQocG9vbDFBcHBJRCkuZ2xvYmFsU3RhdGUoJ2xhc3RQYXlvdXQnKQoJYXNzZXJ0CglmcmFtZV9kaWcgMiAvLyBsYXN0UGF5b3V0VXBkYXRlOiB1aW50NjQKCT09CglieiAqaWYxNV9lbmQKCgkvLyAqaWYxNV9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjA2CgkvLyByZXR1cm4gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS50b2tlblBheW91dFJhdGlvOwoJaW50YyAxNCAvLyAgaGVhZE9mZnNldAoJaW50YyAxOSAvLyAyMDAKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWIgKnNldFRva2VuUGF5b3V0UmF0aW8qcmV0dXJuCgoqaWYxNV9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjA4CgkvLyBlcG9jaFJvdW5kTGVuZ3RoID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcuZXBvY2hSb3VuZExlbmd0aCBhcyB1aW50NjQKCXB1c2hpbnQgMTY5CglpbnRjIDE1IC8vIDQKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgMyAvLyBlcG9jaFJvdW5kTGVuZ3RoOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjA5CgkvLyB0aGlzRXBvY2hCZWdpbiA9IGN1clJvdW5kIC0gKGN1clJvdW5kICUgZXBvY2hSb3VuZExlbmd0aCkKCWZyYW1lX2RpZyAxIC8vIGN1clJvdW5kOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGN1clJvdW5kOiB1aW50NjQKCWZyYW1lX2RpZyAzIC8vIGVwb2NoUm91bmRMZW5ndGg6IHVpbnQ2NAoJJQoJLQoJZnJhbWVfYnVyeSA0IC8vIHRoaXNFcG9jaEJlZ2luOiB1aW50NjQKCgkvLyAqaWYxNl9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MTEKCS8vIGxhc3RQYXlvdXRVcGRhdGUgLSAobGFzdFBheW91dFVwZGF0ZSAlIGVwb2NoUm91bmRMZW5ndGgpID09PSB0aGlzRXBvY2hCZWdpbgoJZnJhbWVfZGlnIDIgLy8gbGFzdFBheW91dFVwZGF0ZTogdWludDY0CglmcmFtZV9kaWcgMiAvLyBsYXN0UGF5b3V0VXBkYXRlOiB1aW50NjQKCWZyYW1lX2RpZyAzIC8vIGVwb2NoUm91bmRMZW5ndGg6IHVpbnQ2NAoJJQoJLQoJZnJhbWVfZGlnIDQgLy8gdGhpc0Vwb2NoQmVnaW46IHVpbnQ2NAoJPT0KCWJ6ICppZjE2X2VuZAoKCS8vICppZjE2X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MTIKCS8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnRva2VuUGF5b3V0UmF0aW87CglpbnRjIDE0IC8vICBoZWFkT2Zmc2V0CglpbnRjIDE5IC8vIDIwMAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYiAqc2V0VG9rZW5QYXlvdXRSYXRpbypyZXR1cm4KCippZjE2X2VuZDoKCippZjE0X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MTUKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUudG9rZW5QYXlvdXRSYXRpby51cGRhdGVkRm9yUGF5b3V0ID0gY3VyUm91bmQKCWludGMgMzEgLy8gODkyCglmcmFtZV9kaWcgMSAvLyBjdXJSb3VuZDogdWludDY0CglpdG9iCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYxNwoJLy8gY3VyTnVtUG9vbHMgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnN0YXRlLm51bVBvb2xzIGFzIHVpbnQ2NAoJaW50YyA5IC8vIDI0MgoJaW50YyAxMCAvLyAyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDUgLy8gY3VyTnVtUG9vbHM6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MTgKCS8vIHRvdGFsU3Rha2VGb3JWYWxpZGF0b3IgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnN0YXRlLnRvdGFsQWxnb1N0YWtlZAoJaW50YyAxMiAvLyAyNTIKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDYgLy8gdG90YWxTdGFrZUZvclZhbGlkYXRvcjogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYxOQoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJOdW1Qb29sczsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNyAvLyBpOiB1aW50NjQKCipmb3JfMjoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MTkKCS8vIGkgPCBjdXJOdW1Qb29scwoJZnJhbWVfZGlnIDcgLy8gaTogdWludDY0CglmcmFtZV9kaWcgNSAvLyBjdXJOdW1Qb29sczogdWludDY0Cgk8CglieiAqZm9yXzJfZW5kCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYyNAoJLy8gb3VyUG9vbFBjdE9mV2hvbGUgPSB3aWRlUmF0aW8oCgkvLyAgICAgICAgIFt0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnBvb2xzW2ldLnRvdGFsQWxnb1N0YWtlZCwgMV8wMDBfMDAwXSwKCS8vICAgICAgICAgW3RvdGFsU3Rha2VGb3JWYWxpZGF0b3JdCgkvLyAgICAgICApCglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyA3IC8vIGk6IHVpbnQ2NAoJaW50YyA0IC8vIDE4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMTEgLy8gIGhlYWRPZmZzZXQKCSsKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglwdXNoaW50IDFfMDAwXzAwMAoJbXVsdwoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyA2IC8vIHRvdGFsU3Rha2VGb3JWYWxpZGF0b3I6IHVpbnQ2NAoJZGl2bW9kdwoJcG9wCglwb3AKCXN3YXAKCSEKCgkvLyB3aWRlUmF0aW8gZmFpbGVkCglhc3NlcnQKCWZyYW1lX2J1cnkgOCAvLyBvdXJQb29sUGN0T2ZXaG9sZTogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYyOAoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS50b2tlblBheW91dFJhdGlvLnBvb2xQY3RPZldob2xlW2ldID0gb3VyUG9vbFBjdE9mV2hvbGUKCWludGMgMTQgLy8gNzAwCglmcmFtZV9kaWcgNyAvLyBpOiB1aW50NjQKCWludGMgMiAvLyA4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWZyYW1lX2RpZyA4IC8vIG91clBvb2xQY3RPZldob2xlOiB1aW50NjQKCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCipmb3JfMl9jb250aW51ZToKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MTkKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDcgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSA3IC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzIKCipmb3JfMl9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjMwCgkvLyByZXR1cm4gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS50b2tlblBheW91dFJhdGlvOwoJaW50YyAxNCAvLyAgaGVhZE9mZnNldAoJaW50YyAxOSAvLyAyMDAKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCipzZXRUb2tlblBheW91dFJhdGlvKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDgKCXJldHN1YgoKLy8gc3Rha2VVcGRhdGVkVmlhUmV3YXJkcygodWludDY0LHVpbnQ2NCx1aW50NjQpLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfc3Rha2VVcGRhdGVkVmlhUmV3YXJkczoKCS8vIHNhdHVyYXRlZEJ1cm5Ub0ZlZVNpbms6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJYnRvaQoKCS8vIHZhbGlkYXRvckNvbW1pc3Npb246IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJYnRvaQoKCS8vIHJld2FyZFRva2VuQW1vdW50UmVzZXJ2ZWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGFsZ29Ub0FkZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gcG9vbEtleTogKHVpbnQ2NCx1aW50NjQsdWludDY0KQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgMyAvLyAyNAoJPT0KCgkvLyBhcmd1bWVudCA0IChwb29sS2V5KSBmb3Igc3Rha2VVcGRhdGVkVmlhUmV3YXJkcyBtdXN0IGJlIGEgKHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzKCh1aW50NjQsdWludDY0LHVpbnQ2NCksdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgc3Rha2VVcGRhdGVkVmlhUmV3YXJkcwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gc3Rha2VVcGRhdGVkVmlhUmV3YXJkcyhwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5LCBhbGdvVG9BZGQ6IHVpbnQ2NCwgcmV3YXJkVG9rZW5BbW91bnRSZXNlcnZlZDogdWludDY0LCB2YWxpZGF0b3JDb21taXNzaW9uOiB1aW50NjQsIHNhdHVyYXRlZEJ1cm5Ub0ZlZVNpbms6IHVpbnQ2NCk6IHZvaWQKLy8KLy8gc3Rha2VVcGRhdGVkVmlhUmV3YXJkcyBpcyBjYWxsZWQgYnkgU3Rha2luZyBwb29scyB0byBpbmZvcm0gdGhlIHZhbGlkYXRvciAodXMpIHRoYXQgYSBwYXJ0aWN1bGFyIGFtb3VudCBvZiB0b3RhbAovLyBzdGFrZSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgc3BlY2lmaWVkIHBvb2wuICBUaGlzIGlzIHVzZWQgdG8gdXBkYXRlIHRoZSBzdGF0cyB3ZSBoYXZlIGluIG91ciBQb29sSW5mbyBzdG9yYWdlLgovLyBUaGUgY2FsbGluZyBBcHAgaWQgaXMgdmFsaWRhdGVkIGFnYWluc3Qgb3VyIHBvb2wgbGlzdCBhcyB3ZWxsLgovLyBAcGFyYW0ge1ZhbGlkYXRvclBvb2xLZXl9IHBvb2xLZXkgLSBWYWxpZGF0b3JQb29sS2V5IHR5cGUKLy8gQHBhcmFtIHt1aW50NjR9IGFsZ29Ub0FkZCAtIGFtb3VudCB0aGlzIHZhbGlkYXRvcidzIHRvdGFsIHN0YWtlIGluY3JlYXNlZCB2aWEgcmV3YXJkcwovLyBAcGFyYW0ge3VpbnQ2NH0gcmV3YXJkVG9rZW5BbW91bnRSZXNlcnZlZCAtIGFtb3VudCB0aGlzIHZhbGlkYXRvcidzIHRvdGFsIHN0YWtlIGluY3JlYXNlZCB2aWEgcmV3YXJkcyAodGhhdCBzaG91bGQgYmUKLy8gQHBhcmFtIHt1aW50NjR9IHZhbGlkYXRvckNvbW1pc3Npb24gLSB0aGUgY29tbWlzc2lvbiBhbW91bnQgdGhlIHZhbGlkYXRvciB3YXMgcGFpZCwgaWYgYW55Ci8vIEBwYXJhbSB7dWludDY0fSBzYXR1cmF0ZWRCdXJuVG9GZWVTaW5rIC0gaWYgdGhlIHBvb2wgd2FzIGluIHNhdHVyYXRlZCBzdGF0ZSwgdGhlIGFtb3VudCBzZW50IGJhY2sgdG8gdGhlIGZlZSBzaW5rLgovLyBzZWVuIGFzICdhY2NvdW50ZWQgZm9yL3BlbmRpbmcgc3BlbnQnKQpzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzOgoJcHJvdG8gNSAwCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY1MQoJLy8gdGhpcy52ZXJpZnlQb29sS2V5Q2FsbGVyKHBvb2xLZXkpCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJY2FsbHN1YiB2ZXJpZnlQb29sS2V5Q2FsbGVyCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY1NAoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnBvb2xzW3Bvb2xLZXkucG9vbElkIC0gMV0udG90YWxBbGdvU3Rha2VkICs9IGFsZ29Ub0FkZAoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAxMSAvLyAgaGVhZE9mZnNldAoJKwoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAxMSAvLyAgaGVhZE9mZnNldAoJKwoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgLTIgLy8gYWxnb1RvQWRkOiB1aW50NjQKCSsKCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY1NQoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLnRvdGFsQWxnb1N0YWtlZCArPSBhbGdvVG9BZGQKCWludGMgMTIgLy8gMjUyCglkdXAKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0yIC8vIGFsZ29Ub0FkZDogdWludDY0CgkrCglpdG9iCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2NTYKCS8vIHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5zdGF0ZS5yZXdhcmRUb2tlbkhlbGRCYWNrICs9IHJld2FyZFRva2VuQW1vdW50UmVzZXJ2ZWQKCWludGMgMTMgLy8gMjYwCglkdXAKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0zIC8vIHJld2FyZFRva2VuQW1vdW50UmVzZXJ2ZWQ6IHVpbnQ2NAoJKwoJaXRvYgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjU4CgkvLyB0aGlzLnRvdGFsQWxnb1N0YWtlZC52YWx1ZSArPSBhbGdvVG9BZGQKCWJ5dGVjIDQgLy8gICJzdGFrZWQiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0yIC8vIGFsZ29Ub0FkZDogdWludDY0CgkrCglieXRlYyA0IC8vICAic3Rha2VkIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjYxCgkvLyB0aGlzLnJldmVyaWZ5TkZET3duZXJzaGlwKHBvb2xLZXkuaWQpCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWNhbGxzdWIgcmV2ZXJpZnlORkRPd25lcnNoaXAKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjYzCgkvLyB0aGlzLnJldGlPUF9lcG9jaFJld2FyZFVwZGF0ZS5sb2coewoJLy8gICAgICAgaWQ6IHBvb2xLZXkuaWQsCgkvLyAgICAgICBwb29sTnVtOiBwb29sS2V5LnBvb2xJZCBhcyB1aW50MTYsCgkvLyAgICAgICBwb29sQXBwSWQ6IEFwcElELmZyb21VaW50NjQocG9vbEtleS5wb29sQXBwSWQpLAoJLy8gICAgICAgYWxnb0FkZGVkOiBhbGdvVG9BZGQsCgkvLyAgICAgICByZXdhcmRUb2tlbkhlbGRCYWNrOiByZXdhcmRUb2tlbkFtb3VudFJlc2VydmVkLAoJLy8gICAgICAgc2F0dXJhdGVkQnVyblRvRmVlU2luazogc2F0dXJhdGVkQnVyblRvRmVlU2luaywKCS8vICAgICAgIHZhbGlkYXRvckNvbW1pc3Npb246IHZhbGlkYXRvckNvbW1pc3Npb24sCgkvLyAgICAgfSkKCXB1c2hieXRlcyAweGIzZTQ3YzNkIC8vIHJldGlPUF9lcG9jaFJld2FyZFVwZGF0ZSh1aW50NjQsdWludDE2LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaXRvYgoJZHVwCgliaXRsZW4KCWludGMgMTggLy8gMTYKCTw9CgoJLy8gcG9vbEtleS5wb29sSWQgYXMgdWludDE2IG92ZXJmbG93ZWQgMTYgYml0cwoJYXNzZXJ0CglleHRyYWN0IDYgMgoJY29uY2F0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAxNiA4CglidG9pCglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAtNCAvLyB2YWxpZGF0b3JDb21taXNzaW9uOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC01IC8vIHNhdHVyYXRlZEJ1cm5Ub0ZlZVNpbms6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglmcmFtZV9kaWcgLTIgLy8gYWxnb1RvQWRkOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC0zIC8vIHJld2FyZFRva2VuQW1vdW50UmVzZXJ2ZWQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyBzdGFrZVJlbW92ZWQoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYm9vbCl2b2lkCiphYmlfcm91dGVfc3Rha2VSZW1vdmVkOgoJLy8gc3Rha2VyUmVtb3ZlZDogYm9vbAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJZHVwCglsZW4KCWludGMgMSAvLyAxCgk9PQoKCS8vIGFyZ3VtZW50IDAgKHN0YWtlclJlbW92ZWQpIGZvciBzdGFrZVJlbW92ZWQgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIHJld2FyZFJlbW92ZWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJYnRvaQoKCS8vIGFtb3VudFJlbW92ZWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIHN0YWtlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgNiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAzIChzdGFrZXIpIGZvciBzdGFrZVJlbW92ZWQgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIHBvb2xLZXk6ICh1aW50NjQsdWludDY0LHVpbnQ2NCkKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDMgLy8gMjQKCT09CgoJLy8gYXJndW1lbnQgNCAocG9vbEtleSkgZm9yIHN0YWtlUmVtb3ZlZCBtdXN0IGJlIGEgKHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBzdGFrZVJlbW92ZWQoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYm9vbCl2b2lkCgljYWxsc3ViIHN0YWtlUmVtb3ZlZAoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gc3Rha2VSZW1vdmVkKHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXksIHN0YWtlcjogQWRkcmVzcywgYW1vdW50UmVtb3ZlZDogdWludDY0LCByZXdhcmRSZW1vdmVkOiB1aW50NjQsIHN0YWtlclJlbW92ZWQ6IGJvb2xlYW4pOiB2b2lkCi8vCi8vIHN0YWtlUmVtb3ZlZCBpcyBjYWxsZWQgYnkgU3Rha2luZyBwb29scyB0byBpbmZvcm0gdGhlIHZhbGlkYXRvciAodXMpIHRoYXQgYSBwYXJ0aWN1bGFyIGFtb3VudCBvZiB0b3RhbCBzdGFrZSBoYXMgYmVlbiByZW1vdmVkCi8vIGZyb20gdGhlIHNwZWNpZmllZCBwb29sLiAgVGhpcyBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgc3RhdHMgd2UgaGF2ZSBpbiBvdXIgUG9vbEluZm8gc3RvcmFnZS4KLy8gSWYgYW55IGFtb3VudCBvZiByZXdhcmRSZW1vdmVkIGlzIHNwZWNpZmllZCwgdGhlbiB0aGF0IGFtb3VudCBvZiByZXdhcmQgaXMgc2VudCB0byB0aGUgdXNlCi8vIFRoZSBjYWxsaW5nIEFwcCBpZCBpcyB2YWxpZGF0ZWQgYWdhaW5zdCBvdXIgcG9vbCBsaXN0IGFzIHdlbGwuCi8vCi8vIEBwYXJhbSB7VmFsaWRhdG9yUG9vbEtleX0gcG9vbEtleSBjYWxsaW5nIHVzIGZyb20gd2hpY2ggc3Rha2Ugd2FzIHJlbW92ZWQKLy8gQHBhcmFtIHtBZGRyZXNzfSBzdGFrZXIKLy8gQHBhcmFtIHt1aW50NjR9IGFtb3VudFJlbW92ZWQgLSBhbGdvIGFtb3VudCByZW1vdmVkCi8vIEBwYXJhbSB7dWludDY0fSByZXdhcmRSZW1vdmVkIC0gaWYgYXBwbGljYWJsZSwgYW1vdW50IG9mIHRva2VuIHJld2FyZCByZW1vdmVkIChieSBwb29sIDEgY2FsbGVyKSBvciBUTyByZW1vdmUgYW5kIHBheSBvdXQgKHZpYSBwb29sIDEgZnJvbSBkaWZmZXJlbnQgcG9vbCBjYWxsZXIpCi8vIEBwYXJhbSB7Ym9vbGVhbn0gc3Rha2VyUmVtb3ZlZApzdGFrZVJlbW92ZWQ6Cglwcm90byA1IDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiAzCgoJLy8gKmlmMTdfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjkzCgkvLyBnbG9iYWxzLm9wY29kZUJ1ZGdldCA8IDMwMAoJZ2xvYmFsIE9wY29kZUJ1ZGdldAoJaW50YyAyOSAvLyAzMDAKCTwKCWJ6ICppZjE3X2VuZAoKCS8vICppZjE3X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2OTQKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCglieXRlYyA4IC8vICAjcHJhZ21hIHZlcnNpb24gMTA7IGludCAxCglkdXAKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCglpbnRjIDI2IC8vICBEZWxldGVBcHBsaWNhdGlvbgoJaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KCWl0eG5fc3VibWl0CgoqaWYxN19lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Njk2CgkvLyB0aGlzLnZlcmlmeVBvb2xLZXlDYWxsZXIocG9vbEtleSkKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CgljYWxsc3ViIHZlcmlmeVBvb2xLZXlDYWxsZXIKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzAwCgkvLyBhc3NlcnQoYW1vdW50UmVtb3ZlZCA+IDAgfHwgcmV3YXJkUmVtb3ZlZCA+IDAsICdzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgYWxnbyBvciByZXdhcmQgd2FzIHJlbW92ZWQnKQoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudFJlbW92ZWQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT4KCWR1cAoJYm56ICpza2lwX29yMgoJZnJhbWVfZGlnIC00IC8vIHJld2FyZFJlbW92ZWQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT4KCXx8Cgoqc2tpcF9vcjI6CgkvLyBzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgYWxnbyBvciByZXdhcmQgd2FzIHJlbW92ZWQKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MDMKCS8vIHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5wb29sc1twb29sS2V5LnBvb2xJZCAtIDFdLnRvdGFsQWxnb1N0YWtlZCAtPSBhbW91bnRSZW1vdmVkCglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50YyAxIC8vIDEKCS0KCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnRjIDExIC8vICBoZWFkT2Zmc2V0CgkrCglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50YyAxIC8vIDEKCS0KCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnRjIDExIC8vICBoZWFkT2Zmc2V0CgkrCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnRSZW1vdmVkOiB1aW50NjQKCS0KCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcwNAoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLnRvdGFsQWxnb1N0YWtlZCAtPSBhbW91bnRSZW1vdmVkCglpbnRjIDEyIC8vIDI1MgoJZHVwCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnRSZW1vdmVkOiB1aW50NjQKCS0KCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcwNQoJLy8gdGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgLT0gYW1vdW50UmVtb3ZlZAoJYnl0ZWMgNCAvLyAgInN0YWtlZCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgLTMgLy8gYW1vdW50UmVtb3ZlZDogdWludDY0CgktCglieXRlYyA0IC8vICAic3Rha2VkIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyAqaWYxOF9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MDcKCS8vIHJld2FyZFJlbW92ZWQgPiAwCglmcmFtZV9kaWcgLTQgLy8gcmV3YXJkUmVtb3ZlZDogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJYnogKmlmMThfZWxzZQoKCS8vICppZjE4X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MDgKCS8vIHJld2FyZFRva2VuSUQgPSB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUuY29uZmlnLnJld2FyZFRva2VuSWQKCWludGMgMzggLy8gMTUzCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgMCAvLyByZXdhcmRUb2tlbklEOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzA5CgkvLyBhc3NlcnQocmV3YXJkVG9rZW5JRCAhPT0gMCwgInJld2FyZFJlbW92ZWQgY2FuJ3QgYmUgc2V0IGlmIHZhbGlkYXRvciBkb2Vzbid0IGhhdmUgcmV3YXJkIHRva2VuISIpCglmcmFtZV9kaWcgMCAvLyByZXdhcmRUb2tlbklEOiB1aW50NjQKCWludGMgMCAvLyAwCgkhPQoKCS8vIHJld2FyZFJlbW92ZWQgY2FuJ3QgYmUgc2V0IGlmIHZhbGlkYXRvciBkb2Vzbid0IGhhdmUgcmV3YXJkIHRva2VuIQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcxMAoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUuc3RhdGUucmV3YXJkVG9rZW5IZWxkQmFjayA+PSByZXdhcmRSZW1vdmVkLAoJLy8gICAgICAgICAncmV3YXJkIGJlaW5nIHJlbW92ZWQgbXVzdCBiZSBjb3ZlcmVkIGJ5IGhvbGQgYmFjayBhbW91bnQnCgkvLyAgICAgICApCglpbnRjIDEzIC8vIDI2MAoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgLTQgLy8gcmV3YXJkUmVtb3ZlZDogdWludDY0Cgk+PQoKCS8vIHJld2FyZCBiZWluZyByZW1vdmVkIG11c3QgYmUgY292ZXJlZCBieSBob2xkIGJhY2sgYW1vdW50Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzE2CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUuc3RhdGUucmV3YXJkVG9rZW5IZWxkQmFjayAtPSByZXdhcmRSZW1vdmVkCglpbnRjIDEzIC8vIDI2MAoJZHVwCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtNCAvLyByZXdhcmRSZW1vdmVkOiB1aW50NjQKCS0KCWl0b2IKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gKmlmMTlfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzIxCgkvLyBwb29sS2V5LnBvb2xJZCAhPT0gMQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnRjIDEgLy8gMQoJIT0KCWJ6ICppZjE5X2VuZAoKCS8vICppZjE5X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MjIKCS8vIHNlbmRNZXRob2RDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUucGF5VG9rZW5SZXdhcmQ+KHsKCS8vICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5wb29sc1swXS5wb29sQXBwSWQpLAoJLy8gICAgICAgICAgIG1ldGhvZEFyZ3M6IFtzdGFrZXIsIHJld2FyZFRva2VuSUQsIHJld2FyZFJlbW92ZWRdLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyA3IC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglieXRlYyAxMyAvLyAgbWV0aG9kICJwYXlUb2tlblJld2FyZChhZGRyZXNzLHVpbnQ2NCx1aW50NjQpdm9pZCIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcyMwoJLy8gYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbMF0ucG9vbEFwcElkKQoJaW50YyA1IC8vIDI2OAoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzI0CgkvLyBtZXRob2RBcmdzOiBbc3Rha2VyLCByZXdhcmRUb2tlbklELCByZXdhcmRSZW1vdmVkXQoJZnJhbWVfZGlnIC0yIC8vIHN0YWtlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAwIC8vIHJld2FyZFRva2VuSUQ6IHVpbnQ2NAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtNCAvLyByZXdhcmRSZW1vdmVkOiB1aW50NjQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMTlfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcyNwoJLy8gdGhpcy5yZXRpT1Bfc3Rha2VSZW1vdmVkLmxvZyh7CgkvLyAgICAgICAgIGlkOiBwb29sS2V5LmlkLAoJLy8gICAgICAgICBwb29sTnVtOiBwb29sS2V5LnBvb2xJZCBhcyB1aW50MTYsCgkvLyAgICAgICAgIHBvb2xBcHBJZDogQXBwSUQuZnJvbVVpbnQ2NChwb29sS2V5LnBvb2xBcHBJZCksCgkvLyAgICAgICAgIHN0YWtlcjogc3Rha2VyLAoJLy8gICAgICAgICBhbW91bnRVbnN0YWtlZDogYW1vdW50UmVtb3ZlZCwKCS8vICAgICAgICAgcmV3YXJkVG9rZW5Bc3NldElkOiBBc3NldElELmZyb21VaW50NjQocmV3YXJkVG9rZW5JRCksCgkvLyAgICAgICAgIHJld2FyZFRva2Vuc1JlY2VpdmVkOiByZXdhcmRSZW1vdmVkLAoJLy8gICAgICAgfSkKCWJ5dGVjIDE0IC8vICByZXRpT1Bfc3Rha2VSZW1vdmVkKHVpbnQ2NCx1aW50MTYsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaXRvYgoJZHVwCgliaXRsZW4KCWludGMgMTggLy8gMTYKCTw9CgoJLy8gcG9vbEtleS5wb29sSWQgYXMgdWludDE2IG92ZXJmbG93ZWQgMTYgYml0cwoJYXNzZXJ0CglleHRyYWN0IDYgMgoJY29uY2F0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAxNiA4CglidG9pCglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAtMiAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudFJlbW92ZWQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglmcmFtZV9kaWcgLTQgLy8gcmV3YXJkUmVtb3ZlZDogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAwIC8vIHJld2FyZFRva2VuSUQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cgljb25jYXQKCWxvZwoJYiAqaWYxOF9lbmQKCippZjE4X2Vsc2U6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzM3CgkvLyB0aGlzLnJldGlPUF9zdGFrZVJlbW92ZWQubG9nKHsKCS8vICAgICAgICAgaWQ6IHBvb2xLZXkuaWQsCgkvLyAgICAgICAgIHBvb2xOdW06IHBvb2xLZXkucG9vbElkIGFzIHVpbnQxNiwKCS8vICAgICAgICAgcG9vbEFwcElkOiBBcHBJRC5mcm9tVWludDY0KHBvb2xLZXkucG9vbEFwcElkKSwKCS8vICAgICAgICAgc3Rha2VyOiBzdGFrZXIsCgkvLyAgICAgICAgIGFtb3VudFVuc3Rha2VkOiBhbW91bnRSZW1vdmVkLAoJLy8gICAgICAgICAvLyBubyB0b2tlbnMgcmV3YXJkZWQuLgoJLy8gICAgICAgICByZXdhcmRUb2tlbkFzc2V0SWQ6IEFzc2V0SUQuemVyb0luZGV4LAoJLy8gICAgICAgICByZXdhcmRUb2tlbnNSZWNlaXZlZDogMCwKCS8vICAgICAgIH0pCglieXRlYyAxNCAvLyAgcmV0aU9QX3N0YWtlUmVtb3ZlZCh1aW50NjQsdWludDE2LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWl0b2IKCWR1cAoJYml0bGVuCglpbnRjIDE4IC8vIDE2Cgk8PQoKCS8vIHBvb2xLZXkucG9vbElkIGFzIHVpbnQxNiBvdmVyZmxvd2VkIDE2IGJpdHMKCWFzc2VydAoJZXh0cmFjdCA2IDIKCWNvbmNhdAoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMTYgOAoJYnRvaQoJaXRvYgoJY29uY2F0CglmcmFtZV9kaWcgLTIgLy8gc3Rha2VyOiBBZGRyZXNzCgljb25jYXQKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnRSZW1vdmVkOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJYnl0ZWMgNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJYnl0ZWMgNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJY29uY2F0Cglsb2cKCippZjE4X2VuZDoKCS8vICppZjIwX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc0OQoJLy8gc3Rha2VyUmVtb3ZlZAoJZnJhbWVfZGlnIC01IC8vIHN0YWtlclJlbW92ZWQ6IGJvb2xlYW4KCWJ6ICppZjIwX2VuZAoKCS8vICppZjIwX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3NTEKCS8vIHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5wb29sc1twb29sS2V5LnBvb2xJZCAtIDFdLnRvdGFsU3Rha2VycyAtPSAxCglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50YyAxIC8vIDEKCS0KCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnRjIDIgLy8gIGhlYWRPZmZzZXQKCSsKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnRjIDEgLy8gMQoJLQoJaW50YyA0IC8vIDE4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMiAvLyAgaGVhZE9mZnNldAoJKwoJaW50YyAxMCAvLyAyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJaW50YyAxIC8vIDEKCS0KCWl0b2IKCWV4dHJhY3QgNiAyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3NTMKCS8vIHJlbW92ZVJldCA9IHRoaXMucmVtb3ZlRnJvbVN0YWtlclBvb2xTZXQoc3Rha2VyLCA8VmFsaWRhdG9yUG9vbEtleT57CgkvLyAgICAgICAgIGlkOiBwb29sS2V5LmlkLAoJLy8gICAgICAgICBwb29sSWQ6IHBvb2xLZXkucG9vbElkLAoJLy8gICAgICAgICBwb29sQXBwSWQ6IHBvb2xLZXkucG9vbEFwcElkLAoJLy8gICAgICAgfSkKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDE2IDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC0yIC8vIHN0YWtlcjogQWRkcmVzcwoJY2FsbHN1YiByZW1vdmVGcm9tU3Rha2VyUG9vbFNldAoJZnJhbWVfYnVyeSAxIC8vIHJlbW92ZVJldDogKGJvb2wsYm9vbCkKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzU4CgkvLyBzdGFrZXJPdXRPZlRoaXNWYWxpZGF0b3IgPSByZW1vdmVSZXRbMF0KCWZyYW1lX2RpZyAxIC8vIHJlbW92ZVJldDogKGJvb2wsYm9vbCkKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDAgLy8gMAoJZ2V0Yml0CglmcmFtZV9idXJ5IDIgLy8gc3Rha2VyT3V0T2ZUaGlzVmFsaWRhdG9yOiBib29sCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc1OQoJLy8gc3Rha2VyT3V0T2ZQcm90b2NvbCA9IHJlbW92ZVJldFsxXQoJZnJhbWVfZGlnIDEgLy8gcmVtb3ZlUmV0OiAoYm9vbCxib29sKQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMSAvLyAxCglnZXRiaXQKCWZyYW1lX2J1cnkgMyAvLyBzdGFrZXJPdXRPZlByb3RvY29sOiBib29sCgoJLy8gKmlmMjFfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzYxCgkvLyBzdGFrZXJPdXRPZlRoaXNWYWxpZGF0b3IKCWZyYW1lX2RpZyAyIC8vIHN0YWtlck91dE9mVGhpc1ZhbGlkYXRvcjogYm9vbAoJYnogKmlmMjFfZW5kCgoJLy8gKmlmMjFfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc2MgoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLnRvdGFsU3Rha2VycyAtPSAxCglpbnRjIDIzIC8vIDI0NAoJZHVwCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpdG9iCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKKmlmMjFfZW5kOgoJLy8gKmlmMjJfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzY1CgkvLyBzdGFrZXJPdXRPZlByb3RvY29sCglmcmFtZV9kaWcgMyAvLyBzdGFrZXJPdXRPZlByb3RvY29sOiBib29sCglieiAqaWYyMl9lbmQKCgkvLyAqaWYyMl9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzY2CgkvLyB0aGlzLm51bVN0YWtlcnMudmFsdWUgLT0gMQoJYnl0ZWMgNiAvLyAgIm51bVN0YWtlcnMiCglhcHBfZ2xvYmFsX2dldAoJaW50YyAxIC8vIDEKCS0KCWJ5dGVjIDYgLy8gICJudW1TdGFrZXJzIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCippZjIyX2VuZDoKCippZjIwX2VuZDoKCXJldHN1YgoKLy8gZmluZFBvb2xGb3JTdGFrZXIodWludDY0LGFkZHJlc3MsdWludDY0KSgodWludDY0LHVpbnQ2NCx1aW50NjQpLGJvb2wsYm9vbCkKKmFiaV9yb3V0ZV9maW5kUG9vbEZvclN0YWtlcjoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMiAvLyAweDE1MWY3Yzc1CgoJLy8gYW1vdW50VG9TdGFrZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gc3Rha2VyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyA2IC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDEgKHN0YWtlcikgZm9yIGZpbmRQb29sRm9yU3Rha2VyIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBmaW5kUG9vbEZvclN0YWtlcih1aW50NjQsYWRkcmVzcyx1aW50NjQpKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxib29sKQoJY2FsbHN1YiBmaW5kUG9vbEZvclN0YWtlcgoJY29uY2F0Cglsb2cKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGZpbmRQb29sRm9yU3Rha2VyKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIHN0YWtlcjogQWRkcmVzcywgYW1vdW50VG9TdGFrZTogdWludDY0KTogW1ZhbGlkYXRvclBvb2xLZXksIGJvb2xlYW4sIGJvb2xlYW5dCi8vCi8vIEZpbmRzIHRoZSBwb29sIGZvciBhIHN0YWtlciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgdmFsaWRhdG9yIGlkLCBzdGFrZXIgYWRkcmVzcywgYW5kIGFtb3VudCB0byBzdGFrZS4KLy8gRmlyc3QgY2hlY2tzIHRoZSBzdGFrZXJzICdhbHJlYWR5IHN0YWtlZCBsaXN0JyBmb3IgdGhlIHZhbGlkYXRvciBwcmVmZXJyaW5nIHRob3NlIChhZGRpbmcgaWYgcG9zc2libGUpIHRoZW4gYWRkcwovLyB0byBuZXcgcG9vbCBpZiBuZWNlc3NhcnkuCi8vCi8vIEBwYXJhbSB7VmFsaWRhdG9ySWRUeXBlfSB2YWxpZGF0b3JJZCAtIFRoZSBpZCBvZiB0aGUgdmFsaWRhdG9yLgovLyBAcGFyYW0ge0FkZHJlc3N9IHN0YWtlciAtIFRoZSBhZGRyZXNzIG9mIHRoZSBzdGFrZXIuCi8vIEBwYXJhbSB7dWludDY0fSBhbW91bnRUb1N0YWtlIC0gVGhlIGFtb3VudCB0byBzdGFrZS4KLy8gQHJldHVybnMge1ZhbGlkYXRvclBvb2xLZXksIGJvb2xlYW4sIGJvb2xlYW59IC0gVGhlIHBvb2wgZm9yIHRoZSBzdGFrZXIsIHRydWUvZmFsc2Ugb24gd2hldGhlciB0aGUgc3Rha2VyIGlzICduZXcnCi8vIHRvIHRoaXMgVkFMSURBVE9SLCBhbmQgdHJ1ZS9mYWxzZSBpZiBzdGFrZXIgaXMgbmV3IHRvIHRoZSBwcm90b2NvbC4KZmluZFBvb2xGb3JTdGFrZXI6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiA3CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc4OAoJLy8gaXNOZXdTdGFrZXJUb1ZhbGlkYXRvciA9IHRydWUKCWludGMgMSAvLyAxCglmcmFtZV9idXJ5IDAgLy8gaXNOZXdTdGFrZXJUb1ZhbGlkYXRvcjogYm9vbAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3ODkKCS8vIGlzTmV3U3Rha2VyVG9Qcm90b2NvbCA9IHRydWUKCWludGMgMSAvLyAxCglmcmFtZV9idXJ5IDEgLy8gaXNOZXdTdGFrZXJUb1Byb3RvY29sOiBib29sCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc5NwoJLy8gbWF4UGVyUG9vbCA9IHRoaXMuZ2V0Q3VyTWF4U3Rha2VQZXJQb29sKHZhbGlkYXRvcklkKQoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWNhbGxzdWIgZ2V0Q3VyTWF4U3Rha2VQZXJQb29sCglmcmFtZV9idXJ5IDIgLy8gbWF4UGVyUG9vbDogdWludDY0CgoJLy8gKmlmMjNfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODAwCgkvLyB0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS5leGlzdHMKCWJ5dGVjIDMgLy8gICJzcHMiCglmcmFtZV9kaWcgLTIgLy8gc3Rha2VyOiBBZGRyZXNzCgljb25jYXQKCWJveF9sZW4KCXN3YXAKCXBvcAoJYnogKmlmMjNfZW5kCgoJLy8gKmlmMjNfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgwMQoJLy8gcG9vbFNldCA9IGNsb25lKHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlKQoJYnl0ZWMgMyAvLyAgInNwcyIKCWZyYW1lX2RpZyAtMiAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUKCWFzc2VydAoJZnJhbWVfYnVyeSAzIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0LHVpbnQ2NClbNl0KCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODAyCgkvLyBhc3NlcnQodmFsaWRhdG9ySWQgIT09IDApCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaW50YyAwIC8vIDAKCSE9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODAzCgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IHBvb2xTZXQubGVuZ3RoOyBpICs9IDEpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSA0IC8vIGk6IHVpbnQ2NAoKKmZvcl8zOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgwMwoJLy8gaSA8IHBvb2xTZXQubGVuZ3RoCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgNyAvLyA2Cgk8CglieiAqZm9yXzNfZW5kCgoJLy8gKmlmMjRfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODA0CgkvLyBnbG9iYWxzLm9wY29kZUJ1ZGdldCA8IDMwMAoJZ2xvYmFsIE9wY29kZUJ1ZGdldAoJaW50YyAyOSAvLyAzMDAKCTwKCWJ6ICppZjI0X2VuZAoKCS8vICppZjI0X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MDUKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCglieXRlYyA4IC8vICAjcHJhZ21hIHZlcnNpb24gMTA7IGludCAxCglkdXAKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCglpbnRjIDI2IC8vICBEZWxldGVBcHBsaWNhdGlvbgoJaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KCWl0eG5fc3VibWl0CgoqaWYyNF9lbmQ6CgkvLyAqaWYyNV9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MDcKCS8vIHBvb2xTZXRbaV0uaWQgPT09IDAKCWZyYW1lX2RpZyAzIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0LHVpbnQ2NClbNl0KCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMCAvLyAwCgkrCglpbnRjIDIgLy8gOAoJZXh0cmFjdDMKCWJ0b2kKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmMjVfZW5kCgoJLy8gKmlmMjVfY29uc2VxdWVudAoJYiAqZm9yXzNfY29udGludWUKCippZjI1X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MTAKCS8vIGlzTmV3U3Rha2VyVG9Qcm90b2NvbCA9IGZhbHNlCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAxIC8vIGlzTmV3U3Rha2VyVG9Qcm90b2NvbDogYm9vbAoKCS8vICppZjI2X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgxMQoJLy8gcG9vbFNldFtpXS5pZCA9PT0gdmFsaWRhdG9ySWQKCWZyYW1lX2RpZyAzIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0LHVpbnQ2NClbNl0KCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMCAvLyAwCgkrCglpbnRjIDIgLy8gOAoJZXh0cmFjdDMKCWJ0b2kKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCgk9PQoJYnogKmlmMjZfZW5kCgoJLy8gKmlmMjZfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgxMwoJLy8gaXNOZXdTdGFrZXJUb1ZhbGlkYXRvciA9IGZhbHNlCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAwIC8vIGlzTmV3U3Rha2VyVG9WYWxpZGF0b3I6IGJvb2wKCgkvLyAqaWYyN19jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MTUKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUucG9vbHNbcG9vbFNldFtpXS5wb29sSWQgLSAxXS50b3RhbEFsZ29TdGFrZWQgKyBhbW91bnRUb1N0YWtlIDw9CgkvLyAgICAgICAgICAgICBtYXhQZXJQb29sCglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAzIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0LHVpbnQ2NClbNl0KCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMiAvLyAgaGVhZE9mZnNldAoJKwoJaW50YyAyIC8vIDgKCWV4dHJhY3QzCglidG9pCglpbnRjIDEgLy8gMQoJLQoJaW50YyA0IC8vIDE4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMTEgLy8gIGhlYWRPZmZzZXQKCSsKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgLTMgLy8gYW1vdW50VG9TdGFrZTogdWludDY0CgkrCglmcmFtZV9kaWcgMiAvLyBtYXhQZXJQb29sOiB1aW50NjQKCTw9CglieiAqaWYyN19lbmQKCgkvLyAqaWYyN19jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODE4CgkvLyByZXR1cm4gW3Bvb2xTZXRbaV0sIGlzTmV3U3Rha2VyVG9WYWxpZGF0b3IsIGlzTmV3U3Rha2VyVG9Qcm90b2NvbF07CglmcmFtZV9kaWcgMyAvLyBwb29sU2V0OiAodWludDY0LHVpbnQ2NCx1aW50NjQpWzZdCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgMyAvLyAyNAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDMgLy8gMjQKCWV4dHJhY3QzCglieXRlYyA1IC8vIDB4MDAKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgMCAvLyBpc05ld1N0YWtlclRvVmFsaWRhdG9yOiBib29sCglzZXRiaXQKCWludGMgMSAvLyAxCglmcmFtZV9kaWcgMSAvLyBpc05ld1N0YWtlclRvUHJvdG9jb2w6IGJvb2wKCXNldGJpdAoJY29uY2F0CgliICpmaW5kUG9vbEZvclN0YWtlcipyZXR1cm4KCippZjI3X2VuZDoKCippZjI2X2VuZDoKCipmb3JfM19jb250aW51ZToKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MDMKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDQgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSA0IC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzMKCipmb3JfM19lbmQ6CgoqaWYyM19lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODI1CgkvLyBhc3NlcnQoCgkvLyAgICAgICBhbW91bnRUb1N0YWtlID49IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1pbkVudHJ5U3Rha2UsCgkvLyAgICAgICAnbXVzdCBzdGFrZSBhdCBsZWFzdCB0aGUgbWluaW11bSBmb3IgdGhpcyBwb29sJwoJLy8gICAgICkKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnRUb1N0YWtlOiB1aW50NjQKCWludGMgMzkgLy8gMjA5CglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJPj0KCgkvLyBtdXN0IHN0YWtlIGF0IGxlYXN0IHRoZSBtaW5pbXVtIGZvciB0aGlzIHBvb2wKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MzEKCS8vIHBvb2xzID0gY2xvbmUodGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29scykKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJaW50YyAzMCAvLyA0MzIKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWZyYW1lX2J1cnkgNSAvLyBwb29sczogKHVpbnQ2NCx1aW50MTYsdWludDY0KVsyNF0KCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODMyCgkvLyBjdXJOdW1Qb29scyA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuc3RhdGUubnVtUG9vbHMgYXMgdWludDY0CglpbnRjIDkgLy8gMjQyCglpbnRjIDEwIC8vIDIKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgNiAvLyBjdXJOdW1Qb29sczogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgzMwoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJOdW1Qb29sczsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNyAvLyBpOiB1aW50NjQKCipmb3JfNDoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MzMKCS8vIGkgPCBjdXJOdW1Qb29scwoJZnJhbWVfZGlnIDcgLy8gaTogdWludDY0CglmcmFtZV9kaWcgNiAvLyBjdXJOdW1Qb29sczogdWludDY0Cgk8CglieiAqZm9yXzRfZW5kCgoJLy8gKmlmMjhfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODM0CgkvLyBwb29sc1tpXS50b3RhbEFsZ29TdGFrZWQgKyBhbW91bnRUb1N0YWtlIDw9IG1heFBlclBvb2wKCWZyYW1lX2RpZyA1IC8vIHBvb2xzOiAodWludDY0LHVpbnQxNix1aW50NjQpWzI0XQoJZnJhbWVfZGlnIDcgLy8gaTogdWludDY0CglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAxMSAvLyAgaGVhZE9mZnNldAoJKwoJaW50YyAyIC8vIDgKCWV4dHJhY3QzCglidG9pCglmcmFtZV9kaWcgLTMgLy8gYW1vdW50VG9TdGFrZTogdWludDY0CgkrCglmcmFtZV9kaWcgMiAvLyBtYXhQZXJQb29sOiB1aW50NjQKCTw9CglieiAqaWYyOF9lbmQKCgkvLyAqaWYyOF9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODM1CgkvLyByZXR1cm4gWwoJLy8gICAgICAgICAgIHsgaWQ6IHZhbGlkYXRvcklkLCBwb29sSWQ6IGkgKyAxLCBwb29sQXBwSWQ6IHBvb2xzW2ldLnBvb2xBcHBJZCB9LAoJLy8gICAgICAgICAgIGlzTmV3U3Rha2VyVG9WYWxpZGF0b3IsCgkvLyAgICAgICAgICAgaXNOZXdTdGFrZXJUb1Byb3RvY29sLAoJLy8gICAgICAgICBdOwoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWZyYW1lX2RpZyA3IC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIDUgLy8gcG9vbHM6ICh1aW50NjQsdWludDE2LHVpbnQ2NClbMjRdCglmcmFtZV9kaWcgNyAvLyBpOiB1aW50NjQKCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDAgLy8gMAoJKwoJaW50YyAyIC8vIDgKCWV4dHJhY3QzCglidG9pCglpdG9iCgljb25jYXQKCWJ5dGVjIDUgLy8gMHgwMAoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAwIC8vIGlzTmV3U3Rha2VyVG9WYWxpZGF0b3I6IGJvb2wKCXNldGJpdAoJaW50YyAxIC8vIDEKCWZyYW1lX2RpZyAxIC8vIGlzTmV3U3Rha2VyVG9Qcm90b2NvbDogYm9vbAoJc2V0Yml0Cgljb25jYXQKCWIgKmZpbmRQb29sRm9yU3Rha2VyKnJldHVybgoKKmlmMjhfZW5kOgoKKmZvcl80X2NvbnRpbnVlOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgzMwoJLy8gaSArPSAxCglmcmFtZV9kaWcgNyAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDcgLy8gaTogdWludDY0CgliICpmb3JfNAoKKmZvcl80X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4NDMKCS8vIHJldHVybiBbeyBpZDogdmFsaWRhdG9ySWQsIHBvb2xJZDogMCwgcG9vbEFwcElkOiAwIH0sIGlzTmV3U3Rha2VyVG9WYWxpZGF0b3IsIGlzTmV3U3Rha2VyVG9Qcm90b2NvbF07CglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJYnl0ZWMgNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJYnl0ZWMgNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJYnl0ZWMgNSAvLyAweDAwCglpbnRjIDAgLy8gMAoJZnJhbWVfZGlnIDAgLy8gaXNOZXdTdGFrZXJUb1ZhbGlkYXRvcjogYm9vbAoJc2V0Yml0CglpbnRjIDEgLy8gMQoJZnJhbWVfZGlnIDEgLy8gaXNOZXdTdGFrZXJUb1Byb3RvY29sOiBib29sCglzZXRiaXQKCWNvbmNhdAoKKmZpbmRQb29sRm9yU3Rha2VyKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDcKCXJldHN1YgoKLy8gbW92ZVBvb2xUb05vZGUodWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX21vdmVQb29sVG9Ob2RlOgoJLy8gbm9kZU51bTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gcG9vbEFwcElkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBtb3ZlUG9vbFRvTm9kZSh1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkCgljYWxsc3ViIG1vdmVQb29sVG9Ob2RlCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBtb3ZlUG9vbFRvTm9kZSh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCBwb29sQXBwSWQ6IHVpbnQ2NCwgbm9kZU51bTogdWludDY0KTogdm9pZAovLwovLyBGaW5kIHRoZSBzcGVjaWZpZWQgcG9vbCAoaW4gYW55IG5vZGUgbnVtYmVyKSBhbmQgbW92ZSBpdCB0byB0aGUgc3BlY2lmaWVkIG5vZGUuCi8vIFRoZSBwb29sIGFjY291bnQgaXMgZm9yY2VkIG9mZmxpbmUgaWYgbW92ZWQgc28gcHJpb3Igbm9kZSB3aWxsIHN0aWxsIHJ1biBmb3IgMzIwIHJvdW5kcyBidXQKLy8gbmV3IGtleSBnb2VzIG9ubGluZSBvbiBuZXcgbm9kZSBzb29uIGFmdGVyICgzMjAgcm91bmRzIGFmdGVyIGl0IGdvZXMgb25saW5lKQovLyBOby1vcCBpZiBzdWNjZXNzLCBhc3NlcnRzIGlmIG5vdCBmb3VuZCBvciBjYW4ndCBtb3ZlICAobm8gc3BhY2UgaW4gdGFyZ2V0KQovLyBbIE9OTFkgT1dORVIgT1IgTUFOQUdFUiBDQU4gQ0hBTkdFIF0KLy8KLy8gQHBhcmFtIHtWYWxpZGF0b3JJZFR5cGV9IHZhbGlkYXRvcklkIC0gVGhlIGlkIG9mIHRoZSB2YWxpZGF0b3IuCi8vIEBwYXJhbSB7dWludDY0fSBwb29sQXBwSWQKLy8gQHBhcmFtIHt1aW50NjR9IG5vZGVOdW0KbW92ZVBvb2xUb05vZGU6Cglwcm90byAzIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiAyCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg1OAoJLy8gdGhpcy5jYWxsZXJNdXN0QmVPd25lck9yTWFuYWdlcih2YWxpZGF0b3JJZCkKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCgljYWxsc3ViIGNhbGxlck11c3RCZU93bmVyT3JNYW5hZ2VyCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2MAoJLy8gbm9kZVBvb2xBc3NpZ25tZW50cyA9IGNsb25lKHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUubm9kZVBvb2xBc3NpZ25tZW50cykKCWludGMgMTcgLy8gIGhlYWRPZmZzZXQKCWludGMgMjIgLy8gMTkyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglmcmFtZV9idXJ5IDAgLy8gbm9kZVBvb2xBc3NpZ25tZW50czogKCh1aW50NjRbM10pWzhdKQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4NjEKCS8vIGFzc2VydChub2RlTnVtID49IDEgJiYgbm9kZU51bSA8PSBNQVhfTk9ERVMsICdub2RlIG51bWJlciBvdXQgb2YgYWxsb3dhYmxlIHJhbmdlJykKCWZyYW1lX2RpZyAtMyAvLyBub2RlTnVtOiB1aW50NjQKCWludGMgMSAvLyAxCgk+PQoJZHVwCglieiAqc2tpcF9hbmQyCglmcmFtZV9kaWcgLTMgLy8gbm9kZU51bTogdWludDY0CglpbnRjIDIgLy8gOAoJPD0KCSYmCgoqc2tpcF9hbmQyOgoJLy8gbm9kZSBudW1iZXIgb3V0IG9mIGFsbG93YWJsZSByYW5nZQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2MwoJLy8gZm9yIChsZXQgc3JjTm9kZUlkeCA9IDA7IHNyY05vZGVJZHggPCBNQVhfTk9ERVM7IHNyY05vZGVJZHggKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDEgLy8gc3JjTm9kZUlkeDogdWludDY0CgoqZm9yXzU6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODYzCgkvLyBzcmNOb2RlSWR4IDwgTUFYX05PREVTCglmcmFtZV9kaWcgMSAvLyBzcmNOb2RlSWR4OiB1aW50NjQKCWludGMgMiAvLyA4Cgk8CglieiAqZm9yXzVfZW5kCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2NAoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfUE9PTFNfUEVSX05PREU7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDIgLy8gaTogdWludDY0CgoqZm9yXzY6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODY0CgkvLyBpIDwgTUFYX1BPT0xTX1BFUl9OT0RFCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgOCAvLyAzCgk8CglieiAqZm9yXzZfZW5kCgoJLy8gKmlmMjlfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODY1CgkvLyBub2RlUG9vbEFzc2lnbm1lbnRzLm5vZGVzW3NyY05vZGVJZHhdLnBvb2xBcHBJZHNbaV0gPT09IHBvb2xBcHBJZAoJZnJhbWVfZGlnIDAgLy8gbm9kZVBvb2xBc3NpZ25tZW50czogKCh1aW50NjRbM10pWzhdKQoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAxIC8vIHNyY05vZGVJZHg6IHVpbnQ2NAoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMCAvLyAwCgkrCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgMiAvLyA4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMiAvLyA4CglleHRyYWN0MwoJYnRvaQoJZnJhbWVfZGlnIC0yIC8vIHBvb2xBcHBJZDogdWludDY0Cgk9PQoJYnogKmlmMjlfZW5kCgoJLy8gKmlmMjlfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2NgoJLy8gYXNzZXJ0KG5vZGVOdW0gLSAxICE9PSBzcmNOb2RlSWR4LCAiY2FuJ3QgbW92ZSB0byBzYW1lIG5vZGUiKQoJZnJhbWVfZGlnIC0zIC8vIG5vZGVOdW06IHVpbnQ2NAoJaW50YyAxIC8vIDEKCS0KCWZyYW1lX2RpZyAxIC8vIHNyY05vZGVJZHg6IHVpbnQ2NAoJIT0KCgkvLyBjYW4ndCBtb3ZlIHRvIHNhbWUgbm9kZQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2OAoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5ub2RlUG9vbEFzc2lnbm1lbnRzLm5vZGVzW3NyY05vZGVJZHhdLnBvb2xBcHBJZHNbaV0gPSAwCglpbnRjIDE3IC8vIDkwMAoJZnJhbWVfZGlnIDEgLy8gc3JjTm9kZUlkeDogdWludDY0CglpbnRjIDMgLy8gMjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAwIC8vIDAKCSsKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAyIC8vIDgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJYnl0ZWMgNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODcxCgkvLyBzZW5kTWV0aG9kQ2FsbDx0eXBlb2YgU3Rha2luZ1Bvb2wucHJvdG90eXBlLmdvT2ZmbGluZT4oewoJLy8gICAgICAgICAgICAgYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NChwb29sQXBwSWQpLAoJLy8gICAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDcgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCXB1c2hieXRlcyAweDUxZWYzYjIxIC8vIG1ldGhvZCAiZ29PZmZsaW5lKCl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODcyCgkvLyBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KHBvb2xBcHBJZCkKCWZyYW1lX2RpZyAtMiAvLyBwb29sQXBwSWQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4NzYKCS8vIHRoaXMuYWRkUG9vbFRvTm9kZSh2YWxpZGF0b3JJZCwgcG9vbEFwcElkLCBub2RlTnVtKQoJZnJhbWVfZGlnIC0zIC8vIG5vZGVOdW06IHVpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIHBvb2xBcHBJZDogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJY2FsbHN1YiBhZGRQb29sVG9Ob2RlCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg3NwoJLy8gcmV0dXJuOwoJcmV0c3ViCgoqaWYyOV9lbmQ6CgoqZm9yXzZfY29udGludWU6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODY0CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCWIgKmZvcl82CgoqZm9yXzZfZW5kOgoKKmZvcl81X2NvbnRpbnVlOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2MwoJLy8gc3JjTm9kZUlkeCArPSAxCglmcmFtZV9kaWcgMSAvLyBzcmNOb2RlSWR4OiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDEgLy8gc3JjTm9kZUlkeDogdWludDY0CgliICpmb3JfNQoKKmZvcl81X2VuZDoKCS8vIGNvdWxkbid0IGZpbmQgcG9vbCBhcHAgaWQgaW4gbm9kZXMgdG8gbW92ZQoJZXJyCglyZXRzdWIKCi8vIGVtcHR5VG9rZW5SZXdhcmRzKHVpbnQ2NCxhZGRyZXNzKXVpbnQ2NAoqYWJpX3JvdXRlX2VtcHR5VG9rZW5SZXdhcmRzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAyIC8vIDB4MTUxZjdjNzUKCgkvLyByZWNlaXZlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgNiAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChyZWNlaXZlcikgZm9yIGVtcHR5VG9rZW5SZXdhcmRzIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyB2YWxpZGF0b3JJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBlbXB0eVRva2VuUmV3YXJkcyh1aW50NjQsYWRkcmVzcyl1aW50NjQKCWNhbGxzdWIgZW1wdHlUb2tlblJld2FyZHMKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBlbXB0eVRva2VuUmV3YXJkcyh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCByZWNlaXZlcjogQWRkcmVzcyk6IHVpbnQ2NAovLwovLyBTZW5kcyB0aGUgcmV3YXJkIHRva2VucyBoZWxkIGluIHBvb2wgMSB0byBzcGVjaWZpZWQgcmVjZWl2ZXIuCi8vIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBieSB0aGUgb3duZXIgd2hlbiB0aGV5IHdhbnQgdG8gZ2V0IHJld2FyZCB0b2tlbnMgJ2JhY2snIHdoaWNoIHRoZXkgc2VudCB0bwovLyB0aGUgZmlyc3QgcG9vbCAobGlrZWx5IGJlY2F1c2UgdmFsaWRhdG9yIGlzIHN1bnNldHRpbmcuICBBbnkgdG9rZW5zIGN1cnJlbnRseSAncmVzZXJ2ZWQnIGZvciBzdGFrZXJzIHRvIGNsYWltIHdpbGwKLy8gTk9UIGJlIHNlbnQgYXMgdGhleSBtdXN0IGJlIGhlbGQgYmFjayBmb3Igc3Rha2VycyB0byBsYXRlciBjbGFpbS4KLy8gWyBPTkxZIE9XTkVSIENBTiBDQUxMXQovLwovLyBAcGFyYW0ge1ZhbGlkYXRvcklkVHlwZX0gdmFsaWRhdG9ySWQgLSBUaGUgaWQgb2YgdGhlIHZhbGlkYXRvci4KLy8gQHBhcmFtIHtBZGRyZXNzfSByZWNlaXZlciAtIHRoZSBhY2NvdW50IHRvIHNlbmQgdGhlIHRva2VucyB0byAobXVzdCBhbHJlYWR5IGJlIG9wdGVkLWluIHRvIHRoZSByZXdhcmQgdG9rZW4pCi8vIEByZXR1cm5zIHt1aW50NjR9IHRoZSBhbW91bnQgb2YgcmV3YXJkIHRva2VuIHNlbnQKZW1wdHlUb2tlblJld2FyZHM6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiAzCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg5NgoJLy8gdGhpcy5jYWxsZXJNdXN0QmVPd25lcih2YWxpZGF0b3JJZCkKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCgljYWxsc3ViIGNhbGxlck11c3RCZU93bmVyCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg5NwoJLy8gcmV3YXJkVG9rZW5JZCA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLnJld2FyZFRva2VuSWQKCWludGMgMzggLy8gMTUzCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAwIC8vIHJld2FyZFRva2VuSWQ6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4OTgKCS8vIHJld2FyZFRva2VuSGVsZEJhY2sgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnN0YXRlLnJld2FyZFRva2VuSGVsZEJhY2sKCWludGMgMTMgLy8gMjYwCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAxIC8vIHJld2FyZFRva2VuSGVsZEJhY2s6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4OTkKCS8vIGFzc2VydChyZXdhcmRUb2tlbklkICE9PSAwLCAidGhpcyB2YWxpZGF0b3IgZG9lc24ndCBoYXZlIGEgcmV3YXJkIHRva2VuIGRlZmluZWQiKQoJZnJhbWVfZGlnIDAgLy8gcmV3YXJkVG9rZW5JZDogdWludDY0CglpbnRjIDAgLy8gMAoJIT0KCgkvLyB0aGlzIHZhbGlkYXRvciBkb2Vzbid0IGhhdmUgYSByZXdhcmQgdG9rZW4gZGVmaW5lZAoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjkwMAoJLy8gcG9vbE9uZUFwcElkID0gQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnBvb2xzWzBdLnBvb2xBcHBJZCkKCWludGMgNSAvLyAyNjgKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDIgLy8gcG9vbE9uZUFwcElkOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTAyCgkvLyB0b2tlblJld2FyZEJhbCA9IHBvb2xPbmVBcHBJZC5hZGRyZXNzLmFzc2V0QmFsYW5jZShBc3NldElELmZyb21VaW50NjQocmV3YXJkVG9rZW5JZCkpIC0gcmV3YXJkVG9rZW5IZWxkQmFjawoJZnJhbWVfZGlnIDIgLy8gcG9vbE9uZUFwcElkOiB1aW50NjQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJZnJhbWVfZGlnIDAgLy8gcmV3YXJkVG9rZW5JZDogdWludDY0Cglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIDEgLy8gcmV3YXJkVG9rZW5IZWxkQmFjazogdWludDY0CgktCglmcmFtZV9idXJ5IDMgLy8gdG9rZW5SZXdhcmRCYWw6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MDUKCS8vIHNlbmRNZXRob2RDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUucGF5VG9rZW5SZXdhcmQ+KHsKCS8vICAgICAgIGFwcGxpY2F0aW9uSUQ6IHBvb2xPbmVBcHBJZCwKCS8vICAgICAgIG1ldGhvZEFyZ3M6IFtyZWNlaXZlciwgcmV3YXJkVG9rZW5JZCwgdG9rZW5SZXdhcmRCYWxdLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDcgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWJ5dGVjIDEzIC8vICBtZXRob2QgInBheVRva2VuUmV3YXJkKGFkZHJlc3MsdWludDY0LHVpbnQ2NCl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTA2CgkvLyBhcHBsaWNhdGlvbklEOiBwb29sT25lQXBwSWQKCWZyYW1lX2RpZyAyIC8vIHBvb2xPbmVBcHBJZDogdWludDY0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTA3CgkvLyBtZXRob2RBcmdzOiBbcmVjZWl2ZXIsIHJld2FyZFRva2VuSWQsIHRva2VuUmV3YXJkQmFsXQoJZnJhbWVfZGlnIC0yIC8vIHJlY2VpdmVyOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDAgLy8gcmV3YXJkVG9rZW5JZDogdWludDY0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDMgLy8gdG9rZW5SZXdhcmRCYWw6IHVpbnQ2NAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjkwOQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgcG9vbE9uZUFwcElkLmFkZHJlc3MuYXNzZXRCYWxhbmNlKEFzc2V0SUQuZnJvbVVpbnQ2NChyZXdhcmRUb2tlbklkKSkgPT09IHJld2FyZFRva2VuSGVsZEJhY2ssCgkvLyAgICAgICAnYmFsYW5jZSBvZiByZW1haW5pbmcgcmV3YXJkIHRva2VucyBzaG91bGQgbWF0Y2ggdGhlIGhlbGQgYmFjayBhbW91bnQnCgkvLyAgICAgKQoJZnJhbWVfZGlnIDIgLy8gcG9vbE9uZUFwcElkOiB1aW50NjQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJZnJhbWVfZGlnIDAgLy8gcmV3YXJkVG9rZW5JZDogdWludDY0Cglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIDEgLy8gcmV3YXJkVG9rZW5IZWxkQmFjazogdWludDY0Cgk9PQoKCS8vIGJhbGFuY2Ugb2YgcmVtYWluaW5nIHJld2FyZCB0b2tlbnMgc2hvdWxkIG1hdGNoIHRoZSBoZWxkIGJhY2sgYW1vdW50Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTEzCgkvLyByZXR1cm4gdG9rZW5SZXdhcmRCYWw7CglmcmFtZV9kaWcgMyAvLyB0b2tlblJld2FyZEJhbDogdWludDY0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMwoJcmV0c3ViCgovLyBjYWxsZXJNdXN0QmVPd25lcih2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlKTogdm9pZApjYWxsZXJNdXN0QmVPd25lcjoKCXByb3RvIDEgMAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDA2CgkvLyBhc3NlcnQoCgkvLyAgICAgICB0aGlzLnR4bi5zZW5kZXIgPT09IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm93bmVyLAoJLy8gICAgICAgJ2NhbiBvbmx5IGJlIGNhbGxlZCBieSB2YWxpZGF0b3Igb3duZXInCgkvLyAgICAgKQoJdHhuIFNlbmRlcgoJaW50YyAyIC8vIDgKCWludGMgNiAvLyAzMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJPT0KCgkvLyBjYW4gb25seSBiZSBjYWxsZWQgYnkgdmFsaWRhdG9yIG93bmVyCglhc3NlcnQKCXJldHN1YgoKLy8gY2FsbGVyTXVzdEJlT3duZXJPck1hbmFnZXIodmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSk6IHZvaWQKY2FsbGVyTXVzdEJlT3duZXJPck1hbmFnZXI6Cglwcm90byAxIDAKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTAxMwoJLy8gYXNzZXJ0KAoJLy8gICAgICAgdGhpcy50eG4uc2VuZGVyID09PSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5vd25lciB8fAoJLy8gICAgICAgICB0aGlzLnR4bi5zZW5kZXIgPT09IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1hbmFnZXIsCgkvLyAgICAgICAnY2FuIG9ubHkgYmUgY2FsbGVkIGJ5IG93bmVyIG9yIG1hbmFnZXIgb2YgdmFsaWRhdG9yJwoJLy8gICAgICkKCXR4biBTZW5kZXIKCWludGMgMiAvLyA4CglpbnRjIDYgLy8gMzIKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCT09CglkdXAKCWJueiAqc2tpcF9vcjMKCXR4biBTZW5kZXIKCWludGMgMjAgLy8gNDAKCWludGMgNiAvLyAzMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJPT0KCXx8Cgoqc2tpcF9vcjM6CgkvLyBjYW4gb25seSBiZSBjYWxsZWQgYnkgb3duZXIgb3IgbWFuYWdlciBvZiB2YWxpZGF0b3IKCWFzc2VydAoJcmV0c3ViCgovLyB2ZXJpZnlQb29sS2V5Q2FsbGVyKHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkpOiB2b2lkCi8vCi8vIHZlcmlmeVBvb2xLZXlDYWxsZXIgdmVyaWZpZXMgdGhlIHBhc3NlZCBpbiBrZXkgKGZyb20gYSBzdGFraW5nIHBvb2wgY2FsbGluZyB1cyB0byB1cGRhdGUgbWV0cmljcykgaXMgdmFsaWQKLy8gYW5kIG1hdGNoZXMgdGhlIGluZm9ybWF0aW9uIHdlIGhhdmUgaW4gb3VyIHN0YXRlLiAgJ0Zha2UnIHBvb2xzIGNvdWxkIGNhbGwgdXMgdG8gdXBkYXRlIG91ciBkYXRhLCBidXQgdGhleQovLyBjYW4ndCBmYWtlIHRoZSBpZHMgYW5kIG1vc3QgaW1wb3J0YW50bHkgYXBwbGljYXRpb24gaWQoISkgb2YgdGhlIGNhbGxlciB0aGF0IGhhcyB0byBtYXRjaC4KdmVyaWZ5UG9vbEtleUNhbGxlcjoKCXByb3RvIDEgMAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDI2CgkvLyBhc3NlcnQodGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLmV4aXN0cywgInRoZSBzcGVjaWZpZWQgdmFsaWRhdG9yIGlkIGlzbid0IHZhbGlkIikKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWJveF9sZW4KCXN3YXAKCXBvcAoKCS8vIHRoZSBzcGVjaWZpZWQgdmFsaWRhdG9yIGlkIGlzbid0IHZhbGlkCglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTAyNwoJLy8gYXNzZXJ0KHBvb2xLZXkucG9vbElkIDw9IE1BWF9QT09MUywgJ3Bvb2wgaWQgbm90IGluIHZhbGlkIHJhbmdlJykKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50YyAzIC8vIDI0Cgk8PQoKCS8vIHBvb2wgaWQgbm90IGluIHZhbGlkIHJhbmdlCglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTAyOAoJLy8gYXNzZXJ0KAoJLy8gICAgICAgcG9vbEtleS5wb29sSWQgPiAwICYmIChwb29sS2V5LnBvb2xJZCBhcyB1aW50MTYpIDw9IHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5zdGF0ZS5udW1Qb29scywKCS8vICAgICAgICdwb29sIGlkIG91dHNpZGUgb2YgcmFuZ2Ugb2YgcG9vbHMgY3JlYXRlZCBmb3IgdGhpcyB2YWxpZGF0b3InCgkvLyAgICAgKQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnRjIDAgLy8gMAoJPgoJZHVwCglieiAqc2tpcF9hbmQzCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgOSAvLyAyNDIKCWludGMgMTAgLy8gMgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCTw9CgkmJgoKKnNraXBfYW5kMzoKCS8vIHBvb2wgaWQgb3V0c2lkZSBvZiByYW5nZSBvZiBwb29scyBjcmVhdGVkIGZvciB0aGlzIHZhbGlkYXRvcgoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMzQKCS8vIGFzc2VydCgKCS8vICAgICAgIHBvb2xLZXkucG9vbEFwcElkID09PSB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXS5wb29sQXBwSWQsCgkvLyAgICAgICAiVGhlIHBhc3NlZCBpbiBhcHAgaWQgZG9lc24ndCBtYXRjaCB0aGUgcGFzc2VkIGluIGlkcyIKCS8vICAgICApCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAxNiA4CglidG9pCglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50YyAxIC8vIDEKCS0KCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnRjIDAgLy8gMAoJKwoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCgk9PQoKCS8vIFRoZSBwYXNzZWQgaW4gYXBwIGlkIGRvZXNuJ3QgbWF0Y2ggdGhlIHBhc3NlZCBpbiBpZHMKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDM5CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBBcHBJRC5mcm9tVWludDY0KHBvb2xLZXkucG9vbEFwcElkKS5hZGRyZXNzKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMTYgOAoJYnRvaQoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCgk9PQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNDEKCS8vIGFzc2VydChwb29sS2V5LmlkID09PSAoQXBwSUQuZnJvbVVpbnQ2NChwb29sS2V5LnBvb2xBcHBJZCkuZ2xvYmFsU3RhdGUoJ3ZhbGlkYXRvcklkJykgYXMgdWludDY0KSkKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMTYgOAoJYnRvaQoJcHVzaGJ5dGVzIDB4NzY2MTZjNjk2NDYxNzQ2ZjcyNDk2NCAvLyAidmFsaWRhdG9ySWQiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NChwb29sS2V5LnBvb2xBcHBJZCkuZ2xvYmFsU3RhdGUoJ3ZhbGlkYXRvcklkJykKCWFzc2VydAoJPT0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDQyCgkvLyBhc3NlcnQocG9vbEtleS5wb29sSWQgPT09IChBcHBJRC5mcm9tVWludDY0KHBvb2xLZXkucG9vbEFwcElkKS5nbG9iYWxTdGF0ZSgncG9vbElkJykgYXMgdWludDY0KSkKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMTYgOAoJYnRvaQoJcHVzaGJ5dGVzIDB4NzA2ZjZmNmM0OTY0IC8vICJwb29sSWQiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NChwb29sS2V5LnBvb2xBcHBJZCkuZ2xvYmFsU3RhdGUoJ3Bvb2xJZCcpCglhc3NlcnQKCT09Cglhc3NlcnQKCXJldHN1YgoKLy8gcmV2ZXJpZnlORkRPd25lcnNoaXAodmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSk6IHZvaWQKLy8KLy8gVGhpcyBtZXRob2QgdmVyaWZpZXMgdGhlIG93bmVyc2hpcCBvZiBORkQgKE5hbWVkIEZ1bmN0aW9uIERhdGEpIGJ5IGEgdmFsaWRhdG9yLgovLyBJZiB0aGUgb3duZXJzaGlwIGlzIG5vIGxvbmdlciB2YWxpZCwgaXQgcmVtb3ZlcyB0aGUgTkZEIGZyb20gdGhlIHZhbGlkYXRvcidzIGNvbmZpZ3VyYXRpb24uCi8vCi8vIEBwYXJhbSB7VmFsaWRhdG9ySWRUeXBlfSB2YWxpZGF0b3JJZCAtIFRoZSBpZCBvZiB0aGUgdmFsaWRhdG9yIHdob3NlIGRhdGEgc2hvdWxkIGJlIHJlLWV2YWx1YXRlZC4KcmV2ZXJpZnlORkRPd25lcnNoaXA6Cglwcm90byAxIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNTIKCS8vIHZhbGlkYXRvckNvbmZpZyA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyBzdG9yYWdlIGtleS8vdmFsaWRhdG9yQ29uZmlnCgoJLy8gKmlmMzBfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA1MwoJLy8gdmFsaWRhdG9yQ29uZmlnLm5mZEZvckluZm8gIT09IDAKCWludGMgMjEgLy8gNzIKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjMwX2VuZAoKCS8vICppZjMwX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDU2CgkvLyBuZmRPd25lciA9IEFwcElELmZyb21VaW50NjQodmFsaWRhdG9yQ29uZmlnLm5mZEZvckluZm8pLmdsb2JhbFN0YXRlKCdpLm93bmVyLmEnKSBhcyBBZGRyZXNzCglpbnRjIDIxIC8vIDcyCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJYnl0ZWMgMTAgLy8gICJpLm93bmVyLmEiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NCh2YWxpZGF0b3JDb25maWcubmZkRm9ySW5mbykuZ2xvYmFsU3RhdGUoJ2kub3duZXIuYScpCglhc3NlcnQKCWZyYW1lX2J1cnkgMSAvLyBuZmRPd25lcjogYWRkcmVzcwoKCS8vICppZjMxX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNTgKCS8vIHZhbGlkYXRvckNvbmZpZy5vd25lciAhPT0gbmZkT3duZXIgJiYgdmFsaWRhdG9yQ29uZmlnLm1hbmFnZXIgIT09IG5mZE93bmVyCglpbnRjIDIgLy8gOAoJaW50YyA2IC8vIDMyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglmcmFtZV9kaWcgMSAvLyBuZmRPd25lcjogYWRkcmVzcwoJIT0KCWR1cAoJYnogKnNraXBfYW5kNAoJaW50YyAyMCAvLyA0MAoJaW50YyA2IC8vIDMyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglmcmFtZV9kaWcgMSAvLyBuZmRPd25lcjogYWRkcmVzcwoJIT0KCSYmCgoqc2tpcF9hbmQ0OgoJYnogKmlmMzFfZW5kCgoJLy8gKmlmMzFfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNjAKCS8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm5mZEZvckluZm8gPSAwCglpbnRjIDIxIC8vIDcyCglieXRlYyA3IC8vIDB4MDAwMDAwMDAwMDAwMDAwMAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKKmlmMzFfZW5kOgoKKmlmMzBfZW5kOgoJcmV0c3ViCgovLyB2YWxpZGF0ZUNvbmZpZyhjb25maWc6IFZhbGlkYXRvckNvbmZpZyk6IHZvaWQKdmFsaWRhdGVDb25maWc6Cglwcm90byAxIDAKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA2NwoJLy8gYXNzZXJ0KGNvbmZpZy5vd25lciAhPT0gQWRkcmVzcy56ZXJvQWRkcmVzcykKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCA4IDMyCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA2OAoJLy8gYXNzZXJ0KGNvbmZpZy5tYW5hZ2VyICE9PSBBZGRyZXNzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDQwIDMyCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA2OQoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gY29uZmlnLm93bmVyLCAnc2VuZGVyIG11c3QgYmUgb3duZXIgdG8gYWRkIG5ldyB2YWxpZGF0b3InKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDggMzIKCT09CgoJLy8gc2VuZGVyIG11c3QgYmUgb3duZXIgdG8gYWRkIG5ldyB2YWxpZGF0b3IKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDcxCgkvLyBhc3NlcnQoCgkvLyAgICAgICBjb25maWcuZW50cnlHYXRpbmdUeXBlID49IEdBVElOR19UWVBFX05PTkUgJiYgY29uZmlnLmVudHJ5R2F0aW5nVHlwZSA8PSBHQVRJTkdfVFlQRV9DT05TVF9NQVgsCgkvLyAgICAgICAnZ2F0aW5nIHR5cGUgbm90IHZhbGlkJwoJLy8gICAgICkKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCA4MCAxCglidG9pCglpbnRjIDAgLy8gMAoJPj0KCWR1cAoJYnogKnNraXBfYW5kNQoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDgwIDEKCWJ0b2kKCWludGMgMTUgLy8gNAoJPD0KCSYmCgoqc2tpcF9hbmQ1OgoJLy8gZ2F0aW5nIHR5cGUgbm90IHZhbGlkCglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA3NQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgY29uZmlnLmVwb2NoUm91bmRMZW5ndGggPj0gTUlOX0VQT0NIX0xFTkdUSCAmJiBjb25maWcuZXBvY2hSb3VuZExlbmd0aCA8PSBNQVhfRVBPQ0hfTEVOR1RILAoJLy8gICAgICAgJ2Vwb2NoIGxlbmd0aCBub3QgaW4gYWxsb3dhYmxlIHJhbmdlJwoJLy8gICAgICkKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAxNjkgNAoJYnRvaQoJaW50YyAxIC8vIDEKCT49CglkdXAKCWJ6ICpza2lwX2FuZDYKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAxNjkgNAoJYnRvaQoJaW50YyAyNCAvLyAxMDAwMDAwCgk8PQoJJiYKCipza2lwX2FuZDY6CgkvLyBlcG9jaCBsZW5ndGggbm90IGluIGFsbG93YWJsZSByYW5nZQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNzkKCS8vIGFzc2VydCgKCS8vICAgICAgIGNvbmZpZy5wZXJjZW50VG9WYWxpZGF0b3IgPj0gTUlOX1BDVF9UT19WQUxJREFUT1IgJiYgY29uZmlnLnBlcmNlbnRUb1ZhbGlkYXRvciA8PSBNQVhfUENUX1RPX1ZBTElEQVRPUiwKCS8vICAgICAgICdjb21taXNzaW9uIHBlcmNlbnRhZ2Ugbm90IHZhbGlkJwoJLy8gICAgICkKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAxNzMgNAoJYnRvaQoJaW50YyAwIC8vIDAKCT49CglkdXAKCWJ6ICpza2lwX2FuZDcKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAxNzMgNAoJYnRvaQoJaW50YyAyNCAvLyAxMDAwMDAwCgk8PQoJJiYKCipza2lwX2FuZDc6CgkvLyBjb21taXNzaW9uIHBlcmNlbnRhZ2Ugbm90IHZhbGlkCglhc3NlcnQKCgkvLyAqaWYzMl9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDgzCgkvLyBjb25maWcucGVyY2VudFRvVmFsaWRhdG9yICE9PSAwCglmcmFtZV9kaWcgLTEgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgMTczIDQKCWJ0b2kKCWludGMgMCAvLyAwCgkhPQoJYnogKmlmMzJfZW5kCgoJLy8gKmlmMzJfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwODQKCS8vIGFzc2VydCgKCS8vICAgICAgICAgY29uZmlnLnZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzICE9PSBBZGRyZXNzLnplcm9BZGRyZXNzLAoJLy8gICAgICAgICAndmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3MgbXVzdCBiZSBzZXQgaWYgcGVyY2VudCB0byB2YWxpZGF0b3IgaXMgbm90IDAnCgkvLyAgICAgICApCglmcmFtZV9kaWcgLTEgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgMTc3IDMyCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9CgoJLy8gdmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3MgbXVzdCBiZSBzZXQgaWYgcGVyY2VudCB0byB2YWxpZGF0b3IgaXMgbm90IDAKCWFzc2VydAoKKmlmMzJfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwODkKCS8vIGFzc2VydChjb25maWcubWluRW50cnlTdGFrZSA+PSBNSU5fQUxHT19TVEFLRV9QRVJfUE9PTCwgJ3N0YWtpbmcgcG9vbCBtdXN0IGhhdmUgbWluaW11bSBlbnRyeSBvZiAxIGFsZ28nKQoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDIwOSA4CglidG9pCglpbnRjIDI0IC8vIDEwMDAwMDAKCT49CgoJLy8gc3Rha2luZyBwb29sIG11c3QgaGF2ZSBtaW5pbXVtIGVudHJ5IG9mIDEgYWxnbwoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwOTEKCS8vIGFzc2VydCgKCS8vICAgICAgIGNvbmZpZy5wb29sc1Blck5vZGUgPiAwICYmIGNvbmZpZy5wb29sc1Blck5vZGUgPD0gTUFYX1BPT0xTX1BFUl9OT0RFLAoJLy8gICAgICAgJ251bWJlciBvZiBwb29scyBwZXIgbm9kZSBtdXN0IGJlIGJlIGJldHdlZW4gMSBhbmQgdGhlIG1heGltdW0gYWxsb3dlZCBudW1iZXInCgkvLyAgICAgKQoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDIyNSAxCglidG9pCglpbnRjIDAgLy8gMAoJPgoJZHVwCglieiAqc2tpcF9hbmQ4CglmcmFtZV9kaWcgLTEgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgMjI1IDEKCWJ0b2kKCWludGMgOCAvLyAzCgk8PQoJJiYKCipza2lwX2FuZDg6CgkvLyBudW1iZXIgb2YgcG9vbHMgcGVyIG5vZGUgbXVzdCBiZSBiZSBiZXR3ZWVuIDEgYW5kIHRoZSBtYXhpbXVtIGFsbG93ZWQgbnVtYmVyCglhc3NlcnQKCgkvLyAqaWYzM19jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDk1CgkvLyBjb25maWcuc3Vuc2V0dGluZ09uICE9PSAwCglmcmFtZV9kaWcgLTEgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgMjI2IDgKCWJ0b2kKCWludGMgMCAvLyAwCgkhPQoJYnogKmlmMzNfZW5kCgoJLy8gKmlmMzNfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwOTYKCS8vIGFzc2VydChjb25maWcuc3Vuc2V0dGluZ09uID4gZ2xvYmFscy5sYXRlc3RUaW1lc3RhbXAsICdzdW5zZXR0aW5nT24gbXVzdCBiZSBsYXRlciB0aGFuIG5vdyBpZiBzZXQnKQoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDIyNiA4CglidG9pCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCgk+CgoJLy8gc3Vuc2V0dGluZ09uIG11c3QgYmUgbGF0ZXIgdGhhbiBub3cgaWYgc2V0Cglhc3NlcnQKCippZjMzX2VuZDoKCXJldHN1YgoKLy8gY2FsbFBvb2xBZGRTdGFrZShzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4sIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXksIG1ickFtdFBhaWQ6IHVpbnQ2NCwgaXNOZXdTdGFrZXJUb1ZhbGlkYXRvcjogYm9vbGVhbiwgaXNOZXdTdGFrZXJUb1Byb3RvY29sOiBib29sZWFuKTogdm9pZAovLwovLyBBZGRzIGEgc3Rha2VycyBhbW91bnQgb2YgYWxnbyB0byBhIHZhbGlkYXRvciBwb29sLCB0cmFuc2ZlcnJpbmcgdGhlIGFsZ28gd2UgcmVjZWl2ZWQgZnJvbSB0aGVtIChhbHJlYWR5IHZlcmlmaWVkCi8vIGJ5IG91ciBjYWxsZXIpIHRvIHRoZSBzdGFraW5nIHBvb2wgYWNjb3VudCwgYW5kIHRoZW4gdGVsbGluZyBpdCBhYm91dCB0aGUgYW1vdW50IGJlaW5nIGFkZGVkIGZvciB0aGUgc3BlY2lmaWVkCi8vIHN0YWtlci4KLy8KLy8gQHBhcmFtIHtQYXlUeG59IHN0YWtlZEFtb3VudFBheW1lbnQgLSBwYXltZW50IGNvbWluZyBmcm9tIHN0YWtlciB0byBwbGFjZSBpbnRvIGEgcG9vbAovLyBAcGFyYW0ge1ZhbGlkYXRvclBvb2xLZXl9IHBvb2xLZXkgLSBUaGUga2V5IG9mIHRoZSB2YWxpZGF0b3IgcG9vbC4KLy8gQHBhcmFtIHt1aW50NjR9IG1ickFtdFBhaWQgLSBBbW91bnQgdGhlIHVzZXIgaXMgbGVhdmluZyBiZWhpbmQgaW4gdGhlIHZhbGlkYXRvciB0byBwYXkgZm9yIHRoZWlyIHN0YWtlciBNQlIgY29zdAovLyBAcGFyYW0ge2Jvb2xlYW59IGlzTmV3U3Rha2VyVG9WYWxpZGF0b3IgLSBpZiB0aGlzIGlzIGEgbmV3LCBmaXJzdC10aW1lIHN0YWtlciB0byB0aGUgdmFsaWRhdG9yCi8vIEBwYXJhbSB7Ym9vbGVhbn0gaXNOZXdTdGFrZXJUb1Byb3RvY29sIC0gaWYgdGhpcyBpcyBhIG5ldywgZmlyc3QtdGltZSBzdGFrZXIgdG8gdGhlIHByb3RvY29sCmNhbGxQb29sQWRkU3Rha2U6Cglwcm90byA1IDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiAyCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMTgKCS8vIHBvb2xBcHBJZCA9IHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5wb29sc1twb29sS2V5LnBvb2xJZCAtIDFdLnBvb2xBcHBJZAoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAwIC8vIDAKCSsKCWludGMgMiAvLyA4CglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMiAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAwIC8vIHBvb2xBcHBJZDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMjIKCS8vIHNlbmRNZXRob2RDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUuYWRkU3Rha2UsIHVpbnQ2ND4oewoJLy8gICAgICAgYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NChwb29sQXBwSWQpLAoJLy8gICAgICAgbWV0aG9kQXJnczogWwoJLy8gICAgICAgICAvLyA9PT09PT09CgkvLyAgICAgICAgIC8vIFRISVMgSVMgQSBTRU5EIG9mIHRoZSBhbW91bnQgcmVjZWl2ZWQgcmlnaHQgYmFjayBvdXQgYW5kIGludG8gdGhlIHN0YWtpbmcgcG9vbCBjb250cmFjdCBhY2NvdW50LgoJLy8gICAgICAgICB7IGFtb3VudDogc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQgLSBtYnJBbXRQYWlkLCByZWNlaXZlcjogQXBwSUQuZnJvbVVpbnQ2NChwb29sQXBwSWQpLmFkZHJlc3MgfSwKCS8vICAgICAgICAgLy8gPT09PT09PQoJLy8gICAgICAgICBzdGFrZWRBbW91bnRQYXltZW50LnNlbmRlciwKCS8vICAgICAgIF0sCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMjcKCS8vIGFtb3VudDogc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQgLSBtYnJBbXRQYWlkCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWZyYW1lX2RpZyAtMyAvLyBtYnJBbXRQYWlkOiB1aW50NjQKCS0KCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMjcKCS8vIHJlY2VpdmVyOiBBcHBJRC5mcm9tVWludDY0KHBvb2xBcHBJZCkuYWRkcmVzcwoJZnJhbWVfZGlnIDAgLy8gcG9vbEFwcElkOiB1aW50NjQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoJaXR4bl9uZXh0CglpbnRjIDcgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCXB1c2hieXRlcyAweGY5YzcwY2JkIC8vIG1ldGhvZCAiYWRkU3Rha2UocGF5LGFkZHJlc3MpdWludDY0IgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEyMwoJLy8gYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NChwb29sQXBwSWQpCglmcmFtZV9kaWcgMCAvLyBwb29sQXBwSWQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMjQKCS8vIG1ldGhvZEFyZ3M6IFsKCS8vICAgICAgICAgLy8gPT09PT09PQoJLy8gICAgICAgICAvLyBUSElTIElTIEEgU0VORCBvZiB0aGUgYW1vdW50IHJlY2VpdmVkIHJpZ2h0IGJhY2sgb3V0IGFuZCBpbnRvIHRoZSBzdGFraW5nIHBvb2wgY29udHJhY3QgYWNjb3VudC4KCS8vICAgICAgICAgeyBhbW91bnQ6IHN0YWtlZEFtb3VudFBheW1lbnQuYW1vdW50IC0gbWJyQW10UGFpZCwgcmVjZWl2ZXI6IEFwcElELmZyb21VaW50NjQocG9vbEFwcElkKS5hZGRyZXNzIH0sCgkvLyAgICAgICAgIC8vID09PT09PT0KCS8vICAgICAgICAgc3Rha2VkQW1vdW50UGF5bWVudC5zZW5kZXIsCgkvLyAgICAgICBdCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBTZW5kZXIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnRjIDEgLy8gMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCglidG9pCgoJLy8gKmlmMzRfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEzMgoJLy8gZ2xvYmFscy5vcGNvZGVCdWRnZXQgPCA1MDAKCWdsb2JhbCBPcGNvZGVCdWRnZXQKCXB1c2hpbnQgNTAwCgk8CglieiAqaWYzNF9lbmQKCgkvLyAqaWYzNF9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEzMwoJLy8gaW5jcmVhc2VPcGNvZGVCdWRnZXQoKQoJaXR4bl9iZWdpbgoJaW50YyA3IC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCWJ5dGVjIDggLy8gICNwcmFnbWEgdmVyc2lvbiAxMDsgaW50IDEKCWR1cAoJaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KCWl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KCWludGMgMjYgLy8gIERlbGV0ZUFwcGxpY2F0aW9uCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoJaXR4bl9zdWJtaXQKCippZjM0X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTM3CgkvLyBwb29sTnVtU3Rha2VycyA9IEFwcElELmZyb21VaW50NjQocG9vbEFwcElkKS5nbG9iYWxTdGF0ZSgnbnVtU3Rha2VycycpIGFzIHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gcG9vbEFwcElkOiB1aW50NjQKCWJ5dGVjIDYgLy8gICJudW1TdGFrZXJzIgoJYXBwX2dsb2JhbF9nZXRfZXgKCgkvLyBnbG9iYWwgc3RhdGUgdmFsdWUgZG9lcyBub3QgZXhpc3Q6IEFwcElELmZyb21VaW50NjQocG9vbEFwcElkKS5nbG9iYWxTdGF0ZSgnbnVtU3Rha2VycycpCglhc3NlcnQKCWZyYW1lX2J1cnkgMSAvLyBwb29sTnVtU3Rha2VyczogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMzgKCS8vIHBvb2xBbGdvU3Rha2VkID0gQXBwSUQuZnJvbVVpbnQ2NChwb29sQXBwSWQpLmdsb2JhbFN0YXRlKCdzdGFrZWQnKSBhcyB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIHBvb2xBcHBJZDogdWludDY0CglieXRlYyA0IC8vICAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXRfZXgKCgkvLyBnbG9iYWwgc3RhdGUgdmFsdWUgZG9lcyBub3QgZXhpc3Q6IEFwcElELmZyb21VaW50NjQocG9vbEFwcElkKS5nbG9iYWxTdGF0ZSgnc3Rha2VkJykKCWFzc2VydAoJZnJhbWVfYnVyeSAyIC8vIHBvb2xBbGdvU3Rha2VkOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEzOQoJLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnBvb2xzW3Bvb2xLZXkucG9vbElkIC0gMV0udG90YWxTdGFrZXJzID0gcG9vbE51bVN0YWtlcnMgYXMgdWludDE2CglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAtMiAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50YyAxIC8vIDEKCS0KCWludGMgNCAvLyAxOAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnRjIDIgLy8gIGhlYWRPZmZzZXQKCSsKCWZyYW1lX2RpZyAxIC8vIHBvb2xOdW1TdGFrZXJzOiB1aW50NjQKCWl0b2IKCWV4dHJhY3QgNiAyCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMiAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTQwCgkvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXS50b3RhbEFsZ29TdGFrZWQgPSBwb29sQWxnb1N0YWtlZAoJaW50YyA1IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgMSAvLyAxCgktCglpbnRjIDQgLy8gMTgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAxMSAvLyAgaGVhZE9mZnNldAoJKwoJZnJhbWVfZGlnIDIgLy8gcG9vbEFsZ29TdGFrZWQ6IHVpbnQ2NAoJaXRvYgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyAqaWYzNV9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTQzCgkvLyBpc05ld1N0YWtlclRvVmFsaWRhdG9yCglmcmFtZV9kaWcgLTQgLy8gaXNOZXdTdGFrZXJUb1ZhbGlkYXRvcjogYm9vbGVhbgoJYnogKmlmMzVfZW5kCgoJLy8gKmlmMzVfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNDQKCS8vIHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5zdGF0ZS50b3RhbFN0YWtlcnMgKz0gMQoJaW50YyAyMyAvLyAyNDQKCWR1cAoJaW50YyAyIC8vIDgKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglpbnRjIDEgLy8gMQoJKwoJaXRvYgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCippZjM1X2VuZDoKCS8vICppZjM2X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNDYKCS8vIGlzTmV3U3Rha2VyVG9Qcm90b2NvbAoJZnJhbWVfZGlnIC01IC8vIGlzTmV3U3Rha2VyVG9Qcm90b2NvbDogYm9vbGVhbgoJYnogKmlmMzZfZW5kCgoJLy8gKmlmMzZfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNDcKCS8vIHRoaXMubnVtU3Rha2Vycy52YWx1ZSArPSAxCglieXRlYyA2IC8vICAibnVtU3Rha2VycyIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDEgLy8gMQoJKwoJYnl0ZWMgNiAvLyAgIm51bVN0YWtlcnMiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKKmlmMzZfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNDkKCS8vIHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5zdGF0ZS50b3RhbEFsZ29TdGFrZWQgKz0gc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQgLSBtYnJBbXRQYWlkCglpbnRjIDEyIC8vIDI1MgoJZHVwCglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJZnJhbWVfZGlnIC0zIC8vIG1ickFtdFBhaWQ6IHVpbnQ2NAoJLQoJKwoJaXRvYgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE1MAoJLy8gdGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgKz0gc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQgLSBtYnJBbXRQYWlkCglieXRlYyA0IC8vICAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJZnJhbWVfZGlnIC0zIC8vIG1ickFtdFBhaWQ6IHVpbnQ2NAoJLQoJKwoJYnl0ZWMgNCAvLyAgInN0YWtlZCIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIHVwZGF0ZVN0YWtlclBvb2xTZXQoc3Rha2VyOiBBZGRyZXNzLCBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5KTogdm9pZAp1cGRhdGVTdGFrZXJQb29sU2V0OgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDEgLy8gMHgKCWR1cG4gMgoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTU0CgkvLyBhc3NlcnQodGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikuZXhpc3RzKQoJYnl0ZWMgMyAvLyAgInNwcyIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE1NgoJLy8gcG9vbFNldCA9IGNsb25lKHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlKQoJYnl0ZWMgMyAvLyAgInNwcyIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUKCWFzc2VydAoJZnJhbWVfYnVyeSAwIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0LHVpbnQ2NClbNl0KCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE1NwoJLy8gZmlyc3RFbXB0eSA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDEgLy8gZmlyc3RFbXB0eTogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNTgKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUubGVuZ3RoOyBpICs9IDEpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoKKmZvcl83OgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNTgKCS8vIGkgPCB0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZS5sZW5ndGgKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyA3IC8vIDYKCTwKCWJ6ICpmb3JfN19lbmQKCgkvLyAqaWYzN19jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTU5CgkvLyBwb29sU2V0W2ldID09PSBwb29sS2V5CglmcmFtZV9kaWcgMCAvLyBwb29sU2V0OiAodWludDY0LHVpbnQ2NCx1aW50NjQpWzZdCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgMyAvLyAyNAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDMgLy8gMjQKCWV4dHJhY3QzCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJPT0KCWJ6ICppZjM3X2VuZAoKCS8vICppZjM3X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTYxCgkvLyByZXR1cm47CglyZXRzdWIKCippZjM3X2VuZDoKCS8vICppZjM4X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNjMKCS8vIGZpcnN0RW1wdHkgPT09IDAgJiYgcG9vbFNldFtpXS5pZCA9PT0gMAoJZnJhbWVfZGlnIDEgLy8gZmlyc3RFbXB0eTogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCWR1cAoJYnogKnNraXBfYW5kOQoJZnJhbWVfZGlnIDAgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQsdWludDY0KVs2XQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnRjIDMgLy8gMjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAwIC8vIDAKCSsKCWludGMgMiAvLyA4CglleHRyYWN0MwoJYnRvaQoJaW50YyAwIC8vIDAKCT09CgkmJgoKKnNraXBfYW5kOToKCWJ6ICppZjM4X2VuZAoKCS8vICppZjM4X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTY0CgkvLyBmaXJzdEVtcHR5ID0gaSArIDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBmaXJzdEVtcHR5OiB1aW50NjQKCippZjM4X2VuZDoKCipmb3JfN19jb250aW51ZToKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTU4CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCWIgKmZvcl83CgoqZm9yXzdfZW5kOgoJLy8gKmlmMzlfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE2NwoJLy8gZmlyc3RFbXB0eSA9PT0gMAoJZnJhbWVfZGlnIDEgLy8gZmlyc3RFbXB0eTogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjM5X2VuZAoKCS8vICppZjM5X2NvbnNlcXVlbnQKCS8vIE5vIGVtcHR5IHNsb3QgYXZhaWxhYmxlIGluIHRoZSBzdGFrZXIgcG9vbCBzZXQKCWVycgoKKmlmMzlfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNzAKCS8vIHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlW2ZpcnN0RW1wdHkgLSAxXSA9IHBvb2xLZXkKCWZyYW1lX2RpZyAxIC8vIGZpcnN0RW1wdHk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCS0KCWludGMgMyAvLyAyNAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJYnl0ZWMgMyAvLyAgInNwcyIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZXI6IEFkZHJlc3MKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCXJldHN1YgoKLy8gcmVtb3ZlRnJvbVN0YWtlclBvb2xTZXQoc3Rha2VyOiBBZGRyZXNzLCBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5KTogW2Jvb2xlYW4sIGJvb2xlYW5dCi8vCi8vIFJlbW92ZXMgYSBwb29sIGtleSBmcm9tIHRoZSBzdGFrZXIncyBhY3RpdmUgcG9vbCBzZXQgLSBmYWlscyBpZiBub3QgZm91bmQgKCEpCi8vCi8vIEBwYXJhbSB7QWRkcmVzc30gc3Rha2VyIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHN0YWtlci4KLy8gQHBhcmFtIHtWYWxpZGF0b3JQb29sS2V5fSBwb29sS2V5IC0gVGhlIHBvb2wga2V5IHRoZXkgc2hvdWxkIGJlIHN0b3JlZCBpbgovLwovLyBAcmV0dXJuIFtib29sZWFuLCBib29sZWFuXSBbaXMgdGhlIHN0YWtlciBnb25lIGZyb20gQUxMIHBvb2xzIG9mIHRoZSBnaXZlbiBWQUxJREFUT1IsIGFuZCBpcyBzdGFrZXIgZ29uZSBmcm9tIEFMTCBwb29sc10KcmVtb3ZlRnJvbVN0YWtlclBvb2xTZXQ6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiA0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExODMKCS8vIGluU2FtZVZhbGlkYXRvclBvb2xDb3VudCA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDAgLy8gaW5TYW1lVmFsaWRhdG9yUG9vbENvdW50OiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE4NAoJLy8gaW5BbnlQb29sQ291bnQgPSAwCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAxIC8vIGluQW55UG9vbENvdW50OiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE4NQoJLy8gZm91bmQgPSBmYWxzZQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMiAvLyBmb3VuZDogYm9vbAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTg3CgkvLyBwb29sU2V0ID0gY2xvbmUodGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUpCglieXRlYyAzIC8vICAic3BzIgoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlcjogQWRkcmVzcwoJY29uY2F0Cglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDMgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQsdWludDY0KVs2XQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTg4CgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlLmxlbmd0aDsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNCAvLyBpOiB1aW50NjQKCipmb3JfODoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTg4CgkvLyBpIDwgdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUubGVuZ3RoCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgNyAvLyA2Cgk8CglieiAqZm9yXzhfZW5kCgoJLy8gKmlmNDBfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE4OQoJLy8gcG9vbFNldFtpXS5pZCA9PT0gMAoJZnJhbWVfZGlnIDMgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQsdWludDY0KVs2XQoJZnJhbWVfZGlnIDQgLy8gaTogdWludDY0CglpbnRjIDMgLy8gMjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAwIC8vIDAKCSsKCWludGMgMiAvLyA4CglleHRyYWN0MwoJYnRvaQoJaW50YyAwIC8vIDAKCT09CglieiAqaWY0MF9lbmQKCgkvLyAqaWY0MF9jb25zZXF1ZW50CgliICpmb3JfOF9jb250aW51ZQoKKmlmNDBfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExOTIKCS8vIGluQW55UG9vbENvdW50ICs9IDEKCWZyYW1lX2RpZyAxIC8vIGluQW55UG9vbENvdW50OiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDEgLy8gaW5BbnlQb29sQ291bnQ6IHVpbnQ2NAoKCS8vICppZjQxX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExOTMKCS8vIHBvb2xTZXRbaV0uaWQgPT09IHBvb2xLZXkuaWQKCWZyYW1lX2RpZyAzIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0LHVpbnQ2NClbNl0KCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMCAvLyAwCgkrCglpbnRjIDIgLy8gOAoJZXh0cmFjdDMKCWJ0b2kKCWZyYW1lX2RpZyAtMiAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJPT0KCWJ6ICppZjQxX2VuZAoKCS8vICppZjQxX2NvbnNlcXVlbnQKCS8vICppZjQyX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExOTQKCS8vIHBvb2xTZXRbaV0gPT09IHBvb2xLZXkKCWZyYW1lX2RpZyAzIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0LHVpbnQ2NClbNl0KCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMyAvLyAyNAoJZXh0cmFjdDMKCWZyYW1lX2RpZyAtMiAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5Cgk9PQoJYnogKmlmNDJfZWxzZQoKCS8vICppZjQyX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTk1CgkvLyBmb3VuZCA9IHRydWUKCWludGMgMSAvLyAxCglmcmFtZV9idXJ5IDIgLy8gZm91bmQ6IGJvb2wKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE5NwoJLy8gdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWVbaV0gPSB7IGlkOiAwLCBwb29sSWQ6IDAsIHBvb2xBcHBJZDogMCB9CglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgMyAvLyAyNAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglwdXNoYnl0ZXMgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWJ5dGVjIDMgLy8gICJzcHMiCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VyOiBBZGRyZXNzCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgliICppZjQyX2VuZAoKKmlmNDJfZWxzZToKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTk5CgkvLyBpblNhbWVWYWxpZGF0b3JQb29sQ291bnQgKz0gMQoJZnJhbWVfZGlnIDAgLy8gaW5TYW1lVmFsaWRhdG9yUG9vbENvdW50OiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDAgLy8gaW5TYW1lVmFsaWRhdG9yUG9vbENvdW50OiB1aW50NjQKCippZjQyX2VuZDoKCippZjQxX2VuZDoKCipmb3JfOF9jb250aW51ZToKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTg4CgkvLyBpICs9IDEKCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgNCAvLyBpOiB1aW50NjQKCWIgKmZvcl84CgoqZm9yXzhfZW5kOgoJLy8gKmlmNDNfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIwMwoJLy8gIWZvdW5kCglmcmFtZV9kaWcgMiAvLyBmb3VuZDogYm9vbAoJIQoJYnogKmlmNDNfZW5kCgoJLy8gKmlmNDNfY29uc2VxdWVudAoJLy8gTm8gbWF0Y2hpbmcgc2xvdCBmb3VuZCB3aGVuIHRvbGQgdG8gcmVtb3ZlIGEgcG9vbCBmcm9tIHRoZSBzdGFrZXJzIHNldAoJZXJyCgoqaWY0M19lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIwNwoJLy8gcmV0dXJuIFtpblNhbWVWYWxpZGF0b3JQb29sQ291bnQgPT09IDAsIGluQW55UG9vbENvdW50ID09PSAwXTsKCWJ5dGVjIDUgLy8gMHgwMAoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAwIC8vIGluU2FtZVZhbGlkYXRvclBvb2xDb3VudDogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCXNldGJpdAoJaW50YyAxIC8vIDEKCWZyYW1lX2RpZyAxIC8vIGluQW55UG9vbENvdW50OiB1aW50NjQKCWludGMgMCAvLyAwCgk9PQoJc2V0Yml0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gNAoJcmV0c3ViCgovLyBhZGRQb29sVG9Ob2RlKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIHBvb2xBcHBJZDogdWludDY0LCBub2RlTnVtOiB1aW50NjQpOiB2b2lkCmFkZFBvb2xUb05vZGU6Cglwcm90byAzIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiAyCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMTEKCS8vIG5vZGVQb29sQXNzaWdubWVudHMgPSBjbG9uZSh0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLm5vZGVQb29sQXNzaWdubWVudHMpCglpbnRjIDE3IC8vICBoZWFkT2Zmc2V0CglpbnRjIDIyIC8vIDE5MgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJZnJhbWVfYnVyeSAwIC8vIG5vZGVQb29sQXNzaWdubWVudHM6ICgodWludDY0WzNdKVs4XSkKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIxMgoJLy8gbWF4UG9vbHNQZXJOb2RlRm9yVGhpc1ZhbGlkYXRvciA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLnBvb2xzUGVyTm9kZSBhcyB1aW50NjQKCXB1c2hpbnQgMjI1CglpbnRjIDEgLy8gMQoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAxIC8vIG1heFBvb2xzUGVyTm9kZUZvclRoaXNWYWxpZGF0b3I6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjE0CgkvLyBhc3NlcnQobm9kZU51bSA+PSAxICYmIG5vZGVOdW0gPD0gTUFYX05PREVTLCAnbm9kZSBudW1iZXIgbm90IGluIHZhbGlkIHJhbmdlJykKCWZyYW1lX2RpZyAtMyAvLyBub2RlTnVtOiB1aW50NjQKCWludGMgMSAvLyAxCgk+PQoJZHVwCglieiAqc2tpcF9hbmQxMAoJZnJhbWVfZGlnIC0zIC8vIG5vZGVOdW06IHVpbnQ2NAoJaW50YyAyIC8vIDgKCTw9CgkmJgoKKnNraXBfYW5kMTA6CgkvLyBub2RlIG51bWJlciBub3QgaW4gdmFsaWQgcmFuZ2UKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjE2CgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IG1heFBvb2xzUGVyTm9kZUZvclRoaXNWYWxpZGF0b3I7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDIgLy8gaTogdWludDY0CgoqZm9yXzk6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIxNgoJLy8gaSA8IG1heFBvb2xzUGVyTm9kZUZvclRoaXNWYWxpZGF0b3IKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gbWF4UG9vbHNQZXJOb2RlRm9yVGhpc1ZhbGlkYXRvcjogdWludDY0Cgk8CglieiAqZm9yXzlfZW5kCgoJLy8gKmlmNDRfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIxNwoJLy8gbm9kZVBvb2xBc3NpZ25tZW50cy5ub2Rlc1tub2RlTnVtIC0gMV0ucG9vbEFwcElkc1tpXSA9PT0gMAoJZnJhbWVfZGlnIDAgLy8gbm9kZVBvb2xBc3NpZ25tZW50czogKCh1aW50NjRbM10pWzhdKQoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAtMyAvLyBub2RlTnVtOiB1aW50NjQKCWludGMgMSAvLyAxCgktCglpbnRjIDMgLy8gMjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAwIC8vIDAKCSsKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAyIC8vIDgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAyIC8vIDgKCWV4dHJhY3QzCglidG9pCglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjQ0X2VuZAoKCS8vICppZjQ0X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjE5CgkvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLm5vZGVQb29sQXNzaWdubWVudHMubm9kZXNbbm9kZU51bSAtIDFdLnBvb2xBcHBJZHNbaV0gPSBwb29sQXBwSWQKCWludGMgMTcgLy8gOTAwCglmcmFtZV9kaWcgLTMgLy8gbm9kZU51bTogdWludDY0CglpbnRjIDEgLy8gMQoJLQoJaW50YyAzIC8vIDI0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludGMgMCAvLyAwCgkrCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludGMgMiAvLyA4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWZyYW1lX2RpZyAtMiAvLyBwb29sQXBwSWQ6IHVpbnQ2NAoJaXRvYgoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjIwCgkvLyByZXR1cm47CglyZXRzdWIKCippZjQ0X2VuZDoKCipmb3JfOV9jb250aW51ZToKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjE2CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCWIgKmZvcl85CgoqZm9yXzlfZW5kOgoJLy8gbm8gYXZhaWxhYmxlIHNwYWNlIGluIHNwZWNpZmllZCBub2RlIGZvciB0aGlzIHBvb2wKCWVycgoJcmV0c3ViCgovLyBkb2VzU3Rha2VyTWVldEdhdGluZyh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCB2YWx1ZVRvVmVyaWZ5OiB1aW50NjQpOiB2b2lkCi8vCi8vIENoZWNrcyBpZiBhIHN0YWtlciBtZWV0cyB0aGUgZ2F0aW5nIHJlcXVpcmVtZW50cyBzcGVjaWZpZWQgYnkgdGhlIHZhbGlkYXRvci4KLy8KLy8gQHBhcmFtIHtWYWxpZGF0b3JJZFR5cGV9IHZhbGlkYXRvcklkIC0gVGhlIGlkIG9mIHRoZSB2YWxpZGF0b3IuCi8vIEBwYXJhbSB7dWludDY0fSB2YWx1ZVRvVmVyaWZ5IC0gVGhlIHZhbHVlIHRvIHZlcmlmeSBhZ2FpbnN0IHRoZSBnYXRpbmcgcmVxdWlyZW1lbnRzLgovLyBAcmV0dXJucyB7dm9pZH0gb3IgYXNzZXJ0cyBpZiByZXF1aXJlbWVudHMgbm90IG1ldC4KZG9lc1N0YWtlck1lZXRHYXRpbmc6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoJZHVwbiA4CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMzQKCS8vIHR5cGUgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5lbnRyeUdhdGluZ1R5cGUKCWludGMgMzYgLy8gODAKCWludGMgMSAvLyAxCglieXRlYyAwIC8vICAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDAgLy8gdHlwZTogdWludDgKCgkvLyAqaWY0NV9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjM1CgkvLyB0eXBlID09PSBHQVRJTkdfVFlQRV9OT05FCglmcmFtZV9kaWcgMCAvLyB0eXBlOiB1aW50OAoJaW50YyAwIC8vIDAKCT09CglieiAqaWY0NV9lbmQKCgkvLyAqaWY0NV9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIzNgoJLy8gcmV0dXJuOwoJcmV0c3ViCgoqaWY0NV9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIzOAoJLy8gc3Rha2VyID0gdGhpcy50eG4uc2VuZGVyCgl0eG4gU2VuZGVyCglmcmFtZV9idXJ5IDEgLy8gc3Rha2VyOiBhZGRyZXNzCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMzkKCS8vIGNvbmZpZyA9IGNsb25lKHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnKQoJaW50YyAwIC8vIDAKCWludGMgOSAvLyAyNDIKCWJ5dGVjIDAgLy8gICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWZyYW1lX2J1cnkgMiAvLyBjb25maWc6ICh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KQoKCS8vICppZjQ2X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNDMKCS8vIHR5cGUgPT09IEdBVElOR19UWVBFX0FTU0VUU19DUkVBVEVEX0JZIHx8CgkvLyAgICAgICB0eXBlID09PSBHQVRJTkdfVFlQRV9BU1NFVF9JRCB8fAoJLy8gICAgICAgdHlwZSA9PT0gR0FUSU5HX1RZUEVfQ1JFQVRFRF9CWV9ORkRfQUREUkVTU0VTCglmcmFtZV9kaWcgMCAvLyB0eXBlOiB1aW50OAoJaW50YyAxIC8vIDEKCT09CglkdXAKCWJueiAqc2tpcF9vcjQKCWZyYW1lX2RpZyAwIC8vIHR5cGU6IHVpbnQ4CglpbnRjIDEwIC8vIDIKCT09Cgl8fAoKKnNraXBfb3I0OgoJZHVwCglibnogKnNraXBfb3I1CglmcmFtZV9kaWcgMCAvLyB0eXBlOiB1aW50OAoJaW50YyA4IC8vIDMKCT09Cgl8fAoKKnNraXBfb3I1OgoJYnogKmlmNDZfZW5kCgoJLy8gKmlmNDZfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNDcKCS8vIGFzc2VydCh2YWx1ZVRvVmVyaWZ5ICE9PSAwKQoJZnJhbWVfZGlnIC0yIC8vIHZhbHVlVG9WZXJpZnk6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCSE9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI0OAoJLy8gYmFsUmVxdWlyZWQgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5nYXRpbmdBc3NldE1pbkJhbGFuY2UKCWludGMgMzcgLy8gMTQ1CglpbnRjIDIgLy8gOAoJYnl0ZWMgMCAvLyAgInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAzIC8vIGJhbFJlcXVpcmVkOiB1aW50NjQKCgkvLyAqaWY0N19jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjQ5CgkvLyBiYWxSZXF1aXJlZCA9PT0gMAoJZnJhbWVfZGlnIDMgLy8gYmFsUmVxdWlyZWQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT09CglieiAqaWY0N19lbmQKCgkvLyAqaWY0N19jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI1MAoJLy8gYmFsUmVxdWlyZWQgPSAxCglpbnRjIDEgLy8gMQoJZnJhbWVfYnVyeSAzIC8vIGJhbFJlcXVpcmVkOiB1aW50NjQKCippZjQ3X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjUyCgkvLyBhc3NlcnQoCgkvLyAgICAgICAgIHN0YWtlci5hc3NldEJhbGFuY2UoQXNzZXRJRC5mcm9tVWludDY0KHZhbHVlVG9WZXJpZnkpKSA+PSBiYWxSZXF1aXJlZCwKCS8vICAgICAgICAgJ211c3QgaGF2ZSByZXF1aXJlZCBtaW5pbXVtIGJhbGFuY2Ugb2YgdmFsaWRhdG9yIGRlZmluZWQgdG9rZW4gdG8gYWRkIHN0YWtlJwoJLy8gICAgICAgKQoJZnJhbWVfZGlnIDEgLy8gc3Rha2VyOiBhZGRyZXNzCglmcmFtZV9kaWcgLTIgLy8gdmFsdWVUb1ZlcmlmeTogdWludDY0Cglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIDMgLy8gYmFsUmVxdWlyZWQ6IHVpbnQ2NAoJPj0KCgkvLyBtdXN0IGhhdmUgcmVxdWlyZWQgbWluaW11bSBiYWxhbmNlIG9mIHZhbGlkYXRvciBkZWZpbmVkIHRva2VuIHRvIGFkZCBzdGFrZQoJYXNzZXJ0CgoqaWY0Nl9lbmQ6CgkvLyAqaWY0OF9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjU3CgkvLyB0eXBlID09PSBHQVRJTkdfVFlQRV9BU1NFVFNfQ1JFQVRFRF9CWQoJZnJhbWVfZGlnIDAgLy8gdHlwZTogdWludDgKCWludGMgMSAvLyAxCgk9PQoJYnogKmlmNDhfZW5kCgoJLy8gKmlmNDhfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNTgKCS8vIGFzc2VydCgKCS8vICAgICAgICAgQXNzZXRJRC5mcm9tVWludDY0KHZhbHVlVG9WZXJpZnkpLmNyZWF0b3IgPT09IGNvbmZpZy5lbnRyeUdhdGluZ0FkZHJlc3MsCgkvLyAgICAgICAgICdzcGVjaWZpZWQgYXNzZXQgbXVzdCBiZSBjcmVhdGVkIGJ5IGNyZWF0b3IgdGhhdCB0aGUgdmFsaWRhdG9yIGRlZmluZWQgYXMgYSByZXF1aXJlbWVudCB0byBzdGFrZScKCS8vICAgICAgICkKCWZyYW1lX2RpZyAtMiAvLyB2YWx1ZVRvVmVyaWZ5OiB1aW50NjQKCWFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCglwb3AKCWZyYW1lX2RpZyAyIC8vIGNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDgxIDMyCgk9PQoKCS8vIHNwZWNpZmllZCBhc3NldCBtdXN0IGJlIGNyZWF0ZWQgYnkgY3JlYXRvciB0aGF0IHRoZSB2YWxpZGF0b3IgZGVmaW5lZCBhcyBhIHJlcXVpcmVtZW50IHRvIHN0YWtlCglhc3NlcnQKCippZjQ4X2VuZDoKCS8vICppZjQ5X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNjMKCS8vIHR5cGUgPT09IEdBVElOR19UWVBFX0FTU0VUX0lECglmcmFtZV9kaWcgMCAvLyB0eXBlOiB1aW50OAoJaW50YyAxMCAvLyAyCgk9PQoJYnogKmlmNDlfZW5kCgoJLy8gKmlmNDlfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNjQKCS8vIGZvdW5kID0gZmFsc2UKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDQgLy8gZm91bmQ6IGJvb2wKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI2NQoJLy8gY29uZmlnLmVudHJ5R2F0aW5nQXNzZXRzCglmcmFtZV9kaWcgMiAvLyBjb25maWc6ICh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAxMTMgMzIKCWR1cAoJZnJhbWVfYnVyeSA1IC8vIGNvcHkgb2YgdGhlIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3ZlcgoJZXh0cmFjdCAwIDgKCWJ0b2kKCWZyYW1lX2J1cnkgNiAvLyBhc3NldElkOiB1aW50NjQKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDcgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCipmb3JPZl8wOgoJLy8gKmlmNTBfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI2NgoJLy8gdmFsdWVUb1ZlcmlmeSA9PT0gYXNzZXRJZAoJZnJhbWVfZGlnIC0yIC8vIHZhbHVlVG9WZXJpZnk6IHVpbnQ2NAoJZnJhbWVfZGlnIDYgLy8gYXNzZXRJZDogdWludDY0Cgk9PQoJYnogKmlmNTBfZW5kCgoJLy8gKmlmNTBfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNjcKCS8vIGZvdW5kID0gdHJ1ZQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgNCAvLyBmb3VuZDogYm9vbAoJYiAqZm9yT2ZfMF9lbmQKCippZjUwX2VuZDoKCipmb3JPZl8wX2NvbnRpbnVlOgoJLy8gaW5jcmVtZW50IG9mZnNldCBhbmQgbG9vcCBpZiBub3Qgb3V0IG9mIGJvdW5kcwoJZnJhbWVfZGlnIDcgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCWludGMgMiAvLyA4CgkrCglkdXAKCWludGMgNiAvLyAgb2Zmc2V0IG9mIGxhc3QgZWxlbWVudAoJPAoJYnogKmZvck9mXzBfZW5kCglmcmFtZV9idXJ5IDcgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCWZyYW1lX2RpZyA1IC8vIGNvcHkgb2YgdGhlIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3ZlcgoJZnJhbWVfZGlnIDcgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCWludGMgMiAvLyA4CglleHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDYgLy8gYXNzZXRJZDogdWludDY0CgliICpmb3JPZl8wCgoqZm9yT2ZfMF9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI3MQoJLy8gYXNzZXJ0KGZvdW5kLCAnc3BlY2lmaWVkIGFzc2V0IG11c3QgYmUgaWRlbnRpY2FsIHRvIHRoZSBhc3NldCBpZCBkZWZpbmVkIGFzIGEgcmVxdWlyZW1lbnQgdG8gc3Rha2UnKQoJZnJhbWVfZGlnIDQgLy8gZm91bmQ6IGJvb2wKCgkvLyBzcGVjaWZpZWQgYXNzZXQgbXVzdCBiZSBpZGVudGljYWwgdG8gdGhlIGFzc2V0IGlkIGRlZmluZWQgYXMgYSByZXF1aXJlbWVudCB0byBzdGFrZQoJYXNzZXJ0CgoqaWY0OV9lbmQ6CgkvLyAqaWY1MV9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjczCgkvLyB0eXBlID09PSBHQVRJTkdfVFlQRV9DUkVBVEVEX0JZX05GRF9BRERSRVNTRVMKCWZyYW1lX2RpZyAwIC8vIHR5cGU6IHVpbnQ4CglpbnRjIDggLy8gMwoJPT0KCWJ6ICppZjUxX2VuZAoKCS8vICppZjUxX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjc2CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgIHRoaXMuaXNBZGRyZXNzSW5ORkRDQUFsZ29MaXN0KGNvbmZpZy5lbnRyeUdhdGluZ0Fzc2V0c1swXSwgQXNzZXRJRC5mcm9tVWludDY0KHZhbHVlVG9WZXJpZnkpLmNyZWF0b3IpLAoJLy8gICAgICAgICAnc3BlY2lmaWVkIGFzc2V0IG11c3QgYmUgY3JlYXRlZCBieSBjcmVhdG9yIHRoYXQgaXMgb25lIG9mIHRoZSBsaW5rZWQgYWRkcmVzc2VzIGluIGFuIG5mZCcKCS8vICAgICAgICkKCWZyYW1lX2RpZyAtMiAvLyB2YWx1ZVRvVmVyaWZ5OiB1aW50NjQKCWFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCglwb3AKCWZyYW1lX2RpZyAyIC8vIGNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDExMyA4CglidG9pCgljYWxsc3ViIGlzQWRkcmVzc0luTkZEQ0FBbGdvTGlzdAoKCS8vIHNwZWNpZmllZCBhc3NldCBtdXN0IGJlIGNyZWF0ZWQgYnkgY3JlYXRvciB0aGF0IGlzIG9uZSBvZiB0aGUgbGlua2VkIGFkZHJlc3NlcyBpbiBhbiBuZmQKCWFzc2VydAoKKmlmNTFfZW5kOgoJLy8gKmlmNTJfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI4MQoJLy8gdHlwZSA9PT0gR0FUSU5HX1RZUEVfU0VHTUVOVF9PRl9ORkQKCWZyYW1lX2RpZyAwIC8vIHR5cGU6IHVpbnQ4CglpbnRjIDE1IC8vIDQKCT09CglieiAqaWY1Ml9lbmQKCgkvLyAqaWY1Ml9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI4MwoJLy8gdXNlck9mZmVyZWRORkRBcHBJRCA9IHZhbHVlVG9WZXJpZnkKCWZyYW1lX2RpZyAtMiAvLyB2YWx1ZVRvVmVyaWZ5OiB1aW50NjQKCWZyYW1lX2J1cnkgOCAvLyB1c2VyT2ZmZXJlZE5GREFwcElEOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI4NAoJLy8gYXNzZXJ0KHRoaXMuaXNORkRBcHBJRFZhbGlkKHVzZXJPZmZlcmVkTkZEQXBwSUQpLCAncHJvdmlkZWQgTkZEIG11c3QgYmUgdmFsaWQnKQoJZnJhbWVfZGlnIDggLy8gdXNlck9mZmVyZWRORkRBcHBJRDogdWludDY0CgljYWxsc3ViIGlzTkZEQXBwSURWYWxpZAoKCS8vIHByb3ZpZGVkIE5GRCBtdXN0IGJlIHZhbGlkCglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI4NwoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICByYXdCeXRlcyhBcHBJRC5mcm9tVWludDY0KHVzZXJPZmZlcmVkTkZEQXBwSUQpLmdsb2JhbFN0YXRlKCdpLm93bmVyLmEnKSBhcyBBZGRyZXNzKSA9PT0gcmF3Qnl0ZXMoc3Rha2VyKSB8fAoJLy8gICAgICAgICAgIHRoaXMuaXNBZGRyZXNzSW5ORkRDQUFsZ29MaXN0KHVzZXJPZmZlcmVkTkZEQXBwSUQsIHN0YWtlciksCgkvLyAgICAgICAgICJwcm92aWRlZCBuZmQgZm9yIGVudHJ5IGlzbid0IG93bmVkIG9yIGxpbmtlZCB0byB0aGUgc3Rha2VyIgoJLy8gICAgICAgKQoJZnJhbWVfZGlnIDggLy8gdXNlck9mZmVyZWRORkRBcHBJRDogdWludDY0CglieXRlYyAxMCAvLyAgImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KHVzZXJPZmZlcmVkTkZEQXBwSUQpLmdsb2JhbFN0YXRlKCdpLm93bmVyLmEnKQoJYXNzZXJ0CglmcmFtZV9kaWcgMSAvLyBzdGFrZXI6IGFkZHJlc3MKCT09CglkdXAKCWJueiAqc2tpcF9vcjYKCWZyYW1lX2RpZyAxIC8vIHN0YWtlcjogYWRkcmVzcwoJZnJhbWVfZGlnIDggLy8gdXNlck9mZmVyZWRORkRBcHBJRDogdWludDY0CgljYWxsc3ViIGlzQWRkcmVzc0luTkZEQ0FBbGdvTGlzdAoJfHwKCipza2lwX29yNjoKCS8vIHByb3ZpZGVkIG5mZCBmb3IgZW50cnkgaXNuJ3Qgb3duZWQgb3IgbGlua2VkIHRvIHRoZSBzdGFrZXIKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjk0CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgIGJ0b2koQXBwSUQuZnJvbVVpbnQ2NCh1c2VyT2ZmZXJlZE5GREFwcElEKS5nbG9iYWxTdGF0ZSgnaS5wYXJlbnRBcHBJRCcpIGFzIGJ5dGVzKSA9PT0KCS8vICAgICAgICAgICBjb25maWcuZW50cnlHYXRpbmdBc3NldHNbMF0sCgkvLyAgICAgICAgICdzcGVjaWZpZWQgbmZkIG11c3QgYmUgYSBzZWdtZW50IG9mIHRoZSBuZmQgdGhlIHZhbGlkYXRvciBzcGVjaWZpZWQgYXMgYSByZXF1aXJlbWVudCcKCS8vICAgICAgICkKCWZyYW1lX2RpZyA4IC8vIHVzZXJPZmZlcmVkTkZEQXBwSUQ6IHVpbnQ2NAoJcHVzaGJ5dGVzIDB4NjkyZTcwNjE3MjY1NmU3NDQxNzA3MDQ5NDQgLy8gImkucGFyZW50QXBwSUQiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NCh1c2VyT2ZmZXJlZE5GREFwcElEKS5nbG9iYWxTdGF0ZSgnaS5wYXJlbnRBcHBJRCcpCglhc3NlcnQKCWJ0b2kKCWZyYW1lX2RpZyAyIC8vIGNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDExMyA4CglidG9pCgk9PQoKCS8vIHNwZWNpZmllZCBuZmQgbXVzdCBiZSBhIHNlZ21lbnQgb2YgdGhlIG5mZCB0aGUgdmFsaWRhdG9yIHNwZWNpZmllZCBhcyBhIHJlcXVpcmVtZW50Cglhc3NlcnQKCippZjUyX2VuZDoKCXJldHN1YgoKLy8gaXNORkRBcHBJRFZhbGlkKG5mZEFwcElEOiB1aW50NjQpOiBib29sZWFuCi8vCi8vIENoZWNrcyBpZiB0aGUgZ2l2ZW4gTkZEIEFwcCBpZCBpcyB2YWxpZC4gIFVzaW5nIG9ubHkgdGhlIEFwcCBpZCB0aGVyZSdzIG5vIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgbmFtZSAoaWU6IHRoYXQgbmZkIFggaXMgbmFtZSBZKQovLyBTbyBpdCdzIGFzc3VtZWQgZm9yIHRoZSBjYWxsZXIsIHRoZSBhcHAgaWQgYWxvbmUgaXMgZmluZS4gIFRoZSBuYW1lIGlzIGZldGNoZWQgZnJvbSB0aGUgc3BlY2lmaWVkIGFwcCBpZCBhbmQgdGhlIHR3bwovLyB0b2dldGhlciBhcmUgdXNlZCBmb3IgdmFsaWRpdHkgY2hlY2sgY2FsbCB0byB0aGUgbmZkIHJlZ2lzdHJ5LgovLwovLyBAcGFyYW0ge3VpbnQ2NH0gbmZkQXBwSUQgLSBUaGUgTkZEIEFwcCBpZCB0byB2ZXJpZnkuCi8vCi8vIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgTkZEIEFwcCBpZCBpcyB2YWxpZCwgb3RoZXJ3aXNlIGZhbHNlLgppc05GREFwcElEVmFsaWQ6Cglwcm90byAxIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzEzCgkvLyB1c2VyT2ZmZXJlZE5GRE5hbWUgPSBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElEKS5nbG9iYWxTdGF0ZSgnaS5uYW1lJykgYXMgc3RyaW5nCglmcmFtZV9kaWcgLTEgLy8gbmZkQXBwSUQ6IHVpbnQ2NAoJcHVzaGJ5dGVzIDB4NjkyZTZlNjE2ZDY1IC8vICJpLm5hbWUiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJRCkuZ2xvYmFsU3RhdGUoJ2kubmFtZScpCglhc3NlcnQKCWZyYW1lX2J1cnkgMCAvLyB1c2VyT2ZmZXJlZE5GRE5hbWU6IHN0cmluZwoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzE1CgkvLyByZXR1cm4gc2VuZE1ldGhvZENhbGw8W3N0cmluZywgdWludDY0XSwgYm9vbGVhbj4oewoJLy8gICAgICAgYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLm5mZFJlZ2lzdHJ5QXBwSWQpLAoJLy8gICAgICAgbmFtZTogJ2lzVmFsaWROZmRBcHBJZCcsCgkvLyAgICAgICBtZXRob2RBcmdzOiBbdXNlck9mZmVyZWRORkROYW1lLCBuZmRBcHBJRF0sCgkvLyAgICAgfSk7CglpdHhuX2JlZ2luCglpbnRjIDcgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCXB1c2hieXRlcyAweDRiZTIyZmM2IC8vIG1ldGhvZCAiaXNWYWxpZE5mZEFwcElkKHN0cmluZyx1aW50NjQpYm9vbCIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMTYKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQodGhpcy5uZmRSZWdpc3RyeUFwcElkKQoJaW50YyAyOCAvLyBUTVBMX25mZFJlZ2lzdHJ5QXBwSWQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzE4CgkvLyBtZXRob2RBcmdzOiBbdXNlck9mZmVyZWRORkROYW1lLCBuZmRBcHBJRF0KCWZyYW1lX2RpZyAwIC8vIHVzZXJPZmZlcmVkTkZETmFtZTogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtMSAvLyBuZmRBcHBJRDogdWludDY0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gTnVtTG9ncwoJaW50YyAxIC8vIDEKCS0KCWl0eG5hcyBMb2dzCglleHRyYWN0IDQgMAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBpc0FkZHJlc3NJbk5GRENBQWxnb0xpc3QobmZkQXBwSUQ6IHVpbnQ2NCwgYWRkclRvRmluZDogQWRkcmVzcyk6IGJvb2xlYW4KLy8KLy8gQ2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgYWRkcmVzcyBpcyBwcmVzZW50IGluIGFuIE5GRHMgbGlzdCBvZiB2ZXJpZmllZCBhZGRyZXNzZXMuCi8vIFRoZSBORkQgaXMgYXNzdW1lZCB0byBoYXZlIGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXMgb2ZmaWNpYWwuCi8vCi8vIEBwYXJhbSB7dWludDY0fSBuZmRBcHBJRCAtIFRoZSBORkQgYXBwbGljYXRpb24gaWQuCi8vIEBwYXJhbSB7QWRkcmVzc30gYWRkclRvRmluZCAtIFRoZSBhZGRyZXNzIHRvIGZpbmQgaW4gdGhlIHYuY2FBbGdvLjAuYXMgcHJvcGVydHkKLy8gQHJldHVybiB7Ym9vbGVhbn0gLSBgdHJ1ZWAgaWYgdGhlIGFkZHJlc3MgaXMgcHJlc2VudCwgYGZhbHNlYCBvdGhlcndpc2UuCmlzQWRkcmVzc0luTkZEQ0FBbGdvTGlzdDoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CglkdXBuIDIKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTMzMQoJLy8gc2VuZEFwcENhbGwoewoJLy8gICAgICAgYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJRCksCgkvLyAgICAgICBhcHBsaWNhdGlvbkFyZ3M6IFsncmVhZF9wcm9wZXJ0eScsICd2LmNhQWxnby4wLmFzJ10sCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgNyAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzMyCgkvLyBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElEKQoJZnJhbWVfZGlnIC0xIC8vIG5mZEFwcElEOiB1aW50NjQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzMzCgkvLyBhcHBsaWNhdGlvbkFyZ3M6IFsncmVhZF9wcm9wZXJ0eScsICd2LmNhQWxnby4wLmFzJ10KCXB1c2hieXRlcyAweDcyNjU2MTY0NWY3MDcyNmY3MDY1NzI3NDc5IC8vICJyZWFkX3Byb3BlcnR5IgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCXB1c2hieXRlcyAweDc2MmU2MzYxNDE2YzY3NmYyZTMwMmU2MTczIC8vICJ2LmNhQWxnby4wLmFzIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMzUKCS8vIGNhQWxnb0RhdGEgPSB0aGlzLml0eG4ubGFzdExvZwoJaXR4biBMYXN0TG9nCglmcmFtZV9idXJ5IDAgLy8gY2FBbGdvRGF0YTogYnl0ZVtdCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMzYKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgY2FBbGdvRGF0YS5sZW5ndGg7IGkgKz0gMzIpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAxIC8vIGk6IHVpbnQ2NAoKKmZvcl8xMDoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzM2CgkvLyBpIDwgY2FBbGdvRGF0YS5sZW5ndGgKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gY2FBbGdvRGF0YTogYnl0ZVtdCglsZW4KCTwKCWJ6ICpmb3JfMTBfZW5kCgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMzcKCS8vIGFkZHIgPSBleHRyYWN0MyhjYUFsZ29EYXRhLCBpLCAzMikKCWZyYW1lX2RpZyAwIC8vIGNhQWxnb0RhdGE6IGJ5dGVbXQoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnRjIDYgLy8gMzIKCWV4dHJhY3QzCglmcmFtZV9idXJ5IDIgLy8gYWRkcjogYnl0ZVtdCgoJLy8gKmlmNTNfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTMzOAoJLy8gYWRkciAhPT0gcmF3Qnl0ZXMoZ2xvYmFscy56ZXJvQWRkcmVzcykgJiYgYWRkciA9PT0gcmF3Qnl0ZXMoYWRkclRvRmluZCkKCWZyYW1lX2RpZyAyIC8vIGFkZHI6IGJ5dGVbXQoJZ2xvYmFsIFplcm9BZGRyZXNzCgkhPQoJZHVwCglieiAqc2tpcF9hbmQxMQoJZnJhbWVfZGlnIDIgLy8gYWRkcjogYnl0ZVtdCglmcmFtZV9kaWcgLTIgLy8gYWRkclRvRmluZDogQWRkcmVzcwoJPT0KCSYmCgoqc2tpcF9hbmQxMToKCWJ6ICppZjUzX2VuZAoKCS8vICppZjUzX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzM5CgkvLyByZXR1cm4gdHJ1ZTsKCWludGMgMSAvLyAxCgliICppc0FkZHJlc3NJbk5GRENBQWxnb0xpc3QqcmV0dXJuCgoqaWY1M19lbmQ6CgoqZm9yXzEwX2NvbnRpbnVlOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMzYKCS8vIGkgKz0gMzIKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50YyA2IC8vIDMyCgkrCglmcmFtZV9idXJ5IDEgLy8gaTogdWludDY0CgliICpmb3JfMTAKCipmb3JfMTBfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzNDIKCS8vIHJldHVybiBmYWxzZTsKCWludGMgMCAvLyAwCgoqaXNBZGRyZXNzSW5ORkRDQUFsZ29MaXN0KnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDIKCXJldHN1YgoKLy8gYWxnb1NhdHVyYXRpb25MZXZlbCgpOiB1aW50NjQKLy8KLy8gUmV0dXJucyB0aGUgbWF4aW11bSBhbGxvd2VkIHN0YWtlIHBlciB2YWxpZGF0b3IgYmFzZWQgb24gYSBwZXJjZW50YWdlIG9mIGFsbCBjdXJyZW50IG9ubGluZSBzdGFrZSBiZWZvcmUKLy8gdGhlIHZhbGlkYXRvciBpcyBjb25zaWRlcmVkIHNhdHVyYXRlZCAtIHdoZXJlIHJld2FyZHMgYXJlIGRpbWluaXNoZWQuCi8vIE5PVEU6IHRoaXMgZnVuY3Rpb24gaXMgZGVmaW5lZCB0d2ljZSAtIGhlcmUgYW5kIGluIHN0YWtpbmcgcG9vbCBjb250cmFjdC4gIEJvdGggbXVzdCBiZSBpZGVudGljYWwuCmFsZ29TYXR1cmF0aW9uTGV2ZWw6Cglwcm90byAwIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMSAvLyAweAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzUxCgkvLyBvbmxpbmUgPSB0aGlzLmdldEN1cnJlbnRPbmxpbmVTdGFrZSgpCgljYWxsc3ViIGdldEN1cnJlbnRPbmxpbmVTdGFrZQoJZnJhbWVfYnVyeSAwIC8vIG9ubGluZTogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzNTMKCS8vIHJldHVybiB3aWRlUmF0aW8oW29ubGluZSwgTUFYX1ZBTElEQVRPUl9TT0ZUX1BDVF9PRl9PTkxJTkVfMURFQ0lNQUxdLCBbMTAwMF0pOwoJZnJhbWVfZGlnIDAgLy8gb25saW5lOiB1aW50NjQKCXB1c2hpbnQgMTAwCgltdWx3CglpbnRjIDAgLy8gMAoJaW50YyAzMiAvLyAxMDAwCglkaXZtb2R3Cglwb3AKCXBvcAoJc3dhcAoJIQoKCS8vIHdpZGVSYXRpbyBmYWlsZWQKCWFzc2VydAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBtYXhBbGxvd2VkU3Rha2UoKTogdWludDY0Ci8vCi8vIFJldHVybnMgdGhlIE1BWElNVU0gYWxsb3dlZCBzdGFrZSBwZXIgdmFsaWRhdG9yIGJhc2VkIG9uIGEgcGVyY2VudGFnZSBvZiBhbGwgY3VycmVudCBvbmxpbmUgc3Rha2UuCi8vIEFkZGluZyBzdGFrZSBpcyBjb21wbGV0ZWx5IGJsb2NrZWQgYXQgdGhpcyBhbW91bnQuCm1heEFsbG93ZWRTdGFrZToKCXByb3RvIDAgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzNjEKCS8vIG9ubGluZSA9IHRoaXMuZ2V0Q3VycmVudE9ubGluZVN0YWtlKCkKCWNhbGxzdWIgZ2V0Q3VycmVudE9ubGluZVN0YWtlCglmcmFtZV9idXJ5IDAgLy8gb25saW5lOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM2MwoJLy8gcmV0dXJuIHdpZGVSYXRpbyhbb25saW5lLCBNQVhfVkFMSURBVE9SX0hBUkRfUENUX09GX09OTElORV8xREVDSU1BTF0sIFsxMDAwXSk7CglmcmFtZV9kaWcgMCAvLyBvbmxpbmU6IHVpbnQ2NAoJcHVzaGludCAxNTAKCW11bHcKCWludGMgMCAvLyAwCglpbnRjIDMyIC8vIDEwMDAKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCi8vIG1heEFsZ29BbGxvd2VkUGVyUG9vbCgpOiB1aW50NjQKLy8KLy8gUmV0dXJucyB0aGUgTUFYSU1VTSBhbGxvd2VkIHN0YWtlIHBlciBwb29sIGFuZCBzdGlsbCByZWNlaXZlIGluY2VudGl2ZXMgLSB3ZSdsbCB0cmVhdCB0aGlzIGFzIHRoZSAnbWF4IHBlciBwb29sJwptYXhBbGdvQWxsb3dlZFBlclBvb2w6Cglwcm90byAwIDEKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM3MAoJLy8gcmV0dXJuIGdsb2JhbHMucGF5b3V0c01heEJhbGFuY2U7CglnbG9iYWwgUGF5b3V0c01heEJhbGFuY2UKCXJldHN1YgoKLy8gZ2V0Q3VycmVudE9ubGluZVN0YWtlKCk6IHVpbnQ2NApnZXRDdXJyZW50T25saW5lU3Rha2U6Cglwcm90byAwIDEKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM3NAoJLy8gcmV0dXJuIG9ubGluZVN0YWtlKCk7CglvbmxpbmVfc3Rha2UKCXJldHN1YgoKLy8gbWluQmFsYW5jZUZvckFjY291bnQoY29udHJhY3RzOiB1aW50NjQsIGV4dHJhUGFnZXM6IHVpbnQ2NCwgYXNzZXRzOiB1aW50NjQsIGxvY2FsSW50czogdWludDY0LCBsb2NhbEJ5dGVzOiB1aW50NjQsIGdsb2JhbEludHM6IHVpbnQ2NCwgZ2xvYmFsQnl0ZXM6IHVpbnQ2NCk6IHVpbnQ2NAptaW5CYWxhbmNlRm9yQWNjb3VudDoKCXByb3RvIDcgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAxIC8vIDB4CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzODYKCS8vIG1pbkJhbCA9IEFMR09SQU5EX0FDQ09VTlRfTUlOX0JBTEFOQ0UKCWludGMgMTYgLy8gMTAwMDAwCglmcmFtZV9idXJ5IDAgLy8gbWluQmFsOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM4NwoJLy8gbWluQmFsICs9IGNvbnRyYWN0cyAqIEFQUExJQ0FUSU9OX0JBU0VfRkVFCglmcmFtZV9kaWcgMCAvLyBtaW5CYWw6IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIGNvbnRyYWN0czogdWludDY0CglpbnRjIDE2IC8vIDEwMDAwMAoJKgoJKwoJZnJhbWVfYnVyeSAwIC8vIG1pbkJhbDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzODgKCS8vIG1pbkJhbCArPSBleHRyYVBhZ2VzICogQVBQTElDQVRJT05fQkFTRV9GRUUKCWZyYW1lX2RpZyAwIC8vIG1pbkJhbDogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gZXh0cmFQYWdlczogdWludDY0CglpbnRjIDE2IC8vIDEwMDAwMAoJKgoJKwoJZnJhbWVfYnVyeSAwIC8vIG1pbkJhbDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzODkKCS8vIG1pbkJhbCArPSBhc3NldHMgKiBBU1NFVF9IT0xESU5HX0ZFRQoJZnJhbWVfZGlnIDAgLy8gbWluQmFsOiB1aW50NjQKCWZyYW1lX2RpZyAtMyAvLyBhc3NldHM6IHVpbnQ2NAoJaW50YyAxNiAvLyAxMDAwMDAKCSoKCSsKCWZyYW1lX2J1cnkgMCAvLyBtaW5CYWw6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzkwCgkvLyBtaW5CYWwgKz0gbG9jYWxJbnRzICogU1NDX1ZBTFVFX1VJTlQKCWZyYW1lX2RpZyAwIC8vIG1pbkJhbDogdWludDY0CglmcmFtZV9kaWcgLTQgLy8gbG9jYWxJbnRzOiB1aW50NjQKCWludGMgMzMgLy8gMjg1MDAKCSoKCSsKCWZyYW1lX2J1cnkgMCAvLyBtaW5CYWw6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzkxCgkvLyBtaW5CYWwgKz0gZ2xvYmFsSW50cyAqIFNTQ19WQUxVRV9VSU5UCglmcmFtZV9kaWcgMCAvLyBtaW5CYWw6IHVpbnQ2NAoJZnJhbWVfZGlnIC02IC8vIGdsb2JhbEludHM6IHVpbnQ2NAoJaW50YyAzMyAvLyAyODUwMAoJKgoJKwoJZnJhbWVfYnVyeSAwIC8vIG1pbkJhbDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzOTIKCS8vIG1pbkJhbCArPSBsb2NhbEJ5dGVzICogU1NDX1ZBTFVFX0JZVEVTCglmcmFtZV9kaWcgMCAvLyBtaW5CYWw6IHVpbnQ2NAoJZnJhbWVfZGlnIC01IC8vIGxvY2FsQnl0ZXM6IHVpbnQ2NAoJaW50YyAzNCAvLyA1MDAwMAoJKgoJKwoJZnJhbWVfYnVyeSAwIC8vIG1pbkJhbDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzOTMKCS8vIG1pbkJhbCArPSBnbG9iYWxCeXRlcyAqIFNTQ19WQUxVRV9CWVRFUwoJZnJhbWVfZGlnIDAgLy8gbWluQmFsOiB1aW50NjQKCWZyYW1lX2RpZyAtNyAvLyBnbG9iYWxCeXRlczogdWludDY0CglpbnRjIDM0IC8vIDUwMDAwCgkqCgkrCglmcmFtZV9idXJ5IDAgLy8gbWluQmFsOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM5NAoJLy8gcmV0dXJuIG1pbkJhbDsKCWZyYW1lX2RpZyAwIC8vIG1pbkJhbDogdWludDY0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCi8vIGNvc3RGb3JCb3hTdG9yYWdlKHRvdGFsTnVtQnl0ZXM6IHVpbnQ2NCk6IHVpbnQ2NApjb3N0Rm9yQm94U3RvcmFnZToKCXByb3RvIDEgMQoKCS8vIGV4YW1wbGVzL3JldGkvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxNDAxCgkvLyByZXR1cm4gU0NCT1hfUEVSQk9YICsgdG90YWxOdW1CeXRlcyAqIFNDQk9YX1BFUkJZVEU7CglwdXNoaW50IDI1MDAKCWZyYW1lX2RpZyAtMSAvLyB0b3RhbE51bUJ5dGVzOiB1aW50NjQKCXB1c2hpbnQgNDAwCgkqCgkrCglyZXRzdWIKCipjcmVhdGVfTm9PcDoKCXB1c2hieXRlcyAweGI4NDQ3YjM2IC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNyZWF0ZSBOb09wCgllcnIKCipjYWxsX05vT3A6CglwdXNoYnl0ZXMgMHgxYjVlODJjNiAvLyBtZXRob2QgImluaXRTdGFraW5nQ29udHJhY3QodWludDY0KXZvaWQiCglwdXNoYnl0ZXMgMHg3OTQ3MmQ4MyAvLyBtZXRob2QgImxvYWRTdGFraW5nQ29udHJhY3REYXRhKHVpbnQ2NCxieXRlW10pdm9pZCIKCXB1c2hieXRlcyAweDVmN2FjZmQ5IC8vIG1ldGhvZCAiZmluYWxpemVTdGFraW5nQ29udHJhY3QoKXZvaWQiCglwdXNoYnl0ZXMgMHgzMTcyY2E5ZCAvLyBtZXRob2QgImdhcygpdm9pZCIKCXB1c2hieXRlcyAweDhhODcxNDJkIC8vIG1ldGhvZCAiZ2V0TWJyQW1vdW50cygpKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkiCglwdXNoYnl0ZXMgMHhkMTM2NmNjMyAvLyBtZXRob2QgImdldFByb3RvY29sQ29uc3RyYWludHMoKSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIKCXB1c2hieXRlcyAweDNiMDQ1YzVjIC8vIG1ldGhvZCAiZ2V0TnVtVmFsaWRhdG9ycygpdWludDY0IgoJcHVzaGJ5dGVzIDB4NzVhZmY2MWQgLy8gbWV0aG9kICJnZXRWYWxpZGF0b3JDb25maWcodWludDY0KSh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KSIKCXB1c2hieXRlcyAweDFmMmYwMTA5IC8vIG1ldGhvZCAiZ2V0VmFsaWRhdG9yU3RhdGUodWludDY0KSh1aW50MTYsdWludDY0LHVpbnQ2NCx1aW50NjQpIgoJcHVzaGJ5dGVzIDB4MmZhMjJjNGIgLy8gbWV0aG9kICJnZXRWYWxpZGF0b3JPd25lckFuZE1hbmFnZXIodWludDY0KShhZGRyZXNzLGFkZHJlc3MpIgoJcHVzaGJ5dGVzIDB4OTEwZTk0YWMgLy8gbWV0aG9kICJnZXRQb29scyh1aW50NjQpKHVpbnQ2NCx1aW50MTYsdWludDY0KVtdIgoJcHVzaGJ5dGVzIDB4NTcyNzY3ZDEgLy8gbWV0aG9kICJnZXRQb29sQXBwSWQodWludDY0LHVpbnQ2NCl1aW50NjQiCglwdXNoYnl0ZXMgMHg5YjUwNGFhZiAvLyBtZXRob2QgImdldFBvb2xJbmZvKCh1aW50NjQsdWludDY0LHVpbnQ2NCkpKHVpbnQ2NCx1aW50MTYsdWludDY0KSIKCXB1c2hieXRlcyAweGZiYzYzMTc4IC8vIG1ldGhvZCAiZ2V0Q3VyTWF4U3Rha2VQZXJQb29sKHVpbnQ2NCl1aW50NjQiCglwdXNoYnl0ZXMgMHgyNDQ5OGNmNCAvLyBtZXRob2QgImRvZXNTdGFrZXJOZWVkVG9QYXlNQlIoYWRkcmVzcylib29sIgoJcHVzaGJ5dGVzIDB4Zjg0NmRkN2EgLy8gbWV0aG9kICJnZXRTdGFrZWRQb29sc0ZvckFjY291bnQoYWRkcmVzcykodWludDY0LHVpbnQ2NCx1aW50NjQpW10iCglwdXNoYnl0ZXMgMHg4MzA1MDUwMSAvLyBtZXRob2QgImdldFRva2VuUGF5b3V0UmF0aW8odWludDY0KSh1aW50NjRbMjRdLHVpbnQ2NCkiCglwdXNoYnl0ZXMgMHg3YmJiNmM4ZCAvLyBtZXRob2QgImdldE5vZGVQb29sQXNzaWdubWVudHModWludDY0KSgodWludDY0WzNdKVs4XSkiCglwdXNoYnl0ZXMgMHhmODM5NDE0YSAvLyBtZXRob2QgImdldE5GRFJlZ2lzdHJ5SUQoKXVpbnQ2NCIKCXB1c2hieXRlcyAweDBjMzE3Y2ZiIC8vIG1ldGhvZCAiYWRkVmFsaWRhdG9yKHBheSxzdHJpbmcsKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpKXVpbnQ2NCIKCXB1c2hieXRlcyAweDNlMjg4OTcyIC8vIG1ldGhvZCAiY2hhbmdlVmFsaWRhdG9yTWFuYWdlcih1aW50NjQsYWRkcmVzcyl2b2lkIgoJcHVzaGJ5dGVzIDB4ZGQ1ZmFhZGEgLy8gbWV0aG9kICJjaGFuZ2VWYWxpZGF0b3JTdW5zZXRJbmZvKHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCglwdXNoYnl0ZXMgMHgxOGFhYzdhNyAvLyBtZXRob2QgImNoYW5nZVZhbGlkYXRvck5GRCh1aW50NjQsdWludDY0LHN0cmluZyl2b2lkIgoJcHVzaGJ5dGVzIDB4Zjk5ZWY1NGQgLy8gbWV0aG9kICJjaGFuZ2VWYWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyh1aW50NjQsYWRkcmVzcyl2b2lkIgoJcHVzaGJ5dGVzIDB4MTA4MDlkNGQgLy8gbWV0aG9kICJjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvKHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0KXZvaWQiCglwdXNoYnl0ZXMgMHhlNzc4ZGQ1YSAvLyBtZXRob2QgImFkZFBvb2wocGF5LHVpbnQ2NCx1aW50NjQpKHVpbnQ2NCx1aW50NjQsdWludDY0KSIKCXB1c2hieXRlcyAweGJmNTI1OWQwIC8vIG1ldGhvZCAiYWRkU3Rha2UocGF5LHVpbnQ2NCx1aW50NjQpKHVpbnQ2NCx1aW50NjQsdWludDY0KSIKCXB1c2hieXRlcyAweDRkZjhkODZlIC8vIG1ldGhvZCAic2V0VG9rZW5QYXlvdXRSYXRpbyh1aW50NjQpKHVpbnQ2NFsyNF0sdWludDY0KSIKCXB1c2hieXRlcyAweDQxOGZjZWZjIC8vIG1ldGhvZCAic3Rha2VVcGRhdGVkVmlhUmV3YXJkcygodWludDY0LHVpbnQ2NCx1aW50NjQpLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIgoJcHVzaGJ5dGVzIDB4YTJkYzUxYjUgLy8gbWV0aG9kICJzdGFrZVJlbW92ZWQoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYm9vbCl2b2lkIgoJcHVzaGJ5dGVzIDB4Mjg3M2Y1MDQgLy8gbWV0aG9kICJmaW5kUG9vbEZvclN0YWtlcih1aW50NjQsYWRkcmVzcyx1aW50NjQpKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYm9vbCxib29sKSIKCXB1c2hieXRlcyAweDA1NDdmNGZlIC8vIG1ldGhvZCAibW92ZVBvb2xUb05vZGUodWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIKCXB1c2hieXRlcyAweGNiNjY4MzU4IC8vIG1ldGhvZCAiZW1wdHlUb2tlblJld2FyZHModWludDY0LGFkZHJlc3MpdWludDY0IgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9pbml0U3Rha2luZ0NvbnRyYWN0ICphYmlfcm91dGVfbG9hZFN0YWtpbmdDb250cmFjdERhdGEgKmFiaV9yb3V0ZV9maW5hbGl6ZVN0YWtpbmdDb250cmFjdCAqYWJpX3JvdXRlX2dhcyAqYWJpX3JvdXRlX2dldE1ickFtb3VudHMgKmFiaV9yb3V0ZV9nZXRQcm90b2NvbENvbnN0cmFpbnRzICphYmlfcm91dGVfZ2V0TnVtVmFsaWRhdG9ycyAqYWJpX3JvdXRlX2dldFZhbGlkYXRvckNvbmZpZyAqYWJpX3JvdXRlX2dldFZhbGlkYXRvclN0YXRlICphYmlfcm91dGVfZ2V0VmFsaWRhdG9yT3duZXJBbmRNYW5hZ2VyICphYmlfcm91dGVfZ2V0UG9vbHMgKmFiaV9yb3V0ZV9nZXRQb29sQXBwSWQgKmFiaV9yb3V0ZV9nZXRQb29sSW5mbyAqYWJpX3JvdXRlX2dldEN1ck1heFN0YWtlUGVyUG9vbCAqYWJpX3JvdXRlX2RvZXNTdGFrZXJOZWVkVG9QYXlNQlIgKmFiaV9yb3V0ZV9nZXRTdGFrZWRQb29sc0ZvckFjY291bnQgKmFiaV9yb3V0ZV9nZXRUb2tlblBheW91dFJhdGlvICphYmlfcm91dGVfZ2V0Tm9kZVBvb2xBc3NpZ25tZW50cyAqYWJpX3JvdXRlX2dldE5GRFJlZ2lzdHJ5SUQgKmFiaV9yb3V0ZV9hZGRWYWxpZGF0b3IgKmFiaV9yb3V0ZV9jaGFuZ2VWYWxpZGF0b3JNYW5hZ2VyICphYmlfcm91dGVfY2hhbmdlVmFsaWRhdG9yU3Vuc2V0SW5mbyAqYWJpX3JvdXRlX2NoYW5nZVZhbGlkYXRvck5GRCAqYWJpX3JvdXRlX2NoYW5nZVZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzICphYmlfcm91dGVfY2hhbmdlVmFsaWRhdG9yUmV3YXJkSW5mbyAqYWJpX3JvdXRlX2FkZFBvb2wgKmFiaV9yb3V0ZV9hZGRTdGFrZSAqYWJpX3JvdXRlX3NldFRva2VuUGF5b3V0UmF0aW8gKmFiaV9yb3V0ZV9zdGFrZVVwZGF0ZWRWaWFSZXdhcmRzICphYmlfcm91dGVfc3Rha2VSZW1vdmVkICphYmlfcm91dGVfZmluZFBvb2xGb3JTdGFrZXIgKmFiaV9yb3V0ZV9tb3ZlUG9vbFRvTm9kZSAqYWJpX3JvdXRlX2VtcHR5VG9rZW5SZXdhcmRzCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNhbGwgTm9PcAoJZXJy",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEx",
  },
  "state": {
    "global": {
      "num_byte_slices": 1,
      "num_uints": 3,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;

exports[`Examples StakingPool Artifacts Generates TEAL 1`] = `
"#pragma version 11
intcblock 0 1 6 64 32 16 128 200 5 1_000_000 300 1000 4 2_100_000 8 100000 400 30857 2 40 48 TMPL_nfdRegistryAppId
bytecblock 0x 0x63726561746f72417070 0x7374616b657273 0x76616c696461746f724964 0x706f6f6c4964 0x0a8101 0x7374616b6564 0x726f756e6473506572446179 0x7374616b65416363756d756c61746f72 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0x0000000000000000 0x62696e526f756e645374617274 0x726577617264416363756d756c61746f72 0x6e756d5374616b657273 0x6c6173745061796f7574 0x75aff61d 0x00000000000000000000000000000000 0x00000000000000000000000000000064 0x6d696e456e7472795374616b65 0x65706f63684e756d626572 0x65776d61 0x151f7c75 0xa2dc51b5 0x572767d1 0x4df8d86e 0x0c2245e1 0x00

// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 2 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(uint64,uint64,uint64,uint64)void
*abi_route_createApplication:
	// minEntryStake: uint64
	txna ApplicationArgs 4
	btoi

	// poolId: uint64
	txna ApplicationArgs 3
	btoi

	// validatorId: uint64
	txna ApplicationArgs 2
	btoi

	// creatingContractId: uint64
	txna ApplicationArgs 1
	btoi

	// execute createApplication(uint64,uint64,uint64,uint64)void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(creatingContractId: AppID, validatorId: uint64, poolId: uint64, minEntryStake: uint64): void
//
// Initialize the staking pool w/ owner and manager, but can only be created by the validator contract.
// @param {uint64} creatingContractId - id of contract that constructed us - the validator application (single global instance)
// @param {uint64} validatorId - id of validator we're a staking pool of
// @param {uint64} poolId - which pool id are we
// @param {uint64} minEntryStake - minimum amount to be in pool, but also minimum amount balance can't go below (without removing all!)
createApplication:
	proto 4 0

	// *if0_condition
	// examples/reti/stakingPool.algo.ts:102
	// creatingContractId === AppID.fromUint64(0)
	frame_dig -1 // creatingContractId: AppID
	intc 0 // 0
	==
	bz *if0_else

	// *if0_consequent
	// examples/reti/stakingPool.algo.ts:104
	// assert(validatorId === 0)
	frame_dig -2 // validatorId: uint64
	intc 0 // 0
	==
	assert

	// examples/reti/stakingPool.algo.ts:105
	// assert(poolId === 0)
	frame_dig -3 // poolId: uint64
	intc 0 // 0
	==
	assert
	b *if0_end

*if0_else:
	// examples/reti/stakingPool.algo.ts:107
	// assert(validatorId !== 0)
	frame_dig -2 // validatorId: uint64
	intc 0 // 0
	!=
	assert

	// examples/reti/stakingPool.algo.ts:108
	// assert(poolId !== 0)
	frame_dig -3 // poolId: uint64
	intc 0 // 0
	!=
	assert

*if0_end:
	// examples/reti/stakingPool.algo.ts:110
	// assert(minEntryStake >= MIN_ALGO_STAKE_PER_POOL, 'staking pool must have minimum entry of 1 algo')
	frame_dig -4 // minEntryStake: uint64
	pushint 1000000
	>=

	// staking pool must have minimum entry of 1 algo
	assert

	// examples/reti/stakingPool.algo.ts:111
	// this.creatingValidatorContractAppId.value = creatingContractId
	bytec 1 //  "creatorApp"
	frame_dig -1 // creatingContractId: AppID
	app_global_put

	// examples/reti/stakingPool.algo.ts:112
	// this.validatorId.value = validatorId
	bytec 3 //  "validatorId"
	frame_dig -2 // validatorId: uint64
	app_global_put

	// examples/reti/stakingPool.algo.ts:113
	// this.poolId.value = poolId
	bytec 4 //  "poolId"
	frame_dig -3 // poolId: uint64
	app_global_put

	// examples/reti/stakingPool.algo.ts:114
	// this.numStakers.value = 0
	bytec 13 //  "numStakers"
	intc 0 // 0
	app_global_put

	// examples/reti/stakingPool.algo.ts:115
	// this.totalAlgoStaked.value = 0
	bytec 6 //  "staked"
	intc 0 // 0
	app_global_put

	// examples/reti/stakingPool.algo.ts:116
	// this.minEntryStake.value = minEntryStake
	bytec 18 //  "minEntryStake"
	frame_dig -4 // minEntryStake: uint64
	app_global_put

	// examples/reti/stakingPool.algo.ts:117
	// this.lastPayout.value = globals.round
	bytec 14 //  "lastPayout"
	global Round
	app_global_put

	// examples/reti/stakingPool.algo.ts:118
	// this.epochNumber.value = 0
	bytec 19 //  "epochNumber"
	intc 0 // 0
	app_global_put

	// examples/reti/stakingPool.algo.ts:120
	// this.setRoundsPerDay()
	callsub setRoundsPerDay

	// examples/reti/stakingPool.algo.ts:121
	// this.binRoundStart.value = globals.round - (globals.round % this.roundsPerDay.value)
	bytec 11 //  "binRoundStart"
	global Round
	global Round
	bytec 7 //  "roundsPerDay"
	app_global_get
	%
	-
	app_global_put

	// examples/reti/stakingPool.algo.ts:122
	// this.stakeAccumulator.value = 0 as uint128
	bytec 8 //  "stakeAccumulator"
	bytec 16 // 0x00000000000000000000000000000000
	app_global_put

	// examples/reti/stakingPool.algo.ts:123
	// this.rewardAccumulator.value = 0
	bytec 12 //  "rewardAccumulator"
	intc 0 // 0
	app_global_put

	// examples/reti/stakingPool.algo.ts:124
	// this.weightedMovingAverage.value = 0 as uint128
	bytec 20 //  "ewma"
	bytec 16 // 0x00000000000000000000000000000000
	app_global_put
	retsub

// gas()void
*abi_route_gas:
	// execute gas()void
	callsub gas
	intc 1 // 1
	return

// gas(): void
//
// gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
gas:
	proto 0 0
	retsub

// costForBoxStorage(totalNumBytes: uint64): uint64
costForBoxStorage:
	proto 1 1

	// examples/reti/stakingPool.algo.ts:136
	// return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE;
	pushint 2500
	frame_dig -1 // totalNumBytes: uint64
	intc 16 // 400
	*
	+
	retsub

// initStorage(pay)void
*abi_route_initStorage:
	// mbrPayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 0 (mbrPayment) for initStorage must be a pay transaction
	assert

	// execute initStorage(pay)void
	callsub initStorage
	intc 1 // 1
	return

// initStorage(mbrPayment: PayTxn): void
//
// Called after we're created and then funded, so we can create our large stakers ledger storage
// Caller has to get MBR amounts from ValidatorRegistry to know how much to fund us to cover the box storage cost
// If this is pool 1 AND the validator has specified a reward token, opt-in to that token
// so that the validator can seed the pool with future rewards of that token.
// @param mbrPayment payment from caller which covers mbr increase of new staking pools' storage
initStorage:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// examples/reti/stakingPool.algo.ts:147
	// assert(!this.stakers.exists, 'staking pool already initialized')
	bytec 2 //  "stakers"
	box_len
	swap
	pop
	!

	// staking pool already initialized
	assert

	// examples/reti/stakingPool.algo.ts:150
	// validatorConfig = sendMethodCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
	//       applicationID: this.creatingValidatorContractAppId.value,
	//       methodArgs: [this.validatorId.value],
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 15 //  method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:151
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:152
	// methodArgs: [this.validatorId.value]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:154
	// isTokenEligible = validatorConfig.rewardTokenId !== 0
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 153 8
	btoi
	intc 0 // 0
	!=
	frame_bury 1 // isTokenEligible: bool

	// examples/reti/stakingPool.algo.ts:155
	// extraMBR = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
	frame_dig 1 // isTokenEligible: bool
	dup
	bz *skip_and0
	bytec 4 //  "poolId"
	app_global_get
	intc 1 // 1
	==
	&&

*skip_and0:
	bz *ternary0_false
	intc 15 // 100000
	b *ternary0_end

*ternary0_false:
	intc 0 // 0

*ternary0_end:
	frame_bury 2 // extraMBR: uint64

	// examples/reti/stakingPool.algo.ts:156
	// PoolInitMbr =
	//       ALGORAND_ACCOUNT_MIN_BALANCE +
	//       extraMBR +
	//       this.costForBoxStorage(7 /* 'stakers' name */ + len<StakedInfo>() * MAX_STAKERS_PER_POOL)
	intc 15 // 100000
	frame_dig 2 // extraMBR: uint64
	+
	pushint 12807
	callsub costForBoxStorage
	+
	frame_bury 3 // PoolInitMbr: uint64

	// examples/reti/stakingPool.algo.ts:162
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: PoolInitMbr })
	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	frame_dig 3 // PoolInitMbr: uint64
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"PoolInitMbr"}
	assert

	// examples/reti/stakingPool.algo.ts:163
	// this.stakers.create()
	bytec 2 //  "stakers"
	pushint 12800
	box_create
	pop

	// *if1_condition
	// examples/reti/stakingPool.algo.ts:165
	// isTokenEligible && this.poolId.value === 1
	frame_dig 1 // isTokenEligible: bool
	dup
	bz *skip_and1
	bytec 4 //  "poolId"
	app_global_get
	intc 1 // 1
	==
	&&

*skip_and1:
	bz *if1_end

	// *if1_consequent
	// examples/reti/stakingPool.algo.ts:167
	// sendAssetTransfer({
	//         xferAsset: AssetID.fromUint64(validatorConfig.rewardTokenId),
	//         assetReceiver: this.app.address,
	//         assetAmount: 0,
	//       })
	itxn_begin
	intc 12 //  axfer
	itxn_field TypeEnum

	// examples/reti/stakingPool.algo.ts:168
	// xferAsset: AssetID.fromUint64(validatorConfig.rewardTokenId)
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 153 8
	btoi
	itxn_field XferAsset

	// examples/reti/stakingPool.algo.ts:169
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// examples/reti/stakingPool.algo.ts:170
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if1_end:
	retsub

// addStake(pay,address)uint64
*abi_route_addStake:
	// The ABI return prefix
	bytec 21 // 0x151f7c75

	// staker: address
	txna ApplicationArgs 1
	dup
	len
	intc 4 // 32
	==

	// argument 0 (staker) for addStake must be a address
	assert

	// stakedAmountPayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 1 (stakedAmountPayment) for addStake must be a pay transaction
	assert

	// execute addStake(pay,address)uint64
	callsub addStake
	itob
	concat
	log
	intc 1 // 1
	return

// addStake(stakedAmountPayment: PayTxn, staker: Address): uint64
//
// Adds stake to the given account.
// Can ONLY be called by the validator contract that created us
// Must receive payment from the validator contract for amount being staked.
//
// @param {PayTxn} stakedAmountPayment prior payment coming from validator contract to us on behalf of staker.
// @param {Address} staker - The account adding new stake
// @throws {Error} - Throws an error if the staking pool is full.
// @returns {uint64} new 'entry round' round number of stake add
addStake:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// examples/reti/stakingPool.algo.ts:186
	// assert(this.stakers.exists, 'staking pool must be initialized first')
	bytec 2 //  "stakers"
	box_len
	swap
	pop

	// staking pool must be initialized first
	assert

	// examples/reti/stakingPool.algo.ts:189
	// assert(
	//       this.txn.sender === this.creatingValidatorContractAppId.value.address,
	//       'stake can only be added via the validator contract'
	//     )
	txn Sender
	bytec 1 //  "creatorApp"
	app_global_get
	app_params_get AppAddress
	pop
	==

	// stake can only be added via the validator contract
	assert

	// examples/reti/stakingPool.algo.ts:193
	// assert(staker !== globals.zeroAddress)
	frame_dig -2 // staker: Address
	global ZeroAddress
	!=
	assert

	// examples/reti/stakingPool.algo.ts:196
	// this.checkIfBinClosed()
	callsub checkIfBinClosed

	// examples/reti/stakingPool.algo.ts:200
	// verifyPayTxn(stakedAmountPayment, {
	//       sender: this.creatingValidatorContractAppId.value.address,
	//       receiver: this.app.address,
	//       amount: stakedAmountPayment.amount,
	//     })
	// verify sender
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Sender
	bytec 1 //  "creatorApp"
	app_global_get
	app_params_get AppAddress
	pop
	==

	// transaction verification failed: {"txn":"stakedAmountPayment","field":"sender","expected":"this.creatingValidatorContractAppId.value.address"}
	assert

	// verify receiver
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"stakedAmountPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	==

	// transaction verification failed: {"txn":"stakedAmountPayment","field":"amount","expected":"stakedAmountPayment.amount"}
	assert

	// examples/reti/stakingPool.algo.ts:209
	// entryRound = globals.round + ALGORAND_STAKING_BLOCK_DELAY
	global Round
	pushint 320
	+
	frame_bury 0 // entryRound: uint64

	// examples/reti/stakingPool.algo.ts:210
	// firstEmpty = 0
	intc 0 // 0
	frame_bury 1 // firstEmpty: uint64

	// examples/reti/stakingPool.algo.ts:212
	// this.totalAlgoStaked.value += stakedAmountPayment.amount
	bytec 6 //  "staked"
	app_global_get
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	+
	bytec 6 //  "staked"
	swap
	app_global_put

	// examples/reti/stakingPool.algo.ts:214
	// roundsLeftInBin = this.binRoundStart.value + this.roundsPerDay.value - globals.round
	bytec 11 //  "binRoundStart"
	app_global_get
	bytec 7 //  "roundsPerDay"
	app_global_get
	+
	global Round
	-
	frame_bury 2 // roundsLeftInBin: uint64

	// examples/reti/stakingPool.algo.ts:215
	// this.stakeAccumulator.value =
	//       this.stakeAccumulator.value + (stakedAmountPayment.amount as uint128) * (roundsLeftInBin as uint128)
	bytec 8 //  "stakeAccumulator"
	dup
	app_global_get
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	itob
	frame_dig 2 // roundsLeftInBin: uint64
	itob
	b*
	b+
	dup
	bitlen
	intc 6 // 128
	<=

	// this.stakeAccumulator.value + (stakedAmountPayment.amount as uint128) * (roundsLeftInBin as uint128) overflowed 128 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 5 // 16
	-
	swap
	substring3
	app_global_put

	// examples/reti/stakingPool.algo.ts:219
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	intc 0 // 0
	frame_bury 3 // i: uint64

*for_0:
	// examples/reti/stakingPool.algo.ts:219
	// i < this.stakers.value.length
	frame_dig 3 // i: uint64
	intc 7 // 200
	<
	bz *for_0_end

	// *if2_condition
	// examples/reti/stakingPool.algo.ts:220
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 10 // 300
	<
	bz *if2_end

	// *if2_consequent
	// examples/reti/stakingPool.algo.ts:221
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if2_end:
	// examples/reti/stakingPool.algo.ts:223
	// cmpStaker = clone(this.stakers.value[i])
	frame_dig 3 // i: uint64
	intc 3 // 64
	* // acc * typeLength
	intc 3 // 64
	bytec 2 //  "stakers"
	cover 2
	box_extract
	frame_bury 4 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// *if3_condition
	// examples/reti/stakingPool.algo.ts:224
	// cmpStaker.account === staker
	frame_dig 4 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 0 32
	frame_dig -2 // staker: Address
	==
	bz *if3_end

	// *if3_consequent
	// examples/reti/stakingPool.algo.ts:226
	// cmpStaker.balance += stakedAmountPayment.amount
	frame_dig 4 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	intc 4 //  headOffset
	frame_dig 4 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	+
	itob
	replace3
	frame_bury 4 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:227
	// cmpStaker.entryRound = entryRound
	frame_dig 4 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	pushint 56 // headOffset
	frame_dig 0 // entryRound: uint64
	itob
	replace3
	frame_bury 4 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:230
	// this.stakers.value[i] = cmpStaker
	frame_dig 3 // i: uint64
	intc 3 // 64
	* // acc * typeLength
	frame_dig 4 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	bytec 2 //  "stakers"
	cover 2
	box_replace

	// examples/reti/stakingPool.algo.ts:232
	// return entryRound;
	frame_dig 0 // entryRound: uint64
	b *addStake*return

*if3_end:
	// *if4_condition
	// examples/reti/stakingPool.algo.ts:234
	// firstEmpty === 0 && cmpStaker.account === globals.zeroAddress
	frame_dig 1 // firstEmpty: uint64
	intc 0 // 0
	==
	dup
	bz *skip_and2
	frame_dig 4 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 0 32
	global ZeroAddress
	==
	&&

*skip_and2:
	bz *if4_end

	// *if4_consequent
	// examples/reti/stakingPool.algo.ts:235
	// firstEmpty = i + 1
	frame_dig 3 // i: uint64
	intc 1 // 1
	+
	frame_bury 1 // firstEmpty: uint64

*if4_end:

*for_0_continue:
	// examples/reti/stakingPool.algo.ts:219
	// i += 1
	frame_dig 3 // i: uint64
	intc 1 // 1
	+
	frame_bury 3 // i: uint64
	b *for_0

*for_0_end:
	// *if5_condition
	// examples/reti/stakingPool.algo.ts:239
	// firstEmpty === 0
	frame_dig 1 // firstEmpty: uint64
	intc 0 // 0
	==
	bz *if5_end

	// *if5_consequent
	// Staking pool full
	err

*if5_end:
	// examples/reti/stakingPool.algo.ts:246
	// assert(stakedAmountPayment.amount >= this.minEntryStake.value, 'must stake at least the minimum for this pool')
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	bytec 18 //  "minEntryStake"
	app_global_get
	>=

	// must stake at least the minimum for this pool
	assert

	// examples/reti/stakingPool.algo.ts:248
	// assert(this.stakers.value[firstEmpty - 1].account === globals.zeroAddress)
	frame_dig 1 // firstEmpty: uint64
	intc 1 // 1
	-
	intc 3 // 64
	* // acc * typeLength
	intc 0 // 0
	+
	intc 4 // 32
	bytec 2 //  "stakers"
	cover 2
	box_extract
	global ZeroAddress
	==
	assert

	// examples/reti/stakingPool.algo.ts:249
	// this.stakers.value[firstEmpty - 1] = {
	//       account: staker,
	//       balance: stakedAmountPayment.amount,
	//       totalRewarded: 0,
	//       rewardTokenBalance: 0,
	//       entryRound: entryRound,
	//     }
	frame_dig 1 // firstEmpty: uint64
	intc 1 // 1
	-
	intc 3 // 64
	* // acc * typeLength
	frame_dig -2 // staker: Address
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	itob
	concat
	bytec 10 // 0x0000000000000000
	concat
	bytec 10 // 0x0000000000000000
	concat
	frame_dig 0 // entryRound: uint64
	itob
	concat
	bytec 2 //  "stakers"
	cover 2
	box_replace

	// examples/reti/stakingPool.algo.ts:256
	// this.numStakers.value += 1
	bytec 13 //  "numStakers"
	app_global_get
	intc 1 // 1
	+
	bytec 13 //  "numStakers"
	swap
	app_global_put

	// examples/reti/stakingPool.algo.ts:257
	// return entryRound;
	frame_dig 0 // entryRound: uint64

*addStake*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// removeStake(address,uint64)void
*abi_route_removeStake:
	// amountToUnstake: uint64
	txna ApplicationArgs 2
	btoi

	// staker: address
	txna ApplicationArgs 1
	dup
	len
	intc 4 // 32
	==

	// argument 1 (staker) for removeStake must be a address
	assert

	// execute removeStake(address,uint64)void
	callsub removeStake
	intc 1 // 1
	return

// removeStake(staker: Address, amountToUnstake: uint64): void
//
// Removes stake on behalf of caller (removing own stake).  If any token rewards exist, those are always sent in
// full. Also notifies the validator contract for this pools validator of the staker / balance changes.
//
// @param {Address} staker - account to remove.  normally same as sender, but the validator owner or manager can also call
// this to remove the specified staker explicitly. The removed stake MUST only go to the staker of course.  This is
// so a validator can shut down a poool and refund the stakers.  It can also be used to kick out stakers who no longer
// meet the gating requirements (determined by the node daemon).
// @param {uint64} amountToUnstake - The amount of stake to be removed.  Specify 0 to remove all stake.
// @throws {Error} If the account has insufficient balance or if the account is not found.
removeStake:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 6

	// *if6_condition
	// examples/reti/stakingPool.algo.ts:274
	// staker !== this.txn.sender
	frame_dig -1 // staker: Address
	txn Sender
	!=
	bz *if6_end

	// *if6_consequent
	// examples/reti/stakingPool.algo.ts:275
	// assert(
	//         this.isOwnerOrManagerCaller(),
	//         'If staker is not sender in removeStake call, then sender MUST be owner or manager of validator'
	//       )
	callsub isOwnerOrManagerCaller

	// If staker is not sender in removeStake call, then sender MUST be owner or manager of validator
	assert

*if6_end:
	// examples/reti/stakingPool.algo.ts:281
	// this.checkIfBinClosed()
	callsub checkIfBinClosed

	// examples/reti/stakingPool.algo.ts:283
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	intc 0 // 0
	frame_bury 0 // i: uint64

*for_1:
	// examples/reti/stakingPool.algo.ts:283
	// i < this.stakers.value.length
	frame_dig 0 // i: uint64
	intc 7 // 200
	<
	bz *for_1_end

	// *if7_condition
	// examples/reti/stakingPool.algo.ts:284
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 10 // 300
	<
	bz *if7_end

	// *if7_consequent
	// examples/reti/stakingPool.algo.ts:285
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if7_end:
	// examples/reti/stakingPool.algo.ts:287
	// cmpStaker = clone(this.stakers.value[i])
	frame_dig 0 // i: uint64
	intc 3 // 64
	* // acc * typeLength
	intc 3 // 64
	bytec 2 //  "stakers"
	cover 2
	box_extract
	frame_bury 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// *if8_condition
	// examples/reti/stakingPool.algo.ts:288
	// cmpStaker.account === staker
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 0 32
	frame_dig -1 // staker: Address
	==
	bz *if8_end

	// *if8_consequent
	// *if9_condition
	// examples/reti/stakingPool.algo.ts:289
	// amountToUnstake === 0
	frame_dig -2 // amountToUnstake: uint64
	intc 0 // 0
	==
	bz *if9_end

	// *if9_consequent
	// examples/reti/stakingPool.algo.ts:291
	// amountToUnstake = cmpStaker.balance
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_bury -2 // amountToUnstake: uint64

*if9_end:
	// *if10_condition
	// examples/reti/stakingPool.algo.ts:293
	// cmpStaker.balance < amountToUnstake
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig -2 // amountToUnstake: uint64
	<
	bz *if10_end

	// *if10_consequent
	// Insufficient balance
	err

*if10_end:
	// examples/reti/stakingPool.algo.ts:296
	// cmpStaker.balance -= amountToUnstake
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	intc 4 //  headOffset
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig -2 // amountToUnstake: uint64
	-
	itob
	replace3
	frame_bury 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:297
	// this.totalAlgoStaked.value -= amountToUnstake
	bytec 6 //  "staked"
	app_global_get
	frame_dig -2 // amountToUnstake: uint64
	-
	bytec 6 //  "staked"
	swap
	app_global_put

	// examples/reti/stakingPool.algo.ts:299
	// amountRewardTokenRemoved = 0
	intc 0 // 0
	frame_bury 2 // amountRewardTokenRemoved: uint64

	// *if11_condition
	// examples/reti/stakingPool.algo.ts:300
	// cmpStaker.rewardTokenBalance > 0
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 48 8
	btoi
	intc 0 // 0
	>
	bz *if11_end

	// *if11_consequent
	// *if12_condition
	// examples/reti/stakingPool.algo.ts:302
	// this.poolId.value === 1
	bytec 4 //  "poolId"
	app_global_get
	intc 1 // 1
	==
	bz *if12_else

	// *if12_consequent
	// examples/reti/stakingPool.algo.ts:303
	// validatorConfig = sendMethodCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
	//               applicationID: this.creatingValidatorContractAppId.value,
	//               methodArgs: [this.validatorId.value],
	//             })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 15 //  method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:304
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:305
	// methodArgs: [this.validatorId.value]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 3 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:311
	// sendAssetTransfer({
	//               xferAsset: AssetID.fromUint64(validatorConfig.rewardTokenId),
	//               assetReceiver: staker,
	//               assetAmount: cmpStaker.rewardTokenBalance,
	//             })
	itxn_begin
	intc 12 //  axfer
	itxn_field TypeEnum

	// examples/reti/stakingPool.algo.ts:312
	// xferAsset: AssetID.fromUint64(validatorConfig.rewardTokenId)
	frame_dig 3 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 153 8
	btoi
	itxn_field XferAsset

	// examples/reti/stakingPool.algo.ts:313
	// assetReceiver: staker
	frame_dig -1 // staker: Address
	itxn_field AssetReceiver

	// examples/reti/stakingPool.algo.ts:314
	// assetAmount: cmpStaker.rewardTokenBalance
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 48 8
	btoi
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/reti/stakingPool.algo.ts:316
	// amountRewardTokenRemoved = cmpStaker.rewardTokenBalance
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 48 8
	btoi
	frame_bury 2 // amountRewardTokenRemoved: uint64

	// examples/reti/stakingPool.algo.ts:317
	// cmpStaker.rewardTokenBalance = 0
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	bytec 10 // 0x0000000000000000
	replace2 48
	frame_bury 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	b *if12_end

*if12_else:
	// examples/reti/stakingPool.algo.ts:322
	// amountRewardTokenRemoved = cmpStaker.rewardTokenBalance
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 48 8
	btoi
	frame_bury 2 // amountRewardTokenRemoved: uint64

	// examples/reti/stakingPool.algo.ts:323
	// cmpStaker.rewardTokenBalance = 0
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	bytec 10 // 0x0000000000000000
	replace2 48
	frame_bury 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)

*if12_end:

*if11_end:
	// examples/reti/stakingPool.algo.ts:328
	// assert(
	//           cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
	//           'cannot reduce balance below minimum allowed stake unless all is removed'
	//         )
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	intc 0 // 0
	==
	dup
	bnz *skip_or0
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	bytec 18 //  "minEntryStake"
	app_global_get
	>=
	||

*skip_or0:
	// cannot reduce balance below minimum allowed stake unless all is removed
	assert

	// examples/reti/stakingPool.algo.ts:336
	// sendPayment({
	//           amount: amountToUnstake,
	//           receiver: staker,
	//           note: 'unstaked',
	//         })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// examples/reti/stakingPool.algo.ts:337
	// amount: amountToUnstake
	frame_dig -2 // amountToUnstake: uint64
	itxn_field Amount

	// examples/reti/stakingPool.algo.ts:338
	// receiver: staker
	frame_dig -1 // staker: Address
	itxn_field Receiver

	// examples/reti/stakingPool.algo.ts:339
	// note: 'unstaked'
	pushbytes 0x756e7374616b6564 // "unstaked"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/reti/stakingPool.algo.ts:341
	// stakerRemoved = false
	intc 0 // 0
	frame_bury 4 // stakerRemoved: bool

	// *if13_condition
	// examples/reti/stakingPool.algo.ts:342
	// cmpStaker.balance === 0
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	intc 0 // 0
	==
	bz *if13_end

	// *if13_consequent
	// examples/reti/stakingPool.algo.ts:344
	// this.numStakers.value -= 1
	bytec 13 //  "numStakers"
	app_global_get
	intc 1 // 1
	-
	bytec 13 //  "numStakers"
	swap
	app_global_put

	// examples/reti/stakingPool.algo.ts:345
	// cmpStaker.account = globals.zeroAddress
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	intc 0 // 0
	global ZeroAddress
	replace3
	frame_bury 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:346
	// cmpStaker.totalRewarded = 0
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	bytec 10 // 0x0000000000000000
	replace2 40
	frame_bury 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:347
	// cmpStaker.rewardTokenBalance = 0
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	bytec 10 // 0x0000000000000000
	replace2 48
	frame_bury 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:348
	// stakerRemoved = true
	intc 1 // 1
	frame_bury 4 // stakerRemoved: bool

*if13_end:
	// examples/reti/stakingPool.algo.ts:351
	// this.stakers.value[i] = cmpStaker
	frame_dig 0 // i: uint64
	intc 3 // 64
	* // acc * typeLength
	frame_dig 1 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	bytec 2 //  "stakers"
	cover 2
	box_replace

	// examples/reti/stakingPool.algo.ts:353
	// roundsLeftInBin = this.binRoundStart.value + this.roundsPerDay.value - globals.round
	bytec 11 //  "binRoundStart"
	app_global_get
	bytec 7 //  "roundsPerDay"
	app_global_get
	+
	global Round
	-
	frame_bury 5 // roundsLeftInBin: uint64

	// examples/reti/stakingPool.algo.ts:354
	// subtractAmount: uint128 = (amountToUnstake as uint128) * (roundsLeftInBin as uint128)
	frame_dig -2 // amountToUnstake: uint64
	itob
	frame_dig 5 // roundsLeftInBin: uint64
	itob
	b*
	dup
	bitlen
	intc 6 // 128
	<=

	// (amountToUnstake as uint128) * (roundsLeftInBin as uint128) overflowed 128 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 5 // 16
	-
	swap
	substring3
	frame_bury 6 // subtractAmount: uint128

	// examples/reti/stakingPool.algo.ts:355
	// this.stakeAccumulator.value = this.stakeAccumulator.value - subtractAmount
	bytec 8 //  "stakeAccumulator"
	dup
	app_global_get
	frame_dig 6 // subtractAmount: uint128
	b-
	dup
	bitlen
	intc 6 // 128
	<=

	// this.stakeAccumulator.value - subtractAmount overflowed 128 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 5 // 16
	-
	swap
	substring3
	app_global_put

	// examples/reti/stakingPool.algo.ts:360
	// sendMethodCall<typeof ValidatorRegistry.prototype.stakeRemoved>({
	//           applicationID: this.creatingValidatorContractAppId.value,
	//           methodArgs: [
	//             { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: this.app.id },
	//             staker,
	//             amountToUnstake,
	//             amountRewardTokenRemoved,
	//             stakerRemoved,
	//           ],
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 22 //  method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:361
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:362
	// methodArgs: [
	//             { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: this.app.id },
	//             staker,
	//             amountToUnstake,
	//             amountRewardTokenRemoved,
	//             stakerRemoved,
	//           ]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	bytec 4 //  "poolId"
	app_global_get
	itob
	concat
	txna Applications 0
	itob
	concat
	itxn_field ApplicationArgs
	frame_dig -1 // staker: Address
	itxn_field ApplicationArgs
	frame_dig -2 // amountToUnstake: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig 2 // amountRewardTokenRemoved: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig 4 // stakerRemoved: bool
	bytec 26 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/reti/stakingPool.algo.ts:370
	// return;
	retsub

*if8_end:

*for_1_continue:
	// examples/reti/stakingPool.algo.ts:283
	// i += 1
	frame_dig 0 // i: uint64
	intc 1 // 1
	+
	frame_bury 0 // i: uint64
	b *for_1

*for_1_end:
	// account not found
	err
	retsub

// claimTokens()void
*abi_route_claimTokens:
	// execute claimTokens()void
	callsub claimTokens
	intc 1 // 1
	return

// claimTokens(): void
//
// Claims all the available reward tokens a staker has available, sending their entire balance to the staker from
// pool 1 (either directly, or via validator->pool1 to pay it out)
// Also notifies the validator contract for this pools validator of the staker / balance changes.
claimTokens:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// examples/reti/stakingPool.algo.ts:385
	// staker = this.txn.sender
	txn Sender
	frame_bury 0 // staker: address

	// examples/reti/stakingPool.algo.ts:387
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	intc 0 // 0
	frame_bury 1 // i: uint64

*for_2:
	// examples/reti/stakingPool.algo.ts:387
	// i < this.stakers.value.length
	frame_dig 1 // i: uint64
	intc 7 // 200
	<
	bz *for_2_end

	// *if14_condition
	// examples/reti/stakingPool.algo.ts:388
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 10 // 300
	<
	bz *if14_end

	// *if14_consequent
	// examples/reti/stakingPool.algo.ts:389
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if14_end:
	// examples/reti/stakingPool.algo.ts:391
	// cmpStaker = clone(this.stakers.value[i])
	frame_dig 1 // i: uint64
	intc 3 // 64
	* // acc * typeLength
	intc 3 // 64
	bytec 2 //  "stakers"
	cover 2
	box_extract
	frame_bury 2 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// *if15_condition
	// examples/reti/stakingPool.algo.ts:392
	// cmpStaker.account === staker
	frame_dig 2 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 0 32
	frame_dig 0 // staker: address
	==
	bz *if15_end

	// *if15_consequent
	// *if16_condition
	// examples/reti/stakingPool.algo.ts:393
	// cmpStaker.rewardTokenBalance === 0
	frame_dig 2 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 48 8
	btoi
	intc 0 // 0
	==
	bz *if16_end

	// *if16_consequent
	// examples/reti/stakingPool.algo.ts:394
	// return;
	retsub

*if16_end:
	// examples/reti/stakingPool.algo.ts:396
	// amountRewardTokenRemoved = 0
	intc 0 // 0
	frame_bury 3 // amountRewardTokenRemoved: uint64

	// *if17_condition
	// examples/reti/stakingPool.algo.ts:398
	// this.poolId.value === 1
	bytec 4 //  "poolId"
	app_global_get
	intc 1 // 1
	==
	bz *if17_else

	// *if17_consequent
	// examples/reti/stakingPool.algo.ts:399
	// validatorConfig = sendMethodCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
	//             applicationID: this.creatingValidatorContractAppId.value,
	//             methodArgs: [this.validatorId.value],
	//           })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 15 //  method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:400
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:401
	// methodArgs: [this.validatorId.value]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 4 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:406
	// sendAssetTransfer({
	//             xferAsset: AssetID.fromUint64(validatorConfig.rewardTokenId),
	//             assetReceiver: staker,
	//             assetAmount: cmpStaker.rewardTokenBalance,
	//           })
	itxn_begin
	intc 12 //  axfer
	itxn_field TypeEnum

	// examples/reti/stakingPool.algo.ts:407
	// xferAsset: AssetID.fromUint64(validatorConfig.rewardTokenId)
	frame_dig 4 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 153 8
	btoi
	itxn_field XferAsset

	// examples/reti/stakingPool.algo.ts:408
	// assetReceiver: staker
	frame_dig 0 // staker: address
	itxn_field AssetReceiver

	// examples/reti/stakingPool.algo.ts:409
	// assetAmount: cmpStaker.rewardTokenBalance
	frame_dig 2 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 48 8
	btoi
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/reti/stakingPool.algo.ts:411
	// amountRewardTokenRemoved = cmpStaker.rewardTokenBalance
	frame_dig 2 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 48 8
	btoi
	frame_bury 3 // amountRewardTokenRemoved: uint64

	// examples/reti/stakingPool.algo.ts:412
	// cmpStaker.rewardTokenBalance = 0
	frame_dig 2 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	bytec 10 // 0x0000000000000000
	replace2 48
	frame_bury 2 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	b *if17_end

*if17_else:
	// examples/reti/stakingPool.algo.ts:417
	// amountRewardTokenRemoved = cmpStaker.rewardTokenBalance
	frame_dig 2 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 48 8
	btoi
	frame_bury 3 // amountRewardTokenRemoved: uint64

	// examples/reti/stakingPool.algo.ts:418
	// cmpStaker.rewardTokenBalance = 0
	frame_dig 2 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	bytec 10 // 0x0000000000000000
	replace2 48
	frame_bury 2 // cmpStaker: (address,uint64,uint64,uint64,uint64)

*if17_end:
	// examples/reti/stakingPool.algo.ts:422
	// this.stakers.value[i] = cmpStaker
	frame_dig 1 // i: uint64
	intc 3 // 64
	* // acc * typeLength
	frame_dig 2 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	bytec 2 //  "stakers"
	cover 2
	box_replace

	// examples/reti/stakingPool.algo.ts:427
	// sendMethodCall<typeof ValidatorRegistry.prototype.stakeRemoved>({
	//           applicationID: this.creatingValidatorContractAppId.value,
	//           methodArgs: [
	//             { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: this.app.id },
	//             staker,
	//             0, // no algo removed
	//             amountRewardTokenRemoved,
	//             false, // staker isn't being removed.
	//           ],
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 22 //  method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:428
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:429
	// methodArgs: [
	//             { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: this.app.id },
	//             staker,
	//             0, // no algo removed
	//             amountRewardTokenRemoved,
	//             false, // staker isn't being removed.
	//           ]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	bytec 4 //  "poolId"
	app_global_get
	itob
	concat
	txna Applications 0
	itob
	concat
	itxn_field ApplicationArgs
	frame_dig 0 // staker: address
	itxn_field ApplicationArgs
	bytec 10 // 0x0000000000000000
	itxn_field ApplicationArgs
	frame_dig 3 // amountRewardTokenRemoved: uint64
	itob
	itxn_field ApplicationArgs
	intc 0 // 0
	bytec 26 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/reti/stakingPool.algo.ts:437
	// return;
	retsub

*if15_end:

*for_2_continue:
	// examples/reti/stakingPool.algo.ts:387
	// i += 1
	frame_dig 1 // i: uint64
	intc 1 // 1
	+
	frame_bury 1 // i: uint64
	b *for_2

*for_2_end:
	// account not found
	err
	retsub

// getStakerInfo(address)(address,uint64,uint64,uint64,uint64)
*abi_route_getStakerInfo:
	// The ABI return prefix
	bytec 21 // 0x151f7c75

	// staker: address
	txna ApplicationArgs 1
	dup
	len
	intc 4 // 32
	==

	// argument 0 (staker) for getStakerInfo must be a address
	assert

	// execute getStakerInfo(address)(address,uint64,uint64,uint64,uint64)
	callsub getStakerInfo
	concat
	log
	intc 1 // 1
	return

// getStakerInfo(staker: Address): StakedInfo
//
// Retrieves the staked information for a given staker.
//
// @param {Address} staker - The address of the staker.
// @returns {StakedInfo} - The staked information for the given staker.
// @throws {Error} - If the staker's account is not found.
getStakerInfo:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/reti/stakingPool.algo.ts:452
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	intc 0 // 0
	frame_bury 0 // i: uint64

*for_3:
	// examples/reti/stakingPool.algo.ts:452
	// i < this.stakers.value.length
	frame_dig 0 // i: uint64
	intc 7 // 200
	<
	bz *for_3_end

	// *if18_condition
	// examples/reti/stakingPool.algo.ts:453
	// globals.opcodeBudget < 200
	global OpcodeBudget
	intc 7 // 200
	<
	bz *if18_end

	// *if18_consequent
	// examples/reti/stakingPool.algo.ts:454
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if18_end:
	// *if19_condition
	// examples/reti/stakingPool.algo.ts:456
	// this.stakers.value[i].account === staker
	frame_dig 0 // i: uint64
	intc 3 // 64
	* // acc * typeLength
	intc 0 // 0
	+
	intc 4 // 32
	bytec 2 //  "stakers"
	cover 2
	box_extract
	frame_dig -1 // staker: Address
	==
	bz *if19_end

	// *if19_consequent
	// examples/reti/stakingPool.algo.ts:457
	// return this.stakers.value[i];
	frame_dig 0 // i: uint64
	intc 3 // 64
	* // acc * typeLength
	intc 3 // 64
	bytec 2 //  "stakers"
	cover 2
	box_extract
	b *getStakerInfo*return

*if19_end:

*for_3_continue:
	// examples/reti/stakingPool.algo.ts:452
	// i += 1
	frame_dig 0 // i: uint64
	intc 1 // 1
	+
	frame_bury 0 // i: uint64
	b *for_3

*for_3_end:
	// account not found
	err

*getStakerInfo*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// payTokenReward(address,uint64,uint64)void
*abi_route_payTokenReward:
	// amountToSend: uint64
	txna ApplicationArgs 3
	btoi

	// rewardToken: uint64
	txna ApplicationArgs 2
	btoi

	// staker: address
	txna ApplicationArgs 1
	dup
	len
	intc 4 // 32
	==

	// argument 2 (staker) for payTokenReward must be a address
	assert

	// execute payTokenReward(address,uint64,uint64)void
	callsub payTokenReward
	intc 1 // 1
	return

// payTokenReward(staker: Address, rewardToken: uint64, amountToSend: uint64): void
//
// [Internal protocol method] Remove a specified amount of 'community token' rewards for a staker.
// This can ONLY be called by our validator and only if we're pool 1 - with the token.
// Note: this can also be called by validator as part of OWNER wanting to send the reward tokens
// somewhere else (ie if they're sunsetting their validator and need the reward tokens back).
// It's up to the validator to ensure that the balance in rewardTokenHeldBack is honored.
// @param staker - the staker account to send rewards to
// @param rewardToken - id of reward token (to avoid re-entrancy in calling validator back to get id)
// @param amountToSend - amount to send the staker (there is significant trust here(!) - also why only validator can call us
payTokenReward:
	proto 3 0

	// examples/reti/stakingPool.algo.ts:475
	// assert(
	//       this.txn.sender === this.creatingValidatorContractAppId.value.address,
	//       'this can only be called via the validator contract'
	//     )
	txn Sender
	bytec 1 //  "creatorApp"
	app_global_get
	app_params_get AppAddress
	pop
	==

	// this can only be called via the validator contract
	assert

	// examples/reti/stakingPool.algo.ts:479
	// assert(this.poolId.value === 1, 'must be pool 1 in order to be called to pay out token rewards')
	bytec 4 //  "poolId"
	app_global_get
	intc 1 // 1
	==

	// must be pool 1 in order to be called to pay out token rewards
	assert

	// examples/reti/stakingPool.algo.ts:480
	// assert(rewardToken !== 0, 'can only claim token rewards from validator that has them')
	frame_dig -2 // rewardToken: uint64
	intc 0 // 0
	!=

	// can only claim token rewards from validator that has them
	assert

	// examples/reti/stakingPool.algo.ts:483
	// sendAssetTransfer({
	//       xferAsset: AssetID.fromUint64(rewardToken),
	//       assetReceiver: staker,
	//       assetAmount: amountToSend,
	//     })
	itxn_begin
	intc 12 //  axfer
	itxn_field TypeEnum

	// examples/reti/stakingPool.algo.ts:484
	// xferAsset: AssetID.fromUint64(rewardToken)
	frame_dig -2 // rewardToken: uint64
	itxn_field XferAsset

	// examples/reti/stakingPool.algo.ts:485
	// assetReceiver: staker
	frame_dig -1 // staker: Address
	itxn_field AssetReceiver

	// examples/reti/stakingPool.algo.ts:486
	// assetAmount: amountToSend
	frame_dig -3 // amountToSend: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// updateAlgodVer(string)void
*abi_route_updateAlgodVer:
	// algodVer: string
	txna ApplicationArgs 1
	extract 2 0

	// execute updateAlgodVer(string)void
	callsub updateAlgodVer
	intc 1 // 1
	return

// updateAlgodVer(algodVer: string): void
//
// Update the (honor system) algod version for the node associated to this pool.  The node management daemon
// should compare its current nodes version to the version stored in global state, updating when different.
// The reti node daemon composes its own version string using format:
// {major}.{minor}.{build} {branch} [{commit hash}],
// ie: 3.22.0 rel/stable [6b508975]
// [ ONLY OWNER OR MANAGER CAN CALL ]
// @param {string} algodVer - string representing the algorand node daemon version (reti node daemon composes its own meta version)
updateAlgodVer:
	proto 1 0

	// examples/reti/stakingPool.algo.ts:500
	// assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
	callsub isOwnerOrManagerCaller

	// can only be called by owner or manager of validator
	assert

	// examples/reti/stakingPool.algo.ts:501
	// this.algodVer.value = algodVer
	pushbytes 0x616c676f64566572 // "algodVer"
	frame_dig -1 // algodVer: string
	app_global_put
	retsub

// epochBalanceUpdate()void
*abi_route_epochBalanceUpdate:
	// execute epochBalanceUpdate()void
	callsub epochBalanceUpdate
	intc 1 // 1
	return

// epochBalanceUpdate(): void
//
// Updates the balance of stakers in the pool based on the received 'rewards' (current balance vs known staked balance)
// stakers outstanding balance is adjusted based on their % of stake and time in the current epoch - so that balance
// compounds over time and staker can remove that amount at will.
// The validator is paid their percentage each epoch payout.
//
// Note: ANYONE can call this.
epochBalanceUpdate:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 39

	// examples/reti/stakingPool.algo.ts:514
	// validatorConfig = sendMethodCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
	//       applicationID: this.creatingValidatorContractAppId.value,
	//       methodArgs: [this.validatorId.value],
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 15 //  method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:515
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:516
	// methodArgs: [this.validatorId.value]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:523
	// epochRoundLength = validatorConfig.epochRoundLength as uint64
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 169 4
	btoi
	frame_bury 1 // epochRoundLength: uint64

	// examples/reti/stakingPool.algo.ts:524
	// curRound = globals.round
	global Round
	frame_bury 2 // curRound: uint64

	// examples/reti/stakingPool.algo.ts:525
	// thisEpochBegin = curRound - (curRound % epochRoundLength)
	frame_dig 2 // curRound: uint64
	frame_dig 2 // curRound: uint64
	frame_dig 1 // epochRoundLength: uint64
	%
	-
	frame_bury 3 // thisEpochBegin: uint64

	// examples/reti/stakingPool.algo.ts:528
	// lastPayoutEpoch = this.lastPayout.value - (this.lastPayout.value % epochRoundLength)
	bytec 14 //  "lastPayout"
	app_global_get
	bytec 14 //  "lastPayout"
	app_global_get
	frame_dig 1 // epochRoundLength: uint64
	%
	-
	frame_bury 4 // lastPayoutEpoch: uint64

	// examples/reti/stakingPool.algo.ts:530
	// assert(lastPayoutEpoch !== thisEpochBegin, "can't call epochBalanceUpdate in same epoch as prior call")
	frame_dig 4 // lastPayoutEpoch: uint64
	frame_dig 3 // thisEpochBegin: uint64
	!=

	// can't call epochBalanceUpdate in same epoch as prior call
	assert

	// examples/reti/stakingPool.algo.ts:532
	// this.checkIfBinClosed()
	callsub checkIfBinClosed

	// examples/reti/stakingPool.algo.ts:535
	// this.lastPayout.value = curRound
	bytec 14 //  "lastPayout"
	frame_dig 2 // curRound: uint64
	app_global_put

	// examples/reti/stakingPool.algo.ts:536
	// this.epochNumber.value += 1
	bytec 19 //  "epochNumber"
	app_global_get
	intc 1 // 1
	+
	bytec 19 //  "epochNumber"
	swap
	app_global_put

	// examples/reti/stakingPool.algo.ts:541
	// isTokenEligible = validatorConfig.rewardTokenId !== 0
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 153 8
	btoi
	intc 0 // 0
	!=
	frame_bury 5 // isTokenEligible: bool

	// examples/reti/stakingPool.algo.ts:542
	// poolOneAppID = this.app.id
	txna Applications 0
	frame_bury 6 // poolOneAppID: uint64

	// examples/reti/stakingPool.algo.ts:543
	// poolOneAddress = this.app.address
	global CurrentApplicationAddress
	frame_bury 7 // poolOneAddress: address

	// *if20_condition
	// examples/reti/stakingPool.algo.ts:548
	// isTokenEligible
	frame_dig 5 // isTokenEligible: bool
	bz *if20_end

	// *if20_consequent
	// *if21_condition
	// examples/reti/stakingPool.algo.ts:549
	// this.poolId.value !== 1
	bytec 4 //  "poolId"
	app_global_get
	intc 1 // 1
	!=
	bz *if21_end

	// *if21_consequent
	// examples/reti/stakingPool.algo.ts:551
	// poolOneAppID = sendMethodCall<typeof ValidatorRegistry.prototype.getPoolAppId>({
	//           applicationID: this.creatingValidatorContractAppId.value,
	//           methodArgs: [this.validatorId.value, 1],
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 23 //  method "getPoolAppId(uint64,uint64)uint64"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:552
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:553
	// methodArgs: [this.validatorId.value, 1]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	itxn_field ApplicationArgs
	pushbytes 0x0000000000000001
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	btoi
	frame_bury 6 // poolOneAppID: uint64

	// examples/reti/stakingPool.algo.ts:555
	// poolOneAddress = AppID.fromUint64(poolOneAppID).address
	frame_dig 6 // poolOneAppID: uint64
	app_params_get AppAddress
	pop
	frame_bury 7 // poolOneAddress: address

*if21_end:
	// *if22_condition
	// examples/reti/stakingPool.algo.ts:560
	// this.poolId.value === 1
	bytec 4 //  "poolId"
	app_global_get
	intc 1 // 1
	==
	bz *if22_else

	// *if22_consequent
	// examples/reti/stakingPool.algo.ts:561
	// tokenPayoutRatio = sendMethodCall<typeof ValidatorRegistry.prototype.setTokenPayoutRatio>({
	//           applicationID: this.creatingValidatorContractAppId.value,
	//           methodArgs: [this.validatorId.value],
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 24 //  method "setTokenPayoutRatio(uint64)(uint64[24],uint64)"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:562
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:563
	// methodArgs: [this.validatorId.value]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 8 // tokenPayoutRatio: PoolTokenPayoutRatio
	b *if22_end

*if22_else:
	// examples/reti/stakingPool.algo.ts:567
	// tokenPayoutRatio = sendMethodCall<typeof StakingPool.prototype.proxiedSetTokenPayoutRatio>({
	//           applicationID: AppID.fromUint64(poolOneAppID),
	//           methodArgs: [{ id: this.validatorId.value, poolId: this.poolId.value, poolAppId: this.app.id }],
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 25 //  method "proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:568
	// applicationID: AppID.fromUint64(poolOneAppID)
	frame_dig 6 // poolOneAppID: uint64
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:569
	// methodArgs: [{ id: this.validatorId.value, poolId: this.poolId.value, poolAppId: this.app.id }]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	bytec 4 //  "poolId"
	app_global_get
	itob
	concat
	txna Applications 0
	itob
	concat
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 8 // tokenPayoutRatio: PoolTokenPayoutRatio

*if22_end:

*if20_end:
	// examples/reti/stakingPool.algo.ts:576
	// validatorState = sendMethodCall<typeof ValidatorRegistry.prototype.getValidatorState>({
	//       applicationID: this.creatingValidatorContractAppId.value,
	//       methodArgs: [this.validatorId.value],
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x1f2f0109 // method "getValidatorState(uint64)(uint16,uint64,uint64,uint64)"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:577
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:578
	// methodArgs: [this.validatorId.value]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 9 // validatorState: (uint16,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:580
	// rewardTokenHeldBack = validatorState.rewardTokenHeldBack
	frame_dig 9 // validatorState: (uint16,uint64,uint64,uint64)
	extract 18 8
	btoi
	frame_bury 10 // rewardTokenHeldBack: uint64

	// examples/reti/stakingPool.algo.ts:586
	// algoRewardAvail = this.app.address.balance - this.totalAlgoStaked.value - this.app.address.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	bytec 6 //  "staked"
	app_global_get
	-
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	-
	frame_bury 11 // algoRewardAvail: uint64

	// examples/reti/stakingPool.algo.ts:587
	// isPoolSaturated = false
	intc 0 // 0
	frame_bury 12 // isPoolSaturated: bool

	// examples/reti/stakingPool.algo.ts:588
	// algoSaturationAmt = this.algoSaturationLevel()
	callsub algoSaturationLevel
	frame_bury 13 // algoSaturationAmt: uint64

	// *if23_condition
	// examples/reti/stakingPool.algo.ts:596
	// validatorState.totalAlgoStaked > algoSaturationAmt
	frame_dig 9 // validatorState: (uint16,uint64,uint64,uint64)
	extract 10 8
	btoi
	frame_dig 13 // algoSaturationAmt: uint64
	>
	bz *if23_end

	// *if23_consequent
	// examples/reti/stakingPool.algo.ts:597
	// isPoolSaturated = true
	intc 1 // 1
	frame_bury 12 // isPoolSaturated: bool

*if23_end:
	// examples/reti/stakingPool.algo.ts:603
	// tokenRewardAvail = 0
	intc 0 // 0
	frame_bury 14 // tokenRewardAvail: uint64

	// examples/reti/stakingPool.algo.ts:604
	// tokenRewardPaidOut = 0
	intc 0 // 0
	frame_bury 15 // tokenRewardPaidOut: uint64

	// examples/reti/stakingPool.algo.ts:605
	// validatorCommissionPaidOut = 0
	intc 0 // 0
	frame_bury 16 // validatorCommissionPaidOut: uint64

	// examples/reti/stakingPool.algo.ts:606
	// excessToFeeSink = 0
	intc 0 // 0
	frame_bury 17 // excessToFeeSink: uint64

	// *if24_condition
	// examples/reti/stakingPool.algo.ts:607
	// isTokenEligible
	frame_dig 5 // isTokenEligible: bool
	bz *if24_end

	// *if24_consequent
	// examples/reti/stakingPool.algo.ts:608
	// tokenRewardBal =
	//         poolOneAddress.assetBalance(AssetID.fromUint64(validatorConfig.rewardTokenId)) - rewardTokenHeldBack
	frame_dig 7 // poolOneAddress: address
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 153 8
	btoi
	asset_holding_get AssetBalance
	pop
	frame_dig 10 // rewardTokenHeldBack: uint64
	-
	frame_bury 18 // tokenRewardBal: uint64

	// *if25_condition
	// examples/reti/stakingPool.algo.ts:613
	// tokenRewardBal >= validatorConfig.rewardPerPayout
	frame_dig 18 // tokenRewardBal: uint64
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 161 8
	btoi
	>=
	bz *if25_end

	// *if25_consequent
	// examples/reti/stakingPool.algo.ts:619
	// ourPoolPctOfWhole = tokenPayoutRatio.poolPctOfWhole[this.poolId.value - 1]
	frame_dig 8 // tokenPayoutRatio: PoolTokenPayoutRatio
	intc 0 // 0
	bytec 4 //  "poolId"
	app_global_get
	intc 1 // 1
	-
	intc 14 // 8
	* // acc * typeLength
	+
	intc 14 // 8
	extract3
	btoi
	frame_bury 19 // ourPoolPctOfWhole: uint64

	// examples/reti/stakingPool.algo.ts:622
	// tokenRewardAvail = wideRatio([validatorConfig.rewardPerPayout, ourPoolPctOfWhole], [1_000_000])
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 161 8
	btoi
	frame_dig 19 // ourPoolPctOfWhole: uint64
	mulw
	intc 0 // 0
	intc 9 // 1_000_000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 14 // tokenRewardAvail: uint64

*if25_end:

*if24_end:
	// *if26_condition
	// examples/reti/stakingPool.algo.ts:625
	// tokenRewardAvail === 0
	frame_dig 14 // tokenRewardAvail: uint64
	intc 0 // 0
	==
	bz *if26_end

	// *if26_consequent
	// *if27_condition
	// examples/reti/stakingPool.algo.ts:630
	// algoRewardAvail < 1_000_000
	frame_dig 11 // algoRewardAvail: uint64
	intc 9 // 1_000_000
	<
	bz *if27_end

	// *if27_consequent
	// examples/reti/stakingPool.algo.ts:631
	// log('!token&&!noalgo to pay')
	pushbytes 0x21746f6b656e2626216e6f616c676f20746f20706179 // "!token&&!noalgo to pay"
	log

	// examples/reti/stakingPool.algo.ts:632
	// return;
	retsub

*if27_end:

*if26_end:
	// *if28_condition
	// examples/reti/stakingPool.algo.ts:636
	// isPoolSaturated
	frame_dig 12 // isPoolSaturated: bool
	bz *if28_elseif1_condition

	// *if28_consequent
	// examples/reti/stakingPool.algo.ts:642
	// normalValidatorCommission = wideRatio(
	//         [algoRewardAvail, validatorConfig.percentToValidator as uint64],
	//         [1_000_000]
	//       )
	frame_dig 11 // algoRewardAvail: uint64
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 173 4
	btoi
	mulw
	intc 0 // 0
	intc 9 // 1_000_000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 20 // normalValidatorCommission: uint64

	// examples/reti/stakingPool.algo.ts:647
	// diminishedReward = wideRatio([algoRewardAvail, algoSaturationAmt], [validatorState.totalAlgoStaked])
	frame_dig 11 // algoRewardAvail: uint64
	frame_dig 13 // algoSaturationAmt: uint64
	mulw
	intc 0 // 0
	frame_dig 9 // validatorState: (uint16,uint64,uint64,uint64)
	extract 10 8
	btoi
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 21 // diminishedReward: uint64

	// *if29_condition
	// examples/reti/stakingPool.algo.ts:649
	// diminishedReward > algoRewardAvail - normalValidatorCommission
	frame_dig 21 // diminishedReward: uint64
	frame_dig 11 // algoRewardAvail: uint64
	frame_dig 20 // normalValidatorCommission: uint64
	-
	>
	bz *if29_end

	// *if29_consequent
	// examples/reti/stakingPool.algo.ts:650
	// diminishedReward = algoRewardAvail - normalValidatorCommission
	frame_dig 11 // algoRewardAvail: uint64
	frame_dig 20 // normalValidatorCommission: uint64
	-
	frame_bury 21 // diminishedReward: uint64

*if29_end:
	// examples/reti/stakingPool.algo.ts:653
	// excessToFeeSink = algoRewardAvail - diminishedReward
	frame_dig 11 // algoRewardAvail: uint64
	frame_dig 21 // diminishedReward: uint64
	-
	frame_bury 17 // excessToFeeSink: uint64

	// examples/reti/stakingPool.algo.ts:654
	// sendPayment({
	//         amount: excessToFeeSink,
	//         receiver: blocks[this.txn.firstValid - 1].feeSink,
	//         note: 'pool saturated, excess to fee sink',
	//       })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// examples/reti/stakingPool.algo.ts:655
	// amount: excessToFeeSink
	frame_dig 17 // excessToFeeSink: uint64
	itxn_field Amount

	// examples/reti/stakingPool.algo.ts:656
	// receiver: blocks[this.txn.firstValid - 1].feeSink
	txn FirstValid
	intc 1 // 1
	-
	block BlkFeeSink
	itxn_field Receiver

	// examples/reti/stakingPool.algo.ts:657
	// note: 'pool saturated, excess to fee sink'
	pushbytes 0x706f6f6c207361747572617465642c2065786365737320746f206665652073696e6b // "pool saturated, excess to fee sink"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// examples/reti/stakingPool.algo.ts:660
	// algoRewardAvail = diminishedReward
	frame_dig 21 // diminishedReward: uint64
	frame_bury 11 // algoRewardAvail: uint64
	b *if28_end

*if28_elseif1_condition:
	// examples/reti/stakingPool.algo.ts:661
	// validatorConfig.percentToValidator !== 0
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 173 4
	btoi
	intc 0 // 0
	!=
	bz *if28_end

	// *if28_elseif1_consequent
	// examples/reti/stakingPool.algo.ts:664
	// validatorCommissionPaidOut = wideRatio(
	//         [algoRewardAvail, validatorConfig.percentToValidator as uint64],
	//         [1_000_000]
	//       )
	frame_dig 11 // algoRewardAvail: uint64
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 173 4
	btoi
	mulw
	intc 0 // 0
	intc 9 // 1_000_000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 16 // validatorCommissionPaidOut: uint64

	// examples/reti/stakingPool.algo.ts:670
	// algoRewardAvail -= validatorCommissionPaidOut
	frame_dig 11 // algoRewardAvail: uint64
	frame_dig 16 // validatorCommissionPaidOut: uint64
	-
	frame_bury 11 // algoRewardAvail: uint64

	// *if30_condition
	// examples/reti/stakingPool.algo.ts:677
	// validatorCommissionPaidOut > 0
	frame_dig 16 // validatorCommissionPaidOut: uint64
	intc 0 // 0
	>
	bz *if30_end

	// *if30_consequent
	// examples/reti/stakingPool.algo.ts:680
	// managerTopOff = 0
	intc 0 // 0
	frame_bury 22 // managerTopOff: uint64

	// *if31_condition
	// examples/reti/stakingPool.algo.ts:682
	// validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
	//           validatorConfig.manager.balance - validatorConfig.manager.minBalance < 2_100_000
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 40 32
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 177 32
	!=
	dup
	bz *skip_and3
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 40 32
	acct_params_get AcctBalance
	pop
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 40 32
	acct_params_get AcctMinBalance
	pop
	-
	intc 13 // 2_100_000
	<
	&&

*skip_and3:
	bz *if31_end

	// *if31_consequent
	// examples/reti/stakingPool.algo.ts:685
	// managerTopOff = validatorCommissionPaidOut < 2_100_000 ? validatorCommissionPaidOut : 2_100_000
	frame_dig 16 // validatorCommissionPaidOut: uint64
	intc 13 // 2_100_000
	<
	bz *ternary1_false
	frame_dig 16 // validatorCommissionPaidOut: uint64
	b *ternary1_end

*ternary1_false:
	intc 13 // 2_100_000

*ternary1_end:
	frame_bury 22 // managerTopOff: uint64

	// examples/reti/stakingPool.algo.ts:686
	// sendPayment({
	//             amount: managerTopOff,
	//             receiver: validatorConfig.manager,
	//             note: 'validator reward to manager for funding epoch updates',
	//           })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// examples/reti/stakingPool.algo.ts:687
	// amount: managerTopOff
	frame_dig 22 // managerTopOff: uint64
	itxn_field Amount

	// examples/reti/stakingPool.algo.ts:688
	// receiver: validatorConfig.manager
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 40 32
	itxn_field Receiver

	// examples/reti/stakingPool.algo.ts:689
	// note: 'validator reward to manager for funding epoch updates'
	pushbytes 0x76616c696461746f722072657761726420746f206d616e6167657220666f722066756e64696e672065706f63682075706461746573 // "validator reward to manager for funding epoch updates"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if31_end:
	// *if32_condition
	// examples/reti/stakingPool.algo.ts:692
	// validatorCommissionPaidOut - managerTopOff > 0
	frame_dig 16 // validatorCommissionPaidOut: uint64
	frame_dig 22 // managerTopOff: uint64
	-
	intc 0 // 0
	>
	bz *if32_end

	// *if32_consequent
	// examples/reti/stakingPool.algo.ts:693
	// sendPayment({
	//             amount: validatorCommissionPaidOut - managerTopOff,
	//             receiver: validatorConfig.validatorCommissionAddress,
	//             note: 'validator reward',
	//           })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// examples/reti/stakingPool.algo.ts:694
	// amount: validatorCommissionPaidOut - managerTopOff
	frame_dig 16 // validatorCommissionPaidOut: uint64
	frame_dig 22 // managerTopOff: uint64
	-
	itxn_field Amount

	// examples/reti/stakingPool.algo.ts:695
	// receiver: validatorConfig.validatorCommissionAddress
	frame_dig 0 // validatorConfig: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 177 32
	itxn_field Receiver

	// examples/reti/stakingPool.algo.ts:696
	// note: 'validator reward'
	pushbytes 0x76616c696461746f7220726577617264 // "validator reward"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if32_end:

*if30_end:

*if28_end:
	// examples/reti/stakingPool.algo.ts:708
	// increasedStake = 0
	intc 0 // 0
	frame_bury 23 // increasedStake: uint64

	// *if33_condition
	// examples/reti/stakingPool.algo.ts:732
	// algoRewardAvail !== 0 || tokenRewardAvail !== 0
	frame_dig 11 // algoRewardAvail: uint64
	intc 0 // 0
	!=
	dup
	bnz *skip_or1
	frame_dig 14 // tokenRewardAvail: uint64
	intc 0 // 0
	!=
	||

*skip_or1:
	bz *if33_end

	// *if33_consequent
	// examples/reti/stakingPool.algo.ts:733
	// partialStakersTotalStake: uint64 = 0
	intc 0 // 0
	frame_bury 24 // partialStakersTotalStake: uint64

	// examples/reti/stakingPool.algo.ts:734
	// origAlgoReward = algoRewardAvail
	frame_dig 11 // algoRewardAvail: uint64
	frame_bury 25 // origAlgoReward: uint64

	// examples/reti/stakingPool.algo.ts:736
	// origTokenReward = tokenRewardAvail
	frame_dig 14 // tokenRewardAvail: uint64
	frame_bury 26 // origTokenReward: uint64

	// examples/reti/stakingPool.algo.ts:737
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	intc 0 // 0
	frame_bury 27 // i: uint64

*for_4:
	// examples/reti/stakingPool.algo.ts:737
	// i < this.stakers.value.length
	frame_dig 27 // i: uint64
	intc 7 // 200
	<
	bz *for_4_end

	// *if34_condition
	// examples/reti/stakingPool.algo.ts:738
	// globals.opcodeBudget < 400
	global OpcodeBudget
	intc 16 // 400
	<
	bz *if34_end

	// *if34_consequent
	// examples/reti/stakingPool.algo.ts:739
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if34_end:
	// examples/reti/stakingPool.algo.ts:741
	// cmpStaker = clone(this.stakers.value[i])
	frame_dig 27 // i: uint64
	intc 3 // 64
	* // acc * typeLength
	intc 3 // 64
	bytec 2 //  "stakers"
	cover 2
	box_extract
	frame_bury 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// *if35_condition
	// examples/reti/stakingPool.algo.ts:742
	// cmpStaker.account !== globals.zeroAddress
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 0 32
	global ZeroAddress
	!=
	bz *if35_end

	// *if35_consequent
	// *if36_condition
	// examples/reti/stakingPool.algo.ts:743
	// cmpStaker.entryRound >= thisEpochBegin
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	frame_dig 3 // thisEpochBegin: uint64
	>=
	bz *if36_else

	// *if36_consequent
	// examples/reti/stakingPool.algo.ts:746
	// partialStakersTotalStake += cmpStaker.balance
	frame_dig 24 // partialStakersTotalStake: uint64
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	+
	frame_bury 24 // partialStakersTotalStake: uint64
	b *if36_end

*if36_else:
	// examples/reti/stakingPool.algo.ts:750
	// timeInPool = thisEpochBegin - cmpStaker.entryRound
	frame_dig 3 // thisEpochBegin: uint64
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	-
	frame_bury 29 // timeInPool: uint64

	// *if37_condition
	// examples/reti/stakingPool.algo.ts:754
	// timeInPool < epochRoundLength
	frame_dig 29 // timeInPool: uint64
	frame_dig 1 // epochRoundLength: uint64
	<
	bz *if37_end

	// *if37_consequent
	// examples/reti/stakingPool.algo.ts:755
	// partialStakersTotalStake += cmpStaker.balance
	frame_dig 24 // partialStakersTotalStake: uint64
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	+
	frame_bury 24 // partialStakersTotalStake: uint64

	// examples/reti/stakingPool.algo.ts:756
	// timePercentage = (timeInPool * 1000) / epochRoundLength
	frame_dig 29 // timeInPool: uint64
	intc 11 // 1000
	*
	frame_dig 1 // epochRoundLength: uint64
	/
	frame_bury 30 // timePercentage: uint64

	// *if38_condition
	// examples/reti/stakingPool.algo.ts:758
	// tokenRewardAvail > 0
	frame_dig 14 // tokenRewardAvail: uint64
	intc 0 // 0
	>
	bz *if38_end

	// *if38_consequent
	// examples/reti/stakingPool.algo.ts:760
	// stakerTokenReward = wideRatio(
	//                   [cmpStaker.balance, origTokenReward, timePercentage],
	//                   [this.totalAlgoStaked.value, 1000]
	//                 )
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 26 // origTokenReward: uint64
	mulw
	frame_dig 30 // timePercentage: uint64
	uncover 2
	dig 1
	*
	cover 2
	mulw
	cover 2
	+
	swap
	bytec 6 //  "staked"
	app_global_get
	intc 11 // 1000
	mulw
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 31 // stakerTokenReward: uint64

	// examples/reti/stakingPool.algo.ts:767
	// tokenRewardAvail -= stakerTokenReward
	frame_dig 14 // tokenRewardAvail: uint64
	frame_dig 31 // stakerTokenReward: uint64
	-
	frame_bury 14 // tokenRewardAvail: uint64

	// examples/reti/stakingPool.algo.ts:768
	// cmpStaker.rewardTokenBalance += stakerTokenReward
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	intc 20 //  headOffset
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 48 8
	btoi
	frame_dig 31 // stakerTokenReward: uint64
	+
	itob
	replace3
	frame_bury 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:769
	// tokenRewardPaidOut += stakerTokenReward
	frame_dig 15 // tokenRewardPaidOut: uint64
	frame_dig 31 // stakerTokenReward: uint64
	+
	frame_bury 15 // tokenRewardPaidOut: uint64

*if38_end:
	// examples/reti/stakingPool.algo.ts:772
	// stakerReward = wideRatio(
	//                 [cmpStaker.balance, origAlgoReward, timePercentage],
	//                 [this.totalAlgoStaked.value, 1000]
	//               )
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 25 // origAlgoReward: uint64
	mulw
	frame_dig 30 // timePercentage: uint64
	uncover 2
	dig 1
	*
	cover 2
	mulw
	cover 2
	+
	swap
	bytec 6 //  "staked"
	app_global_get
	intc 11 // 1000
	mulw
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 32 // stakerReward: uint64

	// examples/reti/stakingPool.algo.ts:778
	// algoRewardAvail -= stakerReward
	frame_dig 11 // algoRewardAvail: uint64
	frame_dig 32 // stakerReward: uint64
	-
	frame_bury 11 // algoRewardAvail: uint64

	// examples/reti/stakingPool.algo.ts:781
	// cmpStaker.balance += stakerReward
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	intc 4 //  headOffset
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 32 // stakerReward: uint64
	+
	itob
	replace3
	frame_bury 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:782
	// cmpStaker.totalRewarded += stakerReward
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	intc 19 //  headOffset
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 40 8
	btoi
	frame_dig 32 // stakerReward: uint64
	+
	itob
	replace3
	frame_bury 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:783
	// increasedStake += stakerReward
	frame_dig 23 // increasedStake: uint64
	frame_dig 32 // stakerReward: uint64
	+
	frame_bury 23 // increasedStake: uint64

	// examples/reti/stakingPool.algo.ts:785
	// this.stakers.value[i] = cmpStaker
	frame_dig 27 // i: uint64
	intc 3 // 64
	* // acc * typeLength
	frame_dig 28 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	bytec 2 //  "stakers"
	cover 2
	box_replace

*if37_end:

*if36_end:

*if35_end:

*for_4_continue:
	// examples/reti/stakingPool.algo.ts:737
	// i += 1
	frame_dig 27 // i: uint64
	intc 1 // 1
	+
	frame_bury 27 // i: uint64
	b *for_4

*for_4_end:
	// examples/reti/stakingPool.algo.ts:793
	// newPoolTotalStake = this.totalAlgoStaked.value - partialStakersTotalStake
	bytec 6 //  "staked"
	app_global_get
	frame_dig 24 // partialStakersTotalStake: uint64
	-
	frame_bury 33 // newPoolTotalStake: uint64

	// *if39_condition
	// examples/reti/stakingPool.algo.ts:797
	// newPoolTotalStake > 0
	frame_dig 33 // newPoolTotalStake: uint64
	intc 0 // 0
	>
	bz *if39_end

	// *if39_consequent
	// examples/reti/stakingPool.algo.ts:799
	// for (let i = 0; i < this.stakers.value.length; i += 1)
	intc 0 // 0
	frame_bury 34 // i: uint64

*for_5:
	// examples/reti/stakingPool.algo.ts:799
	// i < this.stakers.value.length
	frame_dig 34 // i: uint64
	intc 7 // 200
	<
	bz *for_5_end

	// *if40_condition
	// examples/reti/stakingPool.algo.ts:800
	// globals.opcodeBudget < 200
	global OpcodeBudget
	intc 7 // 200
	<
	bz *if40_end

	// *if40_consequent
	// examples/reti/stakingPool.algo.ts:801
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if40_end:
	// examples/reti/stakingPool.algo.ts:803
	// cmpStaker = clone(this.stakers.value[i])
	frame_dig 34 // i: uint64
	intc 3 // 64
	* // acc * typeLength
	intc 3 // 64
	bytec 2 //  "stakers"
	cover 2
	box_extract
	frame_bury 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// *if41_condition
	// examples/reti/stakingPool.algo.ts:804
	// cmpStaker.account !== globals.zeroAddress && cmpStaker.entryRound < thisEpochBegin
	frame_dig 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 0 32
	global ZeroAddress
	!=
	dup
	bz *skip_and4
	frame_dig 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	frame_dig 3 // thisEpochBegin: uint64
	<
	&&

*skip_and4:
	bz *if41_end

	// *if41_consequent
	// examples/reti/stakingPool.algo.ts:805
	// timeInPool = thisEpochBegin - cmpStaker.entryRound
	frame_dig 3 // thisEpochBegin: uint64
	frame_dig 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 56 8
	btoi
	-
	frame_bury 36 // timeInPool: uint64

	// *if42_condition
	// examples/reti/stakingPool.algo.ts:807
	// timeInPool >= epochRoundLength
	frame_dig 36 // timeInPool: uint64
	frame_dig 1 // epochRoundLength: uint64
	>=
	bz *if42_end

	// *if42_consequent
	// *if43_condition
	// examples/reti/stakingPool.algo.ts:812
	// tokenRewardAvail > 0
	frame_dig 14 // tokenRewardAvail: uint64
	intc 0 // 0
	>
	bz *if43_end

	// *if43_consequent
	// examples/reti/stakingPool.algo.ts:813
	// stakerTokenReward = wideRatio([cmpStaker.balance, tokenRewardAvail], [newPoolTotalStake])
	frame_dig 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 14 // tokenRewardAvail: uint64
	mulw
	intc 0 // 0
	frame_dig 33 // newPoolTotalStake: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 37 // stakerTokenReward: uint64

	// examples/reti/stakingPool.algo.ts:815
	// cmpStaker.rewardTokenBalance += stakerTokenReward
	frame_dig 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	intc 20 //  headOffset
	frame_dig 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 48 8
	btoi
	frame_dig 37 // stakerTokenReward: uint64
	+
	itob
	replace3
	frame_bury 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:816
	// tokenRewardPaidOut += stakerTokenReward
	frame_dig 15 // tokenRewardPaidOut: uint64
	frame_dig 37 // stakerTokenReward: uint64
	+
	frame_bury 15 // tokenRewardPaidOut: uint64

*if43_end:
	// *if44_condition
	// examples/reti/stakingPool.algo.ts:818
	// algoRewardAvail > 0
	frame_dig 11 // algoRewardAvail: uint64
	intc 0 // 0
	>
	bz *if44_end

	// *if44_consequent
	// examples/reti/stakingPool.algo.ts:819
	// stakerReward = wideRatio([cmpStaker.balance, algoRewardAvail], [newPoolTotalStake])
	frame_dig 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 11 // algoRewardAvail: uint64
	mulw
	intc 0 // 0
	frame_dig 33 // newPoolTotalStake: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 38 // stakerReward: uint64

	// examples/reti/stakingPool.algo.ts:822
	// cmpStaker.balance += stakerReward
	frame_dig 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	intc 4 //  headOffset
	frame_dig 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 32 8
	btoi
	frame_dig 38 // stakerReward: uint64
	+
	itob
	replace3
	frame_bury 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:823
	// cmpStaker.totalRewarded += stakerReward
	frame_dig 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	intc 19 //  headOffset
	frame_dig 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	extract 40 8
	btoi
	frame_dig 38 // stakerReward: uint64
	+
	itob
	replace3
	frame_bury 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)

	// examples/reti/stakingPool.algo.ts:824
	// increasedStake += stakerReward
	frame_dig 23 // increasedStake: uint64
	frame_dig 38 // stakerReward: uint64
	+
	frame_bury 23 // increasedStake: uint64

*if44_end:
	// examples/reti/stakingPool.algo.ts:828
	// this.stakers.value[i] = cmpStaker
	frame_dig 34 // i: uint64
	intc 3 // 64
	* // acc * typeLength
	frame_dig 35 // cmpStaker: (address,uint64,uint64,uint64,uint64)
	bytec 2 //  "stakers"
	cover 2
	box_replace

*if42_end:

*if41_end:

*for_5_continue:
	// examples/reti/stakingPool.algo.ts:799
	// i += 1
	frame_dig 34 // i: uint64
	intc 1 // 1
	+
	frame_bury 34 // i: uint64
	b *for_5

*for_5_end:

*if39_end:

*if33_end:
	// examples/reti/stakingPool.algo.ts:838
	// roundsLeftInBin = this.binRoundStart.value + this.roundsPerDay.value - globals.round
	bytec 11 //  "binRoundStart"
	app_global_get
	bytec 7 //  "roundsPerDay"
	app_global_get
	+
	global Round
	-
	frame_bury 39 // roundsLeftInBin: uint64

	// examples/reti/stakingPool.algo.ts:839
	// this.totalAlgoStaked.value += increasedStake
	bytec 6 //  "staked"
	app_global_get
	frame_dig 23 // increasedStake: uint64
	+
	bytec 6 //  "staked"
	swap
	app_global_put

	// examples/reti/stakingPool.algo.ts:840
	// this.stakeAccumulator.value =
	//       this.stakeAccumulator.value + (increasedStake as uint128) * (roundsLeftInBin as uint128)
	bytec 8 //  "stakeAccumulator"
	dup
	app_global_get
	frame_dig 23 // increasedStake: uint64
	itob
	frame_dig 39 // roundsLeftInBin: uint64
	itob
	b*
	b+
	dup
	bitlen
	intc 6 // 128
	<=

	// this.stakeAccumulator.value + (increasedStake as uint128) * (roundsLeftInBin as uint128) overflowed 128 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 5 // 16
	-
	swap
	substring3
	app_global_put

	// examples/reti/stakingPool.algo.ts:842
	// this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
	bytec 12 //  "rewardAccumulator"
	dup
	app_global_get
	frame_dig 23 // increasedStake: uint64
	+
	app_global_put

	// examples/reti/stakingPool.algo.ts:848
	// sendMethodCall<typeof ValidatorRegistry.prototype.stakeUpdatedViaRewards>({
	//       applicationID: this.creatingValidatorContractAppId.value,
	//       methodArgs: [
	//         { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: this.app.id },
	//         increasedStake,
	//         tokenRewardPaidOut,
	//         validatorCommissionPaidOut,
	//         excessToFeeSink,
	//       ],
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x418fcefc // method "stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:849
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:850
	// methodArgs: [
	//         { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: this.app.id },
	//         increasedStake,
	//         tokenRewardPaidOut,
	//         validatorCommissionPaidOut,
	//         excessToFeeSink,
	//       ]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	bytec 4 //  "poolId"
	app_global_get
	itob
	concat
	txna Applications 0
	itob
	concat
	itxn_field ApplicationArgs
	frame_dig 23 // increasedStake: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig 15 // tokenRewardPaidOut: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig 16 // validatorCommissionPaidOut: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig 17 // excessToFeeSink: uint64
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void
*abi_route_goOnline:
	// voteKeyDilution: uint64
	txna ApplicationArgs 6
	btoi

	// voteLast: uint64
	txna ApplicationArgs 5
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 4
	btoi

	// stateProofPK: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// selectionPK: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// votePK: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// feePayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 6 (feePayment) for goOnline must be a pay transaction
	assert

	// execute goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub goOnline
	intc 1 // 1
	return

// goOnline(feePayment: PayTxn, votePK: bytes, selectionPK: bytes, stateProofPK: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64): void
//
// Registers a staking pool key online against a participation key.
// [ ONLY OWNER OR MANAGER CAN CALL ]
//
// @param {PayTxn} feePayment - payment to cover extra fee of going online if offline - or 0 if not renewal
// @param {bytes} votePK - The vote public key.
// @param {bytes} selectionPK - The selection public key.
// @param {bytes} stateProofPK - The state proof public key.
// @param {uint64} voteFirst - The first vote index.
// @param {uint64} voteLast - The last vote index.
// @param {uint64} voteKeyDilution - The vote key dilution value.
// @throws {Error} Will throw an error if the caller is not the owner or a manager.
goOnline:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/reti/stakingPool.algo.ts:882
	// assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
	callsub isOwnerOrManagerCaller

	// can only be called by owner or manager of validator
	assert

	// examples/reti/stakingPool.algo.ts:883
	// extraFee = this.getGoOnlineFee()
	callsub getGoOnlineFee
	frame_bury 0 // extraFee: uint64

	// examples/reti/stakingPool.algo.ts:884
	// verifyPayTxn(feePayment, { receiver: this.app.address, amount: extraFee })
	// verify receiver
	frame_dig -1 // feePayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"feePayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // feePayment: PayTxn
	gtxns Amount
	frame_dig 0 // extraFee: uint64
	==

	// transaction verification failed: {"txn":"feePayment","field":"amount","expected":"extraFee"}
	assert

	// examples/reti/stakingPool.algo.ts:885
	// sendOnlineKeyRegistration({
	//       votePK: votePK,
	//       selectionPK: selectionPK,
	//       stateProofPK: stateProofPK,
	//       voteFirst: voteFirst,
	//       voteLast: voteLast,
	//       voteKeyDilution: voteKeyDilution,
	//       fee: extraFee,
	//     })
	itxn_begin
	intc 18 //  keyreg
	itxn_field TypeEnum

	// examples/reti/stakingPool.algo.ts:886
	// votePK: votePK
	frame_dig -2 // votePK: bytes
	itxn_field VotePK

	// examples/reti/stakingPool.algo.ts:887
	// selectionPK: selectionPK
	frame_dig -3 // selectionPK: bytes
	itxn_field SelectionPK

	// examples/reti/stakingPool.algo.ts:888
	// stateProofPK: stateProofPK
	frame_dig -4 // stateProofPK: bytes
	itxn_field StateProofPK

	// examples/reti/stakingPool.algo.ts:889
	// voteFirst: voteFirst
	frame_dig -5 // voteFirst: uint64
	itxn_field VoteFirst

	// examples/reti/stakingPool.algo.ts:890
	// voteLast: voteLast
	frame_dig -6 // voteLast: uint64
	itxn_field VoteLast

	// examples/reti/stakingPool.algo.ts:891
	// voteKeyDilution: voteKeyDilution
	frame_dig -7 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// examples/reti/stakingPool.algo.ts:892
	// fee: extraFee
	frame_dig 0 // extraFee: uint64
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// goOffline()void
*abi_route_goOffline:
	// execute goOffline()void
	callsub goOffline
	intc 1 // 1
	return

// goOffline(): void
//
// Marks a staking pool key OFFLINE.
// [ ONLY OWNER OR MANAGER CAN CALL ]
goOffline:
	proto 0 0

	// *if45_condition
	// examples/reti/stakingPool.algo.ts:904
	// this.txn.sender !== this.creatingValidatorContractAppId.value.address
	txn Sender
	bytec 1 //  "creatorApp"
	app_global_get
	app_params_get AppAddress
	pop
	!=
	bz *if45_end

	// *if45_consequent
	// examples/reti/stakingPool.algo.ts:905
	// assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
	callsub isOwnerOrManagerCaller

	// can only be called by owner or manager of validator
	assert

*if45_end:
	// examples/reti/stakingPool.algo.ts:908
	// sendOfflineKeyRegistration({})
	itxn_begin
	intc 18 //  keyreg
	itxn_field TypeEnum

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// linkToNFD(uint64,string)void
*abi_route_linkToNFD:
	// nfdName: string
	txna ApplicationArgs 2
	extract 2 0

	// nfdAppId: uint64
	txna ApplicationArgs 1
	btoi

	// execute linkToNFD(uint64,string)void
	callsub linkToNFD
	intc 1 // 1
	return

// linkToNFD(nfdAppId: uint64, nfdName: string): void
linkToNFD:
	proto 2 0

	// examples/reti/stakingPool.algo.ts:915
	// assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
	callsub isOwnerOrManagerCaller

	// can only be called by owner or manager of validator
	assert

	// examples/reti/stakingPool.algo.ts:917
	// sendAppCall({
	//       applicationID: AppID.fromUint64(this.nfdRegistryAppId),
	//       applicationArgs: ['verify_nfd_addr', nfdName, itob(nfdAppId), rawBytes(this.app.address)],
	//       applications: [AppID.fromUint64(nfdAppId)],
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum

	// examples/reti/stakingPool.algo.ts:918
	// applicationID: AppID.fromUint64(this.nfdRegistryAppId)
	intc 21 // TMPL_nfdRegistryAppId
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:919
	// applicationArgs: ['verify_nfd_addr', nfdName, itob(nfdAppId), rawBytes(this.app.address)]
	pushbytes 0x7665726966795f6e66645f61646472 // "verify_nfd_addr"
	itxn_field ApplicationArgs
	frame_dig -2 // nfdName: string
	itxn_field ApplicationArgs
	frame_dig -1 // nfdAppId: uint64
	itob
	itxn_field ApplicationArgs
	global CurrentApplicationAddress
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:920
	// applications: [AppID.fromUint64(nfdAppId)]
	frame_dig -1 // nfdAppId: uint64
	itxn_field Applications

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)
*abi_route_proxiedSetTokenPayoutRatio:
	// The ABI return prefix
	bytec 21 // 0x151f7c75

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	pushint 24
	==

	// argument 0 (poolKey) for proxiedSetTokenPayoutRatio must be a (uint64,uint64,uint64)
	assert

	// execute proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)
	callsub proxiedSetTokenPayoutRatio
	concat
	log
	intc 1 // 1
	return

// proxiedSetTokenPayoutRatio(poolKey: ValidatorPoolKey): PoolTokenPayoutRatio
//
// proxiedSetTokenPayoutRatio is meant to be called by pools != 1 - calling US, pool #1
// We need to verify that we are in fact being called by another of OUR pools (not us)
// and then we'll call the validator on their behalf to update the token payouts
// @param poolKey - ValidatorPoolKey tuple
proxiedSetTokenPayoutRatio:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/reti/stakingPool.algo.ts:931
	// assert(this.validatorId.value === poolKey.id, 'caller must be part of same validator set!')
	bytec 3 //  "validatorId"
	app_global_get
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	==

	// caller must be part of same validator set!
	assert

	// examples/reti/stakingPool.algo.ts:932
	// assert(this.poolId.value === 1, 'callee must be pool 1')
	bytec 4 //  "poolId"
	app_global_get
	intc 1 // 1
	==

	// callee must be pool 1
	assert

	// examples/reti/stakingPool.algo.ts:933
	// assert(poolKey.poolId !== 1, 'caller must NOT be pool 1')
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	!=

	// caller must NOT be pool 1
	assert

	// examples/reti/stakingPool.algo.ts:935
	// callerPoolAppID = sendMethodCall<typeof ValidatorRegistry.prototype.getPoolAppId>({
	//       applicationID: this.creatingValidatorContractAppId.value,
	//       methodArgs: [poolKey.id, poolKey.poolId],
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 23 //  method "getPoolAppId(uint64,uint64)uint64"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:936
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:937
	// methodArgs: [poolKey.id, poolKey.poolId]
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	itxn_field ApplicationArgs
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	btoi
	frame_bury 0 // callerPoolAppID: uint64

	// examples/reti/stakingPool.algo.ts:939
	// assert(callerPoolAppID === poolKey.poolAppId)
	frame_dig 0 // callerPoolAppID: uint64
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	==
	assert

	// examples/reti/stakingPool.algo.ts:940
	// assert(this.txn.sender === AppID.fromUint64(poolKey.poolAppId).address)
	txn Sender
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	app_params_get AppAddress
	pop
	==
	assert

	// examples/reti/stakingPool.algo.ts:942
	// return sendMethodCall<typeof ValidatorRegistry.prototype.setTokenPayoutRatio>({
	//       applicationID: this.creatingValidatorContractAppId.value,
	//       methodArgs: [this.validatorId.value],
	//     });
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 24 //  method "setTokenPayoutRatio(uint64)(uint64[24],uint64)"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:943
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:944
	// methodArgs: [this.validatorId.value]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0

	// set the subroutine return value
	frame_bury 0
	retsub

// isOwnerOrManagerCaller(): boolean
isOwnerOrManagerCaller:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/reti/stakingPool.algo.ts:949
	// OwnerAndManager = sendMethodCall<typeof ValidatorRegistry.prototype.getValidatorOwnerAndManager>({
	//       applicationID: this.creatingValidatorContractAppId.value,
	//       methodArgs: [this.validatorId.value],
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x2fa22c4b // method "getValidatorOwnerAndManager(uint64)(address,address)"
	itxn_field ApplicationArgs

	// examples/reti/stakingPool.algo.ts:950
	// applicationID: this.creatingValidatorContractAppId.value
	bytec 1 //  "creatorApp"
	app_global_get
	itxn_field ApplicationID

	// examples/reti/stakingPool.algo.ts:951
	// methodArgs: [this.validatorId.value]
	bytec 3 //  "validatorId"
	app_global_get
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 0 // OwnerAndManager: (address,address)

	// examples/reti/stakingPool.algo.ts:953
	// return this.txn.sender === OwnerAndManager[0] || this.txn.sender === OwnerAndManager[1];
	txn Sender
	frame_dig 0 // OwnerAndManager: (address,address)
	extract 0 32
	==
	dup
	bnz *skip_or2
	txn Sender
	frame_dig 0 // OwnerAndManager: (address,address)
	extract 32 32
	==
	||

*skip_or2:
	// set the subroutine return value
	frame_bury 0
	retsub

// algoSaturationLevel(): uint64
//
// Returns the maximum allowed stake per validator based on a percentage of all current online stake before
// the validator is considered saturated - where rewards are diminished.
algoSaturationLevel:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/reti/stakingPool.algo.ts:961
	// online = this.getCurrentOnlineStake()
	callsub getCurrentOnlineStake
	frame_bury 0 // online: uint64

	// examples/reti/stakingPool.algo.ts:963
	// return wideRatio([online, MAX_VALIDATOR_SOFT_PCT_OF_ONLINE_1DECIMAL], [1000]);
	frame_dig 0 // online: uint64
	pushint 100
	mulw
	intc 0 // 0
	intc 11 // 1000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert

	// set the subroutine return value
	frame_bury 0
	retsub

// getGoOnlineFee(): uint64
getGoOnlineFee:
	proto 0 1

	// *if46_condition
	// examples/reti/stakingPool.algo.ts:968
	// !this.app.address.incentiveEligible
	global CurrentApplicationAddress
	acct_params_get AcctIncentiveEligible
	pop
	!
	bz *if46_end

	// *if46_consequent
	// examples/reti/stakingPool.algo.ts:969
	// return globals.payoutsGoOnlineFee;
	global PayoutsGoOnlineFee
	retsub

*if46_end:
	// examples/reti/stakingPool.algo.ts:971
	// return 0;
	intc 0 // 0
	retsub

// getCurrentOnlineStake(): uint64
getCurrentOnlineStake:
	proto 0 1

	// examples/reti/stakingPool.algo.ts:975
	// return onlineStake();
	online_stake
	retsub

// checkIfBinClosed(): void
//
// Checks if the current round is in a 'new calculation bin' (approximately daily)
checkIfBinClosed:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// examples/reti/stakingPool.algo.ts:982
	// currentBinSize = this.roundsPerDay.value as uint128
	bytec 7 //  "roundsPerDay"
	app_global_get
	itob
	frame_bury 0 // currentBinSize: unsafe uint128

	// *if47_condition
	// examples/reti/stakingPool.algo.ts:983
	// globals.round >= this.binRoundStart.value + (currentBinSize as uint64)
	global Round
	bytec 11 //  "binRoundStart"
	app_global_get
	frame_dig 0 // currentBinSize: unsafe uint128
	dup
	bitlen
	intc 3 // 64
	<=

	// currentBinSize as uint64 overflowed 64 bits
	assert
	pushbytes 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 14 // 8
	-
	swap
	substring3
	btoi
	+
	>=
	bz *if47_end

	// *if47_consequent
	// *if48_condition
	// examples/reti/stakingPool.algo.ts:984
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 10 // 300
	<
	bz *if48_end

	// *if48_consequent
	// examples/reti/stakingPool.algo.ts:985
	// increaseOpcodeBudget()
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 5 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 8 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if48_end:
	// examples/reti/stakingPool.algo.ts:987
	// approxRoundsPerYear: uint128 = currentBinSize * (365 as uint128)
	frame_dig 0 // currentBinSize: unsafe uint128
	pushbytes 0x0000000000000000000000000000016d
	b*
	dup
	bitlen
	intc 6 // 128
	<=

	// currentBinSize * (365 as uint128) overflowed 128 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 5 // 16
	-
	swap
	substring3
	frame_bury 1 // approxRoundsPerYear: uint128

	// examples/reti/stakingPool.algo.ts:988
	// avgStake: uint128 = this.stakeAccumulator.value / currentBinSize
	bytec 8 //  "stakeAccumulator"
	app_global_get
	frame_dig 0 // currentBinSize: unsafe uint128
	b/
	dup
	bitlen
	intc 6 // 128
	<=

	// this.stakeAccumulator.value / currentBinSize overflowed 128 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 5 // 16
	-
	swap
	substring3
	frame_bury 2 // avgStake: uint128

	// *if49_condition
	// examples/reti/stakingPool.algo.ts:989
	// avgStake !== 0
	frame_dig 2 // avgStake: uint128
	bytec 16 // 0x00000000000000000000000000000000
	b!=
	bz *if49_end

	// *if49_consequent
	// examples/reti/stakingPool.algo.ts:993
	// apr: uint128 =
	//           (((this.rewardAccumulator.value as uint128) * (10000 as uint128)) / avgStake) *
	//           (approxRoundsPerYear / currentBinSize)
	bytec 12 //  "rewardAccumulator"
	app_global_get
	itob
	pushbytes 0x00000000000000000000000000002710
	b*
	frame_dig 2 // avgStake: uint128
	b/
	frame_dig 1 // approxRoundsPerYear: uint128
	frame_dig 0 // currentBinSize: unsafe uint128
	b/
	b*
	dup
	bitlen
	intc 6 // 128
	<=

	// (((this.rewardAccumulator.value as uint128) * (10000 as uint128)) / avgStake) *\n          (approxRoundsPerYear / currentBinSize) overflowed 128 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 5 // 16
	-
	swap
	substring3
	frame_bury 3 // apr: uint128

	// examples/reti/stakingPool.algo.ts:997
	// alpha: uint128 = 10 as uint128
	pushbytes 0x0000000000000000000000000000000a
	frame_bury 4 // alpha: unsafe uint128

	// *if50_condition
	// examples/reti/stakingPool.algo.ts:999
	// avgStake > 300000000000
	frame_dig 2 // avgStake: uint128
	pushbytes 0x000000000000000000000045d964b800
	b>
	bz *if50_end

	// *if50_consequent
	// examples/reti/stakingPool.algo.ts:1000
	// alpha = 90 as uint128
	pushbytes 0x0000000000000000000000000000005a
	frame_bury 4 // alpha: unsafe uint128

*if50_end:
	// examples/reti/stakingPool.algo.ts:1002
	// this.weightedMovingAverage.value =
	//           (this.weightedMovingAverage.value * ((100 as uint128) - alpha)) / (100 as uint128) +
	//           (apr * alpha) / (100 as uint128)
	bytec 20 //  "ewma"
	dup
	app_global_get
	bytec 17 // 0x00000000000000000000000000000064
	frame_dig 4 // alpha: unsafe uint128
	b-
	b*
	bytec 17 // 0x00000000000000000000000000000064
	b/
	frame_dig 3 // apr: uint128
	frame_dig 4 // alpha: unsafe uint128
	b*
	bytec 17 // 0x00000000000000000000000000000064
	b/
	b+
	dup
	bitlen
	intc 6 // 128
	<=

	// (this.weightedMovingAverage.value * ((100 as uint128) - alpha)) / (100 as uint128) +\n          (apr * alpha) / (100 as uint128) overflowed 128 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 5 // 16
	-
	swap
	substring3
	app_global_put

*if49_end:
	// examples/reti/stakingPool.algo.ts:1008
	// this.setRoundsPerDay()
	callsub setRoundsPerDay

	// examples/reti/stakingPool.algo.ts:1009
	// this.stakeAccumulator.value = (this.totalAlgoStaked.value as uint128) * (this.roundsPerDay.value as uint128)
	bytec 8 //  "stakeAccumulator"
	bytec 6 //  "staked"
	app_global_get
	itob
	bytec 7 //  "roundsPerDay"
	app_global_get
	itob
	b*
	dup
	bitlen
	intc 6 // 128
	<=

	// (this.totalAlgoStaked.value as uint128) * (this.roundsPerDay.value as uint128) overflowed 128 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 5 // 16
	-
	swap
	substring3
	app_global_put

	// examples/reti/stakingPool.algo.ts:1010
	// this.rewardAccumulator.value = 0
	bytec 12 //  "rewardAccumulator"
	intc 0 // 0
	app_global_put

	// examples/reti/stakingPool.algo.ts:1011
	// this.binRoundStart.value = globals.round - (globals.round % this.roundsPerDay.value)
	bytec 11 //  "binRoundStart"
	global Round
	global Round
	bytec 7 //  "roundsPerDay"
	app_global_get
	%
	-
	app_global_put

*if47_end:
	retsub

// setRoundsPerDay(): void
setRoundsPerDay:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// *if51_condition
	// examples/reti/stakingPool.algo.ts:1020
	// this.txn.firstValid < 12
	txn FirstValid
	pushint 12
	<
	bz *if51_end

	// *if51_consequent
	// examples/reti/stakingPool.algo.ts:1022
	// this.roundsPerDay.value = APPROX_AVG_ROUNDS_PER_DAY
	bytec 7 //  "roundsPerDay"
	intc 17 // 30857
	app_global_put

	// examples/reti/stakingPool.algo.ts:1023
	// return;
	retsub

*if51_end:
	// examples/reti/stakingPool.algo.ts:1026
	// avgBlockTimeTenths = blocks[this.txn.firstValid - 1].timestamp - blocks[this.txn.firstValid - 11].timestamp
	txn FirstValid
	intc 1 // 1
	-
	block BlkTimestamp
	txn FirstValid
	pushint 11
	-
	block BlkTimestamp
	-
	frame_bury 0 // avgBlockTimeTenths: uint64

	// *if52_condition
	// examples/reti/stakingPool.algo.ts:1027
	// avgBlockTimeTenths === 0
	frame_dig 0 // avgBlockTimeTenths: uint64
	intc 0 // 0
	==
	bz *if52_end

	// *if52_consequent
	// examples/reti/stakingPool.algo.ts:1029
	// this.roundsPerDay.value = APPROX_AVG_ROUNDS_PER_DAY
	bytec 7 //  "roundsPerDay"
	intc 17 // 30857
	app_global_put

	// examples/reti/stakingPool.algo.ts:1030
	// return;
	retsub

*if52_end:
	// examples/reti/stakingPool.algo.ts:1035
	// this.roundsPerDay.value = (24 * 60 * 60 * 10) / avgBlockTimeTenths
	bytec 7 //  "roundsPerDay"
	pushint 864000
	frame_dig 0 // avgBlockTimeTenths: uint64
	/
	app_global_put
	retsub

*create_NoOp:
	pushbytes 0x59e90aa6 // method "createApplication(uint64,uint64,uint64,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x3172ca9d // method "gas()void"
	pushbytes 0x47cfcc04 // method "initStorage(pay)void"
	pushbytes 0xf9c70cbd // method "addStake(pay,address)uint64"
	pushbytes 0x421b5abe // method "removeStake(address,uint64)void"
	pushbytes 0xf5892d56 // method "claimTokens()void"
	pushbytes 0x5cfbb057 // method "getStakerInfo(address)(address,uint64,uint64,uint64,uint64)"
	pushbytes 0x63f3f28b // method "payTokenReward(address,uint64,uint64)void"
	pushbytes 0x86a3725c // method "updateAlgodVer(string)void"
	pushbytes 0xefc2608d // method "epochBalanceUpdate()void"
	pushbytes 0x400e14fb // method "goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void"
	pushbytes 0x51ef3b21 // method "goOffline()void"
	pushbytes 0xa24e2717 // method "linkToNFD(uint64,string)void"
	bytec 25 //  method "proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)"
	txna ApplicationArgs 0
	match *abi_route_gas *abi_route_initStorage *abi_route_addStake *abi_route_removeStake *abi_route_claimTokens *abi_route_getStakerInfo *abi_route_payTokenReward *abi_route_updateAlgodVer *abi_route_epochBalanceUpdate *abi_route_goOnline *abi_route_goOffline *abi_route_linkToNFD *abi_route_proxiedSetTokenPayoutRatio

	// this contract does not implement the given ABI method for call NoOp
	err"
`;

exports[`Examples StakingPool Artifacts Maintains program size 1`] = `4553`;

exports[`Examples StakingPool Artifacts Generates ABI JSON 1`] = `
{
  "desc": "",
  "events": undefined,
  "methods": [
    {
      "args": [
        {
          "desc": "id of contract that constructed us - the validator application (single global instance)",
          "name": "creatingContractId",
          "type": "uint64",
        },
        {
          "desc": "id of validator we're a staking pool of",
          "name": "validatorId",
          "type": "uint64",
        },
        {
          "desc": "which pool id are we",
          "name": "poolId",
          "type": "uint64",
        },
        {
          "desc": "minimum amount to be in pool, but also minimum amount balance can't go below (without removing all!)",
          "name": "minEntryStake",
          "type": "uint64",
        },
      ],
      "desc": "Initialize the staking pool w/ owner and manager, but can only be created by the validator contract.",
      "events": undefined,
      "name": "createApplication",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": "gas is a dummy no-op call that can be used to pool-up resource references and opcode cost",
      "events": undefined,
      "name": "gas",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "payment from caller which covers mbr increase of new staking pools' storage",
          "name": "mbrPayment",
          "type": "pay",
        },
      ],
      "desc": 
"Called after we're created and then funded, so we can create our large stakers ledger storage
Caller has to get MBR amounts from ValidatorRegistry to know how much to fund us to cover the box storage cost
If this is pool 1 AND the validator has specified a reward token, opt-in to that token
so that the validator can seed the pool with future rewards of that token."
,
      "events": undefined,
      "name": "initStorage",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "prior payment coming from validator contract to us on behalf of staker.",
          "name": "stakedAmountPayment",
          "type": "pay",
        },
        {
          "desc": "The account adding new stake",
          "name": "staker",
          "type": "address",
        },
      ],
      "desc": 
"Adds stake to the given account.
Can ONLY be called by the validator contract that created us
Must receive payment from the validator contract for amount being staked."
,
      "events": undefined,
      "name": "addStake",
      "readonly": undefined,
      "returns": {
        "desc": "uint64 new 'entry round' round number of stake add",
        "type": "uint64",
      },
    },
    {
      "args": [
        {
          "desc": 
"account to remove.  normally same as sender, but the validator owner or manager can also call
this to remove the specified staker explicitly. The removed stake MUST only go to the staker of course.  This is
so a validator can shut down a poool and refund the stakers.  It can also be used to kick out stakers who no longer
meet the gating requirements (determined by the node daemon)."
,
          "name": "staker",
          "type": "address",
        },
        {
          "desc": "The amount of stake to be removed.  Specify 0 to remove all stake.",
          "name": "amountToUnstake",
          "type": "uint64",
        },
      ],
      "desc": 
"Removes stake on behalf of caller (removing own stake).  If any token rewards exist, those are always sent in
full. Also notifies the validator contract for this pools validator of the staker / balance changes."
,
      "events": undefined,
      "name": "removeStake",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": 
"Claims all the available reward tokens a staker has available, sending their entire balance to the staker from
pool 1 (either directly, or via validator-pool1 to pay it out)
Also notifies the validator contract for this pools validator of the staker / balance changes."
,
      "events": undefined,
      "name": "claimTokens",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "The address of the staker.",
          "name": "staker",
          "type": "address",
        },
      ],
      "desc": "Retrieves the staked information for a given staker.",
      "events": undefined,
      "name": "getStakerInfo",
      "readonly": true,
      "returns": {
        "desc": "StakedInfo - The staked information for the given staker.",
        "type": "(address,uint64,uint64,uint64,uint64)",
      },
    },
    {
      "args": [
        {
          "desc": "the staker account to send rewards to",
          "name": "staker",
          "type": "address",
        },
        {
          "desc": "id of reward token (to avoid re-entrancy in calling validator back to get id)",
          "name": "rewardToken",
          "type": "uint64",
        },
        {
          "desc": "amount to send the staker (there is significant trust here(!) - also why only validator can call us",
          "name": "amountToSend",
          "type": "uint64",
        },
      ],
      "desc": 
"[Internal protocol method] Remove a specified amount of 'community token' rewards for a staker.
This can ONLY be called by our validator and only if we're pool 1 - with the token.
Note: this can also be called by validator as part of OWNER wanting to send the reward tokens
somewhere else (ie if they're sunsetting their validator and need the reward tokens back).
It's up to the validator to ensure that the balance in rewardTokenHeldBack is honored."
,
      "events": undefined,
      "name": "payTokenReward",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "string representing the algorand node daemon version (reti node daemon composes its own meta version)",
          "name": "algodVer",
          "type": "string",
        },
      ],
      "desc": 
"Update the (honor system) algod version for the node associated to this pool.  The node management daemon
should compare its current nodes version to the version stored in global state, updating when different.
The reti node daemon composes its own version string using format:
major.minor.build branch [commit hash],
ie: 3.22.0 rel/stable [6b508975]
[ ONLY OWNER OR MANAGER CAN CALL ]"
,
      "events": undefined,
      "name": "updateAlgodVer",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": 
"Updates the balance of stakers in the pool based on the received 'rewards' (current balance vs known staked balance)
stakers outstanding balance is adjusted based on their % of stake and time in the current epoch - so that balance
compounds over time and staker can remove that amount at will.
The validator is paid their percentage each epoch payout.


Note: ANYONE can call this."
,
      "events": undefined,
      "name": "epochBalanceUpdate",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "payment to cover extra fee of going online if offline - or 0 if not renewal",
          "name": "feePayment",
          "type": "pay",
        },
        {
          "desc": "The vote public key.",
          "name": "votePK",
          "type": "byte[]",
        },
        {
          "desc": "The selection public key.",
          "name": "selectionPK",
          "type": "byte[]",
        },
        {
          "desc": "The state proof public key.",
          "name": "stateProofPK",
          "type": "byte[]",
        },
        {
          "desc": "The first vote index.",
          "name": "voteFirst",
          "type": "uint64",
        },
        {
          "desc": "The last vote index.",
          "name": "voteLast",
          "type": "uint64",
        },
        {
          "desc": "The vote key dilution value.",
          "name": "voteKeyDilution",
          "type": "uint64",
        },
      ],
      "desc": 
"Registers a staking pool key online against a participation key.
[ ONLY OWNER OR MANAGER CAN CALL ]"
,
      "events": undefined,
      "name": "goOnline",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [],
      "desc": 
"Marks a staking pool key OFFLINE.
[ ONLY OWNER OR MANAGER CAN CALL ]"
,
      "events": undefined,
      "name": "goOffline",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": undefined,
          "name": "nfdAppId",
          "type": "uint64",
        },
        {
          "desc": undefined,
          "name": "nfdName",
          "type": "string",
        },
      ],
      "desc": undefined,
      "events": undefined,
      "name": "linkToNFD",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "void",
      },
    },
    {
      "args": [
        {
          "desc": "ValidatorPoolKey tuple",
          "name": "poolKey",
          "type": "(uint64,uint64,uint64)",
        },
      ],
      "desc": 
"proxiedSetTokenPayoutRatio is meant to be called by pools != 1 - calling US, pool #1
We need to verify that we are in fact being called by another of OUR pools (not us)
and then we'll call the validator on their behalf to update the token payouts"
,
      "events": undefined,
      "name": "proxiedSetTokenPayoutRatio",
      "readonly": undefined,
      "returns": {
        "desc": undefined,
        "type": "(uint64[24],uint64)",
      },
    },
  ],
  "name": "StakingPool",
}
`;

exports[`Examples StakingPool Artifacts Generates ARC32 1`] = `
{
  "bare_call_config": {
    "close_out": "NEVER",
    "delete_application": "NEVER",
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "update_application": "NEVER",
  },
  "contract": {
    "desc": "",
    "events": undefined,
    "methods": [
      {
        "args": [
          {
            "desc": "id of contract that constructed us - the validator application (single global instance)",
            "name": "creatingContractId",
            "type": "uint64",
          },
          {
            "desc": "id of validator we're a staking pool of",
            "name": "validatorId",
            "type": "uint64",
          },
          {
            "desc": "which pool id are we",
            "name": "poolId",
            "type": "uint64",
          },
          {
            "desc": "minimum amount to be in pool, but also minimum amount balance can't go below (without removing all!)",
            "name": "minEntryStake",
            "type": "uint64",
          },
        ],
        "desc": "Initialize the staking pool w/ owner and manager, but can only be created by the validator contract.",
        "events": undefined,
        "name": "createApplication",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": "gas is a dummy no-op call that can be used to pool-up resource references and opcode cost",
        "events": undefined,
        "name": "gas",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "payment from caller which covers mbr increase of new staking pools' storage",
            "name": "mbrPayment",
            "type": "pay",
          },
        ],
        "desc": 
"Called after we're created and then funded, so we can create our large stakers ledger storage
Caller has to get MBR amounts from ValidatorRegistry to know how much to fund us to cover the box storage cost
If this is pool 1 AND the validator has specified a reward token, opt-in to that token
so that the validator can seed the pool with future rewards of that token."
,
        "events": undefined,
        "name": "initStorage",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "prior payment coming from validator contract to us on behalf of staker.",
            "name": "stakedAmountPayment",
            "type": "pay",
          },
          {
            "desc": "The account adding new stake",
            "name": "staker",
            "type": "address",
          },
        ],
        "desc": 
"Adds stake to the given account.
Can ONLY be called by the validator contract that created us
Must receive payment from the validator contract for amount being staked."
,
        "events": undefined,
        "name": "addStake",
        "readonly": undefined,
        "returns": {
          "desc": "uint64 new 'entry round' round number of stake add",
          "type": "uint64",
        },
      },
      {
        "args": [
          {
            "desc": 
"account to remove.  normally same as sender, but the validator owner or manager can also call
this to remove the specified staker explicitly. The removed stake MUST only go to the staker of course.  This is
so a validator can shut down a poool and refund the stakers.  It can also be used to kick out stakers who no longer
meet the gating requirements (determined by the node daemon)."
,
            "name": "staker",
            "type": "address",
          },
          {
            "desc": "The amount of stake to be removed.  Specify 0 to remove all stake.",
            "name": "amountToUnstake",
            "type": "uint64",
          },
        ],
        "desc": 
"Removes stake on behalf of caller (removing own stake).  If any token rewards exist, those are always sent in
full. Also notifies the validator contract for this pools validator of the staker / balance changes."
,
        "events": undefined,
        "name": "removeStake",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": 
"Claims all the available reward tokens a staker has available, sending their entire balance to the staker from
pool 1 (either directly, or via validator-pool1 to pay it out)
Also notifies the validator contract for this pools validator of the staker / balance changes."
,
        "events": undefined,
        "name": "claimTokens",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "The address of the staker.",
            "name": "staker",
            "type": "address",
          },
        ],
        "desc": "Retrieves the staked information for a given staker.",
        "events": undefined,
        "name": "getStakerInfo",
        "readonly": true,
        "returns": {
          "desc": "StakedInfo - The staked information for the given staker.",
          "type": "(address,uint64,uint64,uint64,uint64)",
        },
      },
      {
        "args": [
          {
            "desc": "the staker account to send rewards to",
            "name": "staker",
            "type": "address",
          },
          {
            "desc": "id of reward token (to avoid re-entrancy in calling validator back to get id)",
            "name": "rewardToken",
            "type": "uint64",
          },
          {
            "desc": "amount to send the staker (there is significant trust here(!) - also why only validator can call us",
            "name": "amountToSend",
            "type": "uint64",
          },
        ],
        "desc": 
"[Internal protocol method] Remove a specified amount of 'community token' rewards for a staker.
This can ONLY be called by our validator and only if we're pool 1 - with the token.
Note: this can also be called by validator as part of OWNER wanting to send the reward tokens
somewhere else (ie if they're sunsetting their validator and need the reward tokens back).
It's up to the validator to ensure that the balance in rewardTokenHeldBack is honored."
,
        "events": undefined,
        "name": "payTokenReward",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "string representing the algorand node daemon version (reti node daemon composes its own meta version)",
            "name": "algodVer",
            "type": "string",
          },
        ],
        "desc": 
"Update the (honor system) algod version for the node associated to this pool.  The node management daemon
should compare its current nodes version to the version stored in global state, updating when different.
The reti node daemon composes its own version string using format:
major.minor.build branch [commit hash],
ie: 3.22.0 rel/stable [6b508975]
[ ONLY OWNER OR MANAGER CAN CALL ]"
,
        "events": undefined,
        "name": "updateAlgodVer",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": 
"Updates the balance of stakers in the pool based on the received 'rewards' (current balance vs known staked balance)
stakers outstanding balance is adjusted based on their % of stake and time in the current epoch - so that balance
compounds over time and staker can remove that amount at will.
The validator is paid their percentage each epoch payout.


Note: ANYONE can call this."
,
        "events": undefined,
        "name": "epochBalanceUpdate",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "payment to cover extra fee of going online if offline - or 0 if not renewal",
            "name": "feePayment",
            "type": "pay",
          },
          {
            "desc": "The vote public key.",
            "name": "votePK",
            "type": "byte[]",
          },
          {
            "desc": "The selection public key.",
            "name": "selectionPK",
            "type": "byte[]",
          },
          {
            "desc": "The state proof public key.",
            "name": "stateProofPK",
            "type": "byte[]",
          },
          {
            "desc": "The first vote index.",
            "name": "voteFirst",
            "type": "uint64",
          },
          {
            "desc": "The last vote index.",
            "name": "voteLast",
            "type": "uint64",
          },
          {
            "desc": "The vote key dilution value.",
            "name": "voteKeyDilution",
            "type": "uint64",
          },
        ],
        "desc": 
"Registers a staking pool key online against a participation key.
[ ONLY OWNER OR MANAGER CAN CALL ]"
,
        "events": undefined,
        "name": "goOnline",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [],
        "desc": 
"Marks a staking pool key OFFLINE.
[ ONLY OWNER OR MANAGER CAN CALL ]"
,
        "events": undefined,
        "name": "goOffline",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": undefined,
            "name": "nfdAppId",
            "type": "uint64",
          },
          {
            "desc": undefined,
            "name": "nfdName",
            "type": "string",
          },
        ],
        "desc": undefined,
        "events": undefined,
        "name": "linkToNFD",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "void",
        },
      },
      {
        "args": [
          {
            "desc": "ValidatorPoolKey tuple",
            "name": "poolKey",
            "type": "(uint64,uint64,uint64)",
          },
        ],
        "desc": 
"proxiedSetTokenPayoutRatio is meant to be called by pools != 1 - calling US, pool #1
We need to verify that we are in fact being called by another of OUR pools (not us)
and then we'll call the validator on their behalf to update the token payouts"
,
        "events": undefined,
        "name": "proxiedSetTokenPayoutRatio",
        "readonly": undefined,
        "returns": {
          "desc": undefined,
          "type": "(uint64[24],uint64)",
        },
      },
    ],
    "name": "StakingPool",
  },
  "hints": {
    "addStake(pay,address)uint64": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "claimTokens()void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "createApplication(uint64,uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CREATE",
      },
    },
    "epochBalanceUpdate()void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "gas()void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "getStakerInfo(address)(address,uint64,uint64,uint64,uint64)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "goOffline()void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "initStorage(pay)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "linkToNFD(uint64,string)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "payTokenReward(address,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "removeStake(address,uint64)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
    "updateAlgodVer(string)void": {
      "call_config": {
        "no_op": "CALL",
      },
    },
  },
  "schema": {
    "global": {
      "declared": {
        "algodVer": {
          "key": "algodVer",
          "type": "bytes",
        },
        "binRoundStart": {
          "key": "binRoundStart",
          "type": "uint64",
        },
        "creatingValidatorContractAppId": {
          "key": "creatorApp",
          "type": "uint64",
        },
        "epochNumber": {
          "key": "epochNumber",
          "type": "uint64",
        },
        "lastPayout": {
          "key": "lastPayout",
          "type": "uint64",
        },
        "minEntryStake": {
          "key": "minEntryStake",
          "type": "uint64",
        },
        "numStakers": {
          "key": "numStakers",
          "type": "uint64",
        },
        "poolId": {
          "key": "poolId",
          "type": "uint64",
        },
        "rewardAccumulator": {
          "key": "rewardAccumulator",
          "type": "uint64",
        },
        "roundsPerDay": {
          "key": "roundsPerDay",
          "type": "uint64",
        },
        "stakeAccumulator": {
          "key": "stakeAccumulator",
          "type": "bytes",
        },
        "totalAlgoStaked": {
          "key": "staked",
          "type": "uint64",
        },
        "validatorId": {
          "key": "validatorId",
          "type": "uint64",
        },
        "weightedMovingAverage": {
          "key": "ewma",
          "type": "bytes",
        },
      },
      "reserved": {},
    },
    "local": {
      "declared": {},
      "reserved": {},
    },
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCmludGNibG9jayAwIDEgNiA2NCAzMiAxNiAxMjggMjAwIDUgMV8wMDBfMDAwIDMwMCAxMDAwIDQgMl8xMDBfMDAwIDggMTAwMDAwIDQwMCAzMDg1NyAyIDQwIDQ4IFRNUExfbmZkUmVnaXN0cnlBcHBJZApieXRlY2Jsb2NrIDB4IDB4NjM3MjY1NjE3NDZmNzI0MTcwNzAgMHg3Mzc0NjE2YjY1NzI3MyAweDc2NjE2YzY5NjQ2MTc0NmY3MjQ5NjQgMHg3MDZmNmY2YzQ5NjQgMHgwYTgxMDEgMHg3Mzc0NjE2YjY1NjQgMHg3MjZmNzU2ZTY0NzM1MDY1NzI0NDYxNzkgMHg3Mzc0NjE2YjY1NDE2MzYzNzU2ZDc1NmM2MTc0NmY3MiAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGIDB4MDAwMDAwMDAwMDAwMDAwMCAweDYyNjk2ZTUyNmY3NTZlNjQ1Mzc0NjE3Mjc0IDB4NzI2NTc3NjE3MjY0NDE2MzYzNzU2ZDc1NmM2MTc0NmY3MiAweDZlNzU2ZDUzNzQ2MTZiNjU3MjczIDB4NmM2MTczNzQ1MDYxNzk2Zjc1NzQgMHg3NWFmZjYxZCAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjQgMHg2ZDY5NmU0NTZlNzQ3Mjc5NTM3NDYxNmI2NSAweDY1NzA2ZjYzNjg0ZTc1NmQ2MjY1NzIgMHg2NTc3NmQ2MSAweDE1MWY3Yzc1IDB4YTJkYzUxYjUgMHg1NzI3NjdkMSAweDRkZjhkODZlIDB4MGMyMjQ1ZTEgMHgwMAoKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludGMgMiAvLyA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJLy8gVGhlIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udHJhY3QuIEFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgT25Db21wbGV0ZT8gRGlkIHlvdSBzZXQgeW91ciBhcHAgSUQ/CgllcnIKCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CgkvLyBtaW5FbnRyeVN0YWtlOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBwb29sSWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIHZhbGlkYXRvcklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBjcmVhdGluZ0NvbnRyYWN0SWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgY3JlYXRlQXBwbGljYXRpb24odWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgY3JlYXRlQXBwbGljYXRpb24KCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKGNyZWF0aW5nQ29udHJhY3RJZDogQXBwSUQsIHZhbGlkYXRvcklkOiB1aW50NjQsIHBvb2xJZDogdWludDY0LCBtaW5FbnRyeVN0YWtlOiB1aW50NjQpOiB2b2lkCi8vCi8vIEluaXRpYWxpemUgdGhlIHN0YWtpbmcgcG9vbCB3LyBvd25lciBhbmQgbWFuYWdlciwgYnV0IGNhbiBvbmx5IGJlIGNyZWF0ZWQgYnkgdGhlIHZhbGlkYXRvciBjb250cmFjdC4KLy8gQHBhcmFtIHt1aW50NjR9IGNyZWF0aW5nQ29udHJhY3RJZCAtIGlkIG9mIGNvbnRyYWN0IHRoYXQgY29uc3RydWN0ZWQgdXMgLSB0aGUgdmFsaWRhdG9yIGFwcGxpY2F0aW9uIChzaW5nbGUgZ2xvYmFsIGluc3RhbmNlKQovLyBAcGFyYW0ge3VpbnQ2NH0gdmFsaWRhdG9ySWQgLSBpZCBvZiB2YWxpZGF0b3Igd2UncmUgYSBzdGFraW5nIHBvb2wgb2YKLy8gQHBhcmFtIHt1aW50NjR9IHBvb2xJZCAtIHdoaWNoIHBvb2wgaWQgYXJlIHdlCi8vIEBwYXJhbSB7dWludDY0fSBtaW5FbnRyeVN0YWtlIC0gbWluaW11bSBhbW91bnQgdG8gYmUgaW4gcG9vbCwgYnV0IGFsc28gbWluaW11bSBhbW91bnQgYmFsYW5jZSBjYW4ndCBnbyBiZWxvdyAod2l0aG91dCByZW1vdmluZyBhbGwhKQpjcmVhdGVBcHBsaWNhdGlvbjoKCXByb3RvIDQgMAoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTAyCgkvLyBjcmVhdGluZ0NvbnRyYWN0SWQgPT09IEFwcElELmZyb21VaW50NjQoMCkKCWZyYW1lX2RpZyAtMSAvLyBjcmVhdGluZ0NvbnRyYWN0SWQ6IEFwcElECglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjBfZWxzZQoKCS8vICppZjBfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjEwNAoJLy8gYXNzZXJ0KHZhbGlkYXRvcklkID09PSAwKQoJZnJhbWVfZGlnIC0yIC8vIHZhbGlkYXRvcklkOiB1aW50NjQKCWludGMgMCAvLyAwCgk9PQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjEwNQoJLy8gYXNzZXJ0KHBvb2xJZCA9PT0gMCkKCWZyYW1lX2RpZyAtMyAvLyBwb29sSWQ6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT09Cglhc3NlcnQKCWIgKmlmMF9lbmQKCippZjBfZWxzZToKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMDcKCS8vIGFzc2VydCh2YWxpZGF0b3JJZCAhPT0gMCkKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJZDogdWludDY0CglpbnRjIDAgLy8gMAoJIT0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMDgKCS8vIGFzc2VydChwb29sSWQgIT09IDApCglmcmFtZV9kaWcgLTMgLy8gcG9vbElkOiB1aW50NjQKCWludGMgMCAvLyAwCgkhPQoJYXNzZXJ0CgoqaWYwX2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMTAKCS8vIGFzc2VydChtaW5FbnRyeVN0YWtlID49IE1JTl9BTEdPX1NUQUtFX1BFUl9QT09MLCAnc3Rha2luZyBwb29sIG11c3QgaGF2ZSBtaW5pbXVtIGVudHJ5IG9mIDEgYWxnbycpCglmcmFtZV9kaWcgLTQgLy8gbWluRW50cnlTdGFrZTogdWludDY0CglwdXNoaW50IDEwMDAwMDAKCT49CgoJLy8gc3Rha2luZyBwb29sIG11c3QgaGF2ZSBtaW5pbXVtIGVudHJ5IG9mIDEgYWxnbwoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjExMQoJLy8gdGhpcy5jcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSWQudmFsdWUgPSBjcmVhdGluZ0NvbnRyYWN0SWQKCWJ5dGVjIDEgLy8gICJjcmVhdG9yQXBwIgoJZnJhbWVfZGlnIC0xIC8vIGNyZWF0aW5nQ29udHJhY3RJZDogQXBwSUQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjExMgoJLy8gdGhpcy52YWxpZGF0b3JJZC52YWx1ZSA9IHZhbGlkYXRvcklkCglieXRlYyAzIC8vICAidmFsaWRhdG9ySWQiCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySWQ6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTEzCgkvLyB0aGlzLnBvb2xJZC52YWx1ZSA9IHBvb2xJZAoJYnl0ZWMgNCAvLyAgInBvb2xJZCIKCWZyYW1lX2RpZyAtMyAvLyBwb29sSWQ6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTE0CgkvLyB0aGlzLm51bVN0YWtlcnMudmFsdWUgPSAwCglieXRlYyAxMyAvLyAgIm51bVN0YWtlcnMiCglpbnRjIDAgLy8gMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTE1CgkvLyB0aGlzLnRvdGFsQWxnb1N0YWtlZC52YWx1ZSA9IDAKCWJ5dGVjIDYgLy8gICJzdGFrZWQiCglpbnRjIDAgLy8gMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTE2CgkvLyB0aGlzLm1pbkVudHJ5U3Rha2UudmFsdWUgPSBtaW5FbnRyeVN0YWtlCglieXRlYyAxOCAvLyAgIm1pbkVudHJ5U3Rha2UiCglmcmFtZV9kaWcgLTQgLy8gbWluRW50cnlTdGFrZTogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMTcKCS8vIHRoaXMubGFzdFBheW91dC52YWx1ZSA9IGdsb2JhbHMucm91bmQKCWJ5dGVjIDE0IC8vICAibGFzdFBheW91dCIKCWdsb2JhbCBSb3VuZAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTE4CgkvLyB0aGlzLmVwb2NoTnVtYmVyLnZhbHVlID0gMAoJYnl0ZWMgMTkgLy8gICJlcG9jaE51bWJlciIKCWludGMgMCAvLyAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMjAKCS8vIHRoaXMuc2V0Um91bmRzUGVyRGF5KCkKCWNhbGxzdWIgc2V0Um91bmRzUGVyRGF5CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjEyMQoJLy8gdGhpcy5iaW5Sb3VuZFN0YXJ0LnZhbHVlID0gZ2xvYmFscy5yb3VuZCAtIChnbG9iYWxzLnJvdW5kICUgdGhpcy5yb3VuZHNQZXJEYXkudmFsdWUpCglieXRlYyAxMSAvLyAgImJpblJvdW5kU3RhcnQiCglnbG9iYWwgUm91bmQKCWdsb2JhbCBSb3VuZAoJYnl0ZWMgNyAvLyAgInJvdW5kc1BlckRheSIKCWFwcF9nbG9iYWxfZ2V0CgklCgktCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMjIKCS8vIHRoaXMuc3Rha2VBY2N1bXVsYXRvci52YWx1ZSA9IDAgYXMgdWludDEyOAoJYnl0ZWMgOCAvLyAgInN0YWtlQWNjdW11bGF0b3IiCglieXRlYyAxNiAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMjMKCS8vIHRoaXMucmV3YXJkQWNjdW11bGF0b3IudmFsdWUgPSAwCglieXRlYyAxMiAvLyAgInJld2FyZEFjY3VtdWxhdG9yIgoJaW50YyAwIC8vIDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjEyNAoJLy8gdGhpcy53ZWlnaHRlZE1vdmluZ0F2ZXJhZ2UudmFsdWUgPSAwIGFzIHVpbnQxMjgKCWJ5dGVjIDIwIC8vICAiZXdtYSIKCWJ5dGVjIDE2IC8vIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGdhcygpdm9pZAoqYWJpX3JvdXRlX2dhczoKCS8vIGV4ZWN1dGUgZ2FzKCl2b2lkCgljYWxsc3ViIGdhcwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2FzKCk6IHZvaWQKLy8KLy8gZ2FzIGlzIGEgZHVtbXkgbm8tb3AgY2FsbCB0aGF0IGNhbiBiZSB1c2VkIHRvIHBvb2wtdXAgcmVzb3VyY2UgcmVmZXJlbmNlcyBhbmQgb3Bjb2RlIGNvc3QKZ2FzOgoJcHJvdG8gMCAwCglyZXRzdWIKCi8vIGNvc3RGb3JCb3hTdG9yYWdlKHRvdGFsTnVtQnl0ZXM6IHVpbnQ2NCk6IHVpbnQ2NApjb3N0Rm9yQm94U3RvcmFnZToKCXByb3RvIDEgMQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMzYKCS8vIHJldHVybiBTQ0JPWF9QRVJCT1ggKyB0b3RhbE51bUJ5dGVzICogU0NCT1hfUEVSQllURTsKCXB1c2hpbnQgMjUwMAoJZnJhbWVfZGlnIC0xIC8vIHRvdGFsTnVtQnl0ZXM6IHVpbnQ2NAoJaW50YyAxNiAvLyA0MDAKCSoKCSsKCXJldHN1YgoKLy8gaW5pdFN0b3JhZ2UocGF5KXZvaWQKKmFiaV9yb3V0ZV9pbml0U3RvcmFnZToKCS8vIG1iclBheW1lbnQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludGMgMSAvLyAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnRjIDEgLy8gIHBheQoJPT0KCgkvLyBhcmd1bWVudCAwIChtYnJQYXltZW50KSBmb3IgaW5pdFN0b3JhZ2UgbXVzdCBiZSBhIHBheSB0cmFuc2FjdGlvbgoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBpbml0U3RvcmFnZShwYXkpdm9pZAoJY2FsbHN1YiBpbml0U3RvcmFnZQoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gaW5pdFN0b3JhZ2UobWJyUGF5bWVudDogUGF5VHhuKTogdm9pZAovLwovLyBDYWxsZWQgYWZ0ZXIgd2UncmUgY3JlYXRlZCBhbmQgdGhlbiBmdW5kZWQsIHNvIHdlIGNhbiBjcmVhdGUgb3VyIGxhcmdlIHN0YWtlcnMgbGVkZ2VyIHN0b3JhZ2UKLy8gQ2FsbGVyIGhhcyB0byBnZXQgTUJSIGFtb3VudHMgZnJvbSBWYWxpZGF0b3JSZWdpc3RyeSB0byBrbm93IGhvdyBtdWNoIHRvIGZ1bmQgdXMgdG8gY292ZXIgdGhlIGJveCBzdG9yYWdlIGNvc3QKLy8gSWYgdGhpcyBpcyBwb29sIDEgQU5EIHRoZSB2YWxpZGF0b3IgaGFzIHNwZWNpZmllZCBhIHJld2FyZCB0b2tlbiwgb3B0LWluIHRvIHRoYXQgdG9rZW4KLy8gc28gdGhhdCB0aGUgdmFsaWRhdG9yIGNhbiBzZWVkIHRoZSBwb29sIHdpdGggZnV0dXJlIHJld2FyZHMgb2YgdGhhdCB0b2tlbi4KLy8gQHBhcmFtIG1iclBheW1lbnQgcGF5bWVudCBmcm9tIGNhbGxlciB3aGljaCBjb3ZlcnMgbWJyIGluY3JlYXNlIG9mIG5ldyBzdGFraW5nIHBvb2xzJyBzdG9yYWdlCmluaXRTdG9yYWdlOgoJcHJvdG8gMSAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gMwoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxNDcKCS8vIGFzc2VydCghdGhpcy5zdGFrZXJzLmV4aXN0cywgJ3N0YWtpbmcgcG9vbCBhbHJlYWR5IGluaXRpYWxpemVkJykKCWJ5dGVjIDIgLy8gICJzdGFrZXJzIgoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCgoJLy8gc3Rha2luZyBwb29sIGFscmVhZHkgaW5pdGlhbGl6ZWQKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxNTAKCS8vIHZhbGlkYXRvckNvbmZpZyA9IHNlbmRNZXRob2RDYWxsPHR5cGVvZiBWYWxpZGF0b3JSZWdpc3RyeS5wcm90b3R5cGUuZ2V0VmFsaWRhdG9yQ29uZmlnPih7CgkvLyAgICAgICBhcHBsaWNhdGlvbklEOiB0aGlzLmNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJZC52YWx1ZSwKCS8vICAgICAgIG1ldGhvZEFyZ3M6IFt0aGlzLnZhbGlkYXRvcklkLnZhbHVlXSwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAyIC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglieXRlYyAxNSAvLyAgbWV0aG9kICJnZXRWYWxpZGF0b3JDb25maWcodWludDY0KSh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KSIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjE1MQoJLy8gYXBwbGljYXRpb25JRDogdGhpcy5jcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSWQudmFsdWUKCWJ5dGVjIDEgLy8gICJjcmVhdG9yQXBwIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxNTIKCS8vIG1ldGhvZEFyZ3M6IFt0aGlzLnZhbGlkYXRvcklkLnZhbHVlXQoJYnl0ZWMgMyAvLyAgInZhbGlkYXRvcklkIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnRjIDEgLy8gMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCglmcmFtZV9idXJ5IDAgLy8gdmFsaWRhdG9yQ29uZmlnOiAodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTU0CgkvLyBpc1Rva2VuRWxpZ2libGUgPSB2YWxpZGF0b3JDb25maWcucmV3YXJkVG9rZW5JZCAhPT0gMAoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9yQ29uZmlnOiAodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMTUzIDgKCWJ0b2kKCWludGMgMCAvLyAwCgkhPQoJZnJhbWVfYnVyeSAxIC8vIGlzVG9rZW5FbGlnaWJsZTogYm9vbAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxNTUKCS8vIGV4dHJhTUJSID0gaXNUb2tlbkVsaWdpYmxlICYmIHRoaXMucG9vbElkLnZhbHVlID09PSAxID8gQVNTRVRfSE9MRElOR19GRUUgOiAwCglmcmFtZV9kaWcgMSAvLyBpc1Rva2VuRWxpZ2libGU6IGJvb2wKCWR1cAoJYnogKnNraXBfYW5kMAoJYnl0ZWMgNCAvLyAgInBvb2xJZCIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDEgLy8gMQoJPT0KCSYmCgoqc2tpcF9hbmQwOgoJYnogKnRlcm5hcnkwX2ZhbHNlCglpbnRjIDE1IC8vIDEwMDAwMAoJYiAqdGVybmFyeTBfZW5kCgoqdGVybmFyeTBfZmFsc2U6CglpbnRjIDAgLy8gMAoKKnRlcm5hcnkwX2VuZDoKCWZyYW1lX2J1cnkgMiAvLyBleHRyYU1CUjogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjE1NgoJLy8gUG9vbEluaXRNYnIgPQoJLy8gICAgICAgQUxHT1JBTkRfQUNDT1VOVF9NSU5fQkFMQU5DRSArCgkvLyAgICAgICBleHRyYU1CUiArCgkvLyAgICAgICB0aGlzLmNvc3RGb3JCb3hTdG9yYWdlKDcgLyogJ3N0YWtlcnMnIG5hbWUgKi8gKyBsZW48U3Rha2VkSW5mbz4oKSAqIE1BWF9TVEFLRVJTX1BFUl9QT09MKQoJaW50YyAxNSAvLyAxMDAwMDAKCWZyYW1lX2RpZyAyIC8vIGV4dHJhTUJSOiB1aW50NjQKCSsKCXB1c2hpbnQgMTI4MDcKCWNhbGxzdWIgY29zdEZvckJveFN0b3JhZ2UKCSsKCWZyYW1lX2J1cnkgMyAvLyBQb29sSW5pdE1icjogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjE2MgoJLy8gdmVyaWZ5UGF5VHhuKG1iclBheW1lbnQsIHsgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsIGFtb3VudDogUG9vbEluaXRNYnIgfSkKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIG1iclBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoibWJyUGF5bWVudCIsImZpZWxkIjoicmVjZWl2ZXIiLCJleHBlY3RlZCI6InRoaXMuYXBwLmFkZHJlc3MifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIG1iclBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgMyAvLyBQb29sSW5pdE1icjogdWludDY0Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoibWJyUGF5bWVudCIsImZpZWxkIjoiYW1vdW50IiwiZXhwZWN0ZWQiOiJQb29sSW5pdE1iciJ9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTYzCgkvLyB0aGlzLnN0YWtlcnMuY3JlYXRlKCkKCWJ5dGVjIDIgLy8gICJzdGFrZXJzIgoJcHVzaGludCAxMjgwMAoJYm94X2NyZWF0ZQoJcG9wCgoJLy8gKmlmMV9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxNjUKCS8vIGlzVG9rZW5FbGlnaWJsZSAmJiB0aGlzLnBvb2xJZC52YWx1ZSA9PT0gMQoJZnJhbWVfZGlnIDEgLy8gaXNUb2tlbkVsaWdpYmxlOiBib29sCglkdXAKCWJ6ICpza2lwX2FuZDEKCWJ5dGVjIDQgLy8gICJwb29sSWQiCglhcHBfZ2xvYmFsX2dldAoJaW50YyAxIC8vIDEKCT09CgkmJgoKKnNraXBfYW5kMToKCWJ6ICppZjFfZW5kCgoJLy8gKmlmMV9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTY3CgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHZhbGlkYXRvckNvbmZpZy5yZXdhcmRUb2tlbklkKSwKCS8vICAgICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgYXNzZXRBbW91bnQ6IDAsCgkvLyAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxMiAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTY4CgkvLyB4ZmVyQXNzZXQ6IEFzc2V0SUQuZnJvbVVpbnQ2NCh2YWxpZGF0b3JDb25maWcucmV3YXJkVG9rZW5JZCkKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvckNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDE1MyA4CglidG9pCglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxNjkKCS8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTcwCgkvLyBhc3NldEFtb3VudDogMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoqaWYxX2VuZDoKCXJldHN1YgoKLy8gYWRkU3Rha2UocGF5LGFkZHJlc3MpdWludDY0CiphYmlfcm91dGVfYWRkU3Rha2U6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIxIC8vIDB4MTUxZjdjNzUKCgkvLyBzdGFrZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDQgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMCAoc3Rha2VyKSBmb3IgYWRkU3Rha2UgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludGMgMSAvLyAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnRjIDEgLy8gIHBheQoJPT0KCgkvLyBhcmd1bWVudCAxIChzdGFrZWRBbW91bnRQYXltZW50KSBmb3IgYWRkU3Rha2UgbXVzdCBiZSBhIHBheSB0cmFuc2FjdGlvbgoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBhZGRTdGFrZShwYXksYWRkcmVzcyl1aW50NjQKCWNhbGxzdWIgYWRkU3Rha2UKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBhZGRTdGFrZShzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4sIHN0YWtlcjogQWRkcmVzcyk6IHVpbnQ2NAovLwovLyBBZGRzIHN0YWtlIHRvIHRoZSBnaXZlbiBhY2NvdW50LgovLyBDYW4gT05MWSBiZSBjYWxsZWQgYnkgdGhlIHZhbGlkYXRvciBjb250cmFjdCB0aGF0IGNyZWF0ZWQgdXMKLy8gTXVzdCByZWNlaXZlIHBheW1lbnQgZnJvbSB0aGUgdmFsaWRhdG9yIGNvbnRyYWN0IGZvciBhbW91bnQgYmVpbmcgc3Rha2VkLgovLwovLyBAcGFyYW0ge1BheVR4bn0gc3Rha2VkQW1vdW50UGF5bWVudCBwcmlvciBwYXltZW50IGNvbWluZyBmcm9tIHZhbGlkYXRvciBjb250cmFjdCB0byB1cyBvbiBiZWhhbGYgb2Ygc3Rha2VyLgovLyBAcGFyYW0ge0FkZHJlc3N9IHN0YWtlciAtIFRoZSBhY2NvdW50IGFkZGluZyBuZXcgc3Rha2UKLy8gQHRocm93cyB7RXJyb3J9IC0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzdGFraW5nIHBvb2wgaXMgZnVsbC4KLy8gQHJldHVybnMge3VpbnQ2NH0gbmV3ICdlbnRyeSByb3VuZCcgcm91bmQgbnVtYmVyIG9mIHN0YWtlIGFkZAphZGRTdGFrZToKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXBuIDQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTg2CgkvLyBhc3NlcnQodGhpcy5zdGFrZXJzLmV4aXN0cywgJ3N0YWtpbmcgcG9vbCBtdXN0IGJlIGluaXRpYWxpemVkIGZpcnN0JykKCWJ5dGVjIDIgLy8gICJzdGFrZXJzIgoJYm94X2xlbgoJc3dhcAoJcG9wCgoJLy8gc3Rha2luZyBwb29sIG11c3QgYmUgaW5pdGlhbGl6ZWQgZmlyc3QKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxODkKCS8vIGFzc2VydCgKCS8vICAgICAgIHRoaXMudHhuLnNlbmRlciA9PT0gdGhpcy5jcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSWQudmFsdWUuYWRkcmVzcywKCS8vICAgICAgICdzdGFrZSBjYW4gb25seSBiZSBhZGRlZCB2aWEgdGhlIHZhbGlkYXRvciBjb250cmFjdCcKCS8vICAgICApCgl0eG4gU2VuZGVyCglieXRlYyAxIC8vICAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCT09CgoJLy8gc3Rha2UgY2FuIG9ubHkgYmUgYWRkZWQgdmlhIHRoZSB2YWxpZGF0b3IgY29udHJhY3QKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxOTMKCS8vIGFzc2VydChzdGFrZXIgIT09IGdsb2JhbHMuemVyb0FkZHJlc3MpCglmcmFtZV9kaWcgLTIgLy8gc3Rha2VyOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTk2CgkvLyB0aGlzLmNoZWNrSWZCaW5DbG9zZWQoKQoJY2FsbHN1YiBjaGVja0lmQmluQ2xvc2VkCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjIwMAoJLy8gdmVyaWZ5UGF5VHhuKHN0YWtlZEFtb3VudFBheW1lbnQsIHsKCS8vICAgICAgIHNlbmRlcjogdGhpcy5jcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSWQudmFsdWUuYWRkcmVzcywKCS8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgYW1vdW50OiBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudCwKCS8vICAgICB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgU2VuZGVyCglieXRlYyAxIC8vICAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJzdGFrZWRBbW91bnRQYXltZW50IiwiZmllbGQiOiJzZW5kZXIiLCJleHBlY3RlZCI6InRoaXMuY3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElkLnZhbHVlLmFkZHJlc3MifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJzdGFrZWRBbW91bnRQYXltZW50IiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InN0YWtlZEFtb3VudFBheW1lbnQiLCJmaWVsZCI6ImFtb3VudCIsImV4cGVjdGVkIjoic3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQifQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjIwOQoJLy8gZW50cnlSb3VuZCA9IGdsb2JhbHMucm91bmQgKyBBTEdPUkFORF9TVEFLSU5HX0JMT0NLX0RFTEFZCglnbG9iYWwgUm91bmQKCXB1c2hpbnQgMzIwCgkrCglmcmFtZV9idXJ5IDAgLy8gZW50cnlSb3VuZDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjIxMAoJLy8gZmlyc3RFbXB0eSA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDEgLy8gZmlyc3RFbXB0eTogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjIxMgoJLy8gdGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgKz0gc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQKCWJ5dGVjIDYgLy8gICJzdGFrZWQiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CgkrCglieXRlYyA2IC8vICAic3Rha2VkIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MjE0CgkvLyByb3VuZHNMZWZ0SW5CaW4gPSB0aGlzLmJpblJvdW5kU3RhcnQudmFsdWUgKyB0aGlzLnJvdW5kc1BlckRheS52YWx1ZSAtIGdsb2JhbHMucm91bmQKCWJ5dGVjIDExIC8vICAiYmluUm91bmRTdGFydCIKCWFwcF9nbG9iYWxfZ2V0CglieXRlYyA3IC8vICAicm91bmRzUGVyRGF5IgoJYXBwX2dsb2JhbF9nZXQKCSsKCWdsb2JhbCBSb3VuZAoJLQoJZnJhbWVfYnVyeSAyIC8vIHJvdW5kc0xlZnRJbkJpbjogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjIxNQoJLy8gdGhpcy5zdGFrZUFjY3VtdWxhdG9yLnZhbHVlID0KCS8vICAgICAgIHRoaXMuc3Rha2VBY2N1bXVsYXRvci52YWx1ZSArIChzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudCBhcyB1aW50MTI4KSAqIChyb3VuZHNMZWZ0SW5CaW4gYXMgdWludDEyOCkKCWJ5dGVjIDggLy8gICJzdGFrZUFjY3VtdWxhdG9yIgoJZHVwCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglpdG9iCglmcmFtZV9kaWcgMiAvLyByb3VuZHNMZWZ0SW5CaW46IHVpbnQ2NAoJaXRvYgoJYioKCWIrCglkdXAKCWJpdGxlbgoJaW50YyA2IC8vIDEyOAoJPD0KCgkvLyB0aGlzLnN0YWtlQWNjdW11bGF0b3IudmFsdWUgKyAoc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQgYXMgdWludDEyOCkgKiAocm91bmRzTGVmdEluQmluIGFzIHVpbnQxMjgpIG92ZXJmbG93ZWQgMTI4IGJpdHMKCWFzc2VydAoJYnl0ZWMgOSAvLyAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50YyA1IC8vIDE2CgktCglzd2FwCglzdWJzdHJpbmczCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyMTkKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFrZXJzLnZhbHVlLmxlbmd0aDsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMyAvLyBpOiB1aW50NjQKCipmb3JfMDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyMTkKCS8vIGkgPCB0aGlzLnN0YWtlcnMudmFsdWUubGVuZ3RoCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludGMgNyAvLyAyMDAKCTwKCWJ6ICpmb3JfMF9lbmQKCgkvLyAqaWYyX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjIyMAoJLy8gZ2xvYmFscy5vcGNvZGVCdWRnZXQgPCAzMDAKCWdsb2JhbCBPcGNvZGVCdWRnZXQKCWludGMgMTAgLy8gMzAwCgk8CglieiAqaWYyX2VuZAoKCS8vICppZjJfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjIyMQoJLy8gaW5jcmVhc2VPcGNvZGVCdWRnZXQoKQoJaXR4bl9iZWdpbgoJaW50YyAyIC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCWJ5dGVjIDUgLy8gICNwcmFnbWEgdmVyc2lvbiAxMDsgaW50IDEKCWR1cAoJaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KCWl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KCWludGMgOCAvLyAgRGVsZXRlQXBwbGljYXRpb24KCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMl9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MjIzCgkvLyBjbXBTdGFrZXIgPSBjbG9uZSh0aGlzLnN0YWtlcnMudmFsdWVbaV0pCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludGMgMyAvLyA2NAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDMgLy8gNjQKCWJ5dGVjIDIgLy8gICJzdGFrZXJzIgoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWZyYW1lX2J1cnkgNCAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyAqaWYzX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjIyNAoJLy8gY21wU3Rha2VyLmFjY291bnQgPT09IHN0YWtlcgoJZnJhbWVfZGlnIDQgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDAgMzIKCWZyYW1lX2RpZyAtMiAvLyBzdGFrZXI6IEFkZHJlc3MKCT09CglieiAqaWYzX2VuZAoKCS8vICppZjNfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjIyNgoJLy8gY21wU3Rha2VyLmJhbGFuY2UgKz0gc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQKCWZyYW1lX2RpZyA0IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJaW50YyA0IC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgNCAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CgkrCglpdG9iCglyZXBsYWNlMwoJZnJhbWVfYnVyeSA0IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyMjcKCS8vIGNtcFN0YWtlci5lbnRyeVJvdW5kID0gZW50cnlSb3VuZAoJZnJhbWVfZGlnIDQgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglwdXNoaW50IDU2IC8vIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAwIC8vIGVudHJ5Um91bmQ6IHVpbnQ2NAoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgNCAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MjMwCgkvLyB0aGlzLnN0YWtlcnMudmFsdWVbaV0gPSBjbXBTdGFrZXIKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDY0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWZyYW1lX2RpZyA0IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZWMgMiAvLyAgInN0YWtlcnMiCgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyMzIKCS8vIHJldHVybiBlbnRyeVJvdW5kOwoJZnJhbWVfZGlnIDAgLy8gZW50cnlSb3VuZDogdWludDY0CgliICphZGRTdGFrZSpyZXR1cm4KCippZjNfZW5kOgoJLy8gKmlmNF9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyMzQKCS8vIGZpcnN0RW1wdHkgPT09IDAgJiYgY21wU3Rha2VyLmFjY291bnQgPT09IGdsb2JhbHMuemVyb0FkZHJlc3MKCWZyYW1lX2RpZyAxIC8vIGZpcnN0RW1wdHk6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT09CglkdXAKCWJ6ICpza2lwX2FuZDIKCWZyYW1lX2RpZyA0IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAwIDMyCglnbG9iYWwgWmVyb0FkZHJlc3MKCT09CgkmJgoKKnNraXBfYW5kMjoKCWJ6ICppZjRfZW5kCgoJLy8gKmlmNF9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MjM1CgkvLyBmaXJzdEVtcHR5ID0gaSArIDEKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBmaXJzdEVtcHR5OiB1aW50NjQKCippZjRfZW5kOgoKKmZvcl8wX2NvbnRpbnVlOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjIxOQoJLy8gaSArPSAxCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDMgLy8gaTogdWludDY0CgliICpmb3JfMAoKKmZvcl8wX2VuZDoKCS8vICppZjVfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MjM5CgkvLyBmaXJzdEVtcHR5ID09PSAwCglmcmFtZV9kaWcgMSAvLyBmaXJzdEVtcHR5OiB1aW50NjQKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmNV9lbmQKCgkvLyAqaWY1X2NvbnNlcXVlbnQKCS8vIFN0YWtpbmcgcG9vbCBmdWxsCgllcnIKCippZjVfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjI0NgoJLy8gYXNzZXJ0KHN0YWtlZEFtb3VudFBheW1lbnQuYW1vdW50ID49IHRoaXMubWluRW50cnlTdGFrZS52YWx1ZSwgJ211c3Qgc3Rha2UgYXQgbGVhc3QgdGhlIG1pbmltdW0gZm9yIHRoaXMgcG9vbCcpCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWJ5dGVjIDE4IC8vICAibWluRW50cnlTdGFrZSIKCWFwcF9nbG9iYWxfZ2V0Cgk+PQoKCS8vIG11c3Qgc3Rha2UgYXQgbGVhc3QgdGhlIG1pbmltdW0gZm9yIHRoaXMgcG9vbAoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjI0OAoJLy8gYXNzZXJ0KHRoaXMuc3Rha2Vycy52YWx1ZVtmaXJzdEVtcHR5IC0gMV0uYWNjb3VudCA9PT0gZ2xvYmFscy56ZXJvQWRkcmVzcykKCWZyYW1lX2RpZyAxIC8vIGZpcnN0RW1wdHk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCS0KCWludGMgMyAvLyA2NAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDAgLy8gMAoJKwoJaW50YyA0IC8vIDMyCglieXRlYyAyIC8vICAic3Rha2VycyIKCWNvdmVyIDIKCWJveF9leHRyYWN0CglnbG9iYWwgWmVyb0FkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MjQ5CgkvLyB0aGlzLnN0YWtlcnMudmFsdWVbZmlyc3RFbXB0eSAtIDFdID0gewoJLy8gICAgICAgYWNjb3VudDogc3Rha2VyLAoJLy8gICAgICAgYmFsYW5jZTogc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQsCgkvLyAgICAgICB0b3RhbFJld2FyZGVkOiAwLAoJLy8gICAgICAgcmV3YXJkVG9rZW5CYWxhbmNlOiAwLAoJLy8gICAgICAgZW50cnlSb3VuZDogZW50cnlSb3VuZCwKCS8vICAgICB9CglmcmFtZV9kaWcgMSAvLyBmaXJzdEVtcHR5OiB1aW50NjQKCWludGMgMSAvLyAxCgktCglpbnRjIDMgLy8gNjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJZnJhbWVfZGlnIC0yIC8vIHN0YWtlcjogQWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglpdG9iCgljb25jYXQKCWJ5dGVjIDEwIC8vIDB4MDAwMDAwMDAwMDAwMDAwMAoJY29uY2F0CglieXRlYyAxMCAvLyAweDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJZnJhbWVfZGlnIDAgLy8gZW50cnlSb3VuZDogdWludDY0CglpdG9iCgljb25jYXQKCWJ5dGVjIDIgLy8gICJzdGFrZXJzIgoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MjU2CgkvLyB0aGlzLm51bVN0YWtlcnMudmFsdWUgKz0gMQoJYnl0ZWMgMTMgLy8gICJudW1TdGFrZXJzIgoJYXBwX2dsb2JhbF9nZXQKCWludGMgMSAvLyAxCgkrCglieXRlYyAxMyAvLyAgIm51bVN0YWtlcnMiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyNTcKCS8vIHJldHVybiBlbnRyeVJvdW5kOwoJZnJhbWVfZGlnIDAgLy8gZW50cnlSb3VuZDogdWludDY0CgoqYWRkU3Rha2UqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gNAoJcmV0c3ViCgovLyByZW1vdmVTdGFrZShhZGRyZXNzLHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfcmVtb3ZlU3Rha2U6CgkvLyBhbW91bnRUb1Vuc3Rha2U6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHN0YWtlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgNCAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAxIChzdGFrZXIpIGZvciByZW1vdmVTdGFrZSBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSByZW1vdmVTdGFrZShhZGRyZXNzLHVpbnQ2NCl2b2lkCgljYWxsc3ViIHJlbW92ZVN0YWtlCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyByZW1vdmVTdGFrZShzdGFrZXI6IEFkZHJlc3MsIGFtb3VudFRvVW5zdGFrZTogdWludDY0KTogdm9pZAovLwovLyBSZW1vdmVzIHN0YWtlIG9uIGJlaGFsZiBvZiBjYWxsZXIgKHJlbW92aW5nIG93biBzdGFrZSkuICBJZiBhbnkgdG9rZW4gcmV3YXJkcyBleGlzdCwgdGhvc2UgYXJlIGFsd2F5cyBzZW50IGluCi8vIGZ1bGwuIEFsc28gbm90aWZpZXMgdGhlIHZhbGlkYXRvciBjb250cmFjdCBmb3IgdGhpcyBwb29scyB2YWxpZGF0b3Igb2YgdGhlIHN0YWtlciAvIGJhbGFuY2UgY2hhbmdlcy4KLy8KLy8gQHBhcmFtIHtBZGRyZXNzfSBzdGFrZXIgLSBhY2NvdW50IHRvIHJlbW92ZS4gIG5vcm1hbGx5IHNhbWUgYXMgc2VuZGVyLCBidXQgdGhlIHZhbGlkYXRvciBvd25lciBvciBtYW5hZ2VyIGNhbiBhbHNvIGNhbGwKLy8gdGhpcyB0byByZW1vdmUgdGhlIHNwZWNpZmllZCBzdGFrZXIgZXhwbGljaXRseS4gVGhlIHJlbW92ZWQgc3Rha2UgTVVTVCBvbmx5IGdvIHRvIHRoZSBzdGFrZXIgb2YgY291cnNlLiAgVGhpcyBpcwovLyBzbyBhIHZhbGlkYXRvciBjYW4gc2h1dCBkb3duIGEgcG9vb2wgYW5kIHJlZnVuZCB0aGUgc3Rha2Vycy4gIEl0IGNhbiBhbHNvIGJlIHVzZWQgdG8ga2ljayBvdXQgc3Rha2VycyB3aG8gbm8gbG9uZ2VyCi8vIG1lZXQgdGhlIGdhdGluZyByZXF1aXJlbWVudHMgKGRldGVybWluZWQgYnkgdGhlIG5vZGUgZGFlbW9uKS4KLy8gQHBhcmFtIHt1aW50NjR9IGFtb3VudFRvVW5zdGFrZSAtIFRoZSBhbW91bnQgb2Ygc3Rha2UgdG8gYmUgcmVtb3ZlZC4gIFNwZWNpZnkgMCB0byByZW1vdmUgYWxsIHN0YWtlLgovLyBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGFjY291bnQgaGFzIGluc3VmZmljaWVudCBiYWxhbmNlIG9yIGlmIHRoZSBhY2NvdW50IGlzIG5vdCBmb3VuZC4KcmVtb3ZlU3Rha2U6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiA2CgoJLy8gKmlmNl9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyNzQKCS8vIHN0YWtlciAhPT0gdGhpcy50eG4uc2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VyOiBBZGRyZXNzCgl0eG4gU2VuZGVyCgkhPQoJYnogKmlmNl9lbmQKCgkvLyAqaWY2X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyNzUKCS8vIGFzc2VydCgKCS8vICAgICAgICAgdGhpcy5pc093bmVyT3JNYW5hZ2VyQ2FsbGVyKCksCgkvLyAgICAgICAgICdJZiBzdGFrZXIgaXMgbm90IHNlbmRlciBpbiByZW1vdmVTdGFrZSBjYWxsLCB0aGVuIHNlbmRlciBNVVNUIGJlIG93bmVyIG9yIG1hbmFnZXIgb2YgdmFsaWRhdG9yJwoJLy8gICAgICAgKQoJY2FsbHN1YiBpc093bmVyT3JNYW5hZ2VyQ2FsbGVyCgoJLy8gSWYgc3Rha2VyIGlzIG5vdCBzZW5kZXIgaW4gcmVtb3ZlU3Rha2UgY2FsbCwgdGhlbiBzZW5kZXIgTVVTVCBiZSBvd25lciBvciBtYW5hZ2VyIG9mIHZhbGlkYXRvcgoJYXNzZXJ0CgoqaWY2X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyODEKCS8vIHRoaXMuY2hlY2tJZkJpbkNsb3NlZCgpCgljYWxsc3ViIGNoZWNrSWZCaW5DbG9zZWQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MjgzCgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3Rha2Vycy52YWx1ZS5sZW5ndGg7IGkgKz0gMSkKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDAgLy8gaTogdWludDY0CgoqZm9yXzE6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MjgzCgkvLyBpIDwgdGhpcy5zdGFrZXJzLnZhbHVlLmxlbmd0aAoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0CglpbnRjIDcgLy8gMjAwCgk8CglieiAqZm9yXzFfZW5kCgoJLy8gKmlmN19jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyODQKCS8vIGdsb2JhbHMub3Bjb2RlQnVkZ2V0IDwgMzAwCglnbG9iYWwgT3Bjb2RlQnVkZ2V0CglpbnRjIDEwIC8vIDMwMAoJPAoJYnogKmlmN19lbmQKCgkvLyAqaWY3X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyODUKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludGMgMiAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCglieXRlYyA1IC8vICAjcHJhZ21hIHZlcnNpb24gMTA7IGludCAxCglkdXAKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCglpbnRjIDggLy8gIERlbGV0ZUFwcGxpY2F0aW9uCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoJaXR4bl9zdWJtaXQKCippZjdfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjI4NwoJLy8gY21wU3Rha2VyID0gY2xvbmUodGhpcy5zdGFrZXJzLnZhbHVlW2ldKQoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0CglpbnRjIDMgLy8gNjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAzIC8vIDY0CglieXRlYyAyIC8vICAic3Rha2VycyIKCWNvdmVyIDIKCWJveF9leHRyYWN0CglmcmFtZV9idXJ5IDEgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCgoJLy8gKmlmOF9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyODgKCS8vIGNtcFN0YWtlci5hY2NvdW50ID09PSBzdGFrZXIKCWZyYW1lX2RpZyAxIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAwIDMyCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VyOiBBZGRyZXNzCgk9PQoJYnogKmlmOF9lbmQKCgkvLyAqaWY4X2NvbnNlcXVlbnQKCS8vICppZjlfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6Mjg5CgkvLyBhbW91bnRUb1Vuc3Rha2UgPT09IDAKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnRUb1Vuc3Rha2U6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT09CglieiAqaWY5X2VuZAoKCS8vICppZjlfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjI5MQoJLy8gYW1vdW50VG9VbnN0YWtlID0gY21wU3Rha2VyLmJhbGFuY2UKCWZyYW1lX2RpZyAxIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAzMiA4CglidG9pCglmcmFtZV9idXJ5IC0yIC8vIGFtb3VudFRvVW5zdGFrZTogdWludDY0CgoqaWY5X2VuZDoKCS8vICppZjEwX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjI5MwoJLy8gY21wU3Rha2VyLmJhbGFuY2UgPCBhbW91bnRUb1Vuc3Rha2UKCWZyYW1lX2RpZyAxIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAzMiA4CglidG9pCglmcmFtZV9kaWcgLTIgLy8gYW1vdW50VG9VbnN0YWtlOiB1aW50NjQKCTwKCWJ6ICppZjEwX2VuZAoKCS8vICppZjEwX2NvbnNlcXVlbnQKCS8vIEluc3VmZmljaWVudCBiYWxhbmNlCgllcnIKCippZjEwX2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoyOTYKCS8vIGNtcFN0YWtlci5iYWxhbmNlIC09IGFtb3VudFRvVW5zdGFrZQoJZnJhbWVfZGlnIDEgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglpbnRjIDQgLy8gIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAxIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAzMiA4CglidG9pCglmcmFtZV9kaWcgLTIgLy8gYW1vdW50VG9VbnN0YWtlOiB1aW50NjQKCS0KCWl0b2IKCXJlcGxhY2UzCglmcmFtZV9idXJ5IDEgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjI5NwoJLy8gdGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgLT0gYW1vdW50VG9VbnN0YWtlCglieXRlYyA2IC8vICAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnRUb1Vuc3Rha2U6IHVpbnQ2NAoJLQoJYnl0ZWMgNiAvLyAgInN0YWtlZCIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjI5OQoJLy8gYW1vdW50UmV3YXJkVG9rZW5SZW1vdmVkID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMiAvLyBhbW91bnRSZXdhcmRUb2tlblJlbW92ZWQ6IHVpbnQ2NAoKCS8vICppZjExX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjMwMAoJLy8gY21wU3Rha2VyLnJld2FyZFRva2VuQmFsYW5jZSA+IDAKCWZyYW1lX2RpZyAxIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA0OCA4CglidG9pCglpbnRjIDAgLy8gMAoJPgoJYnogKmlmMTFfZW5kCgoJLy8gKmlmMTFfY29uc2VxdWVudAoJLy8gKmlmMTJfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzAyCgkvLyB0aGlzLnBvb2xJZC52YWx1ZSA9PT0gMQoJYnl0ZWMgNCAvLyAgInBvb2xJZCIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDEgLy8gMQoJPT0KCWJ6ICppZjEyX2Vsc2UKCgkvLyAqaWYxMl9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzAzCgkvLyB2YWxpZGF0b3JDb25maWcgPSBzZW5kTWV0aG9kQ2FsbDx0eXBlb2YgVmFsaWRhdG9yUmVnaXN0cnkucHJvdG90eXBlLmdldFZhbGlkYXRvckNvbmZpZz4oewoJLy8gICAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiB0aGlzLmNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJZC52YWx1ZSwKCS8vICAgICAgICAgICAgICAgbWV0aG9kQXJnczogW3RoaXMudmFsaWRhdG9ySWQudmFsdWVdLAoJLy8gICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMiAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJYnl0ZWMgMTUgLy8gIG1ldGhvZCAiZ2V0VmFsaWRhdG9yQ29uZmlnKHVpbnQ2NCkodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozMDQKCS8vIGFwcGxpY2F0aW9uSUQ6IHRoaXMuY3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElkLnZhbHVlCglieXRlYyAxIC8vICAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzA1CgkvLyBtZXRob2RBcmdzOiBbdGhpcy52YWxpZGF0b3JJZC52YWx1ZV0KCWJ5dGVjIDMgLy8gICJ2YWxpZGF0b3JJZCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gTnVtTG9ncwoJaW50YyAxIC8vIDEKCS0KCWl0eG5hcyBMb2dzCglleHRyYWN0IDQgMAoJZnJhbWVfYnVyeSAzIC8vIHZhbGlkYXRvckNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjMxMQoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgICAgICAgICB4ZmVyQXNzZXQ6IEFzc2V0SUQuZnJvbVVpbnQ2NCh2YWxpZGF0b3JDb25maWcucmV3YXJkVG9rZW5JZCksCgkvLyAgICAgICAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHN0YWtlciwKCS8vICAgICAgICAgICAgICAgYXNzZXRBbW91bnQ6IGNtcFN0YWtlci5yZXdhcmRUb2tlbkJhbGFuY2UsCgkvLyAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxMiAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzEyCgkvLyB4ZmVyQXNzZXQ6IEFzc2V0SUQuZnJvbVVpbnQ2NCh2YWxpZGF0b3JDb25maWcucmV3YXJkVG9rZW5JZCkKCWZyYW1lX2RpZyAzIC8vIHZhbGlkYXRvckNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDE1MyA4CglidG9pCglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozMTMKCS8vIGFzc2V0UmVjZWl2ZXI6IHN0YWtlcgoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjMxNAoJLy8gYXNzZXRBbW91bnQ6IGNtcFN0YWtlci5yZXdhcmRUb2tlbkJhbGFuY2UKCWZyYW1lX2RpZyAxIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA0OCA4CglidG9pCglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozMTYKCS8vIGFtb3VudFJld2FyZFRva2VuUmVtb3ZlZCA9IGNtcFN0YWtlci5yZXdhcmRUb2tlbkJhbGFuY2UKCWZyYW1lX2RpZyAxIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA0OCA4CglidG9pCglmcmFtZV9idXJ5IDIgLy8gYW1vdW50UmV3YXJkVG9rZW5SZW1vdmVkOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzE3CgkvLyBjbXBTdGFrZXIucmV3YXJkVG9rZW5CYWxhbmNlID0gMAoJZnJhbWVfZGlnIDEgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglieXRlYyAxMCAvLyAweDAwMDAwMDAwMDAwMDAwMDAKCXJlcGxhY2UyIDQ4CglmcmFtZV9idXJ5IDEgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCgliICppZjEyX2VuZAoKKmlmMTJfZWxzZToKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozMjIKCS8vIGFtb3VudFJld2FyZFRva2VuUmVtb3ZlZCA9IGNtcFN0YWtlci5yZXdhcmRUb2tlbkJhbGFuY2UKCWZyYW1lX2RpZyAxIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA0OCA4CglidG9pCglmcmFtZV9idXJ5IDIgLy8gYW1vdW50UmV3YXJkVG9rZW5SZW1vdmVkOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzIzCgkvLyBjbXBTdGFrZXIucmV3YXJkVG9rZW5CYWxhbmNlID0gMAoJZnJhbWVfZGlnIDEgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglieXRlYyAxMCAvLyAweDAwMDAwMDAwMDAwMDAwMDAKCXJlcGxhY2UyIDQ4CglmcmFtZV9idXJ5IDEgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCgoqaWYxMl9lbmQ6CgoqaWYxMV9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzI4CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgY21wU3Rha2VyLmJhbGFuY2UgPT09IDAgfHwgY21wU3Rha2VyLmJhbGFuY2UgPj0gdGhpcy5taW5FbnRyeVN0YWtlLnZhbHVlLAoJLy8gICAgICAgICAgICdjYW5ub3QgcmVkdWNlIGJhbGFuY2UgYmVsb3cgbWluaW11bSBhbGxvd2VkIHN0YWtlIHVubGVzcyBhbGwgaXMgcmVtb3ZlZCcKCS8vICAgICAgICAgKQoJZnJhbWVfZGlnIDEgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDMyIDgKCWJ0b2kKCWludGMgMCAvLyAwCgk9PQoJZHVwCglibnogKnNraXBfb3IwCglmcmFtZV9kaWcgMSAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJYnl0ZWMgMTggLy8gICJtaW5FbnRyeVN0YWtlIgoJYXBwX2dsb2JhbF9nZXQKCT49Cgl8fAoKKnNraXBfb3IwOgoJLy8gY2Fubm90IHJlZHVjZSBiYWxhbmNlIGJlbG93IG1pbmltdW0gYWxsb3dlZCBzdGFrZSB1bmxlc3MgYWxsIGlzIHJlbW92ZWQKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozMzYKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgICAgICBhbW91bnQ6IGFtb3VudFRvVW5zdGFrZSwKCS8vICAgICAgICAgICByZWNlaXZlcjogc3Rha2VyLAoJLy8gICAgICAgICAgIG5vdGU6ICd1bnN0YWtlZCcsCgkvLyAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDEgLy8gIHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozMzcKCS8vIGFtb3VudDogYW1vdW50VG9VbnN0YWtlCglmcmFtZV9kaWcgLTIgLy8gYW1vdW50VG9VbnN0YWtlOiB1aW50NjQKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjMzOAoJLy8gcmVjZWl2ZXI6IHN0YWtlcgoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozMzkKCS8vIG5vdGU6ICd1bnN0YWtlZCcKCXB1c2hieXRlcyAweDc1NmU3Mzc0NjE2YjY1NjQgLy8gInVuc3Rha2VkIgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozNDEKCS8vIHN0YWtlclJlbW92ZWQgPSBmYWxzZQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNCAvLyBzdGFrZXJSZW1vdmVkOiBib29sCgoJLy8gKmlmMTNfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzQyCgkvLyBjbXBTdGFrZXIuYmFsYW5jZSA9PT0gMAoJZnJhbWVfZGlnIDEgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDMyIDgKCWJ0b2kKCWludGMgMCAvLyAwCgk9PQoJYnogKmlmMTNfZW5kCgoJLy8gKmlmMTNfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjM0NAoJLy8gdGhpcy5udW1TdGFrZXJzLnZhbHVlIC09IDEKCWJ5dGVjIDEzIC8vICAibnVtU3Rha2VycyIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDEgLy8gMQoJLQoJYnl0ZWMgMTMgLy8gICJudW1TdGFrZXJzIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzQ1CgkvLyBjbXBTdGFrZXIuYWNjb3VudCA9IGdsb2JhbHMuemVyb0FkZHJlc3MKCWZyYW1lX2RpZyAxIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJaW50YyAwIC8vIDAKCWdsb2JhbCBaZXJvQWRkcmVzcwoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgMSAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzQ2CgkvLyBjbXBTdGFrZXIudG90YWxSZXdhcmRlZCA9IDAKCWZyYW1lX2RpZyAxIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZWMgMTAgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCglyZXBsYWNlMiA0MAoJZnJhbWVfYnVyeSAxIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozNDcKCS8vIGNtcFN0YWtlci5yZXdhcmRUb2tlbkJhbGFuY2UgPSAwCglmcmFtZV9kaWcgMSAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWJ5dGVjIDEwIC8vIDB4MDAwMDAwMDAwMDAwMDAwMAoJcmVwbGFjZTIgNDgKCWZyYW1lX2J1cnkgMSAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzQ4CgkvLyBzdGFrZXJSZW1vdmVkID0gdHJ1ZQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgNCAvLyBzdGFrZXJSZW1vdmVkOiBib29sCgoqaWYxM19lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzUxCgkvLyB0aGlzLnN0YWtlcnMudmFsdWVbaV0gPSBjbXBTdGFrZXIKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDY0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWZyYW1lX2RpZyAxIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZWMgMiAvLyAgInN0YWtlcnMiCgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozNTMKCS8vIHJvdW5kc0xlZnRJbkJpbiA9IHRoaXMuYmluUm91bmRTdGFydC52YWx1ZSArIHRoaXMucm91bmRzUGVyRGF5LnZhbHVlIC0gZ2xvYmFscy5yb3VuZAoJYnl0ZWMgMTEgLy8gICJiaW5Sb3VuZFN0YXJ0IgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGVjIDcgLy8gICJyb3VuZHNQZXJEYXkiCglhcHBfZ2xvYmFsX2dldAoJKwoJZ2xvYmFsIFJvdW5kCgktCglmcmFtZV9idXJ5IDUgLy8gcm91bmRzTGVmdEluQmluOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzU0CgkvLyBzdWJ0cmFjdEFtb3VudDogdWludDEyOCA9IChhbW91bnRUb1Vuc3Rha2UgYXMgdWludDEyOCkgKiAocm91bmRzTGVmdEluQmluIGFzIHVpbnQxMjgpCglmcmFtZV9kaWcgLTIgLy8gYW1vdW50VG9VbnN0YWtlOiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyA1IC8vIHJvdW5kc0xlZnRJbkJpbjogdWludDY0CglpdG9iCgliKgoJZHVwCgliaXRsZW4KCWludGMgNiAvLyAxMjgKCTw9CgoJLy8gKGFtb3VudFRvVW5zdGFrZSBhcyB1aW50MTI4KSAqIChyb3VuZHNMZWZ0SW5CaW4gYXMgdWludDEyOCkgb3ZlcmZsb3dlZCAxMjggYml0cwoJYXNzZXJ0CglieXRlYyA5IC8vIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnRjIDUgLy8gMTYKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWZyYW1lX2J1cnkgNiAvLyBzdWJ0cmFjdEFtb3VudDogdWludDEyOAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozNTUKCS8vIHRoaXMuc3Rha2VBY2N1bXVsYXRvci52YWx1ZSA9IHRoaXMuc3Rha2VBY2N1bXVsYXRvci52YWx1ZSAtIHN1YnRyYWN0QW1vdW50CglieXRlYyA4IC8vICAic3Rha2VBY2N1bXVsYXRvciIKCWR1cAoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyA2IC8vIHN1YnRyYWN0QW1vdW50OiB1aW50MTI4CgliLQoJZHVwCgliaXRsZW4KCWludGMgNiAvLyAxMjgKCTw9CgoJLy8gdGhpcy5zdGFrZUFjY3VtdWxhdG9yLnZhbHVlIC0gc3VidHJhY3RBbW91bnQgb3ZlcmZsb3dlZCAxMjggYml0cwoJYXNzZXJ0CglieXRlYyA5IC8vIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnRjIDUgLy8gMTYKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjM2MAoJLy8gc2VuZE1ldGhvZENhbGw8dHlwZW9mIFZhbGlkYXRvclJlZ2lzdHJ5LnByb3RvdHlwZS5zdGFrZVJlbW92ZWQ+KHsKCS8vICAgICAgICAgICBhcHBsaWNhdGlvbklEOiB0aGlzLmNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJZC52YWx1ZSwKCS8vICAgICAgICAgICBtZXRob2RBcmdzOiBbCgkvLyAgICAgICAgICAgICB7IGlkOiB0aGlzLnZhbGlkYXRvcklkLnZhbHVlLCBwb29sSWQ6IHRoaXMucG9vbElkLnZhbHVlLCBwb29sQXBwSWQ6IHRoaXMuYXBwLmlkIH0sCgkvLyAgICAgICAgICAgICBzdGFrZXIsCgkvLyAgICAgICAgICAgICBhbW91bnRUb1Vuc3Rha2UsCgkvLyAgICAgICAgICAgICBhbW91bnRSZXdhcmRUb2tlblJlbW92ZWQsCgkvLyAgICAgICAgICAgICBzdGFrZXJSZW1vdmVkLAoJLy8gICAgICAgICAgIF0sCgkvLyAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDIgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWJ5dGVjIDIyIC8vICBtZXRob2QgInN0YWtlUmVtb3ZlZCgodWludDY0LHVpbnQ2NCx1aW50NjQpLGFkZHJlc3MsdWludDY0LHVpbnQ2NCxib29sKXZvaWQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozNjEKCS8vIGFwcGxpY2F0aW9uSUQ6IHRoaXMuY3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElkLnZhbHVlCglieXRlYyAxIC8vICAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzYyCgkvLyBtZXRob2RBcmdzOiBbCgkvLyAgICAgICAgICAgICB7IGlkOiB0aGlzLnZhbGlkYXRvcklkLnZhbHVlLCBwb29sSWQ6IHRoaXMucG9vbElkLnZhbHVlLCBwb29sQXBwSWQ6IHRoaXMuYXBwLmlkIH0sCgkvLyAgICAgICAgICAgICBzdGFrZXIsCgkvLyAgICAgICAgICAgICBhbW91bnRUb1Vuc3Rha2UsCgkvLyAgICAgICAgICAgICBhbW91bnRSZXdhcmRUb2tlblJlbW92ZWQsCgkvLyAgICAgICAgICAgICBzdGFrZXJSZW1vdmVkLAoJLy8gICAgICAgICAgIF0KCWJ5dGVjIDMgLy8gICJ2YWxpZGF0b3JJZCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglieXRlYyA0IC8vICAicG9vbElkIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWNvbmNhdAoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJaXRvYgoJY29uY2F0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnRUb1Vuc3Rha2U6IHVpbnQ2NAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAyIC8vIGFtb3VudFJld2FyZFRva2VuUmVtb3ZlZDogdWludDY0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDQgLy8gc3Rha2VyUmVtb3ZlZDogYm9vbAoJYnl0ZWMgMjYgLy8gMHgwMAoJaW50YyAwIC8vIDAKCXVuY292ZXIgMgoJc2V0Yml0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzcwCgkvLyByZXR1cm47CglyZXRzdWIKCippZjhfZW5kOgoKKmZvcl8xX2NvbnRpbnVlOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjI4MwoJLy8gaSArPSAxCglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDAgLy8gaTogdWludDY0CgliICpmb3JfMQoKKmZvcl8xX2VuZDoKCS8vIGFjY291bnQgbm90IGZvdW5kCgllcnIKCXJldHN1YgoKLy8gY2xhaW1Ub2tlbnMoKXZvaWQKKmFiaV9yb3V0ZV9jbGFpbVRva2VuczoKCS8vIGV4ZWN1dGUgY2xhaW1Ub2tlbnMoKXZvaWQKCWNhbGxzdWIgY2xhaW1Ub2tlbnMKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGNsYWltVG9rZW5zKCk6IHZvaWQKLy8KLy8gQ2xhaW1zIGFsbCB0aGUgYXZhaWxhYmxlIHJld2FyZCB0b2tlbnMgYSBzdGFrZXIgaGFzIGF2YWlsYWJsZSwgc2VuZGluZyB0aGVpciBlbnRpcmUgYmFsYW5jZSB0byB0aGUgc3Rha2VyIGZyb20KLy8gcG9vbCAxIChlaXRoZXIgZGlyZWN0bHksIG9yIHZpYSB2YWxpZGF0b3ItPnBvb2wxIHRvIHBheSBpdCBvdXQpCi8vIEFsc28gbm90aWZpZXMgdGhlIHZhbGlkYXRvciBjb250cmFjdCBmb3IgdGhpcyBwb29scyB2YWxpZGF0b3Igb2YgdGhlIHN0YWtlciAvIGJhbGFuY2UgY2hhbmdlcy4KY2xhaW1Ub2tlbnM6Cglwcm90byAwIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiA0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjM4NQoJLy8gc3Rha2VyID0gdGhpcy50eG4uc2VuZGVyCgl0eG4gU2VuZGVyCglmcmFtZV9idXJ5IDAgLy8gc3Rha2VyOiBhZGRyZXNzCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjM4NwoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YWtlcnMudmFsdWUubGVuZ3RoOyBpICs9IDEpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAxIC8vIGk6IHVpbnQ2NAoKKmZvcl8yOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjM4NwoJLy8gaSA8IHRoaXMuc3Rha2Vycy52YWx1ZS5sZW5ndGgKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50YyA3IC8vIDIwMAoJPAoJYnogKmZvcl8yX2VuZAoKCS8vICppZjE0X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjM4OAoJLy8gZ2xvYmFscy5vcGNvZGVCdWRnZXQgPCAzMDAKCWdsb2JhbCBPcGNvZGVCdWRnZXQKCWludGMgMTAgLy8gMzAwCgk8CglieiAqaWYxNF9lbmQKCgkvLyAqaWYxNF9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6Mzg5CgkvLyBpbmNyZWFzZU9wY29kZUJ1ZGdldCgpCglpdHhuX2JlZ2luCglpbnRjIDIgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoJYnl0ZWMgNSAvLyAgI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50YyA4IC8vICBEZWxldGVBcHBsaWNhdGlvbgoJaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KCWl0eG5fc3VibWl0CgoqaWYxNF9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MzkxCgkvLyBjbXBTdGFrZXIgPSBjbG9uZSh0aGlzLnN0YWtlcnMudmFsdWVbaV0pCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgMyAvLyA2NAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDMgLy8gNjQKCWJ5dGVjIDIgLy8gICJzdGFrZXJzIgoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWZyYW1lX2J1cnkgMiAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyAqaWYxNV9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozOTIKCS8vIGNtcFN0YWtlci5hY2NvdW50ID09PSBzdGFrZXIKCWZyYW1lX2RpZyAyIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAwIDMyCglmcmFtZV9kaWcgMCAvLyBzdGFrZXI6IGFkZHJlc3MKCT09CglieiAqaWYxNV9lbmQKCgkvLyAqaWYxNV9jb25zZXF1ZW50CgkvLyAqaWYxNl9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozOTMKCS8vIGNtcFN0YWtlci5yZXdhcmRUb2tlbkJhbGFuY2UgPT09IDAKCWZyYW1lX2RpZyAyIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA0OCA4CglidG9pCglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjE2X2VuZAoKCS8vICppZjE2X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czozOTQKCS8vIHJldHVybjsKCXJldHN1YgoKKmlmMTZfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjM5NgoJLy8gYW1vdW50UmV3YXJkVG9rZW5SZW1vdmVkID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMyAvLyBhbW91bnRSZXdhcmRUb2tlblJlbW92ZWQ6IHVpbnQ2NAoKCS8vICppZjE3X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjM5OAoJLy8gdGhpcy5wb29sSWQudmFsdWUgPT09IDEKCWJ5dGVjIDQgLy8gICJwb29sSWQiCglhcHBfZ2xvYmFsX2dldAoJaW50YyAxIC8vIDEKCT09CglieiAqaWYxN19lbHNlCgoJLy8gKmlmMTdfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjM5OQoJLy8gdmFsaWRhdG9yQ29uZmlnID0gc2VuZE1ldGhvZENhbGw8dHlwZW9mIFZhbGlkYXRvclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRWYWxpZGF0b3JDb25maWc+KHsKCS8vICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IHRoaXMuY3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElkLnZhbHVlLAoJLy8gICAgICAgICAgICAgbWV0aG9kQXJnczogW3RoaXMudmFsaWRhdG9ySWQudmFsdWVdLAoJLy8gICAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDIgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWJ5dGVjIDE1IC8vICBtZXRob2QgImdldFZhbGlkYXRvckNvbmZpZyh1aW50NjQpKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NDAwCgkvLyBhcHBsaWNhdGlvbklEOiB0aGlzLmNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJZC52YWx1ZQoJYnl0ZWMgMSAvLyAgImNyZWF0b3JBcHAiCglhcHBfZ2xvYmFsX2dldAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjQwMQoJLy8gbWV0aG9kQXJnczogW3RoaXMudmFsaWRhdG9ySWQudmFsdWVdCglieXRlYyAzIC8vICAidmFsaWRhdG9ySWQiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIE51bUxvZ3MKCWludGMgMSAvLyAxCgktCglpdHhuYXMgTG9ncwoJZXh0cmFjdCA0IDAKCWZyYW1lX2J1cnkgNCAvLyB2YWxpZGF0b3JDb25maWc6ICh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo0MDYKCS8vIHNlbmRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgICAgICAgIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHZhbGlkYXRvckNvbmZpZy5yZXdhcmRUb2tlbklkKSwKCS8vICAgICAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHN0YWtlciwKCS8vICAgICAgICAgICAgIGFzc2V0QW1vdW50OiBjbXBTdGFrZXIucmV3YXJkVG9rZW5CYWxhbmNlLAoJLy8gICAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDEyIC8vICBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo0MDcKCS8vIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHZhbGlkYXRvckNvbmZpZy5yZXdhcmRUb2tlbklkKQoJZnJhbWVfZGlnIDQgLy8gdmFsaWRhdG9yQ29uZmlnOiAodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMTUzIDgKCWJ0b2kKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjQwOAoJLy8gYXNzZXRSZWNlaXZlcjogc3Rha2VyCglmcmFtZV9kaWcgMCAvLyBzdGFrZXI6IGFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo0MDkKCS8vIGFzc2V0QW1vdW50OiBjbXBTdGFrZXIucmV3YXJkVG9rZW5CYWxhbmNlCglmcmFtZV9kaWcgMiAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgNDggOAoJYnRvaQoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NDExCgkvLyBhbW91bnRSZXdhcmRUb2tlblJlbW92ZWQgPSBjbXBTdGFrZXIucmV3YXJkVG9rZW5CYWxhbmNlCglmcmFtZV9kaWcgMiAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgNDggOAoJYnRvaQoJZnJhbWVfYnVyeSAzIC8vIGFtb3VudFJld2FyZFRva2VuUmVtb3ZlZDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjQxMgoJLy8gY21wU3Rha2VyLnJld2FyZFRva2VuQmFsYW5jZSA9IDAKCWZyYW1lX2RpZyAyIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZWMgMTAgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCglyZXBsYWNlMiA0OAoJZnJhbWVfYnVyeSAyIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYiAqaWYxN19lbmQKCippZjE3X2Vsc2U6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NDE3CgkvLyBhbW91bnRSZXdhcmRUb2tlblJlbW92ZWQgPSBjbXBTdGFrZXIucmV3YXJkVG9rZW5CYWxhbmNlCglmcmFtZV9kaWcgMiAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgNDggOAoJYnRvaQoJZnJhbWVfYnVyeSAzIC8vIGFtb3VudFJld2FyZFRva2VuUmVtb3ZlZDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjQxOAoJLy8gY21wU3Rha2VyLnJld2FyZFRva2VuQmFsYW5jZSA9IDAKCWZyYW1lX2RpZyAyIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZWMgMTAgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCglyZXBsYWNlMiA0OAoJZnJhbWVfYnVyeSAyIC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoKKmlmMTdfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjQyMgoJLy8gdGhpcy5zdGFrZXJzLnZhbHVlW2ldID0gY21wU3Rha2VyCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgMyAvLyA2NAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglmcmFtZV9kaWcgMiAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWJ5dGVjIDIgLy8gICJzdGFrZXJzIgoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NDI3CgkvLyBzZW5kTWV0aG9kQ2FsbDx0eXBlb2YgVmFsaWRhdG9yUmVnaXN0cnkucHJvdG90eXBlLnN0YWtlUmVtb3ZlZD4oewoJLy8gICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IHRoaXMuY3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElkLnZhbHVlLAoJLy8gICAgICAgICAgIG1ldGhvZEFyZ3M6IFsKCS8vICAgICAgICAgICAgIHsgaWQ6IHRoaXMudmFsaWRhdG9ySWQudmFsdWUsIHBvb2xJZDogdGhpcy5wb29sSWQudmFsdWUsIHBvb2xBcHBJZDogdGhpcy5hcHAuaWQgfSwKCS8vICAgICAgICAgICAgIHN0YWtlciwKCS8vICAgICAgICAgICAgIDAsIC8vIG5vIGFsZ28gcmVtb3ZlZAoJLy8gICAgICAgICAgICAgYW1vdW50UmV3YXJkVG9rZW5SZW1vdmVkLAoJLy8gICAgICAgICAgICAgZmFsc2UsIC8vIHN0YWtlciBpc24ndCBiZWluZyByZW1vdmVkLgoJLy8gICAgICAgICAgIF0sCgkvLyAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDIgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWJ5dGVjIDIyIC8vICBtZXRob2QgInN0YWtlUmVtb3ZlZCgodWludDY0LHVpbnQ2NCx1aW50NjQpLGFkZHJlc3MsdWludDY0LHVpbnQ2NCxib29sKXZvaWQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo0MjgKCS8vIGFwcGxpY2F0aW9uSUQ6IHRoaXMuY3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElkLnZhbHVlCglieXRlYyAxIC8vICAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NDI5CgkvLyBtZXRob2RBcmdzOiBbCgkvLyAgICAgICAgICAgICB7IGlkOiB0aGlzLnZhbGlkYXRvcklkLnZhbHVlLCBwb29sSWQ6IHRoaXMucG9vbElkLnZhbHVlLCBwb29sQXBwSWQ6IHRoaXMuYXBwLmlkIH0sCgkvLyAgICAgICAgICAgICBzdGFrZXIsCgkvLyAgICAgICAgICAgICAwLCAvLyBubyBhbGdvIHJlbW92ZWQKCS8vICAgICAgICAgICAgIGFtb3VudFJld2FyZFRva2VuUmVtb3ZlZCwKCS8vICAgICAgICAgICAgIGZhbHNlLCAvLyBzdGFrZXIgaXNuJ3QgYmVpbmcgcmVtb3ZlZC4KCS8vICAgICAgICAgICBdCglieXRlYyAzIC8vICAidmFsaWRhdG9ySWQiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJYnl0ZWMgNCAvLyAgInBvb2xJZCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCgljb25jYXQKCXR4bmEgQXBwbGljYXRpb25zIDAKCWl0b2IKCWNvbmNhdAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAwIC8vIHN0YWtlcjogYWRkcmVzcwoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWJ5dGVjIDEwIC8vIDB4MDAwMDAwMDAwMDAwMDAwMAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAzIC8vIGFtb3VudFJld2FyZFRva2VuUmVtb3ZlZDogdWludDY0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJaW50YyAwIC8vIDAKCWJ5dGVjIDI2IC8vIDB4MDAKCWludGMgMCAvLyAwCgl1bmNvdmVyIDIKCXNldGJpdAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjQzNwoJLy8gcmV0dXJuOwoJcmV0c3ViCgoqaWYxNV9lbmQ6CgoqZm9yXzJfY29udGludWU6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6Mzg3CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCWIgKmZvcl8yCgoqZm9yXzJfZW5kOgoJLy8gYWNjb3VudCBub3QgZm91bmQKCWVycgoJcmV0c3ViCgovLyBnZXRTdGFrZXJJbmZvKGFkZHJlc3MpKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoqYWJpX3JvdXRlX2dldFN0YWtlckluZm86CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGVjIDIxIC8vIDB4MTUxZjdjNzUKCgkvLyBzdGFrZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDQgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMCAoc3Rha2VyKSBmb3IgZ2V0U3Rha2VySW5mbyBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBnZXRTdGFrZXJJbmZvKGFkZHJlc3MpKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJY2FsbHN1YiBnZXRTdGFrZXJJbmZvCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ2V0U3Rha2VySW5mbyhzdGFrZXI6IEFkZHJlc3MpOiBTdGFrZWRJbmZvCi8vCi8vIFJldHJpZXZlcyB0aGUgc3Rha2VkIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIHN0YWtlci4KLy8KLy8gQHBhcmFtIHtBZGRyZXNzfSBzdGFrZXIgLSBUaGUgYWRkcmVzcyBvZiB0aGUgc3Rha2VyLgovLyBAcmV0dXJucyB7U3Rha2VkSW5mb30gLSBUaGUgc3Rha2VkIGluZm9ybWF0aW9uIGZvciB0aGUgZ2l2ZW4gc3Rha2VyLgovLyBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUgc3Rha2VyJ3MgYWNjb3VudCBpcyBub3QgZm91bmQuCmdldFN0YWtlckluZm86Cglwcm90byAxIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo0NTIKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFrZXJzLnZhbHVlLmxlbmd0aDsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMCAvLyBpOiB1aW50NjQKCipmb3JfMzoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo0NTIKCS8vIGkgPCB0aGlzLnN0YWtlcnMudmFsdWUubGVuZ3RoCglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCWludGMgNyAvLyAyMDAKCTwKCWJ6ICpmb3JfM19lbmQKCgkvLyAqaWYxOF9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo0NTMKCS8vIGdsb2JhbHMub3Bjb2RlQnVkZ2V0IDwgMjAwCglnbG9iYWwgT3Bjb2RlQnVkZ2V0CglpbnRjIDcgLy8gMjAwCgk8CglieiAqaWYxOF9lbmQKCgkvLyAqaWYxOF9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NDU0CgkvLyBpbmNyZWFzZU9wY29kZUJ1ZGdldCgpCglpdHhuX2JlZ2luCglpbnRjIDIgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoJYnl0ZWMgNSAvLyAgI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50YyA4IC8vICBEZWxldGVBcHBsaWNhdGlvbgoJaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KCWl0eG5fc3VibWl0CgoqaWYxOF9lbmQ6CgkvLyAqaWYxOV9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo0NTYKCS8vIHRoaXMuc3Rha2Vycy52YWx1ZVtpXS5hY2NvdW50ID09PSBzdGFrZXIKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDY0CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMCAvLyAwCgkrCglpbnRjIDQgLy8gMzIKCWJ5dGVjIDIgLy8gICJzdGFrZXJzIgoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZXI6IEFkZHJlc3MKCT09CglieiAqaWYxOV9lbmQKCgkvLyAqaWYxOV9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NDU3CgkvLyByZXR1cm4gdGhpcy5zdGFrZXJzLnZhbHVlW2ldOwoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0CglpbnRjIDMgLy8gNjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAzIC8vIDY0CglieXRlYyAyIC8vICAic3Rha2VycyIKCWNvdmVyIDIKCWJveF9leHRyYWN0CgliICpnZXRTdGFrZXJJbmZvKnJldHVybgoKKmlmMTlfZW5kOgoKKmZvcl8zX2NvbnRpbnVlOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjQ1MgoJLy8gaSArPSAxCglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDAgLy8gaTogdWludDY0CgliICpmb3JfMwoKKmZvcl8zX2VuZDoKCS8vIGFjY291bnQgbm90IGZvdW5kCgllcnIKCipnZXRTdGFrZXJJbmZvKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBwYXlUb2tlblJld2FyZChhZGRyZXNzLHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3BheVRva2VuUmV3YXJkOgoJLy8gYW1vdW50VG9TZW5kOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyByZXdhcmRUb2tlbjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gc3Rha2VyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50YyA0IC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDIgKHN0YWtlcikgZm9yIHBheVRva2VuUmV3YXJkIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIHBheVRva2VuUmV3YXJkKGFkZHJlc3MsdWludDY0LHVpbnQ2NCl2b2lkCgljYWxsc3ViIHBheVRva2VuUmV3YXJkCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBwYXlUb2tlblJld2FyZChzdGFrZXI6IEFkZHJlc3MsIHJld2FyZFRva2VuOiB1aW50NjQsIGFtb3VudFRvU2VuZDogdWludDY0KTogdm9pZAovLwovLyBbSW50ZXJuYWwgcHJvdG9jb2wgbWV0aG9kXSBSZW1vdmUgYSBzcGVjaWZpZWQgYW1vdW50IG9mICdjb21tdW5pdHkgdG9rZW4nIHJld2FyZHMgZm9yIGEgc3Rha2VyLgovLyBUaGlzIGNhbiBPTkxZIGJlIGNhbGxlZCBieSBvdXIgdmFsaWRhdG9yIGFuZCBvbmx5IGlmIHdlJ3JlIHBvb2wgMSAtIHdpdGggdGhlIHRva2VuLgovLyBOb3RlOiB0aGlzIGNhbiBhbHNvIGJlIGNhbGxlZCBieSB2YWxpZGF0b3IgYXMgcGFydCBvZiBPV05FUiB3YW50aW5nIHRvIHNlbmQgdGhlIHJld2FyZCB0b2tlbnMKLy8gc29tZXdoZXJlIGVsc2UgKGllIGlmIHRoZXkncmUgc3Vuc2V0dGluZyB0aGVpciB2YWxpZGF0b3IgYW5kIG5lZWQgdGhlIHJld2FyZCB0b2tlbnMgYmFjaykuCi8vIEl0J3MgdXAgdG8gdGhlIHZhbGlkYXRvciB0byBlbnN1cmUgdGhhdCB0aGUgYmFsYW5jZSBpbiByZXdhcmRUb2tlbkhlbGRCYWNrIGlzIGhvbm9yZWQuCi8vIEBwYXJhbSBzdGFrZXIgLSB0aGUgc3Rha2VyIGFjY291bnQgdG8gc2VuZCByZXdhcmRzIHRvCi8vIEBwYXJhbSByZXdhcmRUb2tlbiAtIGlkIG9mIHJld2FyZCB0b2tlbiAodG8gYXZvaWQgcmUtZW50cmFuY3kgaW4gY2FsbGluZyB2YWxpZGF0b3IgYmFjayB0byBnZXQgaWQpCi8vIEBwYXJhbSBhbW91bnRUb1NlbmQgLSBhbW91bnQgdG8gc2VuZCB0aGUgc3Rha2VyICh0aGVyZSBpcyBzaWduaWZpY2FudCB0cnVzdCBoZXJlKCEpIC0gYWxzbyB3aHkgb25seSB2YWxpZGF0b3IgY2FuIGNhbGwgdXMKcGF5VG9rZW5SZXdhcmQ6Cglwcm90byAzIDAKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NDc1CgkvLyBhc3NlcnQoCgkvLyAgICAgICB0aGlzLnR4bi5zZW5kZXIgPT09IHRoaXMuY3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElkLnZhbHVlLmFkZHJlc3MsCgkvLyAgICAgICAndGhpcyBjYW4gb25seSBiZSBjYWxsZWQgdmlhIHRoZSB2YWxpZGF0b3IgY29udHJhY3QnCgkvLyAgICAgKQoJdHhuIFNlbmRlcgoJYnl0ZWMgMSAvLyAgImNyZWF0b3JBcHAiCglhcHBfZ2xvYmFsX2dldAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCgk9PQoKCS8vIHRoaXMgY2FuIG9ubHkgYmUgY2FsbGVkIHZpYSB0aGUgdmFsaWRhdG9yIGNvbnRyYWN0Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NDc5CgkvLyBhc3NlcnQodGhpcy5wb29sSWQudmFsdWUgPT09IDEsICdtdXN0IGJlIHBvb2wgMSBpbiBvcmRlciB0byBiZSBjYWxsZWQgdG8gcGF5IG91dCB0b2tlbiByZXdhcmRzJykKCWJ5dGVjIDQgLy8gICJwb29sSWQiCglhcHBfZ2xvYmFsX2dldAoJaW50YyAxIC8vIDEKCT09CgoJLy8gbXVzdCBiZSBwb29sIDEgaW4gb3JkZXIgdG8gYmUgY2FsbGVkIHRvIHBheSBvdXQgdG9rZW4gcmV3YXJkcwoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjQ4MAoJLy8gYXNzZXJ0KHJld2FyZFRva2VuICE9PSAwLCAnY2FuIG9ubHkgY2xhaW0gdG9rZW4gcmV3YXJkcyBmcm9tIHZhbGlkYXRvciB0aGF0IGhhcyB0aGVtJykKCWZyYW1lX2RpZyAtMiAvLyByZXdhcmRUb2tlbjogdWludDY0CglpbnRjIDAgLy8gMAoJIT0KCgkvLyBjYW4gb25seSBjbGFpbSB0b2tlbiByZXdhcmRzIGZyb20gdmFsaWRhdG9yIHRoYXQgaGFzIHRoZW0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo0ODMKCS8vIHNlbmRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHJld2FyZFRva2VuKSwKCS8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHN0YWtlciwKCS8vICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnRUb1NlbmQsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMTIgLy8gIGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjQ4NAoJLy8geGZlckFzc2V0OiBBc3NldElELmZyb21VaW50NjQocmV3YXJkVG9rZW4pCglmcmFtZV9kaWcgLTIgLy8gcmV3YXJkVG9rZW46IHVpbnQ2NAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NDg1CgkvLyBhc3NldFJlY2VpdmVyOiBzdGFrZXIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo0ODYKCS8vIGFzc2V0QW1vdW50OiBhbW91bnRUb1NlbmQKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnRUb1NlbmQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKLy8gdXBkYXRlQWxnb2RWZXIoc3RyaW5nKXZvaWQKKmFiaV9yb3V0ZV91cGRhdGVBbGdvZFZlcjoKCS8vIGFsZ29kVmVyOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSB1cGRhdGVBbGdvZFZlcihzdHJpbmcpdm9pZAoJY2FsbHN1YiB1cGRhdGVBbGdvZFZlcgoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gdXBkYXRlQWxnb2RWZXIoYWxnb2RWZXI6IHN0cmluZyk6IHZvaWQKLy8KLy8gVXBkYXRlIHRoZSAoaG9ub3Igc3lzdGVtKSBhbGdvZCB2ZXJzaW9uIGZvciB0aGUgbm9kZSBhc3NvY2lhdGVkIHRvIHRoaXMgcG9vbC4gIFRoZSBub2RlIG1hbmFnZW1lbnQgZGFlbW9uCi8vIHNob3VsZCBjb21wYXJlIGl0cyBjdXJyZW50IG5vZGVzIHZlcnNpb24gdG8gdGhlIHZlcnNpb24gc3RvcmVkIGluIGdsb2JhbCBzdGF0ZSwgdXBkYXRpbmcgd2hlbiBkaWZmZXJlbnQuCi8vIFRoZSByZXRpIG5vZGUgZGFlbW9uIGNvbXBvc2VzIGl0cyBvd24gdmVyc2lvbiBzdHJpbmcgdXNpbmcgZm9ybWF0OgovLyB7bWFqb3J9LnttaW5vcn0ue2J1aWxkfSB7YnJhbmNofSBbe2NvbW1pdCBoYXNofV0sCi8vIGllOiAzLjIyLjAgcmVsL3N0YWJsZSBbNmI1MDg5NzVdCi8vIFsgT05MWSBPV05FUiBPUiBNQU5BR0VSIENBTiBDQUxMIF0KLy8gQHBhcmFtIHtzdHJpbmd9IGFsZ29kVmVyIC0gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYWxnb3JhbmQgbm9kZSBkYWVtb24gdmVyc2lvbiAocmV0aSBub2RlIGRhZW1vbiBjb21wb3NlcyBpdHMgb3duIG1ldGEgdmVyc2lvbikKdXBkYXRlQWxnb2RWZXI6Cglwcm90byAxIDAKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTAwCgkvLyBhc3NlcnQodGhpcy5pc093bmVyT3JNYW5hZ2VyQ2FsbGVyKCksICdjYW4gb25seSBiZSBjYWxsZWQgYnkgb3duZXIgb3IgbWFuYWdlciBvZiB2YWxpZGF0b3InKQoJY2FsbHN1YiBpc093bmVyT3JNYW5hZ2VyQ2FsbGVyCgoJLy8gY2FuIG9ubHkgYmUgY2FsbGVkIGJ5IG93bmVyIG9yIG1hbmFnZXIgb2YgdmFsaWRhdG9yCglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTAxCgkvLyB0aGlzLmFsZ29kVmVyLnZhbHVlID0gYWxnb2RWZXIKCXB1c2hieXRlcyAweDYxNmM2NzZmNjQ1NjY1NzIgLy8gImFsZ29kVmVyIgoJZnJhbWVfZGlnIC0xIC8vIGFsZ29kVmVyOiBzdHJpbmcKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGVwb2NoQmFsYW5jZVVwZGF0ZSgpdm9pZAoqYWJpX3JvdXRlX2Vwb2NoQmFsYW5jZVVwZGF0ZToKCS8vIGV4ZWN1dGUgZXBvY2hCYWxhbmNlVXBkYXRlKCl2b2lkCgljYWxsc3ViIGVwb2NoQmFsYW5jZVVwZGF0ZQoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZXBvY2hCYWxhbmNlVXBkYXRlKCk6IHZvaWQKLy8KLy8gVXBkYXRlcyB0aGUgYmFsYW5jZSBvZiBzdGFrZXJzIGluIHRoZSBwb29sIGJhc2VkIG9uIHRoZSByZWNlaXZlZCAncmV3YXJkcycgKGN1cnJlbnQgYmFsYW5jZSB2cyBrbm93biBzdGFrZWQgYmFsYW5jZSkKLy8gc3Rha2VycyBvdXRzdGFuZGluZyBiYWxhbmNlIGlzIGFkanVzdGVkIGJhc2VkIG9uIHRoZWlyICUgb2Ygc3Rha2UgYW5kIHRpbWUgaW4gdGhlIGN1cnJlbnQgZXBvY2ggLSBzbyB0aGF0IGJhbGFuY2UKLy8gY29tcG91bmRzIG92ZXIgdGltZSBhbmQgc3Rha2VyIGNhbiByZW1vdmUgdGhhdCBhbW91bnQgYXQgd2lsbC4KLy8gVGhlIHZhbGlkYXRvciBpcyBwYWlkIHRoZWlyIHBlcmNlbnRhZ2UgZWFjaCBlcG9jaCBwYXlvdXQuCi8vCi8vIE5vdGU6IEFOWU9ORSBjYW4gY2FsbCB0aGlzLgplcG9jaEJhbGFuY2VVcGRhdGU6Cglwcm90byAwIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiAzOQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1MTQKCS8vIHZhbGlkYXRvckNvbmZpZyA9IHNlbmRNZXRob2RDYWxsPHR5cGVvZiBWYWxpZGF0b3JSZWdpc3RyeS5wcm90b3R5cGUuZ2V0VmFsaWRhdG9yQ29uZmlnPih7CgkvLyAgICAgICBhcHBsaWNhdGlvbklEOiB0aGlzLmNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJZC52YWx1ZSwKCS8vICAgICAgIG1ldGhvZEFyZ3M6IFt0aGlzLnZhbGlkYXRvcklkLnZhbHVlXSwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAyIC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglieXRlYyAxNSAvLyAgbWV0aG9kICJnZXRWYWxpZGF0b3JDb25maWcodWludDY0KSh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KSIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjUxNQoJLy8gYXBwbGljYXRpb25JRDogdGhpcy5jcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSWQudmFsdWUKCWJ5dGVjIDEgLy8gICJjcmVhdG9yQXBwIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1MTYKCS8vIG1ldGhvZEFyZ3M6IFt0aGlzLnZhbGlkYXRvcklkLnZhbHVlXQoJYnl0ZWMgMyAvLyAgInZhbGlkYXRvcklkIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnRjIDEgLy8gMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCglmcmFtZV9idXJ5IDAgLy8gdmFsaWRhdG9yQ29uZmlnOiAodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTIzCgkvLyBlcG9jaFJvdW5kTGVuZ3RoID0gdmFsaWRhdG9yQ29uZmlnLmVwb2NoUm91bmRMZW5ndGggYXMgdWludDY0CglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JDb25maWc6ICh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAxNjkgNAoJYnRvaQoJZnJhbWVfYnVyeSAxIC8vIGVwb2NoUm91bmRMZW5ndGg6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1MjQKCS8vIGN1clJvdW5kID0gZ2xvYmFscy5yb3VuZAoJZ2xvYmFsIFJvdW5kCglmcmFtZV9idXJ5IDIgLy8gY3VyUm91bmQ6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1MjUKCS8vIHRoaXNFcG9jaEJlZ2luID0gY3VyUm91bmQgLSAoY3VyUm91bmQgJSBlcG9jaFJvdW5kTGVuZ3RoKQoJZnJhbWVfZGlnIDIgLy8gY3VyUm91bmQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDIgLy8gY3VyUm91bmQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gZXBvY2hSb3VuZExlbmd0aDogdWludDY0CgklCgktCglmcmFtZV9idXJ5IDMgLy8gdGhpc0Vwb2NoQmVnaW46IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1MjgKCS8vIGxhc3RQYXlvdXRFcG9jaCA9IHRoaXMubGFzdFBheW91dC52YWx1ZSAtICh0aGlzLmxhc3RQYXlvdXQudmFsdWUgJSBlcG9jaFJvdW5kTGVuZ3RoKQoJYnl0ZWMgMTQgLy8gICJsYXN0UGF5b3V0IgoJYXBwX2dsb2JhbF9nZXQKCWJ5dGVjIDE0IC8vICAibGFzdFBheW91dCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgMSAvLyBlcG9jaFJvdW5kTGVuZ3RoOiB1aW50NjQKCSUKCS0KCWZyYW1lX2J1cnkgNCAvLyBsYXN0UGF5b3V0RXBvY2g6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1MzAKCS8vIGFzc2VydChsYXN0UGF5b3V0RXBvY2ggIT09IHRoaXNFcG9jaEJlZ2luLCAiY2FuJ3QgY2FsbCBlcG9jaEJhbGFuY2VVcGRhdGUgaW4gc2FtZSBlcG9jaCBhcyBwcmlvciBjYWxsIikKCWZyYW1lX2RpZyA0IC8vIGxhc3RQYXlvdXRFcG9jaDogdWludDY0CglmcmFtZV9kaWcgMyAvLyB0aGlzRXBvY2hCZWdpbjogdWludDY0CgkhPQoKCS8vIGNhbid0IGNhbGwgZXBvY2hCYWxhbmNlVXBkYXRlIGluIHNhbWUgZXBvY2ggYXMgcHJpb3IgY2FsbAoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjUzMgoJLy8gdGhpcy5jaGVja0lmQmluQ2xvc2VkKCkKCWNhbGxzdWIgY2hlY2tJZkJpbkNsb3NlZAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1MzUKCS8vIHRoaXMubGFzdFBheW91dC52YWx1ZSA9IGN1clJvdW5kCglieXRlYyAxNCAvLyAgImxhc3RQYXlvdXQiCglmcmFtZV9kaWcgMiAvLyBjdXJSb3VuZDogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1MzYKCS8vIHRoaXMuZXBvY2hOdW1iZXIudmFsdWUgKz0gMQoJYnl0ZWMgMTkgLy8gICJlcG9jaE51bWJlciIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDEgLy8gMQoJKwoJYnl0ZWMgMTkgLy8gICJlcG9jaE51bWJlciIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjU0MQoJLy8gaXNUb2tlbkVsaWdpYmxlID0gdmFsaWRhdG9yQ29uZmlnLnJld2FyZFRva2VuSWQgIT09IDAKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvckNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDE1MyA4CglidG9pCglpbnRjIDAgLy8gMAoJIT0KCWZyYW1lX2J1cnkgNSAvLyBpc1Rva2VuRWxpZ2libGU6IGJvb2wKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTQyCgkvLyBwb29sT25lQXBwSUQgPSB0aGlzLmFwcC5pZAoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJZnJhbWVfYnVyeSA2IC8vIHBvb2xPbmVBcHBJRDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjU0MwoJLy8gcG9vbE9uZUFkZHJlc3MgPSB0aGlzLmFwcC5hZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZnJhbWVfYnVyeSA3IC8vIHBvb2xPbmVBZGRyZXNzOiBhZGRyZXNzCgoJLy8gKmlmMjBfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTQ4CgkvLyBpc1Rva2VuRWxpZ2libGUKCWZyYW1lX2RpZyA1IC8vIGlzVG9rZW5FbGlnaWJsZTogYm9vbAoJYnogKmlmMjBfZW5kCgoJLy8gKmlmMjBfY29uc2VxdWVudAoJLy8gKmlmMjFfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTQ5CgkvLyB0aGlzLnBvb2xJZC52YWx1ZSAhPT0gMQoJYnl0ZWMgNCAvLyAgInBvb2xJZCIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDEgLy8gMQoJIT0KCWJ6ICppZjIxX2VuZAoKCS8vICppZjIxX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1NTEKCS8vIHBvb2xPbmVBcHBJRCA9IHNlbmRNZXRob2RDYWxsPHR5cGVvZiBWYWxpZGF0b3JSZWdpc3RyeS5wcm90b3R5cGUuZ2V0UG9vbEFwcElkPih7CgkvLyAgICAgICAgICAgYXBwbGljYXRpb25JRDogdGhpcy5jcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSWQudmFsdWUsCgkvLyAgICAgICAgICAgbWV0aG9kQXJnczogW3RoaXMudmFsaWRhdG9ySWQudmFsdWUsIDFdLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAyIC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglieXRlYyAyMyAvLyAgbWV0aG9kICJnZXRQb29sQXBwSWQodWludDY0LHVpbnQ2NCl1aW50NjQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1NTIKCS8vIGFwcGxpY2F0aW9uSUQ6IHRoaXMuY3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElkLnZhbHVlCglieXRlYyAxIC8vICAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTUzCgkvLyBtZXRob2RBcmdzOiBbdGhpcy52YWxpZGF0b3JJZC52YWx1ZSwgMV0KCWJ5dGVjIDMgLy8gICJ2YWxpZGF0b3JJZCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMQoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIE51bUxvZ3MKCWludGMgMSAvLyAxCgktCglpdHhuYXMgTG9ncwoJZXh0cmFjdCA0IDAKCWJ0b2kKCWZyYW1lX2J1cnkgNiAvLyBwb29sT25lQXBwSUQ6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1NTUKCS8vIHBvb2xPbmVBZGRyZXNzID0gQXBwSUQuZnJvbVVpbnQ2NChwb29sT25lQXBwSUQpLmFkZHJlc3MKCWZyYW1lX2RpZyA2IC8vIHBvb2xPbmVBcHBJRDogdWludDY0CglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWZyYW1lX2J1cnkgNyAvLyBwb29sT25lQWRkcmVzczogYWRkcmVzcwoKKmlmMjFfZW5kOgoJLy8gKmlmMjJfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTYwCgkvLyB0aGlzLnBvb2xJZC52YWx1ZSA9PT0gMQoJYnl0ZWMgNCAvLyAgInBvb2xJZCIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDEgLy8gMQoJPT0KCWJ6ICppZjIyX2Vsc2UKCgkvLyAqaWYyMl9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTYxCgkvLyB0b2tlblBheW91dFJhdGlvID0gc2VuZE1ldGhvZENhbGw8dHlwZW9mIFZhbGlkYXRvclJlZ2lzdHJ5LnByb3RvdHlwZS5zZXRUb2tlblBheW91dFJhdGlvPih7CgkvLyAgICAgICAgICAgYXBwbGljYXRpb25JRDogdGhpcy5jcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSWQudmFsdWUsCgkvLyAgICAgICAgICAgbWV0aG9kQXJnczogW3RoaXMudmFsaWRhdG9ySWQudmFsdWVdLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAyIC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglieXRlYyAyNCAvLyAgbWV0aG9kICJzZXRUb2tlblBheW91dFJhdGlvKHVpbnQ2NCkodWludDY0WzI0XSx1aW50NjQpIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTYyCgkvLyBhcHBsaWNhdGlvbklEOiB0aGlzLmNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJZC52YWx1ZQoJYnl0ZWMgMSAvLyAgImNyZWF0b3JBcHAiCglhcHBfZ2xvYmFsX2dldAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjU2MwoJLy8gbWV0aG9kQXJnczogW3RoaXMudmFsaWRhdG9ySWQudmFsdWVdCglieXRlYyAzIC8vICAidmFsaWRhdG9ySWQiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIE51bUxvZ3MKCWludGMgMSAvLyAxCgktCglpdHhuYXMgTG9ncwoJZXh0cmFjdCA0IDAKCWZyYW1lX2J1cnkgOCAvLyB0b2tlblBheW91dFJhdGlvOiBQb29sVG9rZW5QYXlvdXRSYXRpbwoJYiAqaWYyMl9lbmQKCippZjIyX2Vsc2U6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTY3CgkvLyB0b2tlblBheW91dFJhdGlvID0gc2VuZE1ldGhvZENhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5wcm94aWVkU2V0VG9rZW5QYXlvdXRSYXRpbz4oewoJLy8gICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQocG9vbE9uZUFwcElEKSwKCS8vICAgICAgICAgICBtZXRob2RBcmdzOiBbeyBpZDogdGhpcy52YWxpZGF0b3JJZC52YWx1ZSwgcG9vbElkOiB0aGlzLnBvb2xJZC52YWx1ZSwgcG9vbEFwcElkOiB0aGlzLmFwcC5pZCB9XSwKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMiAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJYnl0ZWMgMjUgLy8gIG1ldGhvZCAicHJveGllZFNldFRva2VuUGF5b3V0UmF0aW8oKHVpbnQ2NCx1aW50NjQsdWludDY0KSkodWludDY0WzI0XSx1aW50NjQpIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTY4CgkvLyBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KHBvb2xPbmVBcHBJRCkKCWZyYW1lX2RpZyA2IC8vIHBvb2xPbmVBcHBJRDogdWludDY0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTY5CgkvLyBtZXRob2RBcmdzOiBbeyBpZDogdGhpcy52YWxpZGF0b3JJZC52YWx1ZSwgcG9vbElkOiB0aGlzLnBvb2xJZC52YWx1ZSwgcG9vbEFwcElkOiB0aGlzLmFwcC5pZCB9XQoJYnl0ZWMgMyAvLyAgInZhbGlkYXRvcklkIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWJ5dGVjIDQgLy8gICJwb29sSWQiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJY29uY2F0Cgl0eG5hIEFwcGxpY2F0aW9ucyAwCglpdG9iCgljb25jYXQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnRjIDEgLy8gMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCglmcmFtZV9idXJ5IDggLy8gdG9rZW5QYXlvdXRSYXRpbzogUG9vbFRva2VuUGF5b3V0UmF0aW8KCippZjIyX2VuZDoKCippZjIwX2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1NzYKCS8vIHZhbGlkYXRvclN0YXRlID0gc2VuZE1ldGhvZENhbGw8dHlwZW9mIFZhbGlkYXRvclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRWYWxpZGF0b3JTdGF0ZT4oewoJLy8gICAgICAgYXBwbGljYXRpb25JRDogdGhpcy5jcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSWQudmFsdWUsCgkvLyAgICAgICBtZXRob2RBcmdzOiBbdGhpcy52YWxpZGF0b3JJZC52YWx1ZV0sCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMiAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJcHVzaGJ5dGVzIDB4MWYyZjAxMDkgLy8gbWV0aG9kICJnZXRWYWxpZGF0b3JTdGF0ZSh1aW50NjQpKHVpbnQxNix1aW50NjQsdWludDY0LHVpbnQ2NCkiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1NzcKCS8vIGFwcGxpY2F0aW9uSUQ6IHRoaXMuY3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElkLnZhbHVlCglieXRlYyAxIC8vICAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTc4CgkvLyBtZXRob2RBcmdzOiBbdGhpcy52YWxpZGF0b3JJZC52YWx1ZV0KCWJ5dGVjIDMgLy8gICJ2YWxpZGF0b3JJZCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gTnVtTG9ncwoJaW50YyAxIC8vIDEKCS0KCWl0eG5hcyBMb2dzCglleHRyYWN0IDQgMAoJZnJhbWVfYnVyeSA5IC8vIHZhbGlkYXRvclN0YXRlOiAodWludDE2LHVpbnQ2NCx1aW50NjQsdWludDY0KQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1ODAKCS8vIHJld2FyZFRva2VuSGVsZEJhY2sgPSB2YWxpZGF0b3JTdGF0ZS5yZXdhcmRUb2tlbkhlbGRCYWNrCglmcmFtZV9kaWcgOSAvLyB2YWxpZGF0b3JTdGF0ZTogKHVpbnQxNix1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMTggOAoJYnRvaQoJZnJhbWVfYnVyeSAxMCAvLyByZXdhcmRUb2tlbkhlbGRCYWNrOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTg2CgkvLyBhbGdvUmV3YXJkQXZhaWwgPSB0aGlzLmFwcC5hZGRyZXNzLmJhbGFuY2UgLSB0aGlzLnRvdGFsQWxnb1N0YWtlZC52YWx1ZSAtIHRoaXMuYXBwLmFkZHJlc3MubWluQmFsYW5jZQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQoJcG9wCglieXRlYyA2IC8vICAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCS0KCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKCXBvcAoJLQoJZnJhbWVfYnVyeSAxMSAvLyBhbGdvUmV3YXJkQXZhaWw6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo1ODcKCS8vIGlzUG9vbFNhdHVyYXRlZCA9IGZhbHNlCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAxMiAvLyBpc1Bvb2xTYXR1cmF0ZWQ6IGJvb2wKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NTg4CgkvLyBhbGdvU2F0dXJhdGlvbkFtdCA9IHRoaXMuYWxnb1NhdHVyYXRpb25MZXZlbCgpCgljYWxsc3ViIGFsZ29TYXR1cmF0aW9uTGV2ZWwKCWZyYW1lX2J1cnkgMTMgLy8gYWxnb1NhdHVyYXRpb25BbXQ6IHVpbnQ2NAoKCS8vICppZjIzX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjU5NgoJLy8gdmFsaWRhdG9yU3RhdGUudG90YWxBbGdvU3Rha2VkID4gYWxnb1NhdHVyYXRpb25BbXQKCWZyYW1lX2RpZyA5IC8vIHZhbGlkYXRvclN0YXRlOiAodWludDE2LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAxMCA4CglidG9pCglmcmFtZV9kaWcgMTMgLy8gYWxnb1NhdHVyYXRpb25BbXQ6IHVpbnQ2NAoJPgoJYnogKmlmMjNfZW5kCgoJLy8gKmlmMjNfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjU5NwoJLy8gaXNQb29sU2F0dXJhdGVkID0gdHJ1ZQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgMTIgLy8gaXNQb29sU2F0dXJhdGVkOiBib29sCgoqaWYyM19lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NjAzCgkvLyB0b2tlblJld2FyZEF2YWlsID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMTQgLy8gdG9rZW5SZXdhcmRBdmFpbDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjYwNAoJLy8gdG9rZW5SZXdhcmRQYWlkT3V0ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMTUgLy8gdG9rZW5SZXdhcmRQYWlkT3V0OiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NjA1CgkvLyB2YWxpZGF0b3JDb21taXNzaW9uUGFpZE91dCA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDE2IC8vIHZhbGlkYXRvckNvbW1pc3Npb25QYWlkT3V0OiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NjA2CgkvLyBleGNlc3NUb0ZlZVNpbmsgPSAwCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAxNyAvLyBleGNlc3NUb0ZlZVNpbms6IHVpbnQ2NAoKCS8vICppZjI0X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjYwNwoJLy8gaXNUb2tlbkVsaWdpYmxlCglmcmFtZV9kaWcgNSAvLyBpc1Rva2VuRWxpZ2libGU6IGJvb2wKCWJ6ICppZjI0X2VuZAoKCS8vICppZjI0X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo2MDgKCS8vIHRva2VuUmV3YXJkQmFsID0KCS8vICAgICAgICAgcG9vbE9uZUFkZHJlc3MuYXNzZXRCYWxhbmNlKEFzc2V0SUQuZnJvbVVpbnQ2NCh2YWxpZGF0b3JDb25maWcucmV3YXJkVG9rZW5JZCkpIC0gcmV3YXJkVG9rZW5IZWxkQmFjawoJZnJhbWVfZGlnIDcgLy8gcG9vbE9uZUFkZHJlc3M6IGFkZHJlc3MKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvckNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDE1MyA4CglidG9pCglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIDEwIC8vIHJld2FyZFRva2VuSGVsZEJhY2s6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSAxOCAvLyB0b2tlblJld2FyZEJhbDogdWludDY0CgoJLy8gKmlmMjVfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NjEzCgkvLyB0b2tlblJld2FyZEJhbCA+PSB2YWxpZGF0b3JDb25maWcucmV3YXJkUGVyUGF5b3V0CglmcmFtZV9kaWcgMTggLy8gdG9rZW5SZXdhcmRCYWw6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9yQ29uZmlnOiAodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMTYxIDgKCWJ0b2kKCT49CglieiAqaWYyNV9lbmQKCgkvLyAqaWYyNV9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NjE5CgkvLyBvdXJQb29sUGN0T2ZXaG9sZSA9IHRva2VuUGF5b3V0UmF0aW8ucG9vbFBjdE9mV2hvbGVbdGhpcy5wb29sSWQudmFsdWUgLSAxXQoJZnJhbWVfZGlnIDggLy8gdG9rZW5QYXlvdXRSYXRpbzogUG9vbFRva2VuUGF5b3V0UmF0aW8KCWludGMgMCAvLyAwCglieXRlYyA0IC8vICAicG9vbElkIgoJYXBwX2dsb2JhbF9nZXQKCWludGMgMSAvLyAxCgktCglpbnRjIDE0IC8vIDgKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50YyAxNCAvLyA4CglleHRyYWN0MwoJYnRvaQoJZnJhbWVfYnVyeSAxOSAvLyBvdXJQb29sUGN0T2ZXaG9sZTogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjYyMgoJLy8gdG9rZW5SZXdhcmRBdmFpbCA9IHdpZGVSYXRpbyhbdmFsaWRhdG9yQ29uZmlnLnJld2FyZFBlclBheW91dCwgb3VyUG9vbFBjdE9mV2hvbGVdLCBbMV8wMDBfMDAwXSkKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvckNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDE2MSA4CglidG9pCglmcmFtZV9kaWcgMTkgLy8gb3VyUG9vbFBjdE9mV2hvbGU6IHVpbnQ2NAoJbXVsdwoJaW50YyAwIC8vIDAKCWludGMgOSAvLyAxXzAwMF8wMDAKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CglmcmFtZV9idXJ5IDE0IC8vIHRva2VuUmV3YXJkQXZhaWw6IHVpbnQ2NAoKKmlmMjVfZW5kOgoKKmlmMjRfZW5kOgoJLy8gKmlmMjZfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NjI1CgkvLyB0b2tlblJld2FyZEF2YWlsID09PSAwCglmcmFtZV9kaWcgMTQgLy8gdG9rZW5SZXdhcmRBdmFpbDogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjI2X2VuZAoKCS8vICppZjI2X2NvbnNlcXVlbnQKCS8vICppZjI3X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjYzMAoJLy8gYWxnb1Jld2FyZEF2YWlsIDwgMV8wMDBfMDAwCglmcmFtZV9kaWcgMTEgLy8gYWxnb1Jld2FyZEF2YWlsOiB1aW50NjQKCWludGMgOSAvLyAxXzAwMF8wMDAKCTwKCWJ6ICppZjI3X2VuZAoKCS8vICppZjI3X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo2MzEKCS8vIGxvZygnIXRva2VuJiYhbm9hbGdvIHRvIHBheScpCglwdXNoYnl0ZXMgMHgyMTc0NmY2YjY1NmUyNjI2MjE2ZTZmNjE2YzY3NmYyMDc0NmYyMDcwNjE3OSAvLyAiIXRva2VuJiYhbm9hbGdvIHRvIHBheSIKCWxvZwoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo2MzIKCS8vIHJldHVybjsKCXJldHN1YgoKKmlmMjdfZW5kOgoKKmlmMjZfZW5kOgoJLy8gKmlmMjhfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NjM2CgkvLyBpc1Bvb2xTYXR1cmF0ZWQKCWZyYW1lX2RpZyAxMiAvLyBpc1Bvb2xTYXR1cmF0ZWQ6IGJvb2wKCWJ6ICppZjI4X2Vsc2VpZjFfY29uZGl0aW9uCgoJLy8gKmlmMjhfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY0MgoJLy8gbm9ybWFsVmFsaWRhdG9yQ29tbWlzc2lvbiA9IHdpZGVSYXRpbygKCS8vICAgICAgICAgW2FsZ29SZXdhcmRBdmFpbCwgdmFsaWRhdG9yQ29uZmlnLnBlcmNlbnRUb1ZhbGlkYXRvciBhcyB1aW50NjRdLAoJLy8gICAgICAgICBbMV8wMDBfMDAwXQoJLy8gICAgICAgKQoJZnJhbWVfZGlnIDExIC8vIGFsZ29SZXdhcmRBdmFpbDogdWludDY0CglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JDb25maWc6ICh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAxNzMgNAoJYnRvaQoJbXVsdwoJaW50YyAwIC8vIDAKCWludGMgOSAvLyAxXzAwMF8wMDAKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CglmcmFtZV9idXJ5IDIwIC8vIG5vcm1hbFZhbGlkYXRvckNvbW1pc3Npb246IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo2NDcKCS8vIGRpbWluaXNoZWRSZXdhcmQgPSB3aWRlUmF0aW8oW2FsZ29SZXdhcmRBdmFpbCwgYWxnb1NhdHVyYXRpb25BbXRdLCBbdmFsaWRhdG9yU3RhdGUudG90YWxBbGdvU3Rha2VkXSkKCWZyYW1lX2RpZyAxMSAvLyBhbGdvUmV3YXJkQXZhaWw6IHVpbnQ2NAoJZnJhbWVfZGlnIDEzIC8vIGFsZ29TYXR1cmF0aW9uQW10OiB1aW50NjQKCW11bHcKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgOSAvLyB2YWxpZGF0b3JTdGF0ZTogKHVpbnQxNix1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMTAgOAoJYnRvaQoJZGl2bW9kdwoJcG9wCglwb3AKCXN3YXAKCSEKCgkvLyB3aWRlUmF0aW8gZmFpbGVkCglhc3NlcnQKCWZyYW1lX2J1cnkgMjEgLy8gZGltaW5pc2hlZFJld2FyZDogdWludDY0CgoJLy8gKmlmMjlfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NjQ5CgkvLyBkaW1pbmlzaGVkUmV3YXJkID4gYWxnb1Jld2FyZEF2YWlsIC0gbm9ybWFsVmFsaWRhdG9yQ29tbWlzc2lvbgoJZnJhbWVfZGlnIDIxIC8vIGRpbWluaXNoZWRSZXdhcmQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDExIC8vIGFsZ29SZXdhcmRBdmFpbDogdWludDY0CglmcmFtZV9kaWcgMjAgLy8gbm9ybWFsVmFsaWRhdG9yQ29tbWlzc2lvbjogdWludDY0CgktCgk+CglieiAqaWYyOV9lbmQKCgkvLyAqaWYyOV9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NjUwCgkvLyBkaW1pbmlzaGVkUmV3YXJkID0gYWxnb1Jld2FyZEF2YWlsIC0gbm9ybWFsVmFsaWRhdG9yQ29tbWlzc2lvbgoJZnJhbWVfZGlnIDExIC8vIGFsZ29SZXdhcmRBdmFpbDogdWludDY0CglmcmFtZV9kaWcgMjAgLy8gbm9ybWFsVmFsaWRhdG9yQ29tbWlzc2lvbjogdWludDY0CgktCglmcmFtZV9idXJ5IDIxIC8vIGRpbWluaXNoZWRSZXdhcmQ6IHVpbnQ2NAoKKmlmMjlfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY1MwoJLy8gZXhjZXNzVG9GZWVTaW5rID0gYWxnb1Jld2FyZEF2YWlsIC0gZGltaW5pc2hlZFJld2FyZAoJZnJhbWVfZGlnIDExIC8vIGFsZ29SZXdhcmRBdmFpbDogdWludDY0CglmcmFtZV9kaWcgMjEgLy8gZGltaW5pc2hlZFJld2FyZDogdWludDY0CgktCglmcmFtZV9idXJ5IDE3IC8vIGV4Y2Vzc1RvRmVlU2luazogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY1NAoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgICBhbW91bnQ6IGV4Y2Vzc1RvRmVlU2luaywKCS8vICAgICAgICAgcmVjZWl2ZXI6IGJsb2Nrc1t0aGlzLnR4bi5maXJzdFZhbGlkIC0gMV0uZmVlU2luaywKCS8vICAgICAgICAgbm90ZTogJ3Bvb2wgc2F0dXJhdGVkLCBleGNlc3MgdG8gZmVlIHNpbmsnLAoJLy8gICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY1NQoJLy8gYW1vdW50OiBleGNlc3NUb0ZlZVNpbmsKCWZyYW1lX2RpZyAxNyAvLyBleGNlc3NUb0ZlZVNpbms6IHVpbnQ2NAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NjU2CgkvLyByZWNlaXZlcjogYmxvY2tzW3RoaXMudHhuLmZpcnN0VmFsaWQgLSAxXS5mZWVTaW5rCgl0eG4gRmlyc3RWYWxpZAoJaW50YyAxIC8vIDEKCS0KCWJsb2NrIEJsa0ZlZVNpbmsKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NjU3CgkvLyBub3RlOiAncG9vbCBzYXR1cmF0ZWQsIGV4Y2VzcyB0byBmZWUgc2luaycKCXB1c2hieXRlcyAweDcwNmY2ZjZjMjA3MzYxNzQ3NTcyNjE3NDY1NjQyYzIwNjU3ODYzNjU3MzczMjA3NDZmMjA2NjY1NjUyMDczNjk2ZTZiIC8vICJwb29sIHNhdHVyYXRlZCwgZXhjZXNzIHRvIGZlZSBzaW5rIgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo2NjAKCS8vIGFsZ29SZXdhcmRBdmFpbCA9IGRpbWluaXNoZWRSZXdhcmQKCWZyYW1lX2RpZyAyMSAvLyBkaW1pbmlzaGVkUmV3YXJkOiB1aW50NjQKCWZyYW1lX2J1cnkgMTEgLy8gYWxnb1Jld2FyZEF2YWlsOiB1aW50NjQKCWIgKmlmMjhfZW5kCgoqaWYyOF9lbHNlaWYxX2NvbmRpdGlvbjoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo2NjEKCS8vIHZhbGlkYXRvckNvbmZpZy5wZXJjZW50VG9WYWxpZGF0b3IgIT09IDAKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvckNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDE3MyA0CglidG9pCglpbnRjIDAgLy8gMAoJIT0KCWJ6ICppZjI4X2VuZAoKCS8vICppZjI4X2Vsc2VpZjFfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY2NAoJLy8gdmFsaWRhdG9yQ29tbWlzc2lvblBhaWRPdXQgPSB3aWRlUmF0aW8oCgkvLyAgICAgICAgIFthbGdvUmV3YXJkQXZhaWwsIHZhbGlkYXRvckNvbmZpZy5wZXJjZW50VG9WYWxpZGF0b3IgYXMgdWludDY0XSwKCS8vICAgICAgICAgWzFfMDAwXzAwMF0KCS8vICAgICAgICkKCWZyYW1lX2RpZyAxMSAvLyBhbGdvUmV3YXJkQXZhaWw6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9yQ29uZmlnOiAodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMTczIDQKCWJ0b2kKCW11bHcKCWludGMgMCAvLyAwCglpbnRjIDkgLy8gMV8wMDBfMDAwCglkaXZtb2R3Cglwb3AKCXBvcAoJc3dhcAoJIQoKCS8vIHdpZGVSYXRpbyBmYWlsZWQKCWFzc2VydAoJZnJhbWVfYnVyeSAxNiAvLyB2YWxpZGF0b3JDb21taXNzaW9uUGFpZE91dDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY3MAoJLy8gYWxnb1Jld2FyZEF2YWlsIC09IHZhbGlkYXRvckNvbW1pc3Npb25QYWlkT3V0CglmcmFtZV9kaWcgMTEgLy8gYWxnb1Jld2FyZEF2YWlsOiB1aW50NjQKCWZyYW1lX2RpZyAxNiAvLyB2YWxpZGF0b3JDb21taXNzaW9uUGFpZE91dDogdWludDY0CgktCglmcmFtZV9idXJ5IDExIC8vIGFsZ29SZXdhcmRBdmFpbDogdWludDY0CgoJLy8gKmlmMzBfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6Njc3CgkvLyB2YWxpZGF0b3JDb21taXNzaW9uUGFpZE91dCA+IDAKCWZyYW1lX2RpZyAxNiAvLyB2YWxpZGF0b3JDb21taXNzaW9uUGFpZE91dDogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJYnogKmlmMzBfZW5kCgoJLy8gKmlmMzBfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY4MAoJLy8gbWFuYWdlclRvcE9mZiA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDIyIC8vIG1hbmFnZXJUb3BPZmY6IHVpbnQ2NAoKCS8vICppZjMxX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY4MgoJLy8gdmFsaWRhdG9yQ29uZmlnLm1hbmFnZXIgIT09IHZhbGlkYXRvckNvbmZpZy52YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyAmJgoJLy8gICAgICAgICAgIHZhbGlkYXRvckNvbmZpZy5tYW5hZ2VyLmJhbGFuY2UgLSB2YWxpZGF0b3JDb25maWcubWFuYWdlci5taW5CYWxhbmNlIDwgMl8xMDBfMDAwCglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JDb25maWc6ICh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA0MCAzMgoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9yQ29uZmlnOiAodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMTc3IDMyCgkhPQoJZHVwCglieiAqc2tpcF9hbmQzCglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JDb25maWc6ICh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA0MCAzMgoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvckNvbmZpZzogKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDQwIDMyCglhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKCXBvcAoJLQoJaW50YyAxMyAvLyAyXzEwMF8wMDAKCTwKCSYmCgoqc2tpcF9hbmQzOgoJYnogKmlmMzFfZW5kCgoJLy8gKmlmMzFfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY4NQoJLy8gbWFuYWdlclRvcE9mZiA9IHZhbGlkYXRvckNvbW1pc3Npb25QYWlkT3V0IDwgMl8xMDBfMDAwID8gdmFsaWRhdG9yQ29tbWlzc2lvblBhaWRPdXQgOiAyXzEwMF8wMDAKCWZyYW1lX2RpZyAxNiAvLyB2YWxpZGF0b3JDb21taXNzaW9uUGFpZE91dDogdWludDY0CglpbnRjIDEzIC8vIDJfMTAwXzAwMAoJPAoJYnogKnRlcm5hcnkxX2ZhbHNlCglmcmFtZV9kaWcgMTYgLy8gdmFsaWRhdG9yQ29tbWlzc2lvblBhaWRPdXQ6IHVpbnQ2NAoJYiAqdGVybmFyeTFfZW5kCgoqdGVybmFyeTFfZmFsc2U6CglpbnRjIDEzIC8vIDJfMTAwXzAwMAoKKnRlcm5hcnkxX2VuZDoKCWZyYW1lX2J1cnkgMjIgLy8gbWFuYWdlclRvcE9mZjogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY4NgoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgICAgICAgYW1vdW50OiBtYW5hZ2VyVG9wT2ZmLAoJLy8gICAgICAgICAgICAgcmVjZWl2ZXI6IHZhbGlkYXRvckNvbmZpZy5tYW5hZ2VyLAoJLy8gICAgICAgICAgICAgbm90ZTogJ3ZhbGlkYXRvciByZXdhcmQgdG8gbWFuYWdlciBmb3IgZnVuZGluZyBlcG9jaCB1cGRhdGVzJywKCS8vICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6Njg3CgkvLyBhbW91bnQ6IG1hbmFnZXJUb3BPZmYKCWZyYW1lX2RpZyAyMiAvLyBtYW5hZ2VyVG9wT2ZmOiB1aW50NjQKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY4OAoJLy8gcmVjZWl2ZXI6IHZhbGlkYXRvckNvbmZpZy5tYW5hZ2VyCglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JDb25maWc6ICh1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCx1aW50OCxhZGRyZXNzLHVpbnQ2NFs0XSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50MzIsdWludDMyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA0MCAzMgoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo2ODkKCS8vIG5vdGU6ICd2YWxpZGF0b3IgcmV3YXJkIHRvIG1hbmFnZXIgZm9yIGZ1bmRpbmcgZXBvY2ggdXBkYXRlcycKCXB1c2hieXRlcyAweDc2NjE2YzY5NjQ2MTc0NmY3MjIwNzI2NTc3NjE3MjY0MjA3NDZmMjA2ZDYxNmU2MTY3NjU3MjIwNjY2ZjcyMjA2Njc1NmU2NDY5NmU2NzIwNjU3MDZmNjM2ODIwNzU3MDY0NjE3NDY1NzMgLy8gInZhbGlkYXRvciByZXdhcmQgdG8gbWFuYWdlciBmb3IgZnVuZGluZyBlcG9jaCB1cGRhdGVzIgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMzFfZW5kOgoJLy8gKmlmMzJfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NjkyCgkvLyB2YWxpZGF0b3JDb21taXNzaW9uUGFpZE91dCAtIG1hbmFnZXJUb3BPZmYgPiAwCglmcmFtZV9kaWcgMTYgLy8gdmFsaWRhdG9yQ29tbWlzc2lvblBhaWRPdXQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDIyIC8vIG1hbmFnZXJUb3BPZmY6IHVpbnQ2NAoJLQoJaW50YyAwIC8vIDAKCT4KCWJ6ICppZjMyX2VuZAoKCS8vICppZjMyX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo2OTMKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgICAgICAgIGFtb3VudDogdmFsaWRhdG9yQ29tbWlzc2lvblBhaWRPdXQgLSBtYW5hZ2VyVG9wT2ZmLAoJLy8gICAgICAgICAgICAgcmVjZWl2ZXI6IHZhbGlkYXRvckNvbmZpZy52YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcywKCS8vICAgICAgICAgICAgIG5vdGU6ICd2YWxpZGF0b3IgcmV3YXJkJywKCS8vICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6Njk0CgkvLyBhbW91bnQ6IHZhbGlkYXRvckNvbW1pc3Npb25QYWlkT3V0IC0gbWFuYWdlclRvcE9mZgoJZnJhbWVfZGlnIDE2IC8vIHZhbGlkYXRvckNvbW1pc3Npb25QYWlkT3V0OiB1aW50NjQKCWZyYW1lX2RpZyAyMiAvLyBtYW5hZ2VyVG9wT2ZmOiB1aW50NjQKCS0KCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY5NQoJLy8gcmVjZWl2ZXI6IHZhbGlkYXRvckNvbmZpZy52YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcwoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9yQ29uZmlnOiAodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMTc3IDMyCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjY5NgoJLy8gbm90ZTogJ3ZhbGlkYXRvciByZXdhcmQnCglwdXNoYnl0ZXMgMHg3NjYxNmM2OTY0NjE3NDZmNzIyMDcyNjU3NzYxNzI2NCAvLyAidmFsaWRhdG9yIHJld2FyZCIKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCippZjMyX2VuZDoKCippZjMwX2VuZDoKCippZjI4X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo3MDgKCS8vIGluY3JlYXNlZFN0YWtlID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMjMgLy8gaW5jcmVhc2VkU3Rha2U6IHVpbnQ2NAoKCS8vICppZjMzX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjczMgoJLy8gYWxnb1Jld2FyZEF2YWlsICE9PSAwIHx8IHRva2VuUmV3YXJkQXZhaWwgIT09IDAKCWZyYW1lX2RpZyAxMSAvLyBhbGdvUmV3YXJkQXZhaWw6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCSE9CglkdXAKCWJueiAqc2tpcF9vcjEKCWZyYW1lX2RpZyAxNCAvLyB0b2tlblJld2FyZEF2YWlsOiB1aW50NjQKCWludGMgMCAvLyAwCgkhPQoJfHwKCipza2lwX29yMToKCWJ6ICppZjMzX2VuZAoKCS8vICppZjMzX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo3MzMKCS8vIHBhcnRpYWxTdGFrZXJzVG90YWxTdGFrZTogdWludDY0ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMjQgLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NzM0CgkvLyBvcmlnQWxnb1Jld2FyZCA9IGFsZ29SZXdhcmRBdmFpbAoJZnJhbWVfZGlnIDExIC8vIGFsZ29SZXdhcmRBdmFpbDogdWludDY0CglmcmFtZV9idXJ5IDI1IC8vIG9yaWdBbGdvUmV3YXJkOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NzM2CgkvLyBvcmlnVG9rZW5SZXdhcmQgPSB0b2tlblJld2FyZEF2YWlsCglmcmFtZV9kaWcgMTQgLy8gdG9rZW5SZXdhcmRBdmFpbDogdWludDY0CglmcmFtZV9idXJ5IDI2IC8vIG9yaWdUb2tlblJld2FyZDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjczNwoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YWtlcnMudmFsdWUubGVuZ3RoOyBpICs9IDEpCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSAyNyAvLyBpOiB1aW50NjQKCipmb3JfNDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo3MzcKCS8vIGkgPCB0aGlzLnN0YWtlcnMudmFsdWUubGVuZ3RoCglmcmFtZV9kaWcgMjcgLy8gaTogdWludDY0CglpbnRjIDcgLy8gMjAwCgk8CglieiAqZm9yXzRfZW5kCgoJLy8gKmlmMzRfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NzM4CgkvLyBnbG9iYWxzLm9wY29kZUJ1ZGdldCA8IDQwMAoJZ2xvYmFsIE9wY29kZUJ1ZGdldAoJaW50YyAxNiAvLyA0MDAKCTwKCWJ6ICppZjM0X2VuZAoKCS8vICppZjM0X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo3MzkKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludGMgMiAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCglieXRlYyA1IC8vICAjcHJhZ21hIHZlcnNpb24gMTA7IGludCAxCglkdXAKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCglpbnRjIDggLy8gIERlbGV0ZUFwcGxpY2F0aW9uCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoJaXR4bl9zdWJtaXQKCippZjM0X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo3NDEKCS8vIGNtcFN0YWtlciA9IGNsb25lKHRoaXMuc3Rha2Vycy52YWx1ZVtpXSkKCWZyYW1lX2RpZyAyNyAvLyBpOiB1aW50NjQKCWludGMgMyAvLyA2NAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDMgLy8gNjQKCWJ5dGVjIDIgLy8gICJzdGFrZXJzIgoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWZyYW1lX2J1cnkgMjggLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCgoJLy8gKmlmMzVfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NzQyCgkvLyBjbXBTdGFrZXIuYWNjb3VudCAhPT0gZ2xvYmFscy56ZXJvQWRkcmVzcwoJZnJhbWVfZGlnIDI4IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAwIDMyCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9CglieiAqaWYzNV9lbmQKCgkvLyAqaWYzNV9jb25zZXF1ZW50CgkvLyAqaWYzNl9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo3NDMKCS8vIGNtcFN0YWtlci5lbnRyeVJvdW5kID49IHRoaXNFcG9jaEJlZ2luCglmcmFtZV9kaWcgMjggLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDU2IDgKCWJ0b2kKCWZyYW1lX2RpZyAzIC8vIHRoaXNFcG9jaEJlZ2luOiB1aW50NjQKCT49CglieiAqaWYzNl9lbHNlCgoJLy8gKmlmMzZfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjc0NgoJLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlICs9IGNtcFN0YWtlci5iYWxhbmNlCglmcmFtZV9kaWcgMjQgLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlOiB1aW50NjQKCWZyYW1lX2RpZyAyOCAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJKwoJZnJhbWVfYnVyeSAyNCAvLyBwYXJ0aWFsU3Rha2Vyc1RvdGFsU3Rha2U6IHVpbnQ2NAoJYiAqaWYzNl9lbmQKCippZjM2X2Vsc2U6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NzUwCgkvLyB0aW1lSW5Qb29sID0gdGhpc0Vwb2NoQmVnaW4gLSBjbXBTdGFrZXIuZW50cnlSb3VuZAoJZnJhbWVfZGlnIDMgLy8gdGhpc0Vwb2NoQmVnaW46IHVpbnQ2NAoJZnJhbWVfZGlnIDI4IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA1NiA4CglidG9pCgktCglmcmFtZV9idXJ5IDI5IC8vIHRpbWVJblBvb2w6IHVpbnQ2NAoKCS8vICppZjM3X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjc1NAoJLy8gdGltZUluUG9vbCA8IGVwb2NoUm91bmRMZW5ndGgKCWZyYW1lX2RpZyAyOSAvLyB0aW1lSW5Qb29sOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGVwb2NoUm91bmRMZW5ndGg6IHVpbnQ2NAoJPAoJYnogKmlmMzdfZW5kCgoJLy8gKmlmMzdfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjc1NQoJLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlICs9IGNtcFN0YWtlci5iYWxhbmNlCglmcmFtZV9kaWcgMjQgLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlOiB1aW50NjQKCWZyYW1lX2RpZyAyOCAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJKwoJZnJhbWVfYnVyeSAyNCAvLyBwYXJ0aWFsU3Rha2Vyc1RvdGFsU3Rha2U6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo3NTYKCS8vIHRpbWVQZXJjZW50YWdlID0gKHRpbWVJblBvb2wgKiAxMDAwKSAvIGVwb2NoUm91bmRMZW5ndGgKCWZyYW1lX2RpZyAyOSAvLyB0aW1lSW5Qb29sOiB1aW50NjQKCWludGMgMTEgLy8gMTAwMAoJKgoJZnJhbWVfZGlnIDEgLy8gZXBvY2hSb3VuZExlbmd0aDogdWludDY0CgkvCglmcmFtZV9idXJ5IDMwIC8vIHRpbWVQZXJjZW50YWdlOiB1aW50NjQKCgkvLyAqaWYzOF9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo3NTgKCS8vIHRva2VuUmV3YXJkQXZhaWwgPiAwCglmcmFtZV9kaWcgMTQgLy8gdG9rZW5SZXdhcmRBdmFpbDogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJYnogKmlmMzhfZW5kCgoJLy8gKmlmMzhfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjc2MAoJLy8gc3Rha2VyVG9rZW5SZXdhcmQgPSB3aWRlUmF0aW8oCgkvLyAgICAgICAgICAgICAgICAgICBbY21wU3Rha2VyLmJhbGFuY2UsIG9yaWdUb2tlblJld2FyZCwgdGltZVBlcmNlbnRhZ2VdLAoJLy8gICAgICAgICAgICAgICAgICAgW3RoaXMudG90YWxBbGdvU3Rha2VkLnZhbHVlLCAxMDAwXQoJLy8gICAgICAgICAgICAgICAgICkKCWZyYW1lX2RpZyAyOCAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJZnJhbWVfZGlnIDI2IC8vIG9yaWdUb2tlblJld2FyZDogdWludDY0CgltdWx3CglmcmFtZV9kaWcgMzAgLy8gdGltZVBlcmNlbnRhZ2U6IHVpbnQ2NAoJdW5jb3ZlciAyCglkaWcgMQoJKgoJY292ZXIgMgoJbXVsdwoJY292ZXIgMgoJKwoJc3dhcAoJYnl0ZWMgNiAvLyAgInN0YWtlZCIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDExIC8vIDEwMDAKCW11bHcKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CglmcmFtZV9idXJ5IDMxIC8vIHN0YWtlclRva2VuUmV3YXJkOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NzY3CgkvLyB0b2tlblJld2FyZEF2YWlsIC09IHN0YWtlclRva2VuUmV3YXJkCglmcmFtZV9kaWcgMTQgLy8gdG9rZW5SZXdhcmRBdmFpbDogdWludDY0CglmcmFtZV9kaWcgMzEgLy8gc3Rha2VyVG9rZW5SZXdhcmQ6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSAxNCAvLyB0b2tlblJld2FyZEF2YWlsOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NzY4CgkvLyBjbXBTdGFrZXIucmV3YXJkVG9rZW5CYWxhbmNlICs9IHN0YWtlclRva2VuUmV3YXJkCglmcmFtZV9kaWcgMjggLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglpbnRjIDIwIC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgMjggLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDQ4IDgKCWJ0b2kKCWZyYW1lX2RpZyAzMSAvLyBzdGFrZXJUb2tlblJld2FyZDogdWludDY0CgkrCglpdG9iCglyZXBsYWNlMwoJZnJhbWVfYnVyeSAyOCAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NzY5CgkvLyB0b2tlblJld2FyZFBhaWRPdXQgKz0gc3Rha2VyVG9rZW5SZXdhcmQKCWZyYW1lX2RpZyAxNSAvLyB0b2tlblJld2FyZFBhaWRPdXQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDMxIC8vIHN0YWtlclRva2VuUmV3YXJkOiB1aW50NjQKCSsKCWZyYW1lX2J1cnkgMTUgLy8gdG9rZW5SZXdhcmRQYWlkT3V0OiB1aW50NjQKCippZjM4X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo3NzIKCS8vIHN0YWtlclJld2FyZCA9IHdpZGVSYXRpbygKCS8vICAgICAgICAgICAgICAgICBbY21wU3Rha2VyLmJhbGFuY2UsIG9yaWdBbGdvUmV3YXJkLCB0aW1lUGVyY2VudGFnZV0sCgkvLyAgICAgICAgICAgICAgICAgW3RoaXMudG90YWxBbGdvU3Rha2VkLnZhbHVlLCAxMDAwXQoJLy8gICAgICAgICAgICAgICApCglmcmFtZV9kaWcgMjggLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDMyIDgKCWJ0b2kKCWZyYW1lX2RpZyAyNSAvLyBvcmlnQWxnb1Jld2FyZDogdWludDY0CgltdWx3CglmcmFtZV9kaWcgMzAgLy8gdGltZVBlcmNlbnRhZ2U6IHVpbnQ2NAoJdW5jb3ZlciAyCglkaWcgMQoJKgoJY292ZXIgMgoJbXVsdwoJY292ZXIgMgoJKwoJc3dhcAoJYnl0ZWMgNiAvLyAgInN0YWtlZCIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDExIC8vIDEwMDAKCW11bHcKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CglmcmFtZV9idXJ5IDMyIC8vIHN0YWtlclJld2FyZDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjc3OAoJLy8gYWxnb1Jld2FyZEF2YWlsIC09IHN0YWtlclJld2FyZAoJZnJhbWVfZGlnIDExIC8vIGFsZ29SZXdhcmRBdmFpbDogdWludDY0CglmcmFtZV9kaWcgMzIgLy8gc3Rha2VyUmV3YXJkOiB1aW50NjQKCS0KCWZyYW1lX2J1cnkgMTEgLy8gYWxnb1Jld2FyZEF2YWlsOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6NzgxCgkvLyBjbXBTdGFrZXIuYmFsYW5jZSArPSBzdGFrZXJSZXdhcmQKCWZyYW1lX2RpZyAyOCAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWludGMgNCAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIDI4IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAzMiA4CglidG9pCglmcmFtZV9kaWcgMzIgLy8gc3Rha2VyUmV3YXJkOiB1aW50NjQKCSsKCWl0b2IKCXJlcGxhY2UzCglmcmFtZV9idXJ5IDI4IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo3ODIKCS8vIGNtcFN0YWtlci50b3RhbFJld2FyZGVkICs9IHN0YWtlclJld2FyZAoJZnJhbWVfZGlnIDI4IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJaW50YyAxOSAvLyAgaGVhZE9mZnNldAoJZnJhbWVfZGlnIDI4IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA0MCA4CglidG9pCglmcmFtZV9kaWcgMzIgLy8gc3Rha2VyUmV3YXJkOiB1aW50NjQKCSsKCWl0b2IKCXJlcGxhY2UzCglmcmFtZV9idXJ5IDI4IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo3ODMKCS8vIGluY3JlYXNlZFN0YWtlICs9IHN0YWtlclJld2FyZAoJZnJhbWVfZGlnIDIzIC8vIGluY3JlYXNlZFN0YWtlOiB1aW50NjQKCWZyYW1lX2RpZyAzMiAvLyBzdGFrZXJSZXdhcmQ6IHVpbnQ2NAoJKwoJZnJhbWVfYnVyeSAyMyAvLyBpbmNyZWFzZWRTdGFrZTogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjc4NQoJLy8gdGhpcy5zdGFrZXJzLnZhbHVlW2ldID0gY21wU3Rha2VyCglmcmFtZV9kaWcgMjcgLy8gaTogdWludDY0CglpbnRjIDMgLy8gNjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJZnJhbWVfZGlnIDI4IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZWMgMiAvLyAgInN0YWtlcnMiCgljb3ZlciAyCglib3hfcmVwbGFjZQoKKmlmMzdfZW5kOgoKKmlmMzZfZW5kOgoKKmlmMzVfZW5kOgoKKmZvcl80X2NvbnRpbnVlOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjczNwoJLy8gaSArPSAxCglmcmFtZV9kaWcgMjcgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAyNyAvLyBpOiB1aW50NjQKCWIgKmZvcl80CgoqZm9yXzRfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjc5MwoJLy8gbmV3UG9vbFRvdGFsU3Rha2UgPSB0aGlzLnRvdGFsQWxnb1N0YWtlZC52YWx1ZSAtIHBhcnRpYWxTdGFrZXJzVG90YWxTdGFrZQoJYnl0ZWMgNiAvLyAgInN0YWtlZCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgMjQgLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlOiB1aW50NjQKCS0KCWZyYW1lX2J1cnkgMzMgLy8gbmV3UG9vbFRvdGFsU3Rha2U6IHVpbnQ2NAoKCS8vICppZjM5X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjc5NwoJLy8gbmV3UG9vbFRvdGFsU3Rha2UgPiAwCglmcmFtZV9kaWcgMzMgLy8gbmV3UG9vbFRvdGFsU3Rha2U6IHVpbnQ2NAoJaW50YyAwIC8vIDAKCT4KCWJ6ICppZjM5X2VuZAoKCS8vICppZjM5X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo3OTkKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFrZXJzLnZhbHVlLmxlbmd0aDsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgMzQgLy8gaTogdWludDY0CgoqZm9yXzU6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6Nzk5CgkvLyBpIDwgdGhpcy5zdGFrZXJzLnZhbHVlLmxlbmd0aAoJZnJhbWVfZGlnIDM0IC8vIGk6IHVpbnQ2NAoJaW50YyA3IC8vIDIwMAoJPAoJYnogKmZvcl81X2VuZAoKCS8vICppZjQwX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjgwMAoJLy8gZ2xvYmFscy5vcGNvZGVCdWRnZXQgPCAyMDAKCWdsb2JhbCBPcGNvZGVCdWRnZXQKCWludGMgNyAvLyAyMDAKCTwKCWJ6ICppZjQwX2VuZAoKCS8vICppZjQwX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo4MDEKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludGMgMiAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCglieXRlYyA1IC8vICAjcHJhZ21hIHZlcnNpb24gMTA7IGludCAxCglkdXAKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCglpbnRjIDggLy8gIERlbGV0ZUFwcGxpY2F0aW9uCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoJaXR4bl9zdWJtaXQKCippZjQwX2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo4MDMKCS8vIGNtcFN0YWtlciA9IGNsb25lKHRoaXMuc3Rha2Vycy52YWx1ZVtpXSkKCWZyYW1lX2RpZyAzNCAvLyBpOiB1aW50NjQKCWludGMgMyAvLyA2NAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDMgLy8gNjQKCWJ5dGVjIDIgLy8gICJzdGFrZXJzIgoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWZyYW1lX2J1cnkgMzUgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCgoJLy8gKmlmNDFfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODA0CgkvLyBjbXBTdGFrZXIuYWNjb3VudCAhPT0gZ2xvYmFscy56ZXJvQWRkcmVzcyAmJiBjbXBTdGFrZXIuZW50cnlSb3VuZCA8IHRoaXNFcG9jaEJlZ2luCglmcmFtZV9kaWcgMzUgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDAgMzIKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWR1cAoJYnogKnNraXBfYW5kNAoJZnJhbWVfZGlnIDM1IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA1NiA4CglidG9pCglmcmFtZV9kaWcgMyAvLyB0aGlzRXBvY2hCZWdpbjogdWludDY0Cgk8CgkmJgoKKnNraXBfYW5kNDoKCWJ6ICppZjQxX2VuZAoKCS8vICppZjQxX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo4MDUKCS8vIHRpbWVJblBvb2wgPSB0aGlzRXBvY2hCZWdpbiAtIGNtcFN0YWtlci5lbnRyeVJvdW5kCglmcmFtZV9kaWcgMyAvLyB0aGlzRXBvY2hCZWdpbjogdWludDY0CglmcmFtZV9kaWcgMzUgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDU2IDgKCWJ0b2kKCS0KCWZyYW1lX2J1cnkgMzYgLy8gdGltZUluUG9vbDogdWludDY0CgoJLy8gKmlmNDJfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODA3CgkvLyB0aW1lSW5Qb29sID49IGVwb2NoUm91bmRMZW5ndGgKCWZyYW1lX2RpZyAzNiAvLyB0aW1lSW5Qb29sOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGVwb2NoUm91bmRMZW5ndGg6IHVpbnQ2NAoJPj0KCWJ6ICppZjQyX2VuZAoKCS8vICppZjQyX2NvbnNlcXVlbnQKCS8vICppZjQzX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjgxMgoJLy8gdG9rZW5SZXdhcmRBdmFpbCA+IDAKCWZyYW1lX2RpZyAxNCAvLyB0b2tlblJld2FyZEF2YWlsOiB1aW50NjQKCWludGMgMCAvLyAwCgk+CglieiAqaWY0M19lbmQKCgkvLyAqaWY0M19jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODEzCgkvLyBzdGFrZXJUb2tlblJld2FyZCA9IHdpZGVSYXRpbyhbY21wU3Rha2VyLmJhbGFuY2UsIHRva2VuUmV3YXJkQXZhaWxdLCBbbmV3UG9vbFRvdGFsU3Rha2VdKQoJZnJhbWVfZGlnIDM1IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAzMiA4CglidG9pCglmcmFtZV9kaWcgMTQgLy8gdG9rZW5SZXdhcmRBdmFpbDogdWludDY0CgltdWx3CglpbnRjIDAgLy8gMAoJZnJhbWVfZGlnIDMzIC8vIG5ld1Bvb2xUb3RhbFN0YWtlOiB1aW50NjQKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CglmcmFtZV9idXJ5IDM3IC8vIHN0YWtlclRva2VuUmV3YXJkOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODE1CgkvLyBjbXBTdGFrZXIucmV3YXJkVG9rZW5CYWxhbmNlICs9IHN0YWtlclRva2VuUmV3YXJkCglmcmFtZV9kaWcgMzUgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglpbnRjIDIwIC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgMzUgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDQ4IDgKCWJ0b2kKCWZyYW1lX2RpZyAzNyAvLyBzdGFrZXJUb2tlblJld2FyZDogdWludDY0CgkrCglpdG9iCglyZXBsYWNlMwoJZnJhbWVfYnVyeSAzNSAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODE2CgkvLyB0b2tlblJld2FyZFBhaWRPdXQgKz0gc3Rha2VyVG9rZW5SZXdhcmQKCWZyYW1lX2RpZyAxNSAvLyB0b2tlblJld2FyZFBhaWRPdXQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDM3IC8vIHN0YWtlclRva2VuUmV3YXJkOiB1aW50NjQKCSsKCWZyYW1lX2J1cnkgMTUgLy8gdG9rZW5SZXdhcmRQYWlkT3V0OiB1aW50NjQKCippZjQzX2VuZDoKCS8vICppZjQ0X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjgxOAoJLy8gYWxnb1Jld2FyZEF2YWlsID4gMAoJZnJhbWVfZGlnIDExIC8vIGFsZ29SZXdhcmRBdmFpbDogdWludDY0CglpbnRjIDAgLy8gMAoJPgoJYnogKmlmNDRfZW5kCgoJLy8gKmlmNDRfY29uc2VxdWVudAoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjgxOQoJLy8gc3Rha2VyUmV3YXJkID0gd2lkZVJhdGlvKFtjbXBTdGFrZXIuYmFsYW5jZSwgYWxnb1Jld2FyZEF2YWlsXSwgW25ld1Bvb2xUb3RhbFN0YWtlXSkKCWZyYW1lX2RpZyAzNSAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJZnJhbWVfZGlnIDExIC8vIGFsZ29SZXdhcmRBdmFpbDogdWludDY0CgltdWx3CglpbnRjIDAgLy8gMAoJZnJhbWVfZGlnIDMzIC8vIG5ld1Bvb2xUb3RhbFN0YWtlOiB1aW50NjQKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCgoJLy8gd2lkZVJhdGlvIGZhaWxlZAoJYXNzZXJ0CglmcmFtZV9idXJ5IDM4IC8vIHN0YWtlclJld2FyZDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjgyMgoJLy8gY21wU3Rha2VyLmJhbGFuY2UgKz0gc3Rha2VyUmV3YXJkCglmcmFtZV9kaWcgMzUgLy8gY21wU3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCglpbnRjIDQgLy8gIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAzNSAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJZnJhbWVfZGlnIDM4IC8vIHN0YWtlclJld2FyZDogdWludDY0CgkrCglpdG9iCglyZXBsYWNlMwoJZnJhbWVfYnVyeSAzNSAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODIzCgkvLyBjbXBTdGFrZXIudG90YWxSZXdhcmRlZCArPSBzdGFrZXJSZXdhcmQKCWZyYW1lX2RpZyAzNSAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWludGMgMTkgLy8gIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAzNSAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgNDAgOAoJYnRvaQoJZnJhbWVfZGlnIDM4IC8vIHN0YWtlclJld2FyZDogdWludDY0CgkrCglpdG9iCglyZXBsYWNlMwoJZnJhbWVfYnVyeSAzNSAvLyBjbXBTdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODI0CgkvLyBpbmNyZWFzZWRTdGFrZSArPSBzdGFrZXJSZXdhcmQKCWZyYW1lX2RpZyAyMyAvLyBpbmNyZWFzZWRTdGFrZTogdWludDY0CglmcmFtZV9kaWcgMzggLy8gc3Rha2VyUmV3YXJkOiB1aW50NjQKCSsKCWZyYW1lX2J1cnkgMjMgLy8gaW5jcmVhc2VkU3Rha2U6IHVpbnQ2NAoKKmlmNDRfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjgyOAoJLy8gdGhpcy5zdGFrZXJzLnZhbHVlW2ldID0gY21wU3Rha2VyCglmcmFtZV9kaWcgMzQgLy8gaTogdWludDY0CglpbnRjIDMgLy8gNjQKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJZnJhbWVfZGlnIDM1IC8vIGNtcFN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZWMgMiAvLyAgInN0YWtlcnMiCgljb3ZlciAyCglib3hfcmVwbGFjZQoKKmlmNDJfZW5kOgoKKmlmNDFfZW5kOgoKKmZvcl81X2NvbnRpbnVlOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjc5OQoJLy8gaSArPSAxCglmcmFtZV9kaWcgMzQgLy8gaTogdWludDY0CglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSAzNCAvLyBpOiB1aW50NjQKCWIgKmZvcl81CgoqZm9yXzVfZW5kOgoKKmlmMzlfZW5kOgoKKmlmMzNfZW5kOgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjgzOAoJLy8gcm91bmRzTGVmdEluQmluID0gdGhpcy5iaW5Sb3VuZFN0YXJ0LnZhbHVlICsgdGhpcy5yb3VuZHNQZXJEYXkudmFsdWUgLSBnbG9iYWxzLnJvdW5kCglieXRlYyAxMSAvLyAgImJpblJvdW5kU3RhcnQiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZWMgNyAvLyAgInJvdW5kc1BlckRheSIKCWFwcF9nbG9iYWxfZ2V0CgkrCglnbG9iYWwgUm91bmQKCS0KCWZyYW1lX2J1cnkgMzkgLy8gcm91bmRzTGVmdEluQmluOiB1aW50NjQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODM5CgkvLyB0aGlzLnRvdGFsQWxnb1N0YWtlZC52YWx1ZSArPSBpbmNyZWFzZWRTdGFrZQoJYnl0ZWMgNiAvLyAgInN0YWtlZCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgMjMgLy8gaW5jcmVhc2VkU3Rha2U6IHVpbnQ2NAoJKwoJYnl0ZWMgNiAvLyAgInN0YWtlZCIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjg0MAoJLy8gdGhpcy5zdGFrZUFjY3VtdWxhdG9yLnZhbHVlID0KCS8vICAgICAgIHRoaXMuc3Rha2VBY2N1bXVsYXRvci52YWx1ZSArIChpbmNyZWFzZWRTdGFrZSBhcyB1aW50MTI4KSAqIChyb3VuZHNMZWZ0SW5CaW4gYXMgdWludDEyOCkKCWJ5dGVjIDggLy8gICJzdGFrZUFjY3VtdWxhdG9yIgoJZHVwCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDIzIC8vIGluY3JlYXNlZFN0YWtlOiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAzOSAvLyByb3VuZHNMZWZ0SW5CaW46IHVpbnQ2NAoJaXRvYgoJYioKCWIrCglkdXAKCWJpdGxlbgoJaW50YyA2IC8vIDEyOAoJPD0KCgkvLyB0aGlzLnN0YWtlQWNjdW11bGF0b3IudmFsdWUgKyAoaW5jcmVhc2VkU3Rha2UgYXMgdWludDEyOCkgKiAocm91bmRzTGVmdEluQmluIGFzIHVpbnQxMjgpIG92ZXJmbG93ZWQgMTI4IGJpdHMKCWFzc2VydAoJYnl0ZWMgOSAvLyAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50YyA1IC8vIDE2CgktCglzd2FwCglzdWJzdHJpbmczCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo4NDIKCS8vIHRoaXMucmV3YXJkQWNjdW11bGF0b3IudmFsdWUgPSB0aGlzLnJld2FyZEFjY3VtdWxhdG9yLnZhbHVlICsgaW5jcmVhc2VkU3Rha2UKCWJ5dGVjIDEyIC8vICAicmV3YXJkQWNjdW11bGF0b3IiCglkdXAKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgMjMgLy8gaW5jcmVhc2VkU3Rha2U6IHVpbnQ2NAoJKwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODQ4CgkvLyBzZW5kTWV0aG9kQ2FsbDx0eXBlb2YgVmFsaWRhdG9yUmVnaXN0cnkucHJvdG90eXBlLnN0YWtlVXBkYXRlZFZpYVJld2FyZHM+KHsKCS8vICAgICAgIGFwcGxpY2F0aW9uSUQ6IHRoaXMuY3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElkLnZhbHVlLAoJLy8gICAgICAgbWV0aG9kQXJnczogWwoJLy8gICAgICAgICB7IGlkOiB0aGlzLnZhbGlkYXRvcklkLnZhbHVlLCBwb29sSWQ6IHRoaXMucG9vbElkLnZhbHVlLCBwb29sQXBwSWQ6IHRoaXMuYXBwLmlkIH0sCgkvLyAgICAgICAgIGluY3JlYXNlZFN0YWtlLAoJLy8gICAgICAgICB0b2tlblJld2FyZFBhaWRPdXQsCgkvLyAgICAgICAgIHZhbGlkYXRvckNvbW1pc3Npb25QYWlkT3V0LAoJLy8gICAgICAgICBleGNlc3NUb0ZlZVNpbmssCgkvLyAgICAgICBdLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnRjIDIgLy8gIGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCXB1c2hieXRlcyAweDQxOGZjZWZjIC8vIG1ldGhvZCAic3Rha2VVcGRhdGVkVmlhUmV3YXJkcygodWludDY0LHVpbnQ2NCx1aW50NjQpLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODQ5CgkvLyBhcHBsaWNhdGlvbklEOiB0aGlzLmNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJZC52YWx1ZQoJYnl0ZWMgMSAvLyAgImNyZWF0b3JBcHAiCglhcHBfZ2xvYmFsX2dldAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjg1MAoJLy8gbWV0aG9kQXJnczogWwoJLy8gICAgICAgICB7IGlkOiB0aGlzLnZhbGlkYXRvcklkLnZhbHVlLCBwb29sSWQ6IHRoaXMucG9vbElkLnZhbHVlLCBwb29sQXBwSWQ6IHRoaXMuYXBwLmlkIH0sCgkvLyAgICAgICAgIGluY3JlYXNlZFN0YWtlLAoJLy8gICAgICAgICB0b2tlblJld2FyZFBhaWRPdXQsCgkvLyAgICAgICAgIHZhbGlkYXRvckNvbW1pc3Npb25QYWlkT3V0LAoJLy8gICAgICAgICBleGNlc3NUb0ZlZVNpbmssCgkvLyAgICAgICBdCglieXRlYyAzIC8vICAidmFsaWRhdG9ySWQiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJYnl0ZWMgNCAvLyAgInBvb2xJZCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCgljb25jYXQKCXR4bmEgQXBwbGljYXRpb25zIDAKCWl0b2IKCWNvbmNhdAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAyMyAvLyBpbmNyZWFzZWRTdGFrZTogdWludDY0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDE1IC8vIHRva2VuUmV3YXJkUGFpZE91dDogdWludDY0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDE2IC8vIHZhbGlkYXRvckNvbW1pc3Npb25QYWlkT3V0OiB1aW50NjQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgMTcgLy8gZXhjZXNzVG9GZWVTaW5rOiB1aW50NjQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBnb09ubGluZShwYXksYnl0ZVtdLGJ5dGVbXSxieXRlW10sdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX2dvT25saW5lOgoJLy8gdm90ZUtleURpbHV0aW9uOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDYKCWJ0b2kKCgkvLyB2b3RlTGFzdDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglidG9pCgoJLy8gdm90ZUZpcnN0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBzdGF0ZVByb29mUEs6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZXh0cmFjdCAyIDAKCgkvLyBzZWxlY3Rpb25QSzogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIHZvdGVQSzogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGZlZVBheW1lbnQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludGMgMSAvLyAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnRjIDEgLy8gIHBheQoJPT0KCgkvLyBhcmd1bWVudCA2IChmZWVQYXltZW50KSBmb3IgZ29PbmxpbmUgbXVzdCBiZSBhIHBheSB0cmFuc2FjdGlvbgoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBnb09ubGluZShwYXksYnl0ZVtdLGJ5dGVbXSxieXRlW10sdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBnb09ubGluZQoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gZ29PbmxpbmUoZmVlUGF5bWVudDogUGF5VHhuLCB2b3RlUEs6IGJ5dGVzLCBzZWxlY3Rpb25QSzogYnl0ZXMsIHN0YXRlUHJvb2ZQSzogYnl0ZXMsIHZvdGVGaXJzdDogdWludDY0LCB2b3RlTGFzdDogdWludDY0LCB2b3RlS2V5RGlsdXRpb246IHVpbnQ2NCk6IHZvaWQKLy8KLy8gUmVnaXN0ZXJzIGEgc3Rha2luZyBwb29sIGtleSBvbmxpbmUgYWdhaW5zdCBhIHBhcnRpY2lwYXRpb24ga2V5LgovLyBbIE9OTFkgT1dORVIgT1IgTUFOQUdFUiBDQU4gQ0FMTCBdCi8vCi8vIEBwYXJhbSB7UGF5VHhufSBmZWVQYXltZW50IC0gcGF5bWVudCB0byBjb3ZlciBleHRyYSBmZWUgb2YgZ29pbmcgb25saW5lIGlmIG9mZmxpbmUgLSBvciAwIGlmIG5vdCByZW5ld2FsCi8vIEBwYXJhbSB7Ynl0ZXN9IHZvdGVQSyAtIFRoZSB2b3RlIHB1YmxpYyBrZXkuCi8vIEBwYXJhbSB7Ynl0ZXN9IHNlbGVjdGlvblBLIC0gVGhlIHNlbGVjdGlvbiBwdWJsaWMga2V5LgovLyBAcGFyYW0ge2J5dGVzfSBzdGF0ZVByb29mUEsgLSBUaGUgc3RhdGUgcHJvb2YgcHVibGljIGtleS4KLy8gQHBhcmFtIHt1aW50NjR9IHZvdGVGaXJzdCAtIFRoZSBmaXJzdCB2b3RlIGluZGV4LgovLyBAcGFyYW0ge3VpbnQ2NH0gdm90ZUxhc3QgLSBUaGUgbGFzdCB2b3RlIGluZGV4LgovLyBAcGFyYW0ge3VpbnQ2NH0gdm90ZUtleURpbHV0aW9uIC0gVGhlIHZvdGUga2V5IGRpbHV0aW9uIHZhbHVlLgovLyBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgY2FsbGVyIGlzIG5vdCB0aGUgb3duZXIgb3IgYSBtYW5hZ2VyLgpnb09ubGluZToKCXByb3RvIDcgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjg4MgoJLy8gYXNzZXJ0KHRoaXMuaXNPd25lck9yTWFuYWdlckNhbGxlcigpLCAnY2FuIG9ubHkgYmUgY2FsbGVkIGJ5IG93bmVyIG9yIG1hbmFnZXIgb2YgdmFsaWRhdG9yJykKCWNhbGxzdWIgaXNPd25lck9yTWFuYWdlckNhbGxlcgoKCS8vIGNhbiBvbmx5IGJlIGNhbGxlZCBieSBvd25lciBvciBtYW5hZ2VyIG9mIHZhbGlkYXRvcgoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjg4MwoJLy8gZXh0cmFGZWUgPSB0aGlzLmdldEdvT25saW5lRmVlKCkKCWNhbGxzdWIgZ2V0R29PbmxpbmVGZWUKCWZyYW1lX2J1cnkgMCAvLyBleHRyYUZlZTogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjg4NAoJLy8gdmVyaWZ5UGF5VHhuKGZlZVBheW1lbnQsIHsgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsIGFtb3VudDogZXh0cmFGZWUgfSkKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIGZlZVBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoiZmVlUGF5bWVudCIsImZpZWxkIjoicmVjZWl2ZXIiLCJleHBlY3RlZCI6InRoaXMuYXBwLmFkZHJlc3MifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIGZlZVBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgMCAvLyBleHRyYUZlZTogdWludDY0Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoiZmVlUGF5bWVudCIsImZpZWxkIjoiYW1vdW50IiwiZXhwZWN0ZWQiOiJleHRyYUZlZSJ9Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODg1CgkvLyBzZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uKHsKCS8vICAgICAgIHZvdGVQSzogdm90ZVBLLAoJLy8gICAgICAgc2VsZWN0aW9uUEs6IHNlbGVjdGlvblBLLAoJLy8gICAgICAgc3RhdGVQcm9vZlBLOiBzdGF0ZVByb29mUEssCgkvLyAgICAgICB2b3RlRmlyc3Q6IHZvdGVGaXJzdCwKCS8vICAgICAgIHZvdGVMYXN0OiB2b3RlTGFzdCwKCS8vICAgICAgIHZvdGVLZXlEaWx1dGlvbjogdm90ZUtleURpbHV0aW9uLAoJLy8gICAgICAgZmVlOiBleHRyYUZlZSwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxOCAvLyAga2V5cmVnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjg4NgoJLy8gdm90ZVBLOiB2b3RlUEsKCWZyYW1lX2RpZyAtMiAvLyB2b3RlUEs6IGJ5dGVzCglpdHhuX2ZpZWxkIFZvdGVQSwoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo4ODcKCS8vIHNlbGVjdGlvblBLOiBzZWxlY3Rpb25QSwoJZnJhbWVfZGlnIC0zIC8vIHNlbGVjdGlvblBLOiBieXRlcwoJaXR4bl9maWVsZCBTZWxlY3Rpb25QSwoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo4ODgKCS8vIHN0YXRlUHJvb2ZQSzogc3RhdGVQcm9vZlBLCglmcmFtZV9kaWcgLTQgLy8gc3RhdGVQcm9vZlBLOiBieXRlcwoJaXR4bl9maWVsZCBTdGF0ZVByb29mUEsKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODg5CgkvLyB2b3RlRmlyc3Q6IHZvdGVGaXJzdAoJZnJhbWVfZGlnIC01IC8vIHZvdGVGaXJzdDogdWludDY0CglpdHhuX2ZpZWxkIFZvdGVGaXJzdAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo4OTAKCS8vIHZvdGVMYXN0OiB2b3RlTGFzdAoJZnJhbWVfZGlnIC02IC8vIHZvdGVMYXN0OiB1aW50NjQKCWl0eG5fZmllbGQgVm90ZUxhc3QKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6ODkxCgkvLyB2b3RlS2V5RGlsdXRpb246IHZvdGVLZXlEaWx1dGlvbgoJZnJhbWVfZGlnIC03IC8vIHZvdGVLZXlEaWx1dGlvbjogdWludDY0CglpdHhuX2ZpZWxkIFZvdGVLZXlEaWx1dGlvbgoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo4OTIKCS8vIGZlZTogZXh0cmFGZWUKCWZyYW1lX2RpZyAwIC8vIGV4dHJhRmVlOiB1aW50NjQKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBnb09mZmxpbmUoKXZvaWQKKmFiaV9yb3V0ZV9nb09mZmxpbmU6CgkvLyBleGVjdXRlIGdvT2ZmbGluZSgpdm9pZAoJY2FsbHN1YiBnb09mZmxpbmUKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGdvT2ZmbGluZSgpOiB2b2lkCi8vCi8vIE1hcmtzIGEgc3Rha2luZyBwb29sIGtleSBPRkZMSU5FLgovLyBbIE9OTFkgT1dORVIgT1IgTUFOQUdFUiBDQU4gQ0FMTCBdCmdvT2ZmbGluZToKCXByb3RvIDAgMAoKCS8vICppZjQ1X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjkwNAoJLy8gdGhpcy50eG4uc2VuZGVyICE9PSB0aGlzLmNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJZC52YWx1ZS5hZGRyZXNzCgl0eG4gU2VuZGVyCglieXRlYyAxIC8vICAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCSE9CglieiAqaWY0NV9lbmQKCgkvLyAqaWY0NV9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6OTA1CgkvLyBhc3NlcnQodGhpcy5pc093bmVyT3JNYW5hZ2VyQ2FsbGVyKCksICdjYW4gb25seSBiZSBjYWxsZWQgYnkgb3duZXIgb3IgbWFuYWdlciBvZiB2YWxpZGF0b3InKQoJY2FsbHN1YiBpc093bmVyT3JNYW5hZ2VyQ2FsbGVyCgoJLy8gY2FuIG9ubHkgYmUgY2FsbGVkIGJ5IG93bmVyIG9yIG1hbmFnZXIgb2YgdmFsaWRhdG9yCglhc3NlcnQKCippZjQ1X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5MDgKCS8vIHNlbmRPZmZsaW5lS2V5UmVnaXN0cmF0aW9uKHt9KQoJaXR4bl9iZWdpbgoJaW50YyAxOCAvLyAga2V5cmVnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBsaW5rVG9ORkQodWludDY0LHN0cmluZyl2b2lkCiphYmlfcm91dGVfbGlua1RvTkZEOgoJLy8gbmZkTmFtZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIG5mZEFwcElkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGxpbmtUb05GRCh1aW50NjQsc3RyaW5nKXZvaWQKCWNhbGxzdWIgbGlua1RvTkZECglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBsaW5rVG9ORkQobmZkQXBwSWQ6IHVpbnQ2NCwgbmZkTmFtZTogc3RyaW5nKTogdm9pZApsaW5rVG9ORkQ6Cglwcm90byAyIDAKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6OTE1CgkvLyBhc3NlcnQodGhpcy5pc093bmVyT3JNYW5hZ2VyQ2FsbGVyKCksICdjYW4gb25seSBiZSBjYWxsZWQgYnkgb3duZXIgb3IgbWFuYWdlciBvZiB2YWxpZGF0b3InKQoJY2FsbHN1YiBpc093bmVyT3JNYW5hZ2VyQ2FsbGVyCgoJLy8gY2FuIG9ubHkgYmUgY2FsbGVkIGJ5IG93bmVyIG9yIG1hbmFnZXIgb2YgdmFsaWRhdG9yCglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6OTE3CgkvLyBzZW5kQXBwQ2FsbCh7CgkvLyAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KHRoaXMubmZkUmVnaXN0cnlBcHBJZCksCgkvLyAgICAgICBhcHBsaWNhdGlvbkFyZ3M6IFsndmVyaWZ5X25mZF9hZGRyJywgbmZkTmFtZSwgaXRvYihuZmRBcHBJZCksIHJhd0J5dGVzKHRoaXMuYXBwLmFkZHJlc3MpXSwKCS8vICAgICAgIGFwcGxpY2F0aW9uczogW0FwcElELmZyb21VaW50NjQobmZkQXBwSWQpXSwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAyIC8vICBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjkxOAoJLy8gYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLm5mZFJlZ2lzdHJ5QXBwSWQpCglpbnRjIDIxIC8vIFRNUExfbmZkUmVnaXN0cnlBcHBJZAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjkxOQoJLy8gYXBwbGljYXRpb25BcmdzOiBbJ3ZlcmlmeV9uZmRfYWRkcicsIG5mZE5hbWUsIGl0b2IobmZkQXBwSWQpLCByYXdCeXRlcyh0aGlzLmFwcC5hZGRyZXNzKV0KCXB1c2hieXRlcyAweDc2NjU3MjY5NjY3OTVmNmU2NjY0NWY2MTY0NjQ3MiAvLyAidmVyaWZ5X25mZF9hZGRyIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtMiAvLyBuZmROYW1lOiBzdHJpbmcKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgLTEgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5MjAKCS8vIGFwcGxpY2F0aW9uczogW0FwcElELmZyb21VaW50NjQobmZkQXBwSWQpXQoJZnJhbWVfZGlnIC0xIC8vIG5mZEFwcElkOiB1aW50NjQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25zCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBwcm94aWVkU2V0VG9rZW5QYXlvdXRSYXRpbygodWludDY0LHVpbnQ2NCx1aW50NjQpKSh1aW50NjRbMjRdLHVpbnQ2NCkKKmFiaV9yb3V0ZV9wcm94aWVkU2V0VG9rZW5QYXlvdXRSYXRpbzoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMjEgLy8gMHgxNTFmN2M3NQoKCS8vIHBvb2xLZXk6ICh1aW50NjQsdWludDY0LHVpbnQ2NCkKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglwdXNoaW50IDI0Cgk9PQoKCS8vIGFyZ3VtZW50IDAgKHBvb2xLZXkpIGZvciBwcm94aWVkU2V0VG9rZW5QYXlvdXRSYXRpbyBtdXN0IGJlIGEgKHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBwcm94aWVkU2V0VG9rZW5QYXlvdXRSYXRpbygodWludDY0LHVpbnQ2NCx1aW50NjQpKSh1aW50NjRbMjRdLHVpbnQ2NCkKCWNhbGxzdWIgcHJveGllZFNldFRva2VuUGF5b3V0UmF0aW8KCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBwcm94aWVkU2V0VG9rZW5QYXlvdXRSYXRpbyhwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5KTogUG9vbFRva2VuUGF5b3V0UmF0aW8KLy8KLy8gcHJveGllZFNldFRva2VuUGF5b3V0UmF0aW8gaXMgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IHBvb2xzICE9IDEgLSBjYWxsaW5nIFVTLCBwb29sICMxCi8vIFdlIG5lZWQgdG8gdmVyaWZ5IHRoYXQgd2UgYXJlIGluIGZhY3QgYmVpbmcgY2FsbGVkIGJ5IGFub3RoZXIgb2YgT1VSIHBvb2xzIChub3QgdXMpCi8vIGFuZCB0aGVuIHdlJ2xsIGNhbGwgdGhlIHZhbGlkYXRvciBvbiB0aGVpciBiZWhhbGYgdG8gdXBkYXRlIHRoZSB0b2tlbiBwYXlvdXRzCi8vIEBwYXJhbSBwb29sS2V5IC0gVmFsaWRhdG9yUG9vbEtleSB0dXBsZQpwcm94aWVkU2V0VG9rZW5QYXlvdXRSYXRpbzoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjkzMQoJLy8gYXNzZXJ0KHRoaXMudmFsaWRhdG9ySWQudmFsdWUgPT09IHBvb2xLZXkuaWQsICdjYWxsZXIgbXVzdCBiZSBwYXJ0IG9mIHNhbWUgdmFsaWRhdG9yIHNldCEnKQoJYnl0ZWMgMyAvLyAgInZhbGlkYXRvcklkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJPT0KCgkvLyBjYWxsZXIgbXVzdCBiZSBwYXJ0IG9mIHNhbWUgdmFsaWRhdG9yIHNldCEKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5MzIKCS8vIGFzc2VydCh0aGlzLnBvb2xJZC52YWx1ZSA9PT0gMSwgJ2NhbGxlZSBtdXN0IGJlIHBvb2wgMScpCglieXRlYyA0IC8vICAicG9vbElkIgoJYXBwX2dsb2JhbF9nZXQKCWludGMgMSAvLyAxCgk9PQoKCS8vIGNhbGxlZSBtdXN0IGJlIHBvb2wgMQoJYXNzZXJ0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjkzMwoJLy8gYXNzZXJ0KHBvb2xLZXkucG9vbElkICE9PSAxLCAnY2FsbGVyIG11c3QgTk9UIGJlIHBvb2wgMScpCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludGMgMSAvLyAxCgkhPQoKCS8vIGNhbGxlciBtdXN0IE5PVCBiZSBwb29sIDEKCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5MzUKCS8vIGNhbGxlclBvb2xBcHBJRCA9IHNlbmRNZXRob2RDYWxsPHR5cGVvZiBWYWxpZGF0b3JSZWdpc3RyeS5wcm90b3R5cGUuZ2V0UG9vbEFwcElkPih7CgkvLyAgICAgICBhcHBsaWNhdGlvbklEOiB0aGlzLmNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJZC52YWx1ZSwKCS8vICAgICAgIG1ldGhvZEFyZ3M6IFtwb29sS2V5LmlkLCBwb29sS2V5LnBvb2xJZF0sCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMiAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJYnl0ZWMgMjMgLy8gIG1ldGhvZCAiZ2V0UG9vbEFwcElkKHVpbnQ2NCx1aW50NjQpdWludDY0IgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6OTM2CgkvLyBhcHBsaWNhdGlvbklEOiB0aGlzLmNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJZC52YWx1ZQoJYnl0ZWMgMSAvLyAgImNyZWF0b3JBcHAiCglhcHBfZ2xvYmFsX2dldAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjkzNwoJLy8gbWV0aG9kQXJnczogW3Bvb2xLZXkuaWQsIHBvb2xLZXkucG9vbElkXQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gTnVtTG9ncwoJaW50YyAxIC8vIDEKCS0KCWl0eG5hcyBMb2dzCglleHRyYWN0IDQgMAoJYnRvaQoJZnJhbWVfYnVyeSAwIC8vIGNhbGxlclBvb2xBcHBJRDogdWludDY0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjkzOQoJLy8gYXNzZXJ0KGNhbGxlclBvb2xBcHBJRCA9PT0gcG9vbEtleS5wb29sQXBwSWQpCglmcmFtZV9kaWcgMCAvLyBjYWxsZXJQb29sQXBwSUQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMTYgOAoJYnRvaQoJPT0KCWFzc2VydAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5NDAKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IEFwcElELmZyb21VaW50NjQocG9vbEtleS5wb29sQXBwSWQpLmFkZHJlc3MpCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAxNiA4CglidG9pCglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCT09Cglhc3NlcnQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6OTQyCgkvLyByZXR1cm4gc2VuZE1ldGhvZENhbGw8dHlwZW9mIFZhbGlkYXRvclJlZ2lzdHJ5LnByb3RvdHlwZS5zZXRUb2tlblBheW91dFJhdGlvPih7CgkvLyAgICAgICBhcHBsaWNhdGlvbklEOiB0aGlzLmNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJZC52YWx1ZSwKCS8vICAgICAgIG1ldGhvZEFyZ3M6IFt0aGlzLnZhbGlkYXRvcklkLnZhbHVlXSwKCS8vICAgICB9KTsKCWl0eG5fYmVnaW4KCWludGMgMiAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJYnl0ZWMgMjQgLy8gIG1ldGhvZCAic2V0VG9rZW5QYXlvdXRSYXRpbyh1aW50NjQpKHVpbnQ2NFsyNF0sdWludDY0KSIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjk0MwoJLy8gYXBwbGljYXRpb25JRDogdGhpcy5jcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSWQudmFsdWUKCWJ5dGVjIDEgLy8gICJjcmVhdG9yQXBwIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5NDQKCS8vIG1ldGhvZEFyZ3M6IFt0aGlzLnZhbGlkYXRvcklkLnZhbHVlXQoJYnl0ZWMgMyAvLyAgInZhbGlkYXRvcklkIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnRjIDEgLy8gMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCi8vIGlzT3duZXJPck1hbmFnZXJDYWxsZXIoKTogYm9vbGVhbgppc093bmVyT3JNYW5hZ2VyQ2FsbGVyOgoJcHJvdG8gMCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6OTQ5CgkvLyBPd25lckFuZE1hbmFnZXIgPSBzZW5kTWV0aG9kQ2FsbDx0eXBlb2YgVmFsaWRhdG9yUmVnaXN0cnkucHJvdG90eXBlLmdldFZhbGlkYXRvck93bmVyQW5kTWFuYWdlcj4oewoJLy8gICAgICAgYXBwbGljYXRpb25JRDogdGhpcy5jcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSWQudmFsdWUsCgkvLyAgICAgICBtZXRob2RBcmdzOiBbdGhpcy52YWxpZGF0b3JJZC52YWx1ZV0sCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMiAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJcHVzaGJ5dGVzIDB4MmZhMjJjNGIgLy8gbWV0aG9kICJnZXRWYWxpZGF0b3JPd25lckFuZE1hbmFnZXIodWludDY0KShhZGRyZXNzLGFkZHJlc3MpIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6OTUwCgkvLyBhcHBsaWNhdGlvbklEOiB0aGlzLmNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJZC52YWx1ZQoJYnl0ZWMgMSAvLyAgImNyZWF0b3JBcHAiCglhcHBfZ2xvYmFsX2dldAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjk1MQoJLy8gbWV0aG9kQXJnczogW3RoaXMudmFsaWRhdG9ySWQudmFsdWVdCglieXRlYyAzIC8vICAidmFsaWRhdG9ySWQiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIE51bUxvZ3MKCWludGMgMSAvLyAxCgktCglpdHhuYXMgTG9ncwoJZXh0cmFjdCA0IDAKCWZyYW1lX2J1cnkgMCAvLyBPd25lckFuZE1hbmFnZXI6IChhZGRyZXNzLGFkZHJlc3MpCgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjk1MwoJLy8gcmV0dXJuIHRoaXMudHhuLnNlbmRlciA9PT0gT3duZXJBbmRNYW5hZ2VyWzBdIHx8IHRoaXMudHhuLnNlbmRlciA9PT0gT3duZXJBbmRNYW5hZ2VyWzFdOwoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIDAgLy8gT3duZXJBbmRNYW5hZ2VyOiAoYWRkcmVzcyxhZGRyZXNzKQoJZXh0cmFjdCAwIDMyCgk9PQoJZHVwCglibnogKnNraXBfb3IyCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgMCAvLyBPd25lckFuZE1hbmFnZXI6IChhZGRyZXNzLGFkZHJlc3MpCglleHRyYWN0IDMyIDMyCgk9PQoJfHwKCipza2lwX29yMjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBhbGdvU2F0dXJhdGlvbkxldmVsKCk6IHVpbnQ2NAovLwovLyBSZXR1cm5zIHRoZSBtYXhpbXVtIGFsbG93ZWQgc3Rha2UgcGVyIHZhbGlkYXRvciBiYXNlZCBvbiBhIHBlcmNlbnRhZ2Ugb2YgYWxsIGN1cnJlbnQgb25saW5lIHN0YWtlIGJlZm9yZQovLyB0aGUgdmFsaWRhdG9yIGlzIGNvbnNpZGVyZWQgc2F0dXJhdGVkIC0gd2hlcmUgcmV3YXJkcyBhcmUgZGltaW5pc2hlZC4KYWxnb1NhdHVyYXRpb25MZXZlbDoKCXByb3RvIDAgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjk2MQoJLy8gb25saW5lID0gdGhpcy5nZXRDdXJyZW50T25saW5lU3Rha2UoKQoJY2FsbHN1YiBnZXRDdXJyZW50T25saW5lU3Rha2UKCWZyYW1lX2J1cnkgMCAvLyBvbmxpbmU6IHVpbnQ2NAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5NjMKCS8vIHJldHVybiB3aWRlUmF0aW8oW29ubGluZSwgTUFYX1ZBTElEQVRPUl9TT0ZUX1BDVF9PRl9PTkxJTkVfMURFQ0lNQUxdLCBbMTAwMF0pOwoJZnJhbWVfZGlnIDAgLy8gb25saW5lOiB1aW50NjQKCXB1c2hpbnQgMTAwCgltdWx3CglpbnRjIDAgLy8gMAoJaW50YyAxMSAvLyAxMDAwCglkaXZtb2R3Cglwb3AKCXBvcAoJc3dhcAoJIQoKCS8vIHdpZGVSYXRpbyBmYWlsZWQKCWFzc2VydAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBnZXRHb09ubGluZUZlZSgpOiB1aW50NjQKZ2V0R29PbmxpbmVGZWU6Cglwcm90byAwIDEKCgkvLyAqaWY0Nl9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5NjgKCS8vICF0aGlzLmFwcC5hZGRyZXNzLmluY2VudGl2ZUVsaWdpYmxlCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RJbmNlbnRpdmVFbGlnaWJsZQoJcG9wCgkhCglieiAqaWY0Nl9lbmQKCgkvLyAqaWY0Nl9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6OTY5CgkvLyByZXR1cm4gZ2xvYmFscy5wYXlvdXRzR29PbmxpbmVGZWU7CglnbG9iYWwgUGF5b3V0c0dvT25saW5lRmVlCglyZXRzdWIKCippZjQ2X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5NzEKCS8vIHJldHVybiAwOwoJaW50YyAwIC8vIDAKCXJldHN1YgoKLy8gZ2V0Q3VycmVudE9ubGluZVN0YWtlKCk6IHVpbnQ2NApnZXRDdXJyZW50T25saW5lU3Rha2U6Cglwcm90byAwIDEKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6OTc1CgkvLyByZXR1cm4gb25saW5lU3Rha2UoKTsKCW9ubGluZV9zdGFrZQoJcmV0c3ViCgovLyBjaGVja0lmQmluQ2xvc2VkKCk6IHZvaWQKLy8KLy8gQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHJvdW5kIGlzIGluIGEgJ25ldyBjYWxjdWxhdGlvbiBiaW4nIChhcHByb3hpbWF0ZWx5IGRhaWx5KQpjaGVja0lmQmluQ2xvc2VkOgoJcHJvdG8gMCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gNAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5ODIKCS8vIGN1cnJlbnRCaW5TaXplID0gdGhpcy5yb3VuZHNQZXJEYXkudmFsdWUgYXMgdWludDEyOAoJYnl0ZWMgNyAvLyAgInJvdW5kc1BlckRheSIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglmcmFtZV9idXJ5IDAgLy8gY3VycmVudEJpblNpemU6IHVuc2FmZSB1aW50MTI4CgoJLy8gKmlmNDdfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6OTgzCgkvLyBnbG9iYWxzLnJvdW5kID49IHRoaXMuYmluUm91bmRTdGFydC52YWx1ZSArIChjdXJyZW50QmluU2l6ZSBhcyB1aW50NjQpCglnbG9iYWwgUm91bmQKCWJ5dGVjIDExIC8vICAiYmluUm91bmRTdGFydCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgMCAvLyBjdXJyZW50QmluU2l6ZTogdW5zYWZlIHVpbnQxMjgKCWR1cAoJYml0bGVuCglpbnRjIDMgLy8gNjQKCTw9CgoJLy8gY3VycmVudEJpblNpemUgYXMgdWludDY0IG92ZXJmbG93ZWQgNjQgYml0cwoJYXNzZXJ0CglwdXNoYnl0ZXMgMHhGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50YyAxNCAvLyA4CgktCglzd2FwCglzdWJzdHJpbmczCglidG9pCgkrCgk+PQoJYnogKmlmNDdfZW5kCgoJLy8gKmlmNDdfY29uc2VxdWVudAoJLy8gKmlmNDhfY29uZGl0aW9uCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6OTg0CgkvLyBnbG9iYWxzLm9wY29kZUJ1ZGdldCA8IDMwMAoJZ2xvYmFsIE9wY29kZUJ1ZGdldAoJaW50YyAxMCAvLyAzMDAKCTwKCWJ6ICppZjQ4X2VuZAoKCS8vICppZjQ4X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5ODUKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludGMgMiAvLyAgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCglieXRlYyA1IC8vICAjcHJhZ21hIHZlcnNpb24gMTA7IGludCAxCglkdXAKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCglpbnRjIDggLy8gIERlbGV0ZUFwcGxpY2F0aW9uCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoJaXR4bl9zdWJtaXQKCippZjQ4X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5ODcKCS8vIGFwcHJveFJvdW5kc1BlclllYXI6IHVpbnQxMjggPSBjdXJyZW50QmluU2l6ZSAqICgzNjUgYXMgdWludDEyOCkKCWZyYW1lX2RpZyAwIC8vIGN1cnJlbnRCaW5TaXplOiB1bnNhZmUgdWludDEyOAoJcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxNmQKCWIqCglkdXAKCWJpdGxlbgoJaW50YyA2IC8vIDEyOAoJPD0KCgkvLyBjdXJyZW50QmluU2l6ZSAqICgzNjUgYXMgdWludDEyOCkgb3ZlcmZsb3dlZCAxMjggYml0cwoJYXNzZXJ0CglieXRlYyA5IC8vIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnRjIDUgLy8gMTYKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWZyYW1lX2J1cnkgMSAvLyBhcHByb3hSb3VuZHNQZXJZZWFyOiB1aW50MTI4CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjk4OAoJLy8gYXZnU3Rha2U6IHVpbnQxMjggPSB0aGlzLnN0YWtlQWNjdW11bGF0b3IudmFsdWUgLyBjdXJyZW50QmluU2l6ZQoJYnl0ZWMgOCAvLyAgInN0YWtlQWNjdW11bGF0b3IiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDAgLy8gY3VycmVudEJpblNpemU6IHVuc2FmZSB1aW50MTI4CgliLwoJZHVwCgliaXRsZW4KCWludGMgNiAvLyAxMjgKCTw9CgoJLy8gdGhpcy5zdGFrZUFjY3VtdWxhdG9yLnZhbHVlIC8gY3VycmVudEJpblNpemUgb3ZlcmZsb3dlZCAxMjggYml0cwoJYXNzZXJ0CglieXRlYyA5IC8vIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnRjIDUgLy8gMTYKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWZyYW1lX2J1cnkgMiAvLyBhdmdTdGFrZTogdWludDEyOAoKCS8vICppZjQ5X2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjk4OQoJLy8gYXZnU3Rha2UgIT09IDAKCWZyYW1lX2RpZyAyIC8vIGF2Z1N0YWtlOiB1aW50MTI4CglieXRlYyAxNiAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCgliIT0KCWJ6ICppZjQ5X2VuZAoKCS8vICppZjQ5X2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czo5OTMKCS8vIGFwcjogdWludDEyOCA9CgkvLyAgICAgICAgICAgKCgodGhpcy5yZXdhcmRBY2N1bXVsYXRvci52YWx1ZSBhcyB1aW50MTI4KSAqICgxMDAwMCBhcyB1aW50MTI4KSkgLyBhdmdTdGFrZSkgKgoJLy8gICAgICAgICAgIChhcHByb3hSb3VuZHNQZXJZZWFyIC8gY3VycmVudEJpblNpemUpCglieXRlYyAxMiAvLyAgInJld2FyZEFjY3VtdWxhdG9yIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCXB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyNzEwCgliKgoJZnJhbWVfZGlnIDIgLy8gYXZnU3Rha2U6IHVpbnQxMjgKCWIvCglmcmFtZV9kaWcgMSAvLyBhcHByb3hSb3VuZHNQZXJZZWFyOiB1aW50MTI4CglmcmFtZV9kaWcgMCAvLyBjdXJyZW50QmluU2l6ZTogdW5zYWZlIHVpbnQxMjgKCWIvCgliKgoJZHVwCgliaXRsZW4KCWludGMgNiAvLyAxMjgKCTw9CgoJLy8gKCgodGhpcy5yZXdhcmRBY2N1bXVsYXRvci52YWx1ZSBhcyB1aW50MTI4KSAqICgxMDAwMCBhcyB1aW50MTI4KSkgLyBhdmdTdGFrZSkgKlxuICAgICAgICAgIChhcHByb3hSb3VuZHNQZXJZZWFyIC8gY3VycmVudEJpblNpemUpIG92ZXJmbG93ZWQgMTI4IGJpdHMKCWFzc2VydAoJYnl0ZWMgOSAvLyAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50YyA1IC8vIDE2CgktCglzd2FwCglzdWJzdHJpbmczCglmcmFtZV9idXJ5IDMgLy8gYXByOiB1aW50MTI4CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjk5NwoJLy8gYWxwaGE6IHVpbnQxMjggPSAxMCBhcyB1aW50MTI4CglwdXNoYnl0ZXMgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYQoJZnJhbWVfYnVyeSA0IC8vIGFscGhhOiB1bnNhZmUgdWludDEyOAoKCS8vICppZjUwX2NvbmRpdGlvbgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjk5OQoJLy8gYXZnU3Rha2UgPiAzMDAwMDAwMDAwMDAKCWZyYW1lX2RpZyAyIC8vIGF2Z1N0YWtlOiB1aW50MTI4CglwdXNoYnl0ZXMgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDVkOTY0YjgwMAoJYj4KCWJ6ICppZjUwX2VuZAoKCS8vICppZjUwX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMDAwCgkvLyBhbHBoYSA9IDkwIGFzIHVpbnQxMjgKCXB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDVhCglmcmFtZV9idXJ5IDQgLy8gYWxwaGE6IHVuc2FmZSB1aW50MTI4CgoqaWY1MF9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTAwMgoJLy8gdGhpcy53ZWlnaHRlZE1vdmluZ0F2ZXJhZ2UudmFsdWUgPQoJLy8gICAgICAgICAgICh0aGlzLndlaWdodGVkTW92aW5nQXZlcmFnZS52YWx1ZSAqICgoMTAwIGFzIHVpbnQxMjgpIC0gYWxwaGEpKSAvICgxMDAgYXMgdWludDEyOCkgKwoJLy8gICAgICAgICAgIChhcHIgKiBhbHBoYSkgLyAoMTAwIGFzIHVpbnQxMjgpCglieXRlYyAyMCAvLyAgImV3bWEiCglkdXAKCWFwcF9nbG9iYWxfZ2V0CglieXRlYyAxNyAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDY0CglmcmFtZV9kaWcgNCAvLyBhbHBoYTogdW5zYWZlIHVpbnQxMjgKCWItCgliKgoJYnl0ZWMgMTcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2NAoJYi8KCWZyYW1lX2RpZyAzIC8vIGFwcjogdWludDEyOAoJZnJhbWVfZGlnIDQgLy8gYWxwaGE6IHVuc2FmZSB1aW50MTI4CgliKgoJYnl0ZWMgMTcgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2NAoJYi8KCWIrCglkdXAKCWJpdGxlbgoJaW50YyA2IC8vIDEyOAoJPD0KCgkvLyAodGhpcy53ZWlnaHRlZE1vdmluZ0F2ZXJhZ2UudmFsdWUgKiAoKDEwMCBhcyB1aW50MTI4KSAtIGFscGhhKSkgLyAoMTAwIGFzIHVpbnQxMjgpICtcbiAgICAgICAgICAoYXByICogYWxwaGEpIC8gKDEwMCBhcyB1aW50MTI4KSBvdmVyZmxvd2VkIDEyOCBiaXRzCglhc3NlcnQKCWJ5dGVjIDkgLy8gMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludGMgNSAvLyAxNgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJYXBwX2dsb2JhbF9wdXQKCippZjQ5X2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMDA4CgkvLyB0aGlzLnNldFJvdW5kc1BlckRheSgpCgljYWxsc3ViIHNldFJvdW5kc1BlckRheQoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMDA5CgkvLyB0aGlzLnN0YWtlQWNjdW11bGF0b3IudmFsdWUgPSAodGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgYXMgdWludDEyOCkgKiAodGhpcy5yb3VuZHNQZXJEYXkudmFsdWUgYXMgdWludDEyOCkKCWJ5dGVjIDggLy8gICJzdGFrZUFjY3VtdWxhdG9yIgoJYnl0ZWMgNiAvLyAgInN0YWtlZCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglieXRlYyA3IC8vICAicm91bmRzUGVyRGF5IgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWIqCglkdXAKCWJpdGxlbgoJaW50YyA2IC8vIDEyOAoJPD0KCgkvLyAodGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgYXMgdWludDEyOCkgKiAodGhpcy5yb3VuZHNQZXJEYXkudmFsdWUgYXMgdWludDEyOCkgb3ZlcmZsb3dlZCAxMjggYml0cwoJYXNzZXJ0CglieXRlYyA5IC8vIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnRjIDUgLy8gMTYKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjEwMTAKCS8vIHRoaXMucmV3YXJkQWNjdW11bGF0b3IudmFsdWUgPSAwCglieXRlYyAxMiAvLyAgInJld2FyZEFjY3VtdWxhdG9yIgoJaW50YyAwIC8vIDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gZXhhbXBsZXMvcmV0aS9zdGFraW5nUG9vbC5hbGdvLnRzOjEwMTEKCS8vIHRoaXMuYmluUm91bmRTdGFydC52YWx1ZSA9IGdsb2JhbHMucm91bmQgLSAoZ2xvYmFscy5yb3VuZCAlIHRoaXMucm91bmRzUGVyRGF5LnZhbHVlKQoJYnl0ZWMgMTEgLy8gICJiaW5Sb3VuZFN0YXJ0IgoJZ2xvYmFsIFJvdW5kCglnbG9iYWwgUm91bmQKCWJ5dGVjIDcgLy8gICJyb3VuZHNQZXJEYXkiCglhcHBfZ2xvYmFsX2dldAoJJQoJLQoJYXBwX2dsb2JhbF9wdXQKCippZjQ3X2VuZDoKCXJldHN1YgoKLy8gc2V0Um91bmRzUGVyRGF5KCk6IHZvaWQKc2V0Um91bmRzUGVyRGF5OgoJcHJvdG8gMCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCgkvLyAqaWY1MV9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMDIwCgkvLyB0aGlzLnR4bi5maXJzdFZhbGlkIDwgMTIKCXR4biBGaXJzdFZhbGlkCglwdXNoaW50IDEyCgk8CglieiAqaWY1MV9lbmQKCgkvLyAqaWY1MV9jb25zZXF1ZW50CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTAyMgoJLy8gdGhpcy5yb3VuZHNQZXJEYXkudmFsdWUgPSBBUFBST1hfQVZHX1JPVU5EU19QRVJfREFZCglieXRlYyA3IC8vICAicm91bmRzUGVyRGF5IgoJaW50YyAxNyAvLyAzMDg1NwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTAyMwoJLy8gcmV0dXJuOwoJcmV0c3ViCgoqaWY1MV9lbmQ6CgkvLyBleGFtcGxlcy9yZXRpL3N0YWtpbmdQb29sLmFsZ28udHM6MTAyNgoJLy8gYXZnQmxvY2tUaW1lVGVudGhzID0gYmxvY2tzW3RoaXMudHhuLmZpcnN0VmFsaWQgLSAxXS50aW1lc3RhbXAgLSBibG9ja3NbdGhpcy50eG4uZmlyc3RWYWxpZCAtIDExXS50aW1lc3RhbXAKCXR4biBGaXJzdFZhbGlkCglpbnRjIDEgLy8gMQoJLQoJYmxvY2sgQmxrVGltZXN0YW1wCgl0eG4gRmlyc3RWYWxpZAoJcHVzaGludCAxMQoJLQoJYmxvY2sgQmxrVGltZXN0YW1wCgktCglmcmFtZV9idXJ5IDAgLy8gYXZnQmxvY2tUaW1lVGVudGhzOiB1aW50NjQKCgkvLyAqaWY1Ml9jb25kaXRpb24KCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMDI3CgkvLyBhdmdCbG9ja1RpbWVUZW50aHMgPT09IDAKCWZyYW1lX2RpZyAwIC8vIGF2Z0Jsb2NrVGltZVRlbnRoczogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCWJ6ICppZjUyX2VuZAoKCS8vICppZjUyX2NvbnNlcXVlbnQKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMDI5CgkvLyB0aGlzLnJvdW5kc1BlckRheS52YWx1ZSA9IEFQUFJPWF9BVkdfUk9VTkRTX1BFUl9EQVkKCWJ5dGVjIDcgLy8gICJyb3VuZHNQZXJEYXkiCglpbnRjIDE3IC8vIDMwODU3CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMDMwCgkvLyByZXR1cm47CglyZXRzdWIKCippZjUyX2VuZDoKCS8vIGV4YW1wbGVzL3JldGkvc3Rha2luZ1Bvb2wuYWxnby50czoxMDM1CgkvLyB0aGlzLnJvdW5kc1BlckRheS52YWx1ZSA9ICgyNCAqIDYwICogNjAgKiAxMCkgLyBhdmdCbG9ja1RpbWVUZW50aHMKCWJ5dGVjIDcgLy8gICJyb3VuZHNQZXJEYXkiCglwdXNoaW50IDg2NDAwMAoJZnJhbWVfZGlnIDAgLy8gYXZnQmxvY2tUaW1lVGVudGhzOiB1aW50NjQKCS8KCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCipjcmVhdGVfTm9PcDoKCXB1c2hieXRlcyAweDU5ZTkwYWE2IC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24odWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNyZWF0ZSBOb09wCgllcnIKCipjYWxsX05vT3A6CglwdXNoYnl0ZXMgMHgzMTcyY2E5ZCAvLyBtZXRob2QgImdhcygpdm9pZCIKCXB1c2hieXRlcyAweDQ3Y2ZjYzA0IC8vIG1ldGhvZCAiaW5pdFN0b3JhZ2UocGF5KXZvaWQiCglwdXNoYnl0ZXMgMHhmOWM3MGNiZCAvLyBtZXRob2QgImFkZFN0YWtlKHBheSxhZGRyZXNzKXVpbnQ2NCIKCXB1c2hieXRlcyAweDQyMWI1YWJlIC8vIG1ldGhvZCAicmVtb3ZlU3Rha2UoYWRkcmVzcyx1aW50NjQpdm9pZCIKCXB1c2hieXRlcyAweGY1ODkyZDU2IC8vIG1ldGhvZCAiY2xhaW1Ub2tlbnMoKXZvaWQiCglwdXNoYnl0ZXMgMHg1Y2ZiYjA1NyAvLyBtZXRob2QgImdldFN0YWtlckluZm8oYWRkcmVzcykoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpIgoJcHVzaGJ5dGVzIDB4NjNmM2YyOGIgLy8gbWV0aG9kICJwYXlUb2tlblJld2FyZChhZGRyZXNzLHVpbnQ2NCx1aW50NjQpdm9pZCIKCXB1c2hieXRlcyAweDg2YTM3MjVjIC8vIG1ldGhvZCAidXBkYXRlQWxnb2RWZXIoc3RyaW5nKXZvaWQiCglwdXNoYnl0ZXMgMHhlZmMyNjA4ZCAvLyBtZXRob2QgImVwb2NoQmFsYW5jZVVwZGF0ZSgpdm9pZCIKCXB1c2hieXRlcyAweDQwMGUxNGZiIC8vIG1ldGhvZCAiZ29PbmxpbmUocGF5LGJ5dGVbXSxieXRlW10sYnl0ZVtdLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCglwdXNoYnl0ZXMgMHg1MWVmM2IyMSAvLyBtZXRob2QgImdvT2ZmbGluZSgpdm9pZCIKCXB1c2hieXRlcyAweGEyNGUyNzE3IC8vIG1ldGhvZCAibGlua1RvTkZEKHVpbnQ2NCxzdHJpbmcpdm9pZCIKCWJ5dGVjIDI1IC8vICBtZXRob2QgInByb3hpZWRTZXRUb2tlblBheW91dFJhdGlvKCh1aW50NjQsdWludDY0LHVpbnQ2NCkpKHVpbnQ2NFsyNF0sdWludDY0KSIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfZ2FzICphYmlfcm91dGVfaW5pdFN0b3JhZ2UgKmFiaV9yb3V0ZV9hZGRTdGFrZSAqYWJpX3JvdXRlX3JlbW92ZVN0YWtlICphYmlfcm91dGVfY2xhaW1Ub2tlbnMgKmFiaV9yb3V0ZV9nZXRTdGFrZXJJbmZvICphYmlfcm91dGVfcGF5VG9rZW5SZXdhcmQgKmFiaV9yb3V0ZV91cGRhdGVBbGdvZFZlciAqYWJpX3JvdXRlX2Vwb2NoQmFsYW5jZVVwZGF0ZSAqYWJpX3JvdXRlX2dvT25saW5lICphYmlfcm91dGVfZ29PZmZsaW5lICphYmlfcm91dGVfbGlua1RvTkZEICphYmlfcm91dGVfcHJveGllZFNldFRva2VuUGF5b3V0UmF0aW8KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBOb09wCgllcnI=",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEx",
  },
  "state": {
    "global": {
      "num_byte_slices": 3,
      "num_uints": 11,
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0,
    },
  },
}
`;
