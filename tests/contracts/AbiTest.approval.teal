#pragma version 8
	b main

update_dynamic_tuple_element:
	proto 3 1
	load 3 // full tuple
	load 3 // full tuple
	frame_dig -1 // head offset
	extract_uint16 // extract dynamic array offset of element
	int 0
	swap
	extract3 // extract portion of tuple before element
	frame_dig -2 // new tuple element
	concat
	load 3 // full tuple
	load 3 // full tuple
	frame_dig -1 // head offset
	extract_uint16 // extract dynamic array offset of element
	frame_dig -3 // old element length
	+
	load 3 // full tuple
	len
	substring3
	concat
	store 3 // full tuple
	frame_dig -2 // new tuple element
	len // length of new element
	frame_dig -3 // old element length
	<
	bnz swapped_difference
	frame_dig -2 // new tuple element
	len // length of new element
	frame_dig -3 // old element length
	int 1
	store 7 // subtract head difference
	b get_difference

swapped_difference:
	frame_dig -3 // old element length
	frame_dig -2 // new tuple element
	len // length of new element
	int 0
	store 7 // subtract head difference

get_difference:
	- // get length difference
	retsub

bare_route_create:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	==
	&&
	assert
	callsub create
	int 1
	return

create:
	proto 0 0
	retsub

bare_route_OptIn:
	txn OnCompletion
	int OptIn
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	callsub optIn
	int 1
	return

optIn:
	proto 0 0
	retsub

abi_route_staticArray:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub staticArray
	int 1
	return

staticArray:
	proto 1 0

	// tests/contracts/abi.algo.ts:35
	// a: StaticArray<uint64, 3> = [11, 22, 33]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	frame_bury -1 // a: uint64[3]

	// tests/contracts/abi.algo.ts:37
	// return a[1];
	frame_dig -1 // a: uint64[3]
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_returnStaticArray:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub returnStaticArray
	int 1
	return

returnStaticArray:
	proto 1 0

	// tests/contracts/abi.algo.ts:41
	// a: StaticArray<uint64, 3> = [11, 22, 33]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	frame_bury -1 // a: uint64[3]

	// tests/contracts/abi.algo.ts:43
	// return a;
	frame_dig -1 // a: uint64[3]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_staticArrayArg:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	txna ApplicationArgs 1
	callsub staticArrayArg
	int 1
	return

staticArrayArg:
	proto 1 0

	// tests/contracts/abi.algo.ts:47
	// return a[1];
	frame_dig -1 // a: uint64[3]
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_nonLiteralStaticArrayElements:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dupn 3
	callsub nonLiteralStaticArrayElements
	int 1
	return

nonLiteralStaticArrayElements:
	proto 4 0

	// tests/contracts/abi.algo.ts:51
	// n1 = 11
	int 11
	frame_bury -1 // n1: uint64

	// tests/contracts/abi.algo.ts:52
	// n2 = 22
	int 22
	frame_bury -2 // n2: uint64

	// tests/contracts/abi.algo.ts:53
	// n3 = 33
	int 33
	frame_bury -3 // n3: uint64

	// tests/contracts/abi.algo.ts:54
	// a: StaticArray<uint64, 3> = [n1, n2, n3]
	frame_dig -1 // n1: uint64
	itob
	frame_dig -2 // n2: uint64
	itob
	concat
	frame_dig -3 // n3: uint64
	itob
	concat
	frame_bury -4 // a: uint64[3]

	// tests/contracts/abi.algo.ts:56
	// return a[1];
	frame_dig -4 // a: uint64[3]
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_mixedStaticArrayElements:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dupn 3
	callsub mixedStaticArrayElements
	int 1
	return

mixedStaticArrayElements:
	proto 4 0

	// tests/contracts/abi.algo.ts:60
	// n1 = 3
	int 3
	frame_bury -1 // n1: uint64

	// tests/contracts/abi.algo.ts:61
	// n2 = 4
	int 4
	frame_bury -2 // n2: uint64

	// tests/contracts/abi.algo.ts:62
	// n3 = 5
	int 5
	frame_bury -3 // n3: uint64

	// tests/contracts/abi.algo.ts:63
	// a: StaticArray<uint64, 9> = [0, 1, 2, n1, n2, n3, 6, 7, 8]
	int 0
	itob
	int 1
	itob
	concat
	int 2
	itob
	concat
	frame_dig -1 // n1: uint64
	itob
	concat
	frame_dig -2 // n2: uint64
	itob
	concat
	frame_dig -3 // n3: uint64
	itob
	concat
	int 6
	itob
	concat
	int 7
	itob
	concat
	int 8
	itob
	concat
	frame_bury -4 // a: uint64[9]

	// tests/contracts/abi.algo.ts:65
	// return a[1] + a[4] + a[7];
	frame_dig -4 // a: uint64[9]
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	frame_dig -4 // a: uint64[9]
	int 4
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	+
	frame_dig -4 // a: uint64[9]
	int 7
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	+
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_nonLiteralStaticArrayAccess:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dup
	callsub nonLiteralStaticArrayAccess
	int 1
	return

nonLiteralStaticArrayAccess:
	proto 2 0

	// tests/contracts/abi.algo.ts:69
	// a: StaticArray<uint64, 3> = [11, 22, 33]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	frame_bury -1 // a: uint64[3]

	// tests/contracts/abi.algo.ts:70
	// n = 2
	int 2
	frame_bury -2 // n: uint64

	// tests/contracts/abi.algo.ts:72
	// return a[n];
	frame_dig -1 // a: uint64[3]
	frame_dig -2 // n: uint64
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_setStaticArrayElement:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub setStaticArrayElement
	int 1
	return

setStaticArrayElement:
	proto 1 0

	// tests/contracts/abi.algo.ts:76
	// a: StaticArray<uint64, 3> = [11, 22, 33]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	frame_bury -1 // a: uint64[3]

	// tests/contracts/abi.algo.ts:78
	// a[1] = 222
	frame_dig -1 // a: uint64[3]
	int 1
	int 8 // element length
	* // element offset
	int 222
	itob
	replace3
	frame_bury -1 // a: uint64[3]

	// tests/contracts/abi.algo.ts:80
	// return a[1];
	frame_dig -1 // a: uint64[3]
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_staticArrayInStorageRef:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dup
	callsub staticArrayInStorageRef
	int 1
	return

staticArrayInStorageRef:
	proto 2 0

	// tests/contracts/abi.algo.ts:84
	// a: StaticArray<uint64, 3> = [11, 22, 33]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	frame_bury -1 // a: uint64[3]

	// tests/contracts/abi.algo.ts:86
	// this.gRef.put(a)
	byte "gRef"
	frame_dig -1 // a: uint64[3]
	app_global_put

	// tests/contracts/abi.algo.ts:87
	// this.lRef.put(this.txn.sender, a)
	txn Sender
	byte "lRef"
	frame_dig -1 // a: uint64[3]
	app_local_put

	// tests/contracts/abi.algo.ts:88
	// this.bRef.put(a)
	byte "bRef"
	frame_dig -1 // a: uint64[3]
	box_put

	// tests/contracts/abi.algo.ts:90
	// ret: StaticArray<uint64, 3> = [
	byte "gRef"
	app_global_get
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	txn Sender
	byte "lRef"
	app_local_get
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	concat
	byte "bRef"
	box_get
	assert
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	concat
	frame_bury -2 // ret: uint64[3]

	// tests/contracts/abi.algo.ts:96
	// return ret;
	frame_dig -2 // ret: uint64[3]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_updateStaticArrayInStorageRef:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dup
	callsub updateStaticArrayInStorageRef
	int 1
	return

updateStaticArrayInStorageRef:
	proto 2 0

	// tests/contracts/abi.algo.ts:100
	// a: StaticArray<uint64, 3> = [11, 22, 33]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	frame_bury -1 // a: uint64[3]

	// tests/contracts/abi.algo.ts:102
	// this.gRef.put(a)
	byte "gRef"
	frame_dig -1 // a: uint64[3]
	app_global_put

	// tests/contracts/abi.algo.ts:103
	// this.lRef.put(this.txn.sender, a)
	txn Sender
	byte "lRef"
	frame_dig -1 // a: uint64[3]
	app_local_put

	// tests/contracts/abi.algo.ts:104
	// this.bRef.put(a)
	byte "bRef"
	frame_dig -1 // a: uint64[3]
	box_put

	// tests/contracts/abi.algo.ts:106
	// this.gRef.get()[1] = 111
	byte "gRef"
	app_global_get
	int 1
	int 8 // element length
	* // element offset
	int 111
	itob
	replace3
	byte "gRef"
	swap
	app_global_put

	// tests/contracts/abi.algo.ts:107
	// this.lRef.get(this.txn.sender)[1] = 222
	txn Sender
	byte "lRef"
	app_local_get
	int 1
	int 8 // element length
	* // element offset
	int 222
	itob
	replace3
	txn Sender
	byte "lRef"
	uncover 2
	app_local_put

	// tests/contracts/abi.algo.ts:108
	// this.bRef.get()[1] = 333
	byte "bRef"
	box_get
	assert
	int 1
	int 8 // element length
	* // element offset
	int 333
	itob
	replace3
	byte "bRef"
	swap
	box_put

	// tests/contracts/abi.algo.ts:110
	// ret: StaticArray<uint64, 3> = [
	byte "gRef"
	app_global_get
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	txn Sender
	byte "lRef"
	app_local_get
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	concat
	byte "bRef"
	box_get
	assert
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	concat
	frame_bury -2 // ret: uint64[3]

	// tests/contracts/abi.algo.ts:116
	// return ret;
	frame_dig -2 // ret: uint64[3]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_staticArrayInStorageMap:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dup
	callsub staticArrayInStorageMap
	int 1
	return

staticArrayInStorageMap:
	proto 2 0

	// tests/contracts/abi.algo.ts:120
	// a: StaticArray<uint64, 3> = [11, 22, 33]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	frame_bury -1 // a: uint64[3]

	// tests/contracts/abi.algo.ts:122
	// this.gMap.put('gMap', a)
	byte "gMap"
	frame_dig -1 // a: uint64[3]
	app_global_put

	// tests/contracts/abi.algo.ts:123
	// this.lMap.put(this.txn.sender, 'lMap', a)
	txn Sender
	byte "lMap"
	frame_dig -1 // a: uint64[3]
	app_local_put

	// tests/contracts/abi.algo.ts:124
	// this.bMap.put('bMap', a)
	byte "bMap"
	frame_dig -1 // a: uint64[3]
	box_put

	// tests/contracts/abi.algo.ts:126
	// ret: StaticArray<uint64, 3> = [
	byte "gMap"
	app_global_get
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	txn Sender
	byte "lMap"
	app_local_get
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	concat
	byte "bMap"
	box_get
	assert
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	concat
	frame_bury -2 // ret: uint64[3]

	// tests/contracts/abi.algo.ts:132
	// return ret;
	frame_dig -2 // ret: uint64[3]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_updateStaticArrayInStorageMap:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dup
	callsub updateStaticArrayInStorageMap
	int 1
	return

updateStaticArrayInStorageMap:
	proto 2 0

	// tests/contracts/abi.algo.ts:136
	// a: StaticArray<uint64, 3> = [11, 22, 33]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	frame_bury -1 // a: uint64[3]

	// tests/contracts/abi.algo.ts:138
	// this.gMap.put('gMap', a)
	byte "gMap"
	frame_dig -1 // a: uint64[3]
	app_global_put

	// tests/contracts/abi.algo.ts:139
	// this.lMap.put(this.txn.sender, 'lMap', a)
	txn Sender
	byte "lMap"
	frame_dig -1 // a: uint64[3]
	app_local_put

	// tests/contracts/abi.algo.ts:140
	// this.bMap.put('bMap', a)
	byte "bMap"
	frame_dig -1 // a: uint64[3]
	box_put

	// tests/contracts/abi.algo.ts:142
	// this.gMap.get('gMap')[1] = 1111
	byte "gMap"
	app_global_get
	int 1
	int 8 // element length
	* // element offset
	int 1111
	itob
	replace3
	byte "gMap"
	swap
	app_global_put

	// tests/contracts/abi.algo.ts:143
	// this.lMap.get(this.txn.sender, 'lMap')[1] = 2222
	txn Sender
	byte "lMap"
	app_local_get
	int 1
	int 8 // element length
	* // element offset
	int 2222
	itob
	replace3
	txn Sender
	byte "lMap"
	uncover 2
	app_local_put

	// tests/contracts/abi.algo.ts:144
	// this.bMap.get('bMap')[1] = 3333
	byte "bMap"
	box_get
	assert
	int 1
	int 8 // element length
	* // element offset
	int 3333
	itob
	replace3
	byte "bMap"
	swap
	box_put

	// tests/contracts/abi.algo.ts:146
	// ret: StaticArray<uint64, 3> = [
	byte "gMap"
	app_global_get
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	txn Sender
	byte "lMap"
	app_local_get
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	concat
	byte "bMap"
	box_get
	assert
	int 1
	int 8 // element length
	* // element offset
	int 8
	extract3
	btoi
	itob
	concat
	frame_bury -2 // ret: uint64[3]

	// tests/contracts/abi.algo.ts:152
	// return ret;
	frame_dig -2 // ret: uint64[3]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_nestedStaticArray:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub nestedStaticArray
	int 1
	return

nestedStaticArray:
	proto 1 0

	// tests/contracts/abi.algo.ts:156
	// a: StaticArray<StaticArray<uint64, 3>, 3> = [[11, 22, 33], [44, 55, 66], [77, 88, 99]]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	int 44
	itob
	int 55
	itob
	concat
	int 66
	itob
	concat
	concat
	int 77
	itob
	int 88
	itob
	concat
	int 99
	itob
	concat
	concat
	frame_bury -1 // a: uint64[3][3]

	// tests/contracts/abi.algo.ts:158
	// return a[1][1];
	frame_dig -1 // a: uint64[3][3]
	int 1
	int 24 // element length
	* // element offset
	int 1
	int 8 // element length
	* // element offset
	+
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_updateNestedStaticArrayElement:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub updateNestedStaticArrayElement
	int 1
	return

updateNestedStaticArrayElement:
	proto 1 0

	// tests/contracts/abi.algo.ts:162
	// a: StaticArray<StaticArray<uint64, 3>, 3> = [[11, 22, 33], [44, 55, 66], [77, 88, 99]]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	int 44
	itob
	int 55
	itob
	concat
	int 66
	itob
	concat
	concat
	int 77
	itob
	int 88
	itob
	concat
	int 99
	itob
	concat
	concat
	frame_bury -1 // a: uint64[3][3]

	// tests/contracts/abi.algo.ts:164
	// a[1][1] = 555
	frame_dig -1 // a: uint64[3][3]
	int 1
	int 24 // element length
	* // element offset
	int 1
	int 8 // element length
	* // element offset
	+
	int 555
	itob
	replace3
	frame_bury -1 // a: uint64[3][3]

	// tests/contracts/abi.algo.ts:166
	// return a[1][1];
	frame_dig -1 // a: uint64[3][3]
	int 1
	int 24 // element length
	* // element offset
	int 1
	int 8 // element length
	* // element offset
	+
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_updateNestedStaticArray:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub updateNestedStaticArray
	int 1
	return

updateNestedStaticArray:
	proto 1 0

	// tests/contracts/abi.algo.ts:170
	// a: StaticArray<StaticArray<uint64, 3>, 3> = [[11, 22, 33], [44, 55, 66], [77, 88, 99]]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	int 44
	itob
	int 55
	itob
	concat
	int 66
	itob
	concat
	concat
	int 77
	itob
	int 88
	itob
	concat
	int 99
	itob
	concat
	concat
	frame_bury -1 // a: uint64[3][3]

	// tests/contracts/abi.algo.ts:172
	// a[1] = [444, 555, 666]
	frame_dig -1 // a: uint64[3][3]
	int 1
	int 24 // element length
	* // element offset
	int 444
	itob
	int 555
	itob
	concat
	int 666
	itob
	concat
	replace3
	frame_bury -1 // a: uint64[3][3]

	// tests/contracts/abi.algo.ts:174
	// return a[1][1];
	frame_dig -1 // a: uint64[3][3]
	int 1
	int 24 // element length
	* // element offset
	int 1
	int 8 // element length
	* // element offset
	+
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_threeDimensionalUint16Array:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub threeDimensionalUint16Array
	int 1
	return

threeDimensionalUint16Array:
	proto 1 0

	// tests/contracts/abi.algo.ts:178
	// a: StaticArray<StaticArray<StaticArray<uint16, 2>, 2>, 2> = [
	int 11
	itob
	extract 6 0
	int 22
	itob
	extract 6 0
	concat
	int 33
	itob
	extract 6 0
	int 44
	itob
	extract 6 0
	concat
	concat
	int 55
	itob
	extract 6 0
	int 66
	itob
	extract 6 0
	concat
	int 77
	itob
	extract 6 0
	int 88
	itob
	extract 6 0
	concat
	concat
	concat
	frame_bury -1 // a: uint16[2][2][2]

	// tests/contracts/abi.algo.ts:182
	// a[1][1] = [777, 888]
	frame_dig -1 // a: uint16[2][2][2]
	int 1
	int 8 // element length
	* // element offset
	int 1
	int 4 // element length
	* // element offset
	+
	int 777
	itob
	extract 6 0
	int 888
	itob
	extract 6 0
	concat
	replace3
	frame_bury -1 // a: uint16[2][2][2]

	// tests/contracts/abi.algo.ts:184
	// return a[1][1][1];
	frame_dig -1 // a: uint16[2][2][2]
	int 1
	int 8 // element length
	* // element offset
	int 1
	int 4 // element length
	* // element offset
	+
	int 1
	int 2 // element length
	* // element offset
	+
	int 2
	extract3
	byte 0xFFFF
	b&
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_simpleTuple:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub simpleTuple
	int 1
	return

simpleTuple:
	proto 1 0

	// tests/contracts/abi.algo.ts:188
	// a: [uint64, uint16, uint64, uint16] = [11, 22, 33, 44]
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0014
	store 2 // head offset
	load 0 // tuple head
	int 11
	itob
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 22
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 33
	itob
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 44
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: [uint64,uint16,uint64,uint16]

	// tests/contracts/abi.algo.ts:190
	// return a[3];
	frame_dig -1 // a: [uint64,uint16,uint64,uint16]
	dup
	store 3 // full tuple
	int 18
	int 2
	extract3
	byte 0xFFFF
	b&
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_arrayInTuple:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub arrayInTuple
	int 1
	return

arrayInTuple:
	proto 1 0

	// tests/contracts/abi.algo.ts:194
	// a: [uint64, uint16, StaticArray<uint64, 2>, uint16] = [
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x001c
	store 2 // head offset
	load 0 // tuple head
	int 11
	itob
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 22
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 33
	itob
	int 44
	itob
	concat
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 55
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: [uint64,uint16,uint64[2],uint16]

	// tests/contracts/abi.algo.ts:198
	// return a[2][1];
	frame_dig -1 // a: [uint64,uint16,uint64[2],uint16]
	dup
	store 3 // full tuple
	int 10
	int 1
	int 8 // element length
	* // element offset
	+
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_tupleInArray:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub tupleInArray
	int 1
	return

tupleInArray:
	proto 1 0

	// tests/contracts/abi.algo.ts:202
	// a: StaticArray<[uint64, uint16], 2> = [
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x000a
	store 2 // head offset
	load 0 // tuple head
	int 11
	itob
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 22
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 1 // tuple tail
	concat
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x000a
	store 2 // head offset
	load 0 // tuple head
	int 33
	itob
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 44
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 1 // tuple tail
	concat
	concat
	frame_bury -1 // a: [uint64,uint16][2]

	// tests/contracts/abi.algo.ts:206
	// return a[1][1];
	frame_dig -1 // a: [uint64,uint16][2]
	dup
	store 3 // full tuple
	int 1
	int 10 // element length
	* // element offset
	int 8
	+
	int 2
	extract3
	byte 0xFFFF
	b&
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_shortTypeNotation:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub shortTypeNotation
	int 1
	return

shortTypeNotation:
	proto 1 0

	// tests/contracts/abi.algo.ts:220
	// a: [uint16<2>, uint64<2>, uint16<2>] = [
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0018
	store 2 // head offset
	load 0 // tuple head
	int 11
	itob
	extract 6 0
	int 22
	itob
	extract 6 0
	concat
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 33
	itob
	int 44
	itob
	concat
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 55
	itob
	extract 6 0
	int 66
	itob
	extract 6 0
	concat
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: [uint16[2],uint64[2],uint16[2]]

	// tests/contracts/abi.algo.ts:224
	// return a[2][1];
	frame_dig -1 // a: [uint16[2],uint64[2],uint16[2]]
	dup
	store 3 // full tuple
	int 20
	int 1
	int 2 // element length
	* // element offset
	+
	int 2
	extract3
	byte 0xFFFF
	b&
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_returnTuple:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub returnTuple
	int 1
	return

returnTuple:
	proto 1 0

	// tests/contracts/abi.algo.ts:240
	// a: [uint64, uint16, uint64] = [11, 22, 33]
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0012
	store 2 // head offset
	load 0 // tuple head
	int 11
	itob
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 22
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 33
	itob
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: [uint64,uint16,uint64]

	// tests/contracts/abi.algo.ts:241
	// return a;
	frame_dig -1 // a: [uint64,uint16,uint64]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_tupleArg:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	txna ApplicationArgs 1
	callsub tupleArg
	int 1
	return

tupleArg:
	proto 1 0

	// tests/contracts/abi.algo.ts:245
	// return a[1];
	frame_dig -1 // a: [uint64,uint16,uint64]
	dup
	store 3 // full tuple
	int 8
	int 2
	extract3
	byte 0xFFFF
	b&
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_dynamicArray:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub dynamicArray
	int 1
	return

dynamicArray:
	proto 1 0

	// tests/contracts/abi.algo.ts:249
	// a: uint64[] = [11, 22, 33]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	byte 0x0003
	swap
	concat
	frame_bury -1 // a: uint64[]

	// tests/contracts/abi.algo.ts:251
	// return a[1];
	frame_dig -1 // a: uint64[]
	int 1
	int 8 // element length
	* // element offset
	int 2
	+ // add two for length
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_returnDynamicArray:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub returnDynamicArray
	int 1
	return

returnDynamicArray:
	proto 1 0

	// tests/contracts/abi.algo.ts:255
	// a: uint64[] = [11, 22, 33]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	byte 0x0003
	swap
	concat
	frame_bury -1 // a: uint64[]

	// tests/contracts/abi.algo.ts:256
	// return a;
	frame_dig -1 // a: uint64[]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_dynamicArrayArg:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	txna ApplicationArgs 1
	callsub dynamicArrayArg
	int 1
	return

dynamicArrayArg:
	proto 1 0

	// tests/contracts/abi.algo.ts:260
	// return a[1];
	frame_dig -1 // a: uint64[]
	int 1
	int 8 // element length
	* // element offset
	int 2
	+ // add two for length
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_updateDynamicArrayElement:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub updateDynamicArrayElement
	int 1
	return

updateDynamicArrayElement:
	proto 1 0

	// tests/contracts/abi.algo.ts:264
	// a: uint64[] = [11, 22, 33]
	int 11
	itob
	int 22
	itob
	concat
	int 33
	itob
	concat
	byte 0x0003
	swap
	concat
	frame_bury -1 // a: uint64[]

	// tests/contracts/abi.algo.ts:266
	// a[1] = 222
	frame_dig -1 // a: uint64[]
	int 1
	int 8 // element length
	* // element offset
	int 2
	+ // add two for length
	int 222
	itob
	replace3
	frame_bury -1 // a: uint64[]

	// tests/contracts/abi.algo.ts:268
	// return a[1];
	frame_dig -1 // a: uint64[]
	int 1
	int 8 // element length
	* // element offset
	int 2
	+ // add two for length
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_dynamicTupleArray:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub dynamicTupleArray
	int 1
	return

dynamicTupleArray:
	proto 1 0

	// tests/contracts/abi.algo.ts:272
	// a: [uint16, uint64][] = [[11, 22], [33, 44]]
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x000a
	store 2 // head offset
	load 0 // tuple head
	int 11
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 22
	itob
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 1 // tuple tail
	concat
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x000a
	store 2 // head offset
	load 0 // tuple head
	int 33
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 44
	itob
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 1 // tuple tail
	concat
	concat
	byte 0x0002
	swap
	concat
	frame_bury -1 // a: [uint16,uint64][]

	// tests/contracts/abi.algo.ts:274
	// return a[1][1];
	frame_dig -1 // a: [uint16,uint64][]
	dup
	store 3 // full tuple
	int 1
	int 10 // element length
	* // element offset
	int 2
	+ // add two for length
	int 2
	+
	int 8
	extract3
	btoi
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_returnTupleWithDyamicArray:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub returnTupleWithDyamicArray
	int 1
	return

returnTupleWithDyamicArray:
	proto 1 0

	// tests/contracts/abi.algo.ts:278
	// a: [uint64, uint16, uint64[], uint16[]] = [1, 2, [3, 4], [5, 6]]
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x000e
	store 2 // head offset
	load 0 // tuple head
	int 1
	itob
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 2
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 3
	itob
	int 4
	itob
	concat
	byte 0x0002
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 5
	itob
	extract 6 0
	int 6
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: [uint64,uint16,uint64[],uint16[]]

	// tests/contracts/abi.algo.ts:280
	// return a;
	frame_dig -1 // a: [uint64,uint16,uint64[],uint16[]]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_returnDynamicArrayFromTuple:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub returnDynamicArrayFromTuple
	int 1
	return

returnDynamicArrayFromTuple:
	proto 1 0

	// tests/contracts/abi.algo.ts:284
	// a: [uint8, uint16, uint8[], uint16[], uint8[]] = [1, 2, [3, 4], [5, 6], [7, 8]]
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0009
	store 2 // head offset
	load 0 // tuple head
	int 1
	itob
	extract 7 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 2
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 3
	itob
	extract 7 0
	int 4
	itob
	extract 7 0
	concat
	byte 0x0002
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 5
	itob
	extract 6 0
	int 6
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 7
	itob
	extract 7 0
	int 8
	itob
	extract 7 0
	concat
	byte 0x0002
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: [uint8,uint16,uint8[],uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:286
	// return a[4];
	frame_dig -1 // a: [uint8,uint16,uint8[],uint16[],uint8[]]
	dup
	store 3 // full tuple
	int 7
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_updateDynamicArrayInTuple:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub updateDynamicArrayInTuple
	int 1
	return

updateDynamicArrayInTuple:
	proto 1 0

	// tests/contracts/abi.algo.ts:290
	// a: [uint8, uint16[], uint8[], uint16[], uint8[]] = [9, [8], [7], [6], [5]]
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0009
	store 2 // head offset
	load 0 // tuple head
	int 9
	itob
	extract 7 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 8
	itob
	extract 6 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 7
	itob
	extract 7 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 6
	itob
	extract 6 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 5
	itob
	extract 7 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: [uint8,uint16[],uint8[],uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:292
	// a[0] = 99 as uint8
	frame_dig -1 // a: [uint8,uint16[],uint8[],uint16[],uint8[]]
	dup
	store 3 // full tuple
	int 0
	int 99
	itob
	extract 7 0
	replace3
	frame_bury -1 // a: [uint8,uint16[],uint8[],uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:293
	// a[1] = [10, 11]
	frame_dig -1 // a: [uint8,uint16[],uint8[],uint16[],uint8[]]
	dup
	store 3 // full tuple
	int 1
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 2
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 10
	itob
	extract 6 0
	int 11
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	int 1
	callsub update_dynamic_tuple_element
	dup // duplicate length difference
	load 3 // full tuple
	int 3 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_0_0
	+ // add difference to offset
	b end_calc_new_head_0_0

subtract_head_difference_0_0:
	swap
	- // subtract difference from offet

end_calc_new_head_0_0:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 3 // replace dynamic array offset
	store 3 // full tuple
	dup // duplicate length difference
	load 3 // full tuple
	int 5 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_0_1
	+ // add difference to offset
	b end_calc_new_head_0_1

subtract_head_difference_0_1:
	swap
	- // subtract difference from offet

end_calc_new_head_0_1:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 5 // replace dynamic array offset
	store 3 // full tuple
	dup // duplicate length difference
	load 3 // full tuple
	int 7 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_0_2
	+ // add difference to offset
	b end_calc_new_head_0_2

subtract_head_difference_0_2:
	swap
	- // subtract difference from offet

end_calc_new_head_0_2:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 7 // replace dynamic array offset
	store 3 // full tuple
	load 3 // full tuple
	frame_bury -1 // a: [uint8,uint16[],uint8[],uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:294
	// a[2] = [12, 13]
	frame_dig -1 // a: [uint8,uint16[],uint8[],uint16[],uint8[]]
	dup
	store 3 // full tuple
	int 3
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 12
	itob
	extract 7 0
	int 13
	itob
	extract 7 0
	concat
	byte 0x0002
	swap
	concat
	int 3
	callsub update_dynamic_tuple_element
	dup // duplicate length difference
	load 3 // full tuple
	int 5 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_1_0
	+ // add difference to offset
	b end_calc_new_head_1_0

subtract_head_difference_1_0:
	swap
	- // subtract difference from offet

end_calc_new_head_1_0:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 5 // replace dynamic array offset
	store 3 // full tuple
	dup // duplicate length difference
	load 3 // full tuple
	int 7 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_1_1
	+ // add difference to offset
	b end_calc_new_head_1_1

subtract_head_difference_1_1:
	swap
	- // subtract difference from offet

end_calc_new_head_1_1:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 7 // replace dynamic array offset
	store 3 // full tuple
	load 3 // full tuple
	frame_bury -1 // a: [uint8,uint16[],uint8[],uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:295
	// a[3] = [14, 15]
	frame_dig -1 // a: [uint8,uint16[],uint8[],uint16[],uint8[]]
	dup
	store 3 // full tuple
	int 5
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 2
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 14
	itob
	extract 6 0
	int 15
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	int 5
	callsub update_dynamic_tuple_element
	dup // duplicate length difference
	load 3 // full tuple
	int 7 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_2_0
	+ // add difference to offset
	b end_calc_new_head_2_0

subtract_head_difference_2_0:
	swap
	- // subtract difference from offet

end_calc_new_head_2_0:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 7 // replace dynamic array offset
	store 3 // full tuple
	load 3 // full tuple
	frame_bury -1 // a: [uint8,uint16[],uint8[],uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:296
	// a[4] = [16, 17]
	frame_dig -1 // a: [uint8,uint16[],uint8[],uint16[],uint8[]]
	dup
	store 3 // full tuple
	int 7
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 16
	itob
	extract 7 0
	int 17
	itob
	extract 7 0
	concat
	byte 0x0002
	swap
	concat
	int 7
	callsub update_dynamic_tuple_element
	load 3 // full tuple
	frame_bury -1 // a: [uint8,uint16[],uint8[],uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:298
	// return a;
	frame_dig -1 // a: [uint8,uint16[],uint8[],uint16[],uint8[]]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_nonLiteralDynamicElementInTuple:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dup
	callsub nonLiteralDynamicElementInTuple
	int 1
	return

nonLiteralDynamicElementInTuple:
	proto 2 0

	// tests/contracts/abi.algo.ts:302
	// e: uint16[] = [5, 6]
	int 5
	itob
	extract 6 0
	int 6
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	frame_bury -1 // e: uint16[]

	// tests/contracts/abi.algo.ts:303
	// a: [uint8, uint16, uint8[], uint16[], uint8[]] = [1, 2, [3, 4], e, [7, 8]]
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0009
	store 2 // head offset
	load 0 // tuple head
	int 1
	itob
	extract 7 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	int 2
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 3
	itob
	extract 7 0
	int 4
	itob
	extract 7 0
	concat
	byte 0x0002
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	frame_dig -1 // e: uint16[]
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 7
	itob
	extract 7 0
	int 8
	itob
	extract 7 0
	concat
	byte 0x0002
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -2 // a: [uint8,uint16,uint8[],uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:305
	// return a;
	frame_dig -2 // a: [uint8,uint16,uint8[],uint16[],uint8[]]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_arrayPush:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub arrayPush
	int 1
	return

arrayPush:
	proto 1 0

	// tests/contracts/abi.algo.ts:309
	// a: uint16[] = [1, 2]
	int 1
	itob
	extract 6 0
	int 2
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:311
	// a.push(3 as uint16)
	frame_dig -1 // a: uint16[]
	dup
	int 0
	extract_uint16
	int 1
	+
	itob
	extract 6 2
	swap
	extract 2 0
	concat
	int 3
	itob
	extract 6 0
	concat
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:313
	// return a;
	frame_dig -1 // a: uint16[]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_arrayPop:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub arrayPop
	int 1
	return

arrayPop:
	proto 1 0

	// tests/contracts/abi.algo.ts:317
	// a: uint16[] = [1, 2, 3]
	int 1
	itob
	extract 6 0
	int 2
	itob
	extract 6 0
	concat
	int 3
	itob
	extract 6 0
	concat
	byte 0x0003
	swap
	concat
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:319
	// a.pop()
	frame_dig -1 // a: uint16[]
	dup
	int 0
	extract_uint16
	int 1
	-
	itob
	extract 6 2
	swap
	extract 2 0
	concat
	dup
	len
	int 2
	-
	int 0
	swap
	extract3
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:321
	// return a;
	frame_dig -1 // a: uint16[]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_arrayPopValue:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dup
	callsub arrayPopValue
	int 1
	return

arrayPopValue:
	proto 2 0

	// tests/contracts/abi.algo.ts:325
	// a: uint16[] = [1, 2, 3]
	int 1
	itob
	extract 6 0
	int 2
	itob
	extract 6 0
	concat
	int 3
	itob
	extract 6 0
	concat
	byte 0x0003
	swap
	concat
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:327
	// v = a.pop()!
	frame_dig -1 // a: uint16[]
	dup
	int 0
	extract_uint16
	int 1
	-
	itob
	extract 6 2
	swap
	extract 2 0
	concat
	dup
	len
	int 2
	-
	int 0
	swap
	extract3
	dup
	len
	int 2
	frame_dig -1 // a: uint16[]
	cover 2
	extract3
	swap
	frame_bury -1 // a: uint16[]
	frame_bury -2 // v: uint16

	// tests/contracts/abi.algo.ts:329
	// return v;
	frame_dig -2 // v: uint16
	byte 0xFFFF
	b&
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_arraySplice:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub arraySplice
	int 1
	return

arraySplice:
	proto 1 0

	// tests/contracts/abi.algo.ts:333
	// a: uint64[] = [1, 2, 3]
	int 1
	itob
	int 2
	itob
	concat
	int 3
	itob
	concat
	byte 0x0003
	swap
	concat
	frame_bury -1 // a: uint64[]

	// tests/contracts/abi.algo.ts:335
	// a.splice(1, 1)
	frame_dig -1 // a: uint64[]
	int 0
	extract_uint16
	int 1
	-
	itob
	extract 6 2
	int 1
	int 8
	*
	int 2
	+
	store 12 // splice start
	int 1
	int 8
	*
	int 8
	+
	store 13 // splice byte length
	frame_dig -1 // a: uint64[]
	int 2
	load 12 // splice start
	substring3
	frame_dig -1 // a: uint64[]
	dup
	len
	load 12 // splice start
	load 13 // splice byte length
	+
	int 8
	-
	swap
	substring3
	concat
	concat
	frame_bury -1 // a: uint64[]

	// tests/contracts/abi.algo.ts:337
	// return a;
	frame_dig -1 // a: uint64[]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_arraySpliceValue:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dupn 3
	callsub arraySpliceValue
	int 1
	return

arraySpliceValue:
	proto 4 0

	// tests/contracts/abi.algo.ts:341
	// a: uint16[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	int 1
	itob
	extract 6 0
	int 2
	itob
	extract 6 0
	concat
	int 3
	itob
	extract 6 0
	concat
	int 4
	itob
	extract 6 0
	concat
	int 5
	itob
	extract 6 0
	concat
	int 6
	itob
	extract 6 0
	concat
	int 7
	itob
	extract 6 0
	concat
	int 8
	itob
	extract 6 0
	concat
	int 9
	itob
	extract 6 0
	concat
	int 10
	itob
	extract 6 0
	concat
	byte 0x000a
	swap
	concat
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:343
	// i = 1
	int 1
	frame_bury -2 // i: uint64

	// tests/contracts/abi.algo.ts:344
	// l = 7
	int 7
	frame_bury -3 // l: uint64

	// tests/contracts/abi.algo.ts:345
	// v = a.splice(i, l)
	frame_dig -1 // a: uint16[]
	int 0
	extract_uint16
	frame_dig -3 // l: uint64
	-
	itob
	extract 6 2
	frame_dig -2 // i: uint64
	int 2
	*
	int 2
	+
	store 12 // splice start
	frame_dig -3 // l: uint64
	int 2
	*
	int 2
	+
	store 13 // splice byte length
	frame_dig -1 // a: uint16[]
	int 2
	load 12 // splice start
	substring3
	frame_dig -1 // a: uint16[]
	dup
	len
	load 12 // splice start
	load 13 // splice byte length
	+
	int 2
	-
	swap
	substring3
	concat
	concat
	frame_dig -3 // l: uint64
	itob
	extract 6 2
	frame_dig -1 // a: uint16[]
	load 12 // splice start
	load 13 // splice byte length
	int 2
	-
	extract3
	concat
	swap
	frame_bury -1 // a: uint16[]
	frame_bury -4 // v: uint16[]

	// tests/contracts/abi.algo.ts:347
	// return v;
	frame_dig -4 // v: uint16[]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_dynamicArrayElements:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dup
	callsub dynamicArrayElements
	int 1
	return

dynamicArrayElements:
	proto 2 0

	// tests/contracts/abi.algo.ts:351
	// a: uint16[] = [1, 2, 3]
	int 1
	itob
	extract 6 0
	int 2
	itob
	extract 6 0
	concat
	int 3
	itob
	extract 6 0
	concat
	byte 0x0003
	swap
	concat
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:352
	// newA: uint16[] = [a[0], a[1], a[2]]
	frame_dig -1 // a: uint16[]
	int 0
	int 2 // element length
	* // element offset
	int 2
	+ // add two for length
	int 2
	extract3
	frame_dig -1 // a: uint16[]
	int 1
	int 2 // element length
	* // element offset
	int 2
	+ // add two for length
	int 2
	extract3
	concat
	frame_dig -1 // a: uint16[]
	int 2
	int 2 // element length
	* // element offset
	int 2
	+ // add two for length
	int 2
	extract3
	concat
	byte 0x0003
	swap
	concat
	frame_bury -2 // newA: uint16[]

	// tests/contracts/abi.algo.ts:354
	// return newA;
	frame_dig -2 // newA: uint16[]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_spliceLastElement:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub spliceLastElement
	int 1
	return

spliceLastElement:
	proto 1 0

	// tests/contracts/abi.algo.ts:358
	// a: uint16[] = [1, 2, 3]
	int 1
	itob
	extract 6 0
	int 2
	itob
	extract 6 0
	concat
	int 3
	itob
	extract 6 0
	concat
	byte 0x0003
	swap
	concat
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:360
	// a.splice(2, 1)
	frame_dig -1 // a: uint16[]
	int 0
	extract_uint16
	int 1
	-
	itob
	extract 6 2
	int 2
	int 2
	*
	int 2
	+
	store 12 // splice start
	int 1
	int 2
	*
	int 2
	+
	store 13 // splice byte length
	frame_dig -1 // a: uint16[]
	int 2
	load 12 // splice start
	substring3
	frame_dig -1 // a: uint16[]
	dup
	len
	load 12 // splice start
	load 13 // splice byte length
	+
	int 2
	-
	swap
	substring3
	concat
	concat
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:362
	// return a;
	frame_dig -1 // a: uint16[]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_spliceLastElementValue:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dup
	callsub spliceLastElementValue
	int 1
	return

spliceLastElementValue:
	proto 2 0

	// tests/contracts/abi.algo.ts:366
	// a: uint16[] = [1, 2, 3]
	int 1
	itob
	extract 6 0
	int 2
	itob
	extract 6 0
	concat
	int 3
	itob
	extract 6 0
	concat
	byte 0x0003
	swap
	concat
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:368
	// v = a.splice(2, 1)
	frame_dig -1 // a: uint16[]
	int 0
	extract_uint16
	int 1
	-
	itob
	extract 6 2
	int 2
	int 2
	*
	int 2
	+
	store 12 // splice start
	int 1
	int 2
	*
	int 2
	+
	store 13 // splice byte length
	frame_dig -1 // a: uint16[]
	int 2
	load 12 // splice start
	substring3
	frame_dig -1 // a: uint16[]
	dup
	len
	load 12 // splice start
	load 13 // splice byte length
	+
	int 2
	-
	swap
	substring3
	concat
	concat
	int 1
	itob
	extract 6 2
	frame_dig -1 // a: uint16[]
	load 12 // splice start
	load 13 // splice byte length
	int 2
	-
	extract3
	concat
	swap
	frame_bury -1 // a: uint16[]
	frame_bury -2 // v: uint16[]

	// tests/contracts/abi.algo.ts:370
	// return v;
	frame_dig -2 // v: uint16[]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_spliceFirstElement:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub spliceFirstElement
	int 1
	return

spliceFirstElement:
	proto 1 0

	// tests/contracts/abi.algo.ts:374
	// a: uint16[] = [1, 2, 3]
	int 1
	itob
	extract 6 0
	int 2
	itob
	extract 6 0
	concat
	int 3
	itob
	extract 6 0
	concat
	byte 0x0003
	swap
	concat
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:376
	// a.splice(0, 1)
	frame_dig -1 // a: uint16[]
	int 0
	extract_uint16
	int 1
	-
	itob
	extract 6 2
	int 0
	int 2
	*
	int 2
	+
	store 12 // splice start
	int 1
	int 2
	*
	int 2
	+
	store 13 // splice byte length
	frame_dig -1 // a: uint16[]
	int 2
	load 12 // splice start
	substring3
	frame_dig -1 // a: uint16[]
	dup
	len
	load 12 // splice start
	load 13 // splice byte length
	+
	int 2
	-
	swap
	substring3
	concat
	concat
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:378
	// return a;
	frame_dig -1 // a: uint16[]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_spliceFirstElementValue:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	dup
	callsub spliceFirstElementValue
	int 1
	return

spliceFirstElementValue:
	proto 2 0

	// tests/contracts/abi.algo.ts:382
	// a: uint16[] = [1, 2, 3]
	int 1
	itob
	extract 6 0
	int 2
	itob
	extract 6 0
	concat
	int 3
	itob
	extract 6 0
	concat
	byte 0x0003
	swap
	concat
	frame_bury -1 // a: uint16[]

	// tests/contracts/abi.algo.ts:384
	// v = a.splice(0, 1)
	frame_dig -1 // a: uint16[]
	int 0
	extract_uint16
	int 1
	-
	itob
	extract 6 2
	int 0
	int 2
	*
	int 2
	+
	store 12 // splice start
	int 1
	int 2
	*
	int 2
	+
	store 13 // splice byte length
	frame_dig -1 // a: uint16[]
	int 2
	load 12 // splice start
	substring3
	frame_dig -1 // a: uint16[]
	dup
	len
	load 12 // splice start
	load 13 // splice byte length
	+
	int 2
	-
	swap
	substring3
	concat
	concat
	int 1
	itob
	extract 6 2
	frame_dig -1 // a: uint16[]
	load 12 // splice start
	load 13 // splice byte length
	int 2
	-
	extract3
	concat
	swap
	frame_bury -1 // a: uint16[]
	frame_bury -2 // v: uint16[]

	// tests/contracts/abi.algo.ts:386
	// return v;
	frame_dig -2 // v: uint16[]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_stringReturn:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	callsub stringReturn
	int 1
	return

stringReturn:
	proto 0 0

	// tests/contracts/abi.algo.ts:390
	// return 'Hello World!';
	byte "Hello World!"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_stringArg:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	txna ApplicationArgs 1
	extract 2 0
	callsub stringArg
	int 1
	return

stringArg:
	proto 1 0

	// tests/contracts/abi.algo.ts:394
	// assert(s === 'Hello World!')
	frame_dig -1 // s: bytes
	byte "Hello World!"
	==
	assert
	retsub

abi_route_stringInTuple:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub stringInTuple
	int 1
	return

stringInTuple:
	proto 1 0

	// tests/contracts/abi.algo.ts:398
	// a: [uint16, uint8[], string, uint8[]] = [1, [2], 'Hello World!', [3]]
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0008
	store 2 // head offset
	load 0 // tuple head
	int 1
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 2
	itob
	extract 7 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	byte "Hello World!"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 3
	itob
	extract 7 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: [uint16,uint8[],string,uint8[]]

	// tests/contracts/abi.algo.ts:400
	// return a;
	frame_dig -1 // a: [uint16,uint8[],string,uint8[]]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_accesStringInTuple:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub accesStringInTuple
	int 1
	return

accesStringInTuple:
	proto 1 0

	// tests/contracts/abi.algo.ts:404
	// a: [uint16, uint8[], string, uint8[]] = [1, [2], 'Hello World!', [3]]
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0008
	store 2 // head offset
	load 0 // tuple head
	int 1
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 2
	itob
	extract 7 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	byte "Hello World!"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 3
	itob
	extract 7 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: [uint16,uint8[],string,uint8[]]

	// tests/contracts/abi.algo.ts:406
	// assert(a[2] === 'Hello World!')
	frame_dig -1 // a: [uint16,uint8[],string,uint8[]]
	dup
	store 3 // full tuple
	int 4
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	byte "Hello World!"
	==
	assert

	// tests/contracts/abi.algo.ts:408
	// return a[2];
	frame_dig -1 // a: [uint16,uint8[],string,uint8[]]
	dup
	store 3 // full tuple
	int 4
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_updateStringInTuple:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub updateStringInTuple
	int 1
	return

updateStringInTuple:
	proto 1 0

	// tests/contracts/abi.algo.ts:412
	// a: [uint8, uint16[], string, uint16[], uint8[]] = [9, [8], 'Hi?', [6], [5]]
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0009
	store 2 // head offset
	load 0 // tuple head
	int 9
	itob
	extract 7 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 8
	itob
	extract 6 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	byte "Hi?"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 6
	itob
	extract 6 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 5
	itob
	extract 7 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: [uint8,uint16[],string,uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:414
	// a[0] = 99 as uint8
	frame_dig -1 // a: [uint8,uint16[],string,uint16[],uint8[]]
	dup
	store 3 // full tuple
	int 0
	int 99
	itob
	extract 7 0
	replace3
	frame_bury -1 // a: [uint8,uint16[],string,uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:415
	// a[1] = [10, 11]
	frame_dig -1 // a: [uint8,uint16[],string,uint16[],uint8[]]
	dup
	store 3 // full tuple
	int 1
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 2
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 10
	itob
	extract 6 0
	int 11
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	int 1
	callsub update_dynamic_tuple_element
	dup // duplicate length difference
	load 3 // full tuple
	int 3 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_4_0
	+ // add difference to offset
	b end_calc_new_head_4_0

subtract_head_difference_4_0:
	swap
	- // subtract difference from offet

end_calc_new_head_4_0:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 3 // replace dynamic array offset
	store 3 // full tuple
	dup // duplicate length difference
	load 3 // full tuple
	int 5 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_4_1
	+ // add difference to offset
	b end_calc_new_head_4_1

subtract_head_difference_4_1:
	swap
	- // subtract difference from offet

end_calc_new_head_4_1:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 5 // replace dynamic array offset
	store 3 // full tuple
	dup // duplicate length difference
	load 3 // full tuple
	int 7 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_4_2
	+ // add difference to offset
	b end_calc_new_head_4_2

subtract_head_difference_4_2:
	swap
	- // subtract difference from offet

end_calc_new_head_4_2:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 7 // replace dynamic array offset
	store 3 // full tuple
	load 3 // full tuple
	frame_bury -1 // a: [uint8,uint16[],string,uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:416
	// a[2] = 'Hello World!'
	frame_dig -1 // a: [uint8,uint16[],string,uint16[],uint8[]]
	dup
	store 3 // full tuple
	int 3
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	byte "Hello World!"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	int 3
	callsub update_dynamic_tuple_element
	dup // duplicate length difference
	load 3 // full tuple
	int 5 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_5_0
	+ // add difference to offset
	b end_calc_new_head_5_0

subtract_head_difference_5_0:
	swap
	- // subtract difference from offet

end_calc_new_head_5_0:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 5 // replace dynamic array offset
	store 3 // full tuple
	dup // duplicate length difference
	load 3 // full tuple
	int 7 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_5_1
	+ // add difference to offset
	b end_calc_new_head_5_1

subtract_head_difference_5_1:
	swap
	- // subtract difference from offet

end_calc_new_head_5_1:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 7 // replace dynamic array offset
	store 3 // full tuple
	load 3 // full tuple
	frame_bury -1 // a: [uint8,uint16[],string,uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:417
	// a[3] = [14, 15]
	frame_dig -1 // a: [uint8,uint16[],string,uint16[],uint8[]]
	dup
	store 3 // full tuple
	int 5
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 2
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 14
	itob
	extract 6 0
	int 15
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	int 5
	callsub update_dynamic_tuple_element
	dup // duplicate length difference
	load 3 // full tuple
	int 7 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_6_0
	+ // add difference to offset
	b end_calc_new_head_6_0

subtract_head_difference_6_0:
	swap
	- // subtract difference from offet

end_calc_new_head_6_0:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 7 // replace dynamic array offset
	store 3 // full tuple
	load 3 // full tuple
	frame_bury -1 // a: [uint8,uint16[],string,uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:418
	// a[4] = [16, 17]
	frame_dig -1 // a: [uint8,uint16[],string,uint16[],uint8[]]
	dup
	store 3 // full tuple
	int 7
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 16
	itob
	extract 7 0
	int 17
	itob
	extract 7 0
	concat
	byte 0x0002
	swap
	concat
	int 7
	callsub update_dynamic_tuple_element
	load 3 // full tuple
	frame_bury -1 // a: [uint8,uint16[],string,uint16[],uint8[]]

	// tests/contracts/abi.algo.ts:420
	// return a;
	frame_dig -1 // a: [uint8,uint16[],string,uint16[],uint8[]]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_updateTupleWithOnlyDynamicTypes:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub updateTupleWithOnlyDynamicTypes
	int 1
	return

updateTupleWithOnlyDynamicTypes:
	proto 1 0

	// tests/contracts/abi.algo.ts:424
	// a: [uint16[], uint16[], uint16[]] = [[1], [2], [3]]
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0006
	store 2 // head offset
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 1
	itob
	extract 6 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 2
	itob
	extract 6 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 3
	itob
	extract 6 0
	byte 0x0001
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: [uint16[],uint16[],uint16[]]

	// tests/contracts/abi.algo.ts:426
	// a[0] = [4, 5]
	frame_dig -1 // a: [uint16[],uint16[],uint16[]]
	dup
	store 3 // full tuple
	int 0
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 2
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 4
	itob
	extract 6 0
	int 5
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	int 0
	callsub update_dynamic_tuple_element
	dup // duplicate length difference
	load 3 // full tuple
	int 2 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_8_0
	+ // add difference to offset
	b end_calc_new_head_8_0

subtract_head_difference_8_0:
	swap
	- // subtract difference from offet

end_calc_new_head_8_0:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 2 // replace dynamic array offset
	store 3 // full tuple
	dup // duplicate length difference
	load 3 // full tuple
	int 4 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_8_1
	+ // add difference to offset
	b end_calc_new_head_8_1

subtract_head_difference_8_1:
	swap
	- // subtract difference from offet

end_calc_new_head_8_1:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 4 // replace dynamic array offset
	store 3 // full tuple
	load 3 // full tuple
	frame_bury -1 // a: [uint16[],uint16[],uint16[]]

	// tests/contracts/abi.algo.ts:427
	// a[1] = [6, 7]
	frame_dig -1 // a: [uint16[],uint16[],uint16[]]
	dup
	store 3 // full tuple
	int 2
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 2
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 6
	itob
	extract 6 0
	int 7
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	int 2
	callsub update_dynamic_tuple_element
	dup // duplicate length difference
	load 3 // full tuple
	int 4 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_9_0
	+ // add difference to offset
	b end_calc_new_head_9_0

subtract_head_difference_9_0:
	swap
	- // subtract difference from offet

end_calc_new_head_9_0:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 4 // replace dynamic array offset
	store 3 // full tuple
	load 3 // full tuple
	frame_bury -1 // a: [uint16[],uint16[],uint16[]]

	// tests/contracts/abi.algo.ts:428
	// a[2] = [8, 9]
	frame_dig -1 // a: [uint16[],uint16[],uint16[]]
	dup
	store 3 // full tuple
	int 4
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 2
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 8
	itob
	extract 6 0
	int 9
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	int 4
	callsub update_dynamic_tuple_element
	load 3 // full tuple
	frame_bury -1 // a: [uint16[],uint16[],uint16[]]

	// tests/contracts/abi.algo.ts:430
	// return a;
	frame_dig -1 // a: [uint16[],uint16[],uint16[]]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_shortenDynamicElementInTuple:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub shortenDynamicElementInTuple
	int 1
	return

shortenDynamicElementInTuple:
	proto 1 0

	// tests/contracts/abi.algo.ts:434
	// a: [uint16[], uint16[], uint16[]] = [[1, 2], [2, 3], [3, 4]]
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0006
	store 2 // head offset
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 1
	itob
	extract 6 0
	int 2
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 2
	itob
	extract 6 0
	int 3
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	int 3
	itob
	extract 6 0
	int 4
	itob
	extract 6 0
	concat
	byte 0x0002
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: [uint16[],uint16[],uint16[]]

	// tests/contracts/abi.algo.ts:436
	// a[0] = [5]
	frame_dig -1 // a: [uint16[],uint16[],uint16[]]
	dup
	store 3 // full tuple
	int 0
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 2
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 5
	itob
	extract 6 0
	byte 0x0001
	swap
	concat
	int 0
	callsub update_dynamic_tuple_element
	dup // duplicate length difference
	load 3 // full tuple
	int 2 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_11_0
	+ // add difference to offset
	b end_calc_new_head_11_0

subtract_head_difference_11_0:
	swap
	- // subtract difference from offet

end_calc_new_head_11_0:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 2 // replace dynamic array offset
	store 3 // full tuple
	dup // duplicate length difference
	load 3 // full tuple
	int 4 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_11_1
	+ // add difference to offset
	b end_calc_new_head_11_1

subtract_head_difference_11_1:
	swap
	- // subtract difference from offet

end_calc_new_head_11_1:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 4 // replace dynamic array offset
	store 3 // full tuple
	load 3 // full tuple
	frame_bury -1 // a: [uint16[],uint16[],uint16[]]

	// tests/contracts/abi.algo.ts:437
	// a[1] = [6]
	frame_dig -1 // a: [uint16[],uint16[],uint16[]]
	dup
	store 3 // full tuple
	int 2
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 2
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 6
	itob
	extract 6 0
	byte 0x0001
	swap
	concat
	int 2
	callsub update_dynamic_tuple_element
	dup // duplicate length difference
	load 3 // full tuple
	int 4 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 7 // subtract head difference
	bz subtract_head_difference_12_0
	+ // add difference to offset
	b end_calc_new_head_12_0

subtract_head_difference_12_0:
	swap
	- // subtract difference from offet

end_calc_new_head_12_0:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 3 // full tuple
	swap
	replace 4 // replace dynamic array offset
	store 3 // full tuple
	load 3 // full tuple
	frame_bury -1 // a: [uint16[],uint16[],uint16[]]

	// tests/contracts/abi.algo.ts:438
	// a[2] = [7]
	frame_dig -1 // a: [uint16[],uint16[],uint16[]]
	dup
	store 3 // full tuple
	int 4
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 2
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	int 7
	itob
	extract 6 0
	byte 0x0001
	swap
	concat
	int 4
	callsub update_dynamic_tuple_element
	load 3 // full tuple
	frame_bury -1 // a: [uint16[],uint16[],uint16[]]

	// tests/contracts/abi.algo.ts:440
	// return a;
	frame_dig -1 // a: [uint16[],uint16[],uint16[]]
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_namedTuple:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub namedTuple
	int 1
	return

namedTuple:
	proto 1 0

	// tests/contracts/abi.algo.ts:444
	// a: {
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0004
	store 2 // head offset
	load 0 // tuple head
	int 1
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	byte "Hello World!"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: { foo: uint16, bar: string, }

	// tests/contracts/abi.algo.ts:452
	// return a.bar;
	frame_dig -1 // a: { foo: uint16, bar: string, }
	dup
	store 3 // full tuple
	int 2
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_updateNamedTuple:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub updateNamedTuple
	int 1
	return

updateNamedTuple:
	proto 1 0

	// tests/contracts/abi.algo.ts:456
	// a: {
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0004
	store 2 // head offset
	load 0 // tuple head
	int 1
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	byte "Hi?"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // a: { foo: uint16, bar: string, }

	// tests/contracts/abi.algo.ts:464
	// a.bar = 'Hello World!'
	frame_dig -1 // a: { foo: uint16, bar: string, }
	dup
	store 3 // full tuple
	int 2
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	byte "Hello World!"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	int 2
	callsub update_dynamic_tuple_element
	load 3 // full tuple
	frame_bury -1 // a: { foo: uint16, bar: string, }

	// tests/contracts/abi.algo.ts:466
	// return a.bar;
	frame_dig -1 // a: { foo: uint16, bar: string, }
	dup
	store 3 // full tuple
	int 2
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_customTypes:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	callsub customTypes
	int 1
	return

customTypes:
	proto 1 0

	// tests/contracts/abi.algo.ts:470
	// aa: CustomType = {
	byte 0x
	dup
	store 0 // tuple head
	store 1 // tuple tail
	byte 0x0004
	store 2 // head offset
	load 0 // tuple head
	int 1
	itob
	extract 6 0
	concat
	store 0 // tuple head
	load 0 // tuple head
	load 2 // head offset
	concat
	store 0 // tuple head
	byte "Hi?"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	len
	load 2 // head offset
	btoi
	+
	itob
	extract 6 2
	store 2 // head offset
	load 1 // tuple tail
	swap
	concat
	store 1 // tuple tail
	load 0 // tuple head
	load 1 // tuple tail
	concat
	frame_bury -1 // aa: CustomType

	// tests/contracts/abi.algo.ts:475
	// aa.bar = 'Hello World!'
	frame_dig -1 // aa: CustomType
	dup
	store 3 // full tuple
	int 2
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	store 4 // old tuple element
	load 4 // old tuple element
	len // length of old element
	byte "Hello World!"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	int 2
	callsub update_dynamic_tuple_element
	load 3 // full tuple
	frame_bury -1 // aa: CustomType

	// tests/contracts/abi.algo.ts:477
	// return aa.bar;
	frame_dig -1 // aa: CustomType
	dup
	store 3 // full tuple
	int 2
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_staticStringArrayArg:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	txna ApplicationArgs 1
	callsub staticStringArrayArg
	int 1
	return

staticStringArrayArg:
	proto 1 0

	// tests/contracts/abi.algo.ts:481
	// return a[1];
	frame_dig -1 // a: bytes[3]
	dup
	store 3 // full tuple
	int 1
	int 2
	*
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_dynamicAccessOfDynamicElementInStaticArray:
	txn OnCompletion
	int NoOp
	==
	txn ApplicationID
	int 0
	!=
	&&
	assert
	byte 0x
	txna ApplicationArgs 1
	callsub dynamicAccessOfDynamicElementInStaticArray
	int 1
	return

dynamicAccessOfDynamicElementInStaticArray:
	proto 2 0

	// tests/contracts/abi.algo.ts:485
	// i = 1
	int 1
	frame_bury -2 // i: uint64

	// tests/contracts/abi.algo.ts:486
	// return a[i];
	frame_dig -1 // a: bytes[3]
	dup
	store 3 // full tuple
	frame_dig -2 // i: uint64
	int 2
	*
	swap
	dupn 2
	uncover 3
	int 2
	extract3
	btoi // start of dynamic array
	dup
	cover 2 // duplicate start for later
	int 2
	extract3 // extract length of array
	btoi
	int 1
	* // get array length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

main:
	txn NumAppArgs
	bnz route_abi
	txn ApplicationID
	int 0
	==
	bnz bare_route_create
	txn OnCompletion
	int OptIn
	==
	int 1
	match bare_route_OptIn

route_abi:
	method "staticArray()uint64"
	method "returnStaticArray()uint64[3]"
	method "staticArrayArg(uint64[3])uint64"
	method "nonLiteralStaticArrayElements()uint64"
	method "mixedStaticArrayElements()uint64"
	method "nonLiteralStaticArrayAccess()uint64"
	method "setStaticArrayElement()uint64"
	method "staticArrayInStorageRef()uint64[3]"
	method "updateStaticArrayInStorageRef()uint64[3]"
	method "staticArrayInStorageMap()uint64[3]"
	method "updateStaticArrayInStorageMap()uint64[3]"
	method "nestedStaticArray()uint64"
	method "updateNestedStaticArrayElement()uint64"
	method "updateNestedStaticArray()uint64"
	method "threeDimensionalUint16Array()uint16"
	method "simpleTuple()uint16"
	method "arrayInTuple()uint64"
	method "tupleInArray()uint16"
	method "shortTypeNotation()uint16"
	method "returnTuple()(uint64,uint16,uint64)"
	method "tupleArg((uint64,uint16,uint64))uint16"
	method "dynamicArray()uint64"
	method "returnDynamicArray()uint64[]"
	method "dynamicArrayArg(uint64[])uint64"
	method "updateDynamicArrayElement()uint64"
	method "dynamicTupleArray()uint64"
	method "returnTupleWithDyamicArray()(uint64,uint16,uint64[],uint16[])"
	method "returnDynamicArrayFromTuple()uint8[]"
	method "updateDynamicArrayInTuple()(uint8,uint16[],uint8[],uint16[],uint8[])"
	method "nonLiteralDynamicElementInTuple()(uint8,uint16,uint8[],uint16[],uint8[])"
	method "arrayPush()uint16[]"
	method "arrayPop()uint16[]"
	method "arrayPopValue()uint16"
	method "arraySplice()uint64[]"
	method "arraySpliceValue()uint16[]"
	method "dynamicArrayElements()uint16[]"
	method "spliceLastElement()uint16[]"
	method "spliceLastElementValue()uint16[]"
	method "spliceFirstElement()uint16[]"
	method "spliceFirstElementValue()uint16[]"
	method "stringReturn()string"
	method "stringArg(string)void"
	method "stringInTuple()(uint16,uint8[],string,uint8[])"
	method "accesStringInTuple()string"
	method "updateStringInTuple()(uint8,uint16[],string,uint16[],uint8[])"
	method "updateTupleWithOnlyDynamicTypes()(uint16[],uint16[],uint16[])"
	method "shortenDynamicElementInTuple()(uint16[],uint16[],uint16[])"
	method "namedTuple()string"
	method "updateNamedTuple()string"
	method "customTypes()string"
	method "staticStringArrayArg(string[3])string"
	method "dynamicAccessOfDynamicElementInStaticArray(string[3])string"
	txna ApplicationArgs 0
	match abi_route_staticArray abi_route_returnStaticArray abi_route_staticArrayArg abi_route_nonLiteralStaticArrayElements abi_route_mixedStaticArrayElements abi_route_nonLiteralStaticArrayAccess abi_route_setStaticArrayElement abi_route_staticArrayInStorageRef abi_route_updateStaticArrayInStorageRef abi_route_staticArrayInStorageMap abi_route_updateStaticArrayInStorageMap abi_route_nestedStaticArray abi_route_updateNestedStaticArrayElement abi_route_updateNestedStaticArray abi_route_threeDimensionalUint16Array abi_route_simpleTuple abi_route_arrayInTuple abi_route_tupleInArray abi_route_shortTypeNotation abi_route_returnTuple abi_route_tupleArg abi_route_dynamicArray abi_route_returnDynamicArray abi_route_dynamicArrayArg abi_route_updateDynamicArrayElement abi_route_dynamicTupleArray abi_route_returnTupleWithDyamicArray abi_route_returnDynamicArrayFromTuple abi_route_updateDynamicArrayInTuple abi_route_nonLiteralDynamicElementInTuple abi_route_arrayPush abi_route_arrayPop abi_route_arrayPopValue abi_route_arraySplice abi_route_arraySpliceValue abi_route_dynamicArrayElements abi_route_spliceLastElement abi_route_spliceLastElementValue abi_route_spliceFirstElement abi_route_spliceFirstElementValue abi_route_stringReturn abi_route_stringArg abi_route_stringInTuple abi_route_accesStringInTuple abi_route_updateStringInTuple abi_route_updateTupleWithOnlyDynamicTypes abi_route_shortenDynamicElementInTuple abi_route_namedTuple abi_route_updateNamedTuple abi_route_customTypes abi_route_staticStringArrayArg abi_route_dynamicAccessOfDynamicElementInStaticArray