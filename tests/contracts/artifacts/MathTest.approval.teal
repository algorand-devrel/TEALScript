#pragma version 10

// This TEAL was generated by TEALScript v0.90.4
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	err

// u64plus(uint64,uint64)uint64
*abi_route_u64plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64plus(uint64,uint64)uint64
	callsub u64plus
	itob
	concat
	log
	int 1
	return

// u64plus(a: uint64, b: uint64): uint64
u64plus:
	proto 2 1

	// tests/contracts/math.algo.ts:8
	// return a + b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	retsub

// u64minus(uint64,uint64)uint64
*abi_route_u64minus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64minus(uint64,uint64)uint64
	callsub u64minus
	itob
	concat
	log
	int 1
	return

// u64minus(a: uint64, b: uint64): uint64
u64minus:
	proto 2 1

	// tests/contracts/math.algo.ts:12
	// return a - b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	-
	retsub

// u64mul(uint64,uint64)uint64
*abi_route_u64mul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64mul(uint64,uint64)uint64
	callsub u64mul
	itob
	concat
	log
	int 1
	return

// u64mul(a: uint64, b: uint64): uint64
u64mul:
	proto 2 1

	// tests/contracts/math.algo.ts:16
	// return a * b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	*
	retsub

// u64div(uint64,uint64)uint64
*abi_route_u64div:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64div(uint64,uint64)uint64
	callsub u64div
	itob
	concat
	log
	int 1
	return

// u64div(a: uint64, b: uint64): uint64
u64div:
	proto 2 1

	// tests/contracts/math.algo.ts:20
	// return a / b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	/
	retsub

// u256plus(uint256,uint256)uint256
*abi_route_u256plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256plus(uint256,uint256)uint256
	callsub u256plus
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u256plus(a: uint256, b: uint256): uint256
u256plus:
	proto 2 1

	// tests/contracts/math.algo.ts:24
	// return <uint256>(a + b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b+
	retsub

// u256minus(uint256,uint256)uint256
*abi_route_u256minus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256minus(uint256,uint256)uint256
	callsub u256minus
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u256minus(a: uint256, b: uint256): uint256
u256minus:
	proto 2 1

	// tests/contracts/math.algo.ts:28
	// return <uint256>(a - b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b-
	retsub

// u256mul(uint256,uint256)uint256
*abi_route_u256mul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256mul(uint256,uint256)uint256
	callsub u256mul
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u256mul(a: uint256, b: uint256): uint256
u256mul:
	proto 2 1

	// tests/contracts/math.algo.ts:32
	// return <uint256>(a * b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b*
	retsub

// u256div(uint256,uint256)uint256
*abi_route_u256div:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256div(uint256,uint256)uint256
	callsub u256div
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u256div(a: uint256, b: uint256): uint256
u256div:
	proto 2 1

	// tests/contracts/math.algo.ts:36
	// return <uint256>(a / b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b/
	retsub

// u64Return256(uint64,uint64)uint256
*abi_route_u64Return256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64Return256(uint64,uint64)uint256
	callsub u64Return256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u64Return256(a: uint64, b: uint64): uint256
u64Return256:
	proto 2 1

	// tests/contracts/math.algo.ts:40
	// return <uint256>(a + b);
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	itob
	retsub

// maxU64()uint64
*abi_route_maxU64:
	// The ABI return prefix
	byte 0x151f7c75

	// execute maxU64()uint64
	callsub maxU64
	itob
	concat
	log
	int 1
	return

// maxU64(): uint64
maxU64:
	proto 0 1

	// tests/contracts/math.algo.ts:45
	// return 18_446_744_073_709_551_615;
	int 18_446_744_073_709_551_615
	retsub

// exponent(uint64,uint64)uint64
*abi_route_exponent:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute exponent(uint64,uint64)uint64
	callsub exponent
	itob
	concat
	log
	int 1
	return

// exponent(a: uint64, b: uint64): uint64
exponent:
	proto 2 1

	// tests/contracts/math.algo.ts:49
	// return a ** b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	exp
	retsub

// variableTypeHint(uint8,uint8)uint16
*abi_route_variableTypeHint:
	// The ABI return prefix
	byte 0x151f7c75

	// y: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// x: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert
	btoi

	// execute variableTypeHint(uint8,uint8)uint16
	callsub variableTypeHint
	itob
	dup
	bitlen
	int 16
	<=
	assert
	extract 6 2
	concat
	log
	int 1
	return

// variableTypeHint(x: uint<8>, y: uint<8>): uint16
variableTypeHint:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:53
	// z = <uint16>(x + y)
	frame_dig -1 // x: uint<8>
	frame_dig -2 // y: uint<8>
	+
	frame_bury 0 // z: unsafe uint16

	// tests/contracts/math.algo.ts:55
	// return z;
	frame_dig 0 // z: unsafe uint16

	// set the subroutine return value
	frame_bury 0
	retsub

// uint8plus(uint8,uint8)uint8
*abi_route_uint8plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// a: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert
	btoi

	// execute uint8plus(uint8,uint8)uint8
	callsub uint8plus
	itob
	dup
	bitlen
	int 8
	<=
	assert
	extract 7 1
	concat
	log
	int 1
	return

// uint8plus(a: uint<8>, b: uint<8>): uint<8>
uint8plus:
	proto 2 1

	// tests/contracts/math.algo.ts:59
	// return a + b;
	frame_dig -1 // a: uint<8>
	frame_dig -2 // b: uint<8>
	+
	retsub

// uint8exp(uint8,uint8)uint8
*abi_route_uint8exp:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// a: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert
	btoi

	// execute uint8exp(uint8,uint8)uint8
	callsub uint8exp
	itob
	dup
	bitlen
	int 8
	<=
	assert
	extract 7 1
	concat
	log
	int 1
	return

// uint8exp(a: uint<8>, b: uint<8>): uint<8>
uint8exp:
	proto 2 1

	// tests/contracts/math.algo.ts:63
	// return a ** b;
	frame_dig -1 // a: uint<8>
	frame_dig -2 // b: uint<8>
	exp
	retsub

// plusEquals(uint64,uint64)uint64
*abi_route_plusEquals:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute plusEquals(uint64,uint64)uint64
	callsub plusEquals
	itob
	concat
	log
	int 1
	return

// plusEquals(a: uint64, b: uint64): uint64
plusEquals:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:67
	// x = a
	frame_dig -1 // a: uint64
	frame_bury 0 // x: uint64

	// tests/contracts/math.algo.ts:69
	// x += b
	frame_dig 0 // x: uint64
	frame_dig -2 // b: uint64
	+
	frame_bury 0 // x: uint64

	// tests/contracts/math.algo.ts:71
	// return x;
	frame_dig 0 // x: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// plusEqualsFromGlobal(uint64,uint64)uint64
*abi_route_plusEqualsFromGlobal:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute plusEqualsFromGlobal(uint64,uint64)uint64
	callsub plusEqualsFromGlobal
	itob
	concat
	log
	int 1
	return

// plusEqualsFromGlobal(a: uint64, b: uint64): uint64
plusEqualsFromGlobal:
	proto 2 1

	// tests/contracts/math.algo.ts:75
	// this.gKey.value = a
	byte 0x674b6579 // "gKey"
	frame_dig -1 // a: uint64
	app_global_put

	// tests/contracts/math.algo.ts:77
	// this.gKey.value += b
	byte 0x674b6579 // "gKey"
	app_global_get
	frame_dig -2 // b: uint64
	+
	byte 0x674b6579 // "gKey"
	swap
	app_global_put

	// tests/contracts/math.algo.ts:79
	// return this.gKey.value;
	byte 0x674b6579 // "gKey"
	app_global_get
	retsub

// boxTest()uint256
*abi_route_boxTest:
	// The ABI return prefix
	byte 0x151f7c75

	// execute boxTest()uint256
	callsub boxTest
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// boxTest(): uint256
boxTest:
	proto 0 1

	// tests/contracts/math.algo.ts:85
	// this.boxKey.value = <uint256>1
	byte 0x626f784b6579 // "boxKey"
	byte 0x0000000000000000000000000000000000000000000000000000000000000001
	box_put

	// tests/contracts/math.algo.ts:86
	// this.boxKey.value += 1
	byte 0x626f784b6579 // "boxKey"
	box_get
	assert
	byte 0x0000000000000000000000000000000000000000000000000000000000000001
	b+
	byte 0x626f784b6579 // "boxKey"
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	swap
	box_put

	// tests/contracts/math.algo.ts:88
	// return this.boxKey.value;
	byte 0x626f784b6579 // "boxKey"
	box_get
	assert
	retsub

// foo(x: uint256): uint256
foo:
	proto 1 1

	// tests/contracts/math.algo.ts:92
	// return x;
	frame_dig -1 // x: uint256
	retsub

// unsafeMethodArgs(uint256,uint256)uint256
*abi_route_unsafeMethodArgs:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute unsafeMethodArgs(uint256,uint256)uint256
	callsub unsafeMethodArgs
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// unsafeMethodArgs(a: uint256, b: uint256): uint256
unsafeMethodArgs:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:96
	// c = a + b
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b+
	frame_bury 0 // c: unsafe uint256

	// tests/contracts/math.algo.ts:98
	// return this.foo(c);
	frame_dig 0 // c: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub foo

	// set the subroutine return value
	frame_bury 0
	retsub

// uint256ComparisonType(uint256,uint256)void
*abi_route_uint256ComparisonType:
	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute uint256ComparisonType(uint256,uint256)void
	callsub uint256ComparisonType
	int 1
	return

// uint256ComparisonType(a: uint256, b: uint256): void
uint256ComparisonType:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:102
	// senderBalanceAfter = a - b
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b-
	frame_bury 0 // senderBalanceAfter: unsafe uint256

	// *if0_condition
	// tests/contracts/math.algo.ts:103
	// senderBalanceAfter > <uint256>0
	frame_dig 0 // senderBalanceAfter: unsafe uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if0_else

	// *if0_consequent
	// tests/contracts/math.algo.ts:104
	// log('nonZero')
	byte 0x6e6f6e5a65726f // "nonZero"
	log
	b *if0_end

*if0_else:
	// tests/contracts/math.algo.ts:106
	// log('zero')
	byte 0x7a65726f // "zero"
	log

*if0_end:
	retsub

// squareRoot256(uint256,uint256)uint256
*abi_route_squareRoot256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute squareRoot256(uint256,uint256)uint256
	callsub squareRoot256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// squareRoot256(a: uint256, b: uint256): uint256
squareRoot256:
	proto 2 1

	// tests/contracts/math.algo.ts:111
	// return sqrt(a * b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b*
	bsqrt
	retsub

// squareRoot64(uint64,uint64)uint64
*abi_route_squareRoot64:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute squareRoot64(uint64,uint64)uint64
	callsub squareRoot64
	itob
	concat
	log
	int 1
	return

// squareRoot64(a: uint64, b: uint64): uint64
squareRoot64:
	proto 2 1

	// tests/contracts/math.algo.ts:115
	// return sqrt(a * b);
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	*
	sqrt
	retsub

// addressToBigInt(address)bool
*abi_route_addressToBigInt:
	// The ABI return prefix
	byte 0x151f7c75

	// addr: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute addressToBigInt(address)bool
	callsub addressToBigInt
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// addressToBigInt(addr: Address): boolean
addressToBigInt:
	proto 1 1

	// tests/contracts/math.algo.ts:119
	// return btobigint(addr) > btobigint(this.txn.sender);
	frame_dig -1 // addr: Address
	txn Sender
	b>
	retsub

// u8Tou64()uint64
*abi_route_u8Tou64:
	// The ABI return prefix
	byte 0x151f7c75

	// execute u8Tou64()uint64
	callsub u8Tou64
	itob
	concat
	log
	int 1
	return

// u8Tou64(): uint64
u8Tou64:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:123
	// x: uint8 = 7
	int 7
	frame_bury 0 // x: uint8

	// tests/contracts/math.algo.ts:124
	// return <uint64>x;
	frame_dig 0 // x: uint8

	// set the subroutine return value
	frame_bury 0
	retsub

// privateFuncName(x: uint8, y: uint64): void
privateFuncName:
	proto 2 0

	// tests/contracts/math.algo.ts:128
	// assert(<uint8>y > x)
	frame_dig -2 // y: uint64
	frame_dig -1 // x: uint8
	>
	assert
	retsub

// funcName(uint256)void
*abi_route_funcName:
	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute funcName(uint256)void
	callsub funcName
	int 1
	return

// funcName(x: uint256): void
funcName:
	proto 1 0

	// tests/contracts/math.algo.ts:132
	// this.privateFuncName(<uint8>x, 1337)
	int 1337
	frame_dig -1 // x: uint256
	dup
	bitlen
	int 8
	<=
	assert
	extract 31 1
	btoi
	callsub privateFuncName
	retsub

// bigintPlus(uint64,uint64)uint64
*abi_route_bigintPlus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bigintPlus(uint64,uint64)uint64
	callsub bigintPlus
	itob
	concat
	log
	int 1
	return

// bigintPlus(a: uint64, b: uint64): uint64
bigintPlus:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// tests/contracts/math.algo.ts:136
	// x = itob(a)
	frame_dig -1 // a: uint64
	itob
	frame_bury 0 // x: byte[]

	// tests/contracts/math.algo.ts:137
	// y = itob(b)
	frame_dig -2 // b: uint64
	itob
	frame_bury 1 // y: byte[]

	// tests/contracts/math.algo.ts:138
	// return (btobigint(x) + btobigint(y)) as uint64;
	frame_dig 0 // x: byte[]
	frame_dig 1 // y: byte[]
	b+
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// bitwiseOr(uint64,uint64)uint64
*abi_route_bitwiseOr:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitwiseOr(uint64,uint64)uint64
	callsub bitwiseOr
	itob
	concat
	log
	int 1
	return

// bitwiseOr(a: uint64, b: uint64): uint64
bitwiseOr:
	proto 2 1

	// tests/contracts/math.algo.ts:142
	// return a | b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	|
	retsub

// bitwiseAnd(uint64,uint64)uint64
*abi_route_bitwiseAnd:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitwiseAnd(uint64,uint64)uint64
	callsub bitwiseAnd
	itob
	concat
	log
	int 1
	return

// bitwiseAnd(a: uint64, b: uint64): uint64
bitwiseAnd:
	proto 2 1

	// tests/contracts/math.algo.ts:146
	// return a & b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	&
	retsub

// bitwiseXor(uint64,uint64)uint64
*abi_route_bitwiseXor:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitwiseXor(uint64,uint64)uint64
	callsub bitwiseXor
	itob
	concat
	log
	int 1
	return

// bitwiseXor(a: uint64, b: uint64): uint64
bitwiseXor:
	proto 2 1

	// tests/contracts/math.algo.ts:150
	// return a ^ b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	^
	retsub

// bitwiseOrU256(uint256,uint256)uint256
*abi_route_bitwiseOrU256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute bitwiseOrU256(uint256,uint256)uint256
	callsub bitwiseOrU256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// bitwiseOrU256(a: uint256, b: uint256): uint256
bitwiseOrU256:
	proto 2 1

	// tests/contracts/math.algo.ts:154
	// return a | b;
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b|
	retsub

// bitwiseAndU256(uint256,uint256)uint256
*abi_route_bitwiseAndU256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute bitwiseAndU256(uint256,uint256)uint256
	callsub bitwiseAndU256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// bitwiseAndU256(a: uint256, b: uint256): uint256
bitwiseAndU256:
	proto 2 1

	// tests/contracts/math.algo.ts:158
	// return a & b;
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b&
	retsub

// bitwiseXorU256(uint256,uint256)uint256
*abi_route_bitwiseXorU256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute bitwiseXorU256(uint256,uint256)uint256
	callsub bitwiseXorU256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// bitwiseXorU256(a: uint256, b: uint256): uint256
bitwiseXorU256:
	proto 2 1

	// tests/contracts/math.algo.ts:162
	// return a ^ b;
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b^
	retsub

// bitwiseNot(uint64)uint64
*abi_route_bitwiseNot:
	// The ABI return prefix
	byte 0x151f7c75

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitwiseNot(uint64)uint64
	callsub bitwiseNot
	itob
	concat
	log
	int 1
	return

// bitwiseNot(a: uint64): uint64
bitwiseNot:
	proto 1 1

	// tests/contracts/math.algo.ts:166
	// return ~a;
	frame_dig -1 // a: uint64
	~
	retsub

// bitwiseNotU256(uint256)uint256
*abi_route_bitwiseNotU256:
	// The ABI return prefix
	byte 0x151f7c75

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute bitwiseNotU256(uint256)uint256
	callsub bitwiseNotU256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// bitwiseNotU256(a: uint256): uint256
bitwiseNotU256:
	proto 1 1

	// tests/contracts/math.algo.ts:170
	// return ~a;
	frame_dig -1 // a: uint256
	b~
	retsub

// mulw(uint64,uint64)uint64
*abi_route_mulw:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute mulw(uint64,uint64)uint64
	callsub mulw
	itob
	concat
	log
	int 1
	return

// mulw(a: uint64, b: uint64): uint64
mulw:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// tests/contracts/math.algo.ts:174
	// p = mulw(a, b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	mulw
	frame_bury 2 // p low: uint64
	frame_bury 3 // p high: uint64

	// tests/contracts/math.algo.ts:178
	// return p2.low;
	frame_dig 2 // p low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// addw(uint64,uint64)uint64
*abi_route_addw:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute addw(uint64,uint64)uint64
	callsub addw
	itob
	concat
	log
	int 1
	return

// addw(a: uint64, b: uint64): uint64
addw:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// tests/contracts/math.algo.ts:182
	// p = addw(a, b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	addw
	frame_bury 2 // p low: uint64
	frame_bury 3 // p high: uint64

	// tests/contracts/math.algo.ts:186
	// return p2.low;
	frame_dig 2 // p low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// expw(uint64,uint64)uint64
*abi_route_expw:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute expw(uint64,uint64)uint64
	callsub expw
	itob
	concat
	log
	int 1
	return

// expw(a: uint64, b: uint64): uint64
expw:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// tests/contracts/math.algo.ts:190
	// p = expw(a, b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	expw
	frame_bury 2 // p low: uint64
	frame_bury 3 // p high: uint64

	// tests/contracts/math.algo.ts:194
	// return p2.low;
	frame_dig 2 // p low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// divw(uint64,uint64)uint64
*abi_route_divw:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute divw(uint64,uint64)uint64
	callsub divw
	itob
	concat
	log
	int 1
	return

// divw(a: uint64, b: uint64): uint64
divw:
	proto 2 1

	// tests/contracts/math.algo.ts:198
	// return divw(0, a, b);
	int 0
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	divw
	retsub

// divmodw(uint64,uint64)uint64
*abi_route_divmodw:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute divmodw(uint64,uint64)uint64
	callsub divmodw
	itob
	concat
	log
	int 1
	return

// divmodw(a: uint64, b: uint64): uint64
divmodw:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// tests/contracts/math.algo.ts:202
	// p = divmodw(0, a, 0, b)
	int 0
	frame_dig -1 // a: uint64
	int 0
	frame_dig -2 // b: uint64
	divmodw
	frame_bury 4 // p remainderLow: uint64
	frame_bury 5 // p remainderHigh: uint64
	frame_bury 6 // p quotientLow: uint64
	frame_bury 7 // p quotientHigh: uint64

	// tests/contracts/math.algo.ts:206
	// return p2.quotientLow;
	frame_dig 6 // p quotientLow: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// unsafeVariables()uint64
*abi_route_unsafeVariables:
	// The ABI return prefix
	byte 0x151f7c75

	// execute unsafeVariables()uint64
	callsub unsafeVariables
	itob
	concat
	log
	int 1
	return

// unsafeVariables(): uint64
unsafeVariables:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// tests/contracts/math.algo.ts:210
	// A = <uint256>250000000
	byte 0x000000000000000000000000000000000000000000000000000000000ee6b280
	frame_bury 0 // A: unsafe uint256

	// tests/contracts/math.algo.ts:211
	// B = <uint256>1000
	byte 0x00000000000000000000000000000000000000000000000000000000000003e8
	frame_bury 1 // B: uint256

	// tests/contracts/math.algo.ts:213
	// A = A / B
	frame_dig 0 // A: unsafe uint256
	byte 0x00000000000000000000000000000000000000000000000000000000000003e8 // B: uint256
	b/
	frame_bury 0 // A: unsafe uint256

	// tests/contracts/math.algo.ts:215
	// c = A as uint64
	frame_dig 0 // A: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 2 // c: uint64

	// tests/contracts/math.algo.ts:217
	// return c;
	frame_dig 2 // c: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// foobar(uint128)uint128
*abi_route_foobar:
	// The ABI return prefix
	byte 0x151f7c75

	// x: uint128
	txna ApplicationArgs 1
	dup
	len
	int 16
	==
	assert

	// execute foobar(uint128)uint128
	callsub foobar
	dup
	bitlen
	int 128
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	concat
	log
	int 1
	return

// foobar(x: uint128): uint128
foobar:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:221
	// avgStake: uint128 = x / (30000 as uint128)
	frame_dig -1 // x: uint128
	byte 0x00000000000000000000000000007530
	b/
	dup
	bitlen
	int 128
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	frame_bury 0 // avgStake: uint128

	// tests/contracts/math.algo.ts:223
	// return avgStake;
	frame_dig 0 // avgStake: uint128

	// set the subroutine return value
	frame_bury 0
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication
	err

*call_NoOp:
	method "u64plus(uint64,uint64)uint64"
	method "u64minus(uint64,uint64)uint64"
	method "u64mul(uint64,uint64)uint64"
	method "u64div(uint64,uint64)uint64"
	method "u256plus(uint256,uint256)uint256"
	method "u256minus(uint256,uint256)uint256"
	method "u256mul(uint256,uint256)uint256"
	method "u256div(uint256,uint256)uint256"
	method "u64Return256(uint64,uint64)uint256"
	method "maxU64()uint64"
	method "exponent(uint64,uint64)uint64"
	method "variableTypeHint(uint8,uint8)uint16"
	method "uint8plus(uint8,uint8)uint8"
	method "uint8exp(uint8,uint8)uint8"
	method "plusEquals(uint64,uint64)uint64"
	method "plusEqualsFromGlobal(uint64,uint64)uint64"
	method "boxTest()uint256"
	method "unsafeMethodArgs(uint256,uint256)uint256"
	method "uint256ComparisonType(uint256,uint256)void"
	method "squareRoot256(uint256,uint256)uint256"
	method "squareRoot64(uint64,uint64)uint64"
	method "addressToBigInt(address)bool"
	method "u8Tou64()uint64"
	method "funcName(uint256)void"
	method "bigintPlus(uint64,uint64)uint64"
	method "bitwiseOr(uint64,uint64)uint64"
	method "bitwiseAnd(uint64,uint64)uint64"
	method "bitwiseXor(uint64,uint64)uint64"
	method "bitwiseOrU256(uint256,uint256)uint256"
	method "bitwiseAndU256(uint256,uint256)uint256"
	method "bitwiseXorU256(uint256,uint256)uint256"
	method "bitwiseNot(uint64)uint64"
	method "bitwiseNotU256(uint256)uint256"
	method "mulw(uint64,uint64)uint64"
	method "addw(uint64,uint64)uint64"
	method "expw(uint64,uint64)uint64"
	method "divw(uint64,uint64)uint64"
	method "divmodw(uint64,uint64)uint64"
	method "unsafeVariables()uint64"
	method "foobar(uint128)uint128"
	txna ApplicationArgs 0
	match *abi_route_u64plus *abi_route_u64minus *abi_route_u64mul *abi_route_u64div *abi_route_u256plus *abi_route_u256minus *abi_route_u256mul *abi_route_u256div *abi_route_u64Return256 *abi_route_maxU64 *abi_route_exponent *abi_route_variableTypeHint *abi_route_uint8plus *abi_route_uint8exp *abi_route_plusEquals *abi_route_plusEqualsFromGlobal *abi_route_boxTest *abi_route_unsafeMethodArgs *abi_route_uint256ComparisonType *abi_route_squareRoot256 *abi_route_squareRoot64 *abi_route_addressToBigInt *abi_route_u8Tou64 *abi_route_funcName *abi_route_bigintPlus *abi_route_bitwiseOr *abi_route_bitwiseAnd *abi_route_bitwiseXor *abi_route_bitwiseOrU256 *abi_route_bitwiseAndU256 *abi_route_bitwiseXorU256 *abi_route_bitwiseNot *abi_route_bitwiseNotU256 *abi_route_mulw *abi_route_addw *abi_route_expw *abi_route_divw *abi_route_divmodw *abi_route_unsafeVariables *abi_route_foobar
	err