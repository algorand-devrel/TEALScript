#pragma version 10

// This TEAL was generated by TEALScript v0.77.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// u64plus(uint64,uint64)uint64
abi_route_u64plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64plus(uint64,uint64)uint64
	callsub u64plus
	itob
	concat
	log
	int 1
	return

// u64plus(a: uint64, b: uint64): uint64
u64plus:
	proto 2 1

	// tests/contracts/math.algo.ts:8
	// return a + b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	retsub

// u64minus(uint64,uint64)uint64
abi_route_u64minus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64minus(uint64,uint64)uint64
	callsub u64minus
	itob
	concat
	log
	int 1
	return

// u64minus(a: uint64, b: uint64): uint64
u64minus:
	proto 2 1

	// tests/contracts/math.algo.ts:12
	// return a - b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	-
	retsub

// u64mul(uint64,uint64)uint64
abi_route_u64mul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64mul(uint64,uint64)uint64
	callsub u64mul
	itob
	concat
	log
	int 1
	return

// u64mul(a: uint64, b: uint64): uint64
u64mul:
	proto 2 1

	// tests/contracts/math.algo.ts:16
	// return a * b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	*
	retsub

// u64div(uint64,uint64)uint64
abi_route_u64div:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64div(uint64,uint64)uint64
	callsub u64div
	itob
	concat
	log
	int 1
	return

// u64div(a: uint64, b: uint64): uint64
u64div:
	proto 2 1

	// tests/contracts/math.algo.ts:20
	// return a / b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	/
	retsub

// u256plus(uint256,uint256)uint256
abi_route_u256plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256plus(uint256,uint256)uint256
	callsub u256plus
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u256plus(a: uint256, b: uint256): uint256
u256plus:
	proto 2 1

	// tests/contracts/math.algo.ts:24
	// return <uint256>(a + b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b+
	retsub

// u256minus(uint256,uint256)uint256
abi_route_u256minus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256minus(uint256,uint256)uint256
	callsub u256minus
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u256minus(a: uint256, b: uint256): uint256
u256minus:
	proto 2 1

	// tests/contracts/math.algo.ts:28
	// return <uint256>(a - b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b-
	retsub

// u256mul(uint256,uint256)uint256
abi_route_u256mul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256mul(uint256,uint256)uint256
	callsub u256mul
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u256mul(a: uint256, b: uint256): uint256
u256mul:
	proto 2 1

	// tests/contracts/math.algo.ts:32
	// return <uint256>(a * b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b*
	retsub

// u256div(uint256,uint256)uint256
abi_route_u256div:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256div(uint256,uint256)uint256
	callsub u256div
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u256div(a: uint256, b: uint256): uint256
u256div:
	proto 2 1

	// tests/contracts/math.algo.ts:36
	// return <uint256>(a / b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b/
	retsub

// u64Return256(uint64,uint64)uint256
abi_route_u64Return256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64Return256(uint64,uint64)uint256
	callsub u64Return256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u64Return256(a: uint64, b: uint64): uint256
u64Return256:
	proto 2 1

	// tests/contracts/math.algo.ts:40
	// return <uint256>(a + b);
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	itob
	retsub

// maxU64()uint64
abi_route_maxU64:
	// The ABI return prefix
	byte 0x151f7c75

	// execute maxU64()uint64
	callsub maxU64
	itob
	concat
	log
	int 1
	return

// maxU64(): uint64
maxU64:
	proto 0 1

	// tests/contracts/math.algo.ts:45
	// return 18_446_744_073_709_551_615;
	int 18_446_744_073_709_551_615
	retsub

// exponent(uint64,uint64)uint64
abi_route_exponent:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute exponent(uint64,uint64)uint64
	callsub exponent
	itob
	concat
	log
	int 1
	return

// exponent(a: uint64, b: uint64): uint64
exponent:
	proto 2 1

	// tests/contracts/math.algo.ts:49
	// return a ** b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	exp
	retsub

// variableTypeHint(uint8,uint8)uint16
abi_route_variableTypeHint:
	// The ABI return prefix
	byte 0x151f7c75

	// y: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// x: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert
	btoi

	// execute variableTypeHint(uint8,uint8)uint16
	callsub variableTypeHint
	itob
	dup
	bitlen
	int 16
	<=
	assert
	extract 6 2
	concat
	log
	int 1
	return

// variableTypeHint(x: uint<8>, y: uint<8>): uint16
variableTypeHint:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:53
	// z = <uint16>(x + y)
	frame_dig -1 // x: uint<8>
	frame_dig -2 // y: uint<8>
	+
	frame_bury 0 // z: unsafe uint16

	// tests/contracts/math.algo.ts:55
	// return z;
	frame_dig 0 // z: unsafe uint16

	// set the subroutine return value
	frame_bury 0
	retsub

// uint8plus(uint8,uint8)uint8
abi_route_uint8plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// a: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert
	btoi

	// execute uint8plus(uint8,uint8)uint8
	callsub uint8plus
	itob
	dup
	bitlen
	int 8
	<=
	assert
	extract 7 1
	concat
	log
	int 1
	return

// uint8plus(a: uint<8>, b: uint<8>): uint<8>
uint8plus:
	proto 2 1

	// tests/contracts/math.algo.ts:59
	// return a + b;
	frame_dig -1 // a: uint<8>
	frame_dig -2 // b: uint<8>
	+
	retsub

// uint8exp(uint8,uint8)uint8
abi_route_uint8exp:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// a: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert
	btoi

	// execute uint8exp(uint8,uint8)uint8
	callsub uint8exp
	itob
	dup
	bitlen
	int 8
	<=
	assert
	extract 7 1
	concat
	log
	int 1
	return

// uint8exp(a: uint<8>, b: uint<8>): uint<8>
uint8exp:
	proto 2 1

	// tests/contracts/math.algo.ts:63
	// return a ** b;
	frame_dig -1 // a: uint<8>
	frame_dig -2 // b: uint<8>
	exp
	retsub

// plusEquals(uint64,uint64)uint64
abi_route_plusEquals:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute plusEquals(uint64,uint64)uint64
	callsub plusEquals
	itob
	concat
	log
	int 1
	return

// plusEquals(a: number, b: number): number
plusEquals:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:67
	// x = a
	frame_dig -1 // a: number
	frame_bury 0 // x: uint64

	// tests/contracts/math.algo.ts:69
	// x += b
	frame_dig 0 // x: uint64
	frame_dig -2 // b: number
	+
	frame_bury 0 // x: uint64

	// tests/contracts/math.algo.ts:71
	// return x;
	frame_dig 0 // x: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// plusEqualsFromGlobal(uint64,uint64)uint64
abi_route_plusEqualsFromGlobal:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute plusEqualsFromGlobal(uint64,uint64)uint64
	callsub plusEqualsFromGlobal
	itob
	concat
	log
	int 1
	return

// plusEqualsFromGlobal(a: number, b: number): number
plusEqualsFromGlobal:
	proto 2 1

	// tests/contracts/math.algo.ts:75
	// this.gKey.value = a
	byte 0x674b6579 // "gKey"
	frame_dig -1 // a: number
	app_global_put

	// tests/contracts/math.algo.ts:77
	// this.gKey.value += b
	byte 0x674b6579 // "gKey"
	app_global_get
	frame_dig -2 // b: number
	+
	byte 0x674b6579 // "gKey"
	swap
	app_global_put

	// tests/contracts/math.algo.ts:79
	// return this.gKey.value;
	byte 0x674b6579 // "gKey"
	app_global_get
	retsub

// ufixedLiteralMul()ufixed64x2
abi_route_ufixedLiteralMul:
	// The ABI return prefix
	byte 0x151f7c75

	// execute ufixedLiteralMul()ufixed64x2
	callsub ufixedLiteralMul
	itob
	extract 0 8
	concat
	log
	int 1
	return

// ufixedLiteralMul(): ufixed<64, 2>
ufixedLiteralMul:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// tests/contracts/math.algo.ts:83
	// a: ufixed<64, 2> = 12.34
	int 1234
	frame_bury 0 // a: ufixed<64, 2>

	// tests/contracts/math.algo.ts:84
	// b: ufixed<64, 2> = 12.34
	int 1234
	frame_bury 1 // b: ufixed<64, 2>

	// tests/contracts/math.algo.ts:85
	// c = a * b
	frame_dig 0 // a: ufixed<64, 2>
	int 1234 // b: ufixed<64, 2>
	*
	int 100
	/
	frame_bury 2 // c: ufixed64x2

	// tests/contracts/math.algo.ts:87
	// return c;
	frame_dig 2 // c: ufixed64x2

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// ufixedMul(ufixed64x2,ufixed64x2)ufixed64x2
abi_route_ufixedMul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: ufixed64x2
	txna ApplicationArgs 2
	dup
	len
	int 8
	==
	assert
	btoi

	// a: ufixed64x2
	txna ApplicationArgs 1
	dup
	len
	int 8
	==
	assert
	btoi

	// execute ufixedMul(ufixed64x2,ufixed64x2)ufixed64x2
	callsub ufixedMul
	itob
	extract 0 8
	concat
	log
	int 1
	return

// ufixedMul(a: ufixed<64, 2>, b: ufixed<64, 2>): ufixed<64, 2>
ufixedMul:
	proto 2 1

	// tests/contracts/math.algo.ts:91
	// return a * b;
	frame_dig -1 // a: ufixed<64, 2>
	frame_dig -2 // b: ufixed<64, 2>
	*
	int 100
	/
	retsub

// BigUfixedMul(ufixed128x2,ufixed128x2)ufixed128x2
abi_route_BigUfixedMul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: ufixed128x2
	txna ApplicationArgs 2
	dup
	len
	int 16
	==
	assert

	// a: ufixed128x2
	txna ApplicationArgs 1
	dup
	len
	int 16
	==
	assert

	// execute BigUfixedMul(ufixed128x2,ufixed128x2)ufixed128x2
	callsub BigUfixedMul
	dup
	bitlen
	int 128
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	concat
	log
	int 1
	return

// BigUfixedMul(a: ufixed<128, 2>, b: ufixed<128, 2>): ufixed<128, 2>
BigUfixedMul:
	proto 2 1

	// tests/contracts/math.algo.ts:95
	// return a * b;
	frame_dig -1 // a: ufixed<128, 2>
	frame_dig -2 // b: ufixed<128, 2>
	b*
	byte 0x64
	b/
	retsub

// TripleBigUfixedMul(ufixed128x2,ufixed128x2,ufixed128x2)ufixed128x2
abi_route_TripleBigUfixedMul:
	// The ABI return prefix
	byte 0x151f7c75

	// c: ufixed128x2
	txna ApplicationArgs 3
	dup
	len
	int 16
	==
	assert

	// b: ufixed128x2
	txna ApplicationArgs 2
	dup
	len
	int 16
	==
	assert

	// a: ufixed128x2
	txna ApplicationArgs 1
	dup
	len
	int 16
	==
	assert

	// execute TripleBigUfixedMul(ufixed128x2,ufixed128x2,ufixed128x2)ufixed128x2
	callsub TripleBigUfixedMul
	dup
	bitlen
	int 128
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	concat
	log
	int 1
	return

// TripleBigUfixedMul(a: ufixed<128, 2>, b: ufixed<128, 2>, c: ufixed<128, 2>): ufixed<128, 2>
TripleBigUfixedMul:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// tests/contracts/math.algo.ts:99
	// ab = a * b
	frame_dig -1 // a: ufixed<128, 2>
	frame_dig -2 // b: ufixed<128, 2>
	b*
	byte 0x64
	b/
	frame_bury 0 // ab: unsafe ufixed128x2

	// tests/contracts/math.algo.ts:100
	// abc = ab * c
	frame_dig 0 // ab: unsafe ufixed128x2
	frame_dig -3 // c: ufixed<128, 2>
	b*
	byte 0x64
	b/
	frame_bury 1 // abc: unsafe ufixed128x2

	// tests/contracts/math.algo.ts:101
	// return abc;
	frame_dig 1 // abc: unsafe ufixed128x2

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// boxTest()uint256
abi_route_boxTest:
	// The ABI return prefix
	byte 0x151f7c75

	// execute boxTest()uint256
	callsub boxTest
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// boxTest(): uint256
boxTest:
	proto 0 1

	// tests/contracts/math.algo.ts:107
	// this.boxKey.value = <uint256>1
	byte 0x626f784b6579 // "boxKey"
	byte 0x0000000000000000000000000000000000000000000000000000000000000001
	box_put

	// tests/contracts/math.algo.ts:108
	// this.boxKey.value += 1
	byte 0x626f784b6579 // "boxKey"
	box_get
	assert
	byte 0x0000000000000000000000000000000000000000000000000000000000000001
	b+
	byte 0x626f784b6579 // "boxKey"
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	swap
	box_put

	// tests/contracts/math.algo.ts:110
	// return this.boxKey.value;
	byte 0x626f784b6579 // "boxKey"
	box_get
	assert
	retsub

// foo(x: uint256): uint256
foo:
	proto 1 1

	// tests/contracts/math.algo.ts:114
	// return x;
	frame_dig -1 // x: uint256
	retsub

// unsafeMethodArgs(uint256,uint256)uint256
abi_route_unsafeMethodArgs:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute unsafeMethodArgs(uint256,uint256)uint256
	callsub unsafeMethodArgs
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// unsafeMethodArgs(a: uint256, b: uint256): uint256
unsafeMethodArgs:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:118
	// c = a + b
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b+
	frame_bury 0 // c: unsafe uint256

	// tests/contracts/math.algo.ts:120
	// return this.foo(c);
	frame_dig 0 // c: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub foo

	// set the subroutine return value
	frame_bury 0
	retsub

// uint256ComparisonType(uint256,uint256)void
abi_route_uint256ComparisonType:
	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute uint256ComparisonType(uint256,uint256)void
	callsub uint256ComparisonType
	int 1
	return

// uint256ComparisonType(a: uint256, b: uint256): void
uint256ComparisonType:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:124
	// senderBalanceAfter = a - b
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b-
	frame_bury 0 // senderBalanceAfter: unsafe uint256

	// if0_condition
	// tests/contracts/math.algo.ts:125
	// senderBalanceAfter > <uint256>0
	frame_dig 0 // senderBalanceAfter: unsafe uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz if0_else

	// if0_consequent
	// tests/contracts/math.algo.ts:126
	// log('nonZero')
	byte 0x6e6f6e5a65726f // "nonZero"
	log
	b if0_end

if0_else:
	// tests/contracts/math.algo.ts:128
	// log('zero')
	byte 0x7a65726f // "zero"
	log

if0_end:
	retsub

// squareRoot256(uint256,uint256)uint256
abi_route_squareRoot256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute squareRoot256(uint256,uint256)uint256
	callsub squareRoot256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// squareRoot256(a: uint256, b: uint256): uint256
squareRoot256:
	proto 2 1

	// tests/contracts/math.algo.ts:133
	// return sqrt(a * b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b*
	bsqrt
	retsub

// squareRoot64(uint64,uint64)uint64
abi_route_squareRoot64:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute squareRoot64(uint64,uint64)uint64
	callsub squareRoot64
	itob
	concat
	log
	int 1
	return

// squareRoot64(a: uint64, b: uint64): uint64
squareRoot64:
	proto 2 1

	// tests/contracts/math.algo.ts:137
	// return sqrt(a * b);
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	*
	sqrt
	retsub

// addressToBigInt(address)bool
abi_route_addressToBigInt:
	// The ABI return prefix
	byte 0x151f7c75

	// addr: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute addressToBigInt(address)bool
	callsub addressToBigInt
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// addressToBigInt(addr: Address): boolean
addressToBigInt:
	proto 1 1

	// tests/contracts/math.algo.ts:141
	// return btobigint(addr) > btobigint(this.txn.sender);
	frame_dig -1 // addr: Address
	txn Sender
	b>
	retsub

// u8Tou64()uint64
abi_route_u8Tou64:
	// The ABI return prefix
	byte 0x151f7c75

	// execute u8Tou64()uint64
	callsub u8Tou64
	itob
	concat
	log
	int 1
	return

// u8Tou64(): uint64
u8Tou64:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:145
	// x: uint8 = 7
	int 7
	frame_bury 0 // x: uint8

	// tests/contracts/math.algo.ts:146
	// return <uint64>x;
	frame_dig 0 // x: uint8

	// set the subroutine return value
	frame_bury 0
	retsub

// privateFuncName(x: uint8, y: uint64): void
privateFuncName:
	proto 2 0

	// tests/contracts/math.algo.ts:150
	// assert(<uint8>y > x)
	frame_dig -2 // y: uint64
	frame_dig -1 // x: uint8
	>
	assert
	retsub

// funcName(uint256)void
abi_route_funcName:
	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute funcName(uint256)void
	callsub funcName
	int 1
	return

// funcName(x: uint256): void
funcName:
	proto 1 0

	// tests/contracts/math.algo.ts:154
	// this.privateFuncName(<uint8>x, 1337)
	int 1337
	frame_dig -1 // x: uint256
	dup
	bitlen
	int 8
	<=
	assert
	extract 31 1
	btoi
	callsub privateFuncName
	retsub

// bigintPlus(uint64,uint64)uint64
abi_route_bigintPlus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bigintPlus(uint64,uint64)uint64
	callsub bigintPlus
	itob
	concat
	log
	int 1
	return

// bigintPlus(a: uint64, b: uint64): uint64
bigintPlus:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// tests/contracts/math.algo.ts:158
	// x = itob(a)
	frame_dig -1 // a: uint64
	itob
	frame_bury 0 // x: byte[]

	// tests/contracts/math.algo.ts:159
	// y = itob(b)
	frame_dig -2 // b: uint64
	itob
	frame_bury 1 // y: byte[]

	// tests/contracts/math.algo.ts:160
	// return (btobigint(x) + btobigint(y)) as uint64;
	frame_dig 0 // x: byte[]
	frame_dig 1 // y: byte[]
	b+
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// bitwiseOr(uint64,uint64)uint64
abi_route_bitwiseOr:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitwiseOr(uint64,uint64)uint64
	callsub bitwiseOr
	itob
	concat
	log
	int 1
	return

// bitwiseOr(a: uint64, b: uint64): uint64
bitwiseOr:
	proto 2 1

	// tests/contracts/math.algo.ts:164
	// return a | b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	|
	retsub

// bitwiseAnd(uint64,uint64)uint64
abi_route_bitwiseAnd:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitwiseAnd(uint64,uint64)uint64
	callsub bitwiseAnd
	itob
	concat
	log
	int 1
	return

// bitwiseAnd(a: uint64, b: uint64): uint64
bitwiseAnd:
	proto 2 1

	// tests/contracts/math.algo.ts:168
	// return a & b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	&
	retsub

// bitwiseXor(uint64,uint64)uint64
abi_route_bitwiseXor:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitwiseXor(uint64,uint64)uint64
	callsub bitwiseXor
	itob
	concat
	log
	int 1
	return

// bitwiseXor(a: uint64, b: uint64): uint64
bitwiseXor:
	proto 2 1

	// tests/contracts/math.algo.ts:172
	// return a ^ b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	^
	retsub

// bitwiseOrU256(uint256,uint256)uint256
abi_route_bitwiseOrU256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute bitwiseOrU256(uint256,uint256)uint256
	callsub bitwiseOrU256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// bitwiseOrU256(a: uint256, b: uint256): uint256
bitwiseOrU256:
	proto 2 1

	// tests/contracts/math.algo.ts:176
	// return a | b;
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b|
	retsub

// bitwiseAndU256(uint256,uint256)uint256
abi_route_bitwiseAndU256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute bitwiseAndU256(uint256,uint256)uint256
	callsub bitwiseAndU256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// bitwiseAndU256(a: uint256, b: uint256): uint256
bitwiseAndU256:
	proto 2 1

	// tests/contracts/math.algo.ts:180
	// return a & b;
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b&
	retsub

// bitwiseXorU256(uint256,uint256)uint256
abi_route_bitwiseXorU256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute bitwiseXorU256(uint256,uint256)uint256
	callsub bitwiseXorU256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// bitwiseXorU256(a: uint256, b: uint256): uint256
bitwiseXorU256:
	proto 2 1

	// tests/contracts/math.algo.ts:184
	// return a ^ b;
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b^
	retsub

// bitwiseNot(uint64)uint64
abi_route_bitwiseNot:
	// The ABI return prefix
	byte 0x151f7c75

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitwiseNot(uint64)uint64
	callsub bitwiseNot
	itob
	concat
	log
	int 1
	return

// bitwiseNot(a: uint64): uint64
bitwiseNot:
	proto 1 1

	// tests/contracts/math.algo.ts:188
	// return ~a;
	frame_dig -1 // a: uint64
	~
	retsub

// bitwiseNotU256(uint256)uint256
abi_route_bitwiseNotU256:
	// The ABI return prefix
	byte 0x151f7c75

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute bitwiseNotU256(uint256)uint256
	callsub bitwiseNotU256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// bitwiseNotU256(a: uint256): uint256
bitwiseNotU256:
	proto 1 1

	// tests/contracts/math.algo.ts:192
	// return ~a;
	frame_dig -1 // a: uint256
	b~
	retsub

// mulw(uint64,uint64)uint64
abi_route_mulw:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute mulw(uint64,uint64)uint64
	callsub mulw
	itob
	concat
	log
	int 1
	return

// mulw(a: uint64, b: uint64): uint64
mulw:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// tests/contracts/math.algo.ts:196
	// p = mulw(a, b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	mulw
	frame_bury 2 // p low: uint64
	frame_bury 3 // p high: uint64

	// tests/contracts/math.algo.ts:200
	// return p2.low;
	frame_dig 2 // p low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// addw(uint64,uint64)uint64
abi_route_addw:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute addw(uint64,uint64)uint64
	callsub addw
	itob
	concat
	log
	int 1
	return

// addw(a: uint64, b: uint64): uint64
addw:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// tests/contracts/math.algo.ts:204
	// p = addw(a, b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	addw
	frame_bury 2 // p low: uint64
	frame_bury 3 // p high: uint64

	// tests/contracts/math.algo.ts:208
	// return p2.low;
	frame_dig 2 // p low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// expw(uint64,uint64)uint64
abi_route_expw:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute expw(uint64,uint64)uint64
	callsub expw
	itob
	concat
	log
	int 1
	return

// expw(a: uint64, b: uint64): uint64
expw:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// tests/contracts/math.algo.ts:212
	// p = expw(a, b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	expw
	frame_bury 2 // p low: uint64
	frame_bury 3 // p high: uint64

	// tests/contracts/math.algo.ts:216
	// return p2.low;
	frame_dig 2 // p low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// divw(uint64,uint64)uint64
abi_route_divw:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute divw(uint64,uint64)uint64
	callsub divw
	itob
	concat
	log
	int 1
	return

// divw(a: uint64, b: uint64): uint64
divw:
	proto 2 1

	// tests/contracts/math.algo.ts:220
	// return divw(0, a, b);
	int 0
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	divw
	retsub

// divmodw(uint64,uint64)uint64
abi_route_divmodw:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute divmodw(uint64,uint64)uint64
	callsub divmodw
	itob
	concat
	log
	int 1
	return

// divmodw(a: uint64, b: uint64): uint64
divmodw:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 8

	// tests/contracts/math.algo.ts:224
	// p = divmodw(0, a, 0, b)
	int 0
	frame_dig -1 // a: uint64
	int 0
	frame_dig -2 // b: uint64
	divmodw
	frame_bury 4 // p remainderLow: uint64
	frame_bury 5 // p remainderHigh: uint64
	frame_bury 6 // p quotientLow: uint64
	frame_bury 7 // p quotientHigh: uint64

	// tests/contracts/math.algo.ts:228
	// return p2.quotientLow;
	frame_dig 6 // p quotientLow: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

abi_route_createApplication:
	int 1
	return

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "u64plus(uint64,uint64)uint64"
	method "u64minus(uint64,uint64)uint64"
	method "u64mul(uint64,uint64)uint64"
	method "u64div(uint64,uint64)uint64"
	method "u256plus(uint256,uint256)uint256"
	method "u256minus(uint256,uint256)uint256"
	method "u256mul(uint256,uint256)uint256"
	method "u256div(uint256,uint256)uint256"
	method "u64Return256(uint64,uint64)uint256"
	method "maxU64()uint64"
	method "exponent(uint64,uint64)uint64"
	method "variableTypeHint(uint8,uint8)uint16"
	method "uint8plus(uint8,uint8)uint8"
	method "uint8exp(uint8,uint8)uint8"
	method "plusEquals(uint64,uint64)uint64"
	method "plusEqualsFromGlobal(uint64,uint64)uint64"
	method "ufixedLiteralMul()ufixed64x2"
	method "ufixedMul(ufixed64x2,ufixed64x2)ufixed64x2"
	method "BigUfixedMul(ufixed128x2,ufixed128x2)ufixed128x2"
	method "TripleBigUfixedMul(ufixed128x2,ufixed128x2,ufixed128x2)ufixed128x2"
	method "boxTest()uint256"
	method "unsafeMethodArgs(uint256,uint256)uint256"
	method "uint256ComparisonType(uint256,uint256)void"
	method "squareRoot256(uint256,uint256)uint256"
	method "squareRoot64(uint64,uint64)uint64"
	method "addressToBigInt(address)bool"
	method "u8Tou64()uint64"
	method "funcName(uint256)void"
	method "bigintPlus(uint64,uint64)uint64"
	method "bitwiseOr(uint64,uint64)uint64"
	method "bitwiseAnd(uint64,uint64)uint64"
	method "bitwiseXor(uint64,uint64)uint64"
	method "bitwiseOrU256(uint256,uint256)uint256"
	method "bitwiseAndU256(uint256,uint256)uint256"
	method "bitwiseXorU256(uint256,uint256)uint256"
	method "bitwiseNot(uint64)uint64"
	method "bitwiseNotU256(uint256)uint256"
	method "mulw(uint64,uint64)uint64"
	method "addw(uint64,uint64)uint64"
	method "expw(uint64,uint64)uint64"
	method "divw(uint64,uint64)uint64"
	method "divmodw(uint64,uint64)uint64"
	txna ApplicationArgs 0
	match abi_route_u64plus abi_route_u64minus abi_route_u64mul abi_route_u64div abi_route_u256plus abi_route_u256minus abi_route_u256mul abi_route_u256div abi_route_u64Return256 abi_route_maxU64 abi_route_exponent abi_route_variableTypeHint abi_route_uint8plus abi_route_uint8exp abi_route_plusEquals abi_route_plusEqualsFromGlobal abi_route_ufixedLiteralMul abi_route_ufixedMul abi_route_BigUfixedMul abi_route_TripleBigUfixedMul abi_route_boxTest abi_route_unsafeMethodArgs abi_route_uint256ComparisonType abi_route_squareRoot256 abi_route_squareRoot64 abi_route_addressToBigInt abi_route_u8Tou64 abi_route_funcName abi_route_bigintPlus abi_route_bitwiseOr abi_route_bitwiseAnd abi_route_bitwiseXor abi_route_bitwiseOrU256 abi_route_bitwiseAndU256 abi_route_bitwiseXorU256 abi_route_bitwiseNot abi_route_bitwiseNotU256 abi_route_mulw abi_route_addw abi_route_expw abi_route_divw abi_route_divmodw
	err