#pragma version 9

// This TEAL was generated by TEALScript v0.72.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

abi_route_u64plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64plus(uint64,uint64)uint64
	callsub u64plus
	itob
	concat
	log
	int 1
	return

// u64plus(uint64,uint64)uint64
u64plus:
	proto 2 1

	// tests/contracts/math.algo.ts:8
	// return a + b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	retsub

abi_route_u64minus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64minus(uint64,uint64)uint64
	callsub u64minus
	itob
	concat
	log
	int 1
	return

// u64minus(uint64,uint64)uint64
u64minus:
	proto 2 1

	// tests/contracts/math.algo.ts:12
	// return a - b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	-
	retsub

abi_route_u64mul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64mul(uint64,uint64)uint64
	callsub u64mul
	itob
	concat
	log
	int 1
	return

// u64mul(uint64,uint64)uint64
u64mul:
	proto 2 1

	// tests/contracts/math.algo.ts:16
	// return a * b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	*
	retsub

abi_route_u64div:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64div(uint64,uint64)uint64
	callsub u64div
	itob
	concat
	log
	int 1
	return

// u64div(uint64,uint64)uint64
u64div:
	proto 2 1

	// tests/contracts/math.algo.ts:20
	// return a / b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	/
	retsub

abi_route_u256plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256plus(uint256,uint256)uint256
	callsub u256plus
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u256plus(uint256,uint256)uint256
u256plus:
	proto 2 1

	// tests/contracts/math.algo.ts:24
	// return <uint256>(a + b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b+
	retsub

abi_route_u256minus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256minus(uint256,uint256)uint256
	callsub u256minus
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u256minus(uint256,uint256)uint256
u256minus:
	proto 2 1

	// tests/contracts/math.algo.ts:28
	// return <uint256>(a - b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b-
	retsub

abi_route_u256mul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256mul(uint256,uint256)uint256
	callsub u256mul
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u256mul(uint256,uint256)uint256
u256mul:
	proto 2 1

	// tests/contracts/math.algo.ts:32
	// return <uint256>(a * b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b*
	retsub

abi_route_u256div:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256div(uint256,uint256)uint256
	callsub u256div
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u256div(uint256,uint256)uint256
u256div:
	proto 2 1

	// tests/contracts/math.algo.ts:36
	// return <uint256>(a / b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b/
	retsub

abi_route_u64Return256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64Return256(uint64,uint64)uint256
	callsub u64Return256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// u64Return256(uint64,uint64)uint256
u64Return256:
	proto 2 1

	// tests/contracts/math.algo.ts:40
	// return <uint256>(a + b);
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	itob
	retsub

abi_route_maxU64:
	// The ABI return prefix
	byte 0x151f7c75

	// execute maxU64()uint64
	callsub maxU64
	itob
	concat
	log
	int 1
	return

// maxU64()uint64
maxU64:
	proto 0 1

	// tests/contracts/math.algo.ts:45
	// return 18_446_744_073_709_551_615;
	int 18_446_744_073_709_551_615
	retsub

abi_route_exponent:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute exponent(uint64,uint64)uint64
	callsub exponent
	itob
	concat
	log
	int 1
	return

// exponent(uint64,uint64)uint64
exponent:
	proto 2 1

	// tests/contracts/math.algo.ts:49
	// return a ** b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	exp
	retsub

abi_route_variableTypeHint:
	// The ABI return prefix
	byte 0x151f7c75

	// y: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// x: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert
	btoi

	// execute variableTypeHint(uint8,uint8)uint16
	callsub variableTypeHint
	itob
	dup
	bitlen
	int 16
	<=
	assert
	extract 6 2
	concat
	log
	int 1
	return

// variableTypeHint(uint8,uint8)uint16
variableTypeHint:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:53
	// z = <uint16>(x + y)
	frame_dig -1 // x: uint<8>
	frame_dig -2 // y: uint<8>
	+
	frame_bury 0 // z: unsafe uint16

	// tests/contracts/math.algo.ts:55
	// return z;
	frame_dig 0 // z: unsafe uint16

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_uint8plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// a: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert
	btoi

	// execute uint8plus(uint8,uint8)uint8
	callsub uint8plus
	itob
	dup
	bitlen
	int 8
	<=
	assert
	extract 7 1
	concat
	log
	int 1
	return

// uint8plus(uint8,uint8)uint8
uint8plus:
	proto 2 1

	// tests/contracts/math.algo.ts:59
	// return a + b;
	frame_dig -1 // a: uint<8>
	frame_dig -2 // b: uint<8>
	+
	retsub

abi_route_uint8exp:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// a: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert
	btoi

	// execute uint8exp(uint8,uint8)uint8
	callsub uint8exp
	itob
	dup
	bitlen
	int 8
	<=
	assert
	extract 7 1
	concat
	log
	int 1
	return

// uint8exp(uint8,uint8)uint8
uint8exp:
	proto 2 1

	// tests/contracts/math.algo.ts:63
	// return a ** b;
	frame_dig -1 // a: uint<8>
	frame_dig -2 // b: uint<8>
	exp
	retsub

abi_route_plusEquals:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute plusEquals(uint64,uint64)uint64
	callsub plusEquals
	itob
	concat
	log
	int 1
	return

// plusEquals(uint64,uint64)uint64
plusEquals:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:67
	// x = a
	frame_dig -1 // a: number
	frame_bury 0 // x: uint64

	// tests/contracts/math.algo.ts:69
	// x += b
	frame_dig 0 // x: uint64
	frame_dig -2 // b: number
	+
	frame_bury 0 // x: uint64

	// tests/contracts/math.algo.ts:71
	// return x;
	frame_dig 0 // x: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_plusEqualsFromGlobal:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute plusEqualsFromGlobal(uint64,uint64)uint64
	callsub plusEqualsFromGlobal
	itob
	concat
	log
	int 1
	return

// plusEqualsFromGlobal(uint64,uint64)uint64
plusEqualsFromGlobal:
	proto 2 1

	// tests/contracts/math.algo.ts:75
	// this.gKey.value = a
	byte 0x674b6579 // "gKey"
	frame_dig -1 // a: number
	app_global_put

	// tests/contracts/math.algo.ts:77
	// this.gKey.value += b
	byte 0x674b6579 // "gKey"
	app_global_get
	frame_dig -2 // b: number
	+
	byte 0x674b6579 // "gKey"
	swap
	app_global_put

	// tests/contracts/math.algo.ts:79
	// return this.gKey.value;
	byte 0x674b6579 // "gKey"
	app_global_get
	retsub

abi_route_ufixedLiteralMul:
	// The ABI return prefix
	byte 0x151f7c75

	// execute ufixedLiteralMul()ufixed64x2
	callsub ufixedLiteralMul
	itob
	extract 0 8
	concat
	log
	int 1
	return

// ufixedLiteralMul()ufixed64x2
ufixedLiteralMul:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// tests/contracts/math.algo.ts:83
	// a: ufixed<64, 2> = 12.34
	int 1234
	frame_bury 0 // a: ufixed<64, 2>

	// tests/contracts/math.algo.ts:84
	// b: ufixed<64, 2> = 12.34
	int 1234
	frame_bury 1 // b: ufixed<64, 2>

	// tests/contracts/math.algo.ts:85
	// c = a * b
	frame_dig 0 // a: ufixed<64, 2>
	int 1234 // b: ufixed<64, 2>
	*
	int 100
	/
	frame_bury 2 // c: ufixed64x2

	// tests/contracts/math.algo.ts:87
	// return c;
	frame_dig 2 // c: ufixed64x2

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

abi_route_ufixedMul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: ufixed64x2
	txna ApplicationArgs 2
	dup
	len
	int 8
	==
	assert
	btoi

	// a: ufixed64x2
	txna ApplicationArgs 1
	dup
	len
	int 8
	==
	assert
	btoi

	// execute ufixedMul(ufixed64x2,ufixed64x2)ufixed64x2
	callsub ufixedMul
	itob
	extract 0 8
	concat
	log
	int 1
	return

// ufixedMul(ufixed64x2,ufixed64x2)ufixed64x2
ufixedMul:
	proto 2 1

	// tests/contracts/math.algo.ts:91
	// return a * b;
	frame_dig -1 // a: ufixed<64, 2>
	frame_dig -2 // b: ufixed<64, 2>
	*
	int 100
	/
	retsub

abi_route_BigUfixedMul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: ufixed128x2
	txna ApplicationArgs 2
	dup
	len
	int 16
	==
	assert

	// a: ufixed128x2
	txna ApplicationArgs 1
	dup
	len
	int 16
	==
	assert

	// execute BigUfixedMul(ufixed128x2,ufixed128x2)ufixed128x2
	callsub BigUfixedMul
	dup
	bitlen
	int 128
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	concat
	log
	int 1
	return

// BigUfixedMul(ufixed128x2,ufixed128x2)ufixed128x2
BigUfixedMul:
	proto 2 1

	// tests/contracts/math.algo.ts:95
	// return a * b;
	frame_dig -1 // a: ufixed<128, 2>
	frame_dig -2 // b: ufixed<128, 2>
	b*
	byte 0x64
	b/
	retsub

abi_route_TripleBigUfixedMul:
	// The ABI return prefix
	byte 0x151f7c75

	// c: ufixed128x2
	txna ApplicationArgs 3
	dup
	len
	int 16
	==
	assert

	// b: ufixed128x2
	txna ApplicationArgs 2
	dup
	len
	int 16
	==
	assert

	// a: ufixed128x2
	txna ApplicationArgs 1
	dup
	len
	int 16
	==
	assert

	// execute TripleBigUfixedMul(ufixed128x2,ufixed128x2,ufixed128x2)ufixed128x2
	callsub TripleBigUfixedMul
	dup
	bitlen
	int 128
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	concat
	log
	int 1
	return

// TripleBigUfixedMul(ufixed128x2,ufixed128x2,ufixed128x2)ufixed128x2
TripleBigUfixedMul:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// tests/contracts/math.algo.ts:99
	// ab = a * b
	frame_dig -1 // a: ufixed<128, 2>
	frame_dig -2 // b: ufixed<128, 2>
	b*
	byte 0x64
	b/
	frame_bury 0 // ab: unsafe ufixed128x2

	// tests/contracts/math.algo.ts:100
	// abc = ab * c
	frame_dig 0 // ab: unsafe ufixed128x2
	frame_dig -3 // c: ufixed<128, 2>
	b*
	byte 0x64
	b/
	frame_bury 1 // abc: unsafe ufixed128x2

	// tests/contracts/math.algo.ts:101
	// return abc;
	frame_dig 1 // abc: unsafe ufixed128x2

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

abi_route_boxTest:
	// The ABI return prefix
	byte 0x151f7c75

	// execute boxTest()uint256
	callsub boxTest
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// boxTest()uint256
boxTest:
	proto 0 1

	// tests/contracts/math.algo.ts:107
	// this.boxKey.value = <uint256>1
	byte 0x626f784b6579 // "boxKey"
	byte 0x0000000000000000000000000000000000000000000000000000000000000001
	box_put

	// tests/contracts/math.algo.ts:108
	// this.boxKey.value += 1
	byte 0x626f784b6579 // "boxKey"
	box_get
	assert
	byte 0x0000000000000000000000000000000000000000000000000000000000000001
	b+
	byte 0x626f784b6579 // "boxKey"
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	swap
	box_put

	// tests/contracts/math.algo.ts:110
	// return this.boxKey.value;
	byte 0x626f784b6579 // "boxKey"
	box_get
	assert
	retsub

// foo(uint256)uint256
foo:
	proto 1 1

	// tests/contracts/math.algo.ts:114
	// return x;
	frame_dig -1 // x: uint256
	retsub

abi_route_unsafeMethodArgs:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute unsafeMethodArgs(uint256,uint256)uint256
	callsub unsafeMethodArgs
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// unsafeMethodArgs(uint256,uint256)uint256
unsafeMethodArgs:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:118
	// c = a + b
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b+
	frame_bury 0 // c: unsafe uint256

	// tests/contracts/math.algo.ts:120
	// return this.foo(c);
	frame_dig 0 // c: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	callsub foo

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_uint256ComparisonType:
	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute uint256ComparisonType(uint256,uint256)void
	callsub uint256ComparisonType
	int 1
	return

// uint256ComparisonType(uint256,uint256)void
uint256ComparisonType:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:124
	// senderBalanceAfter = a - b
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b-
	frame_bury 0 // senderBalanceAfter: unsafe uint256

	// if0_condition
	// tests/contracts/math.algo.ts:125
	// senderBalanceAfter > <uint256>0
	frame_dig 0 // senderBalanceAfter: unsafe uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz if0_else

	// if0_consequent
	// tests/contracts/math.algo.ts:126
	// log('nonZero')
	byte 0x6e6f6e5a65726f // "nonZero"
	log
	b if0_end

if0_else:
	// tests/contracts/math.algo.ts:128
	// log('zero')
	byte 0x7a65726f // "zero"
	log

if0_end:
	retsub

abi_route_squareRoot256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute squareRoot256(uint256,uint256)uint256
	callsub squareRoot256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// squareRoot256(uint256,uint256)uint256
squareRoot256:
	proto 2 1

	// tests/contracts/math.algo.ts:133
	// return sqrt(a * b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b*
	bsqrt
	retsub

abi_route_squareRoot64:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute squareRoot64(uint64,uint64)uint64
	callsub squareRoot64
	itob
	concat
	log
	int 1
	return

// squareRoot64(uint64,uint64)uint64
squareRoot64:
	proto 2 1

	// tests/contracts/math.algo.ts:137
	// return sqrt(a * b);
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	*
	sqrt
	retsub

abi_route_addressToBigInt:
	// The ABI return prefix
	byte 0x151f7c75

	// addr: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute addressToBigInt(address)bool
	callsub addressToBigInt
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// addressToBigInt(address)bool
addressToBigInt:
	proto 1 1

	// tests/contracts/math.algo.ts:141
	// return btobigint(addr) > btobigint(this.txn.sender);
	frame_dig -1 // addr: Address
	txn Sender
	b>
	retsub

abi_route_u8Tou64:
	// The ABI return prefix
	byte 0x151f7c75

	// execute u8Tou64()uint64
	callsub u8Tou64
	itob
	concat
	log
	int 1
	return

// u8Tou64()uint64
u8Tou64:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:145
	// x: uint8 = 7
	int 7
	frame_bury 0 // x: uint8

	// tests/contracts/math.algo.ts:146
	// return <uint64>x;
	frame_dig 0 // x: uint8

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_createApplication:
	int 1
	return

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "u64plus(uint64,uint64)uint64"
	method "u64minus(uint64,uint64)uint64"
	method "u64mul(uint64,uint64)uint64"
	method "u64div(uint64,uint64)uint64"
	method "u256plus(uint256,uint256)uint256"
	method "u256minus(uint256,uint256)uint256"
	method "u256mul(uint256,uint256)uint256"
	method "u256div(uint256,uint256)uint256"
	method "u64Return256(uint64,uint64)uint256"
	method "maxU64()uint64"
	method "exponent(uint64,uint64)uint64"
	method "variableTypeHint(uint8,uint8)uint16"
	method "uint8plus(uint8,uint8)uint8"
	method "uint8exp(uint8,uint8)uint8"
	method "plusEquals(uint64,uint64)uint64"
	method "plusEqualsFromGlobal(uint64,uint64)uint64"
	method "ufixedLiteralMul()ufixed64x2"
	method "ufixedMul(ufixed64x2,ufixed64x2)ufixed64x2"
	method "BigUfixedMul(ufixed128x2,ufixed128x2)ufixed128x2"
	method "TripleBigUfixedMul(ufixed128x2,ufixed128x2,ufixed128x2)ufixed128x2"
	method "boxTest()uint256"
	method "unsafeMethodArgs(uint256,uint256)uint256"
	method "uint256ComparisonType(uint256,uint256)void"
	method "squareRoot256(uint256,uint256)uint256"
	method "squareRoot64(uint64,uint64)uint64"
	method "addressToBigInt(address)bool"
	method "u8Tou64()uint64"
	txna ApplicationArgs 0
	match abi_route_u64plus abi_route_u64minus abi_route_u64mul abi_route_u64div abi_route_u256plus abi_route_u256minus abi_route_u256mul abi_route_u256div abi_route_u64Return256 abi_route_maxU64 abi_route_exponent abi_route_variableTypeHint abi_route_uint8plus abi_route_uint8exp abi_route_plusEquals abi_route_plusEqualsFromGlobal abi_route_ufixedLiteralMul abi_route_ufixedMul abi_route_BigUfixedMul abi_route_TripleBigUfixedMul abi_route_boxTest abi_route_unsafeMethodArgs abi_route_uint256ComparisonType abi_route_squareRoot256 abi_route_squareRoot64 abi_route_addressToBigInt abi_route_u8Tou64
	err