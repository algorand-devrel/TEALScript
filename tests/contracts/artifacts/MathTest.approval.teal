#pragma version 9

// This TEAL was generated by TEALScript v0.67.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

abi_route_u64plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64plus(uint64,uint64)uint64
	callsub u64plus
	itob
	concat
	log
	int 1
	return

// u64plus(uint64,uint64)uint64
u64plus:
	proto 2 1

	// tests/contracts/math.algo.ts:8
	// return a + b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	retsub

abi_route_u64minus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64minus(uint64,uint64)uint64
	callsub u64minus
	itob
	concat
	log
	int 1
	return

// u64minus(uint64,uint64)uint64
u64minus:
	proto 2 1

	// tests/contracts/math.algo.ts:12
	// return a - b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	-
	retsub

abi_route_u64mul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64mul(uint64,uint64)uint64
	callsub u64mul
	itob
	concat
	log
	int 1
	return

// u64mul(uint64,uint64)uint64
u64mul:
	proto 2 1

	// tests/contracts/math.algo.ts:16
	// return a * b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	*
	retsub

abi_route_u64div:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64div(uint64,uint64)uint64
	callsub u64div
	itob
	concat
	log
	int 1
	return

// u64div(uint64,uint64)uint64
u64div:
	proto 2 1

	// tests/contracts/math.algo.ts:20
	// return a / b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	/
	retsub

abi_route_u256plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256plus(uint256,uint256)uint256
	callsub u256plus
	concat
	log
	int 1
	return

// u256plus(uint256,uint256)uint256
u256plus:
	proto 2 1

	// tests/contracts/math.algo.ts:24
	// return <uint<256>>(a + b);
	frame_dig -1 // a: uint<256>
	frame_dig -2 // b: uint<256>
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	retsub

abi_route_u256minus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256minus(uint256,uint256)uint256
	callsub u256minus
	concat
	log
	int 1
	return

// u256minus(uint256,uint256)uint256
u256minus:
	proto 2 1

	// tests/contracts/math.algo.ts:28
	// return <uint<256>>(a - b);
	frame_dig -1 // a: uint<256>
	frame_dig -2 // b: uint<256>
	b-
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	retsub

abi_route_u256mul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256mul(uint256,uint256)uint256
	callsub u256mul
	concat
	log
	int 1
	return

// u256mul(uint256,uint256)uint256
u256mul:
	proto 2 1

	// tests/contracts/math.algo.ts:32
	// return <uint<256>>(a * b);
	frame_dig -1 // a: uint<256>
	frame_dig -2 // b: uint<256>
	b*
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	retsub

abi_route_u256div:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256div(uint256,uint256)uint256
	callsub u256div
	concat
	log
	int 1
	return

// u256div(uint256,uint256)uint256
u256div:
	proto 2 1

	// tests/contracts/math.algo.ts:36
	// return <uint<256>>(a / b);
	frame_dig -1 // a: uint<256>
	frame_dig -2 // b: uint<256>
	b/
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	retsub

abi_route_u64Return256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64Return256(uint64,uint64)uint256
	callsub u64Return256
	concat
	log
	int 1
	return

// u64Return256(uint64,uint64)uint256
u64Return256:
	proto 2 1

	// tests/contracts/math.algo.ts:40
	// return <uint<256>>(a + b);
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	retsub

abi_route_maxU64:
	// The ABI return prefix
	byte 0x151f7c75

	// execute maxU64()uint64
	callsub maxU64
	itob
	concat
	log
	int 1
	return

// maxU64()uint64
maxU64:
	proto 0 1

	// tests/contracts/math.algo.ts:45
	// return 18_446_744_073_709_551_615;
	int 18_446_744_073_709_551_615
	retsub

abi_route_exponent:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute exponent(uint64,uint64)uint64
	callsub exponent
	itob
	concat
	log
	int 1
	return

// exponent(uint64,uint64)uint64
exponent:
	proto 2 1

	// tests/contracts/math.algo.ts:49
	// return a ** b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	exp
	retsub

abi_route_variableTypeHint:
	// The ABI return prefix
	byte 0x151f7c75

	// y: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert

	// x: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert

	// execute variableTypeHint(uint8,uint8)uint16
	callsub variableTypeHint
	concat
	log
	int 1
	return

// variableTypeHint(uint8,uint8)uint16
variableTypeHint:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:53
	// z = <uint<16>>(x + y)
	frame_dig -1 // x: uint<8>
	btoi
	frame_dig -2 // y: uint<8>
	btoi
	+
	itob
	dup
	bitlen
	int 16
	<=
	assert
	byte 0xFFFF
	b&
	dup
	len
	dup
	int 2
	-
	swap
	substring3
	frame_bury 0 // z: uint16

	// tests/contracts/math.algo.ts:55
	// return z;
	frame_dig 0 // z: uint16

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_uint8plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert

	// a: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert

	// execute uint8plus(uint8,uint8)uint8
	callsub uint8plus
	concat
	log
	int 1
	return

// uint8plus(uint8,uint8)uint8
uint8plus:
	proto 2 1

	// tests/contracts/math.algo.ts:59
	// return a + b;
	frame_dig -1 // a: uint<8>
	btoi
	frame_dig -2 // b: uint<8>
	btoi
	+
	itob
	dup
	bitlen
	int 8
	<=
	assert
	byte 0xFF
	b&
	dup
	len
	dup
	int 1
	-
	swap
	substring3
	retsub

abi_route_uint8exp:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert

	// a: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert

	// execute uint8exp(uint8,uint8)uint8
	callsub uint8exp
	concat
	log
	int 1
	return

// uint8exp(uint8,uint8)uint8
uint8exp:
	proto 2 1

	// tests/contracts/math.algo.ts:63
	// return a ** b;
	frame_dig -1 // a: uint<8>
	btoi
	frame_dig -2 // b: uint<8>
	btoi
	exp
	itob
	dup
	bitlen
	int 8
	<=
	assert
	byte 0xFF
	b&
	dup
	len
	dup
	int 1
	-
	swap
	substring3
	retsub

abi_route_plusEquals:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute plusEquals(uint64,uint64)uint64
	callsub plusEquals
	itob
	concat
	log
	int 1
	return

// plusEquals(uint64,uint64)uint64
plusEquals:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// tests/contracts/math.algo.ts:67
	// x = a
	frame_dig -1 // a: number
	frame_bury 0 // x: uint64

	// tests/contracts/math.algo.ts:69
	// x += b
	frame_dig 0 // x: uint64
	frame_dig -2 // b: number
	+
	frame_bury 0 // x: uint64

	// tests/contracts/math.algo.ts:71
	// return x;
	frame_dig 0 // x: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_plusEqualsFromGlobal:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute plusEqualsFromGlobal(uint64,uint64)uint64
	callsub plusEqualsFromGlobal
	itob
	concat
	log
	int 1
	return

// plusEqualsFromGlobal(uint64,uint64)uint64
plusEqualsFromGlobal:
	proto 2 1

	// tests/contracts/math.algo.ts:75
	// this.gKey.value = a
	byte 0x674b6579 // "gKey"
	frame_dig -1 // a: number
	app_global_put

	// tests/contracts/math.algo.ts:77
	// this.gKey.value += b
	byte 0x674b6579 // "gKey"
	app_global_get
	frame_dig -2 // b: number
	+
	byte 0x674b6579 // "gKey"
	swap
	app_global_put

	// tests/contracts/math.algo.ts:79
	// return this.gKey.value;
	byte 0x674b6579 // "gKey"
	app_global_get
	retsub

abi_route_ufixedLiteralMul:
	// The ABI return prefix
	byte 0x151f7c75

	// execute ufixedLiteralMul()ufixed64x2
	callsub ufixedLiteralMul
	concat
	log
	int 1
	return

// ufixedLiteralMul()ufixed64x2
ufixedLiteralMul:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// tests/contracts/math.algo.ts:83
	// a: ufixed<64, 2> = 12.34
	byte 0x00000000000004d2
	frame_bury 0 // a: ufixed<64, 2>

	// tests/contracts/math.algo.ts:84
	// b: ufixed<64, 2> = 12.34
	byte 0x00000000000004d2
	frame_bury 1 // b: ufixed<64, 2>

	// tests/contracts/math.algo.ts:85
	// c = a * b
	frame_dig 0 // a: ufixed<64, 2>
	btoi
	int 1234
	*
	itob
	btoi
	int 100
	/
	itob
	frame_bury 2 // c: unsafe ufixed64x2

	// tests/contracts/math.algo.ts:87
	// return c;
	frame_dig 2 // c: unsafe ufixed64x2
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

abi_route_ufixedMul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: ufixed64x2
	txna ApplicationArgs 2
	dup
	len
	int 8
	==
	assert

	// a: ufixed64x2
	txna ApplicationArgs 1
	dup
	len
	int 8
	==
	assert

	// execute ufixedMul(ufixed64x2,ufixed64x2)ufixed64x2
	callsub ufixedMul
	concat
	log
	int 1
	return

// ufixedMul(ufixed64x2,ufixed64x2)ufixed64x2
ufixedMul:
	proto 2 1

	// tests/contracts/math.algo.ts:91
	// return a * b;
	frame_dig -1 // a: ufixed<64, 2>
	btoi
	frame_dig -2 // b: ufixed<64, 2>
	btoi
	*
	itob
	btoi
	int 100
	/
	itob
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	retsub

abi_route_BigUfixedMul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: ufixed128x2
	txna ApplicationArgs 2
	dup
	len
	int 16
	==
	assert

	// a: ufixed128x2
	txna ApplicationArgs 1
	dup
	len
	int 16
	==
	assert

	// execute BigUfixedMul(ufixed128x2,ufixed128x2)ufixed128x2
	callsub BigUfixedMul
	concat
	log
	int 1
	return

// BigUfixedMul(ufixed128x2,ufixed128x2)ufixed128x2
BigUfixedMul:
	proto 2 1

	// tests/contracts/math.algo.ts:95
	// return a * b;
	frame_dig -1 // a: ufixed<128, 2>
	frame_dig -2 // b: ufixed<128, 2>
	b*
	byte 0x64
	b/
	dup
	bitlen
	int 128
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	retsub

abi_route_TripleBigUfixedMul:
	// The ABI return prefix
	byte 0x151f7c75

	// c: ufixed128x2
	txna ApplicationArgs 3
	dup
	len
	int 16
	==
	assert

	// b: ufixed128x2
	txna ApplicationArgs 2
	dup
	len
	int 16
	==
	assert

	// a: ufixed128x2
	txna ApplicationArgs 1
	dup
	len
	int 16
	==
	assert

	// execute TripleBigUfixedMul(ufixed128x2,ufixed128x2,ufixed128x2)ufixed128x2
	callsub TripleBigUfixedMul
	concat
	log
	int 1
	return

// TripleBigUfixedMul(ufixed128x2,ufixed128x2,ufixed128x2)ufixed128x2
TripleBigUfixedMul:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// tests/contracts/math.algo.ts:99
	// ab = a * b
	frame_dig -1 // a: ufixed<128, 2>
	frame_dig -2 // b: ufixed<128, 2>
	b*
	byte 0x64
	b/
	frame_bury 0 // ab: unsafe ufixed128x2

	// tests/contracts/math.algo.ts:100
	// abc = ab * c
	frame_dig 0 // ab: unsafe ufixed128x2
	frame_dig -3 // c: ufixed<128, 2>
	b*
	byte 0x64
	b/
	frame_bury 1 // abc: unsafe ufixed128x2

	// tests/contracts/math.algo.ts:101
	// return abc;
	frame_dig 1 // abc: unsafe ufixed128x2
	dup
	bitlen
	int 128
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

abi_route_createApplication:
	int 1
	return

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "u64plus(uint64,uint64)uint64"
	method "u64minus(uint64,uint64)uint64"
	method "u64mul(uint64,uint64)uint64"
	method "u64div(uint64,uint64)uint64"
	method "u256plus(uint256,uint256)uint256"
	method "u256minus(uint256,uint256)uint256"
	method "u256mul(uint256,uint256)uint256"
	method "u256div(uint256,uint256)uint256"
	method "u64Return256(uint64,uint64)uint256"
	method "maxU64()uint64"
	method "exponent(uint64,uint64)uint64"
	method "variableTypeHint(uint8,uint8)uint16"
	method "uint8plus(uint8,uint8)uint8"
	method "uint8exp(uint8,uint8)uint8"
	method "plusEquals(uint64,uint64)uint64"
	method "plusEqualsFromGlobal(uint64,uint64)uint64"
	method "ufixedLiteralMul()ufixed64x2"
	method "ufixedMul(ufixed64x2,ufixed64x2)ufixed64x2"
	method "BigUfixedMul(ufixed128x2,ufixed128x2)ufixed128x2"
	method "TripleBigUfixedMul(ufixed128x2,ufixed128x2,ufixed128x2)ufixed128x2"
	txna ApplicationArgs 0
	match abi_route_u64plus abi_route_u64minus abi_route_u64mul abi_route_u64div abi_route_u256plus abi_route_u256minus abi_route_u256mul abi_route_u256div abi_route_u64Return256 abi_route_maxU64 abi_route_exponent abi_route_variableTypeHint abi_route_uint8plus abi_route_uint8exp abi_route_plusEquals abi_route_plusEqualsFromGlobal abi_route_ufixedLiteralMul abi_route_ufixedMul abi_route_BigUfixedMul abi_route_TripleBigUfixedMul
	err