#pragma version 9

// This TEAL was generated by TEALScript v0.65.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

// u64plus(uint64,uint64)uint64
abi_route_u64plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64plus(uint64,uint64)uint64
	callsub u64plus
	itob
	concat
	log
	int 1
	return

u64plus:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:8
	// return a + b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	retsub

// u64minus(uint64,uint64)uint64
abi_route_u64minus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64minus(uint64,uint64)uint64
	callsub u64minus
	itob
	concat
	log
	int 1
	return

u64minus:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:12
	// return a - b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	-
	retsub

// u64mul(uint64,uint64)uint64
abi_route_u64mul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64mul(uint64,uint64)uint64
	callsub u64mul
	itob
	concat
	log
	int 1
	return

u64mul:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:16
	// return a * b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	*
	retsub

// u64div(uint64,uint64)uint64
abi_route_u64div:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64div(uint64,uint64)uint64
	callsub u64div
	itob
	concat
	log
	int 1
	return

u64div:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:20
	// return a / b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	/
	retsub

// u256plus(uint256,uint256)uint256
abi_route_u256plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256plus(uint256,uint256)uint256
	callsub u256plus
	concat
	log
	int 1
	return

u256plus:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:24
	// return <uint<256>>(a + b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b+
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	retsub

// u256minus(uint256,uint256)uint256
abi_route_u256minus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256minus(uint256,uint256)uint256
	callsub u256minus
	concat
	log
	int 1
	return

u256minus:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:28
	// return <uint<256>>(a - b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b-
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	retsub

// u256mul(uint256,uint256)uint256
abi_route_u256mul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256mul(uint256,uint256)uint256
	callsub u256mul
	concat
	log
	int 1
	return

u256mul:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:32
	// return <uint<256>>(a * b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b*
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	retsub

// u256div(uint256,uint256)uint256
abi_route_u256div:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute u256div(uint256,uint256)uint256
	callsub u256div
	concat
	log
	int 1
	return

u256div:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:36
	// return <uint<256>>(a / b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b/
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	retsub

// u64Return256(uint64,uint64)uint256
abi_route_u64Return256:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64Return256(uint64,uint64)uint256
	callsub u64Return256
	concat
	log
	int 1
	return

u64Return256:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:40
	// return <uint<256>>(a + b);
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	retsub

// maxU64()uint64
abi_route_maxU64:
	// The ABI return prefix
	byte 0x151f7c75

	// execute maxU64()uint64
	callsub maxU64
	itob
	concat
	log
	int 1
	return

maxU64:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 0 1

	// tests/contracts/math.algo.ts:45
	// return 18_446_744_073_709_551_615;
	int 18_446_744_073_709_551_615
	retsub

// exponent(uint64,uint64)uint64
abi_route_exponent:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute exponent(uint64,uint64)uint64
	callsub exponent
	itob
	concat
	log
	int 1
	return

exponent:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:49
	// return a ** b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	exp
	retsub

// variableTypeHint(uint8,uint8)uint16
abi_route_variableTypeHint:
	// The ABI return prefix
	byte 0x151f7c75

	// y: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert

	// x: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert

	// execute variableTypeHint(uint8,uint8)uint16
	callsub variableTypeHint
	concat
	log
	int 1
	return

variableTypeHint:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1; byte 0x; dupn 1

	// tests/contracts/math.algo.ts:53
	// z = <uint<16>>(x + y)
	frame_dig -1 // x: uint8
	btoi
	frame_dig -2 // y: uint8
	btoi
	+
	itob
	dup
	bitlen
	int 16
	<=
	assert
	byte 0xFFFF
	b&
	dup
	len
	dup
	int 2
	-
	swap
	substring3
	frame_bury 1 // z: uint16

	// tests/contracts/math.algo.ts:55
	// return z;
	frame_dig 1 // z: uint16

	// cover the return value and pop all of the stack used for local variables
	cover 2
	popn 2
	retsub

// uint8plus(uint8,uint8)uint8
abi_route_uint8plus:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert

	// a: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert

	// execute uint8plus(uint8,uint8)uint8
	callsub uint8plus
	concat
	log
	int 1
	return

uint8plus:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:59
	// return a + b;
	frame_dig -1 // a: uint8
	btoi
	frame_dig -2 // b: uint8
	btoi
	+
	itob
	dup
	bitlen
	int 8
	<=
	assert
	byte 0xFF
	b&
	dup
	len
	dup
	int 1
	-
	swap
	substring3
	retsub

// uint8exp(uint8,uint8)uint8
abi_route_uint8exp:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert

	// a: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert

	// execute uint8exp(uint8,uint8)uint8
	callsub uint8exp
	concat
	log
	int 1
	return

uint8exp:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:63
	// return a ** b;
	frame_dig -1 // a: uint8
	btoi
	frame_dig -2 // b: uint8
	btoi
	exp
	itob
	dup
	bitlen
	int 8
	<=
	assert
	byte 0xFF
	b&
	dup
	len
	dup
	int 1
	-
	swap
	substring3
	retsub

// plusEquals(uint64,uint64)uint64
abi_route_plusEquals:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute plusEquals(uint64,uint64)uint64
	callsub plusEquals
	itob
	concat
	log
	int 1
	return

plusEquals:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1; byte 0x; dupn 1

	// tests/contracts/math.algo.ts:67
	// x = a
	frame_dig -1 // a: uint64
	frame_bury 1 // x: uint64

	// tests/contracts/math.algo.ts:69
	// x += b
	frame_dig 1 // x: uint64
	frame_dig -2 // b: uint64
	+
	frame_bury 1 // x: uint64

	// tests/contracts/math.algo.ts:71
	// return x;
	frame_dig 1 // x: uint64

	// cover the return value and pop all of the stack used for local variables
	cover 2
	popn 2
	retsub

// plusEqualsFromGlobal(uint64,uint64)uint64
abi_route_plusEqualsFromGlobal:
	// The ABI return prefix
	byte 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute plusEqualsFromGlobal(uint64,uint64)uint64
	callsub plusEqualsFromGlobal
	itob
	concat
	log
	int 1
	return

plusEqualsFromGlobal:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:75
	// this.gKey.value = a
	byte 0x674b6579 // "gKey"
	frame_dig -1 // a: uint64
	app_global_put

	// tests/contracts/math.algo.ts:77
	// this.gKey.value += b
	byte 0x674b6579 // "gKey"
	app_global_get
	frame_dig -2 // b: uint64
	+
	byte 0x674b6579 // "gKey"
	swap
	app_global_put

	// tests/contracts/math.algo.ts:79
	// return this.gKey.value;
	byte 0x674b6579 // "gKey"
	app_global_get
	retsub

// ufixedLiteralMul()ufixed64x2
abi_route_ufixedLiteralMul:
	// The ABI return prefix
	byte 0x151f7c75

	// execute ufixedLiteralMul()ufixed64x2
	callsub ufixedLiteralMul
	concat
	log
	int 1
	return

ufixedLiteralMul:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 0 1; byte 0x; dupn 3

	// tests/contracts/math.algo.ts:83
	// a: ufixed<64, 2> = 12.34
	byte 0x00000000000004d2
	frame_bury 1 // a: ufixed64x2

	// tests/contracts/math.algo.ts:84
	// b: ufixed<64, 2> = 12.34
	byte 0x00000000000004d2
	frame_bury 2 // b: ufixed64x2

	// tests/contracts/math.algo.ts:85
	// c = a * b
	byte 0x0000000000003b7b
	frame_bury 3 // c: unsafe ufixed64x2

	// tests/contracts/math.algo.ts:87
	// return c;
	byte 0x0000000000003b7b // c: unsafe ufixed64x2
	byte 0x0000000000003b7b // c: unsafe ufixed64x2
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3

	// cover the return value and pop all of the stack used for local variables
	cover 4
	popn 4
	retsub

// ufixedMul(ufixed64x2,ufixed64x2)ufixed64x2
abi_route_ufixedMul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: ufixed64x2
	txna ApplicationArgs 2
	dup
	len
	int 8
	==
	assert

	// a: ufixed64x2
	txna ApplicationArgs 1
	dup
	len
	int 8
	==
	assert

	// execute ufixedMul(ufixed64x2,ufixed64x2)ufixed64x2
	callsub ufixedMul
	concat
	log
	int 1
	return

ufixedMul:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:91
	// return a * b;
	frame_dig -1 // a: ufixed64x2
	btoi
	frame_dig -2 // b: ufixed64x2
	btoi
	*
	itob
	btoi
	int 100
	/
	itob
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	retsub

// BigUfixedMul(ufixed128x2,ufixed128x2)ufixed128x2
abi_route_BigUfixedMul:
	// The ABI return prefix
	byte 0x151f7c75

	// b: ufixed128x2
	txna ApplicationArgs 2
	dup
	len
	int 16
	==
	assert

	// a: ufixed128x2
	txna ApplicationArgs 1
	dup
	len
	int 16
	==
	assert

	// execute BigUfixedMul(ufixed128x2,ufixed128x2)ufixed128x2
	callsub BigUfixedMul
	concat
	log
	int 1
	return

BigUfixedMul:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 1

	// tests/contracts/math.algo.ts:95
	// return a * b;
	frame_dig -1 // a: ufixed128x2
	frame_dig -2 // b: ufixed128x2
	b*
	byte 0x64
	b/
	dup
	bitlen
	int 128
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3
	retsub

// TripleBigUfixedMul(ufixed128x2,ufixed128x2,ufixed128x2)ufixed128x2
abi_route_TripleBigUfixedMul:
	// The ABI return prefix
	byte 0x151f7c75

	// c: ufixed128x2
	txna ApplicationArgs 3
	dup
	len
	int 16
	==
	assert

	// b: ufixed128x2
	txna ApplicationArgs 2
	dup
	len
	int 16
	==
	assert

	// a: ufixed128x2
	txna ApplicationArgs 1
	dup
	len
	int 16
	==
	assert

	// execute TripleBigUfixedMul(ufixed128x2,ufixed128x2,ufixed128x2)ufixed128x2
	callsub TripleBigUfixedMul
	concat
	log
	int 1
	return

TripleBigUfixedMul:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 3 1; byte 0x; dupn 2

	// tests/contracts/math.algo.ts:99
	// ab = a * b
	frame_dig -1 // a: ufixed128x2
	frame_dig -2 // b: ufixed128x2
	b*
	byte 0x64
	b/
	frame_bury 1 // ab: unsafe ufixed128x2

	// tests/contracts/math.algo.ts:100
	// abc = ab * c
	frame_dig 1 // ab: unsafe ufixed128x2
	frame_dig -3 // c: ufixed128x2
	b*
	byte 0x64
	b/
	frame_bury 2 // abc: unsafe ufixed128x2

	// tests/contracts/math.algo.ts:101
	// return abc;
	frame_dig 2 // abc: unsafe ufixed128x2
	dup
	bitlen
	int 128
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 16
	-
	swap
	substring3

	// cover the return value and pop all of the stack used for local variables
	cover 3
	popn 3
	retsub

abi_route_createApplication:
	int 1
	return

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "u64plus(uint64,uint64)uint64"
	method "u64minus(uint64,uint64)uint64"
	method "u64mul(uint64,uint64)uint64"
	method "u64div(uint64,uint64)uint64"
	method "u256plus(uint256,uint256)uint256"
	method "u256minus(uint256,uint256)uint256"
	method "u256mul(uint256,uint256)uint256"
	method "u256div(uint256,uint256)uint256"
	method "u64Return256(uint64,uint64)uint256"
	method "maxU64()uint64"
	method "exponent(uint64,uint64)uint64"
	method "variableTypeHint(uint8,uint8)uint16"
	method "uint8plus(uint8,uint8)uint8"
	method "uint8exp(uint8,uint8)uint8"
	method "plusEquals(uint64,uint64)uint64"
	method "plusEqualsFromGlobal(uint64,uint64)uint64"
	method "ufixedLiteralMul()ufixed64x2"
	method "ufixedMul(ufixed64x2,ufixed64x2)ufixed64x2"
	method "BigUfixedMul(ufixed128x2,ufixed128x2)ufixed128x2"
	method "TripleBigUfixedMul(ufixed128x2,ufixed128x2,ufixed128x2)ufixed128x2"
	txna ApplicationArgs 0
	match abi_route_u64plus abi_route_u64minus abi_route_u64mul abi_route_u64div abi_route_u256plus abi_route_u256minus abi_route_u256mul abi_route_u256div abi_route_u64Return256 abi_route_maxU64 abi_route_exponent abi_route_variableTypeHint abi_route_uint8plus abi_route_uint8exp abi_route_plusEquals abi_route_plusEqualsFromGlobal abi_route_ufixedLiteralMul abi_route_ufixedMul abi_route_BigUfixedMul abi_route_TripleBigUfixedMul
	err