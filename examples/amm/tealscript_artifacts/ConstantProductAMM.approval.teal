#pragma version 9

// This TEAL was generated by TEALScript v0.73.5
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication()void
createApplication:
	proto 0 0

	// examples/amm/amm.algo.ts:20
	// this.governor.value = this.txn.sender
	byte 0x67 // "g"
	txn Sender
	app_global_put
	retsub

// doCreatePoolToken(asset,asset)uint64
doCreatePoolToken:
	proto 2 1

	// examples/amm/amm.algo.ts:26
	// return sendAssetCreation({
	//       configAssetName: 'DPT-' + aAsset.unitName + '-' + bAsset.unitName,
	//       configAssetUnitName: 'dpt',
	//       configAssetTotal: TOTAL_SUPPLY,
	//       configAssetDecimals: 3,
	//       configAssetManager: this.app.address,
	//       configAssetReserve: this.app.address,
	//     });
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// examples/amm/amm.algo.ts:27
	// configAssetName: 'DPT-' + aAsset.unitName + '-' + bAsset.unitName
	byte 0x4450542d // "DPT-"
	frame_dig -1 // aAsset: Asset
	asset_params_get AssetUnitName
	assert
	concat
	byte 0x2d // "-"
	concat
	frame_dig -2 // bAsset: Asset
	asset_params_get AssetUnitName
	assert
	concat
	itxn_field ConfigAssetName

	// examples/amm/amm.algo.ts:28
	// configAssetUnitName: 'dpt'
	byte 0x647074 // "dpt"
	itxn_field ConfigAssetUnitName

	// examples/amm/amm.algo.ts:29
	// configAssetTotal: TOTAL_SUPPLY
	int 10_000_000_000
	itxn_field ConfigAssetTotal

	// examples/amm/amm.algo.ts:30
	// configAssetDecimals: 3
	int 3
	itxn_field ConfigAssetDecimals

	// examples/amm/amm.algo.ts:31
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// examples/amm/amm.algo.ts:32
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	retsub

// doAxfer(uint64,asset,account)void
doAxfer:
	proto 3 0

	// examples/amm/amm.algo.ts:37
	// sendAssetTransfer({
	//       assetReceiver: receiver,
	//       xferAsset: asset,
	//       assetAmount: amount,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// examples/amm/amm.algo.ts:38
	// assetReceiver: receiver
	frame_dig -1 // receiver: Account
	itxn_field AssetReceiver

	// examples/amm/amm.algo.ts:39
	// xferAsset: asset
	frame_dig -2 // asset: Asset
	itxn_field XferAsset

	// examples/amm/amm.algo.ts:40
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// doOptIn(asset)void
doOptIn:
	proto 1 0

	// examples/amm/amm.algo.ts:45
	// this.doAxfer(this.app.address, asset, 0)
	int 0
	frame_dig -1 // asset: Asset
	global CurrentApplicationAddress
	callsub doAxfer
	retsub

// tokensToMintIntial(uint64,uint64)uint64
tokensToMintIntial:
	proto 2 1

	// examples/amm/amm.algo.ts:49
	// return sqrt(aAmount * bAmount);
	frame_dig -1 // aAmount: uint64
	frame_dig -2 // bAmount: uint64
	*
	sqrt
	retsub

// tokensToMint(uint64,uint64,uint64,uint64,uint64)uint64
tokensToMint:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// examples/amm/amm.algo.ts:53
	// aRatio = wideRatio([aAmount, SCALE], [aSupply])
	frame_dig -4 // aAmount: uint64
	int 1_000
	mulw
	int 0
	frame_dig -2 // aSupply: uint64
	divmodw
	pop
	pop
	swap
	!
	assert
	frame_bury 0 // aRatio: uint64

	// examples/amm/amm.algo.ts:54
	// bRatio = wideRatio([bAmount, SCALE], [bSupply])
	frame_dig -5 // bAmount: uint64
	int 1_000
	mulw
	int 0
	frame_dig -3 // bSupply: uint64
	divmodw
	pop
	pop
	swap
	!
	assert
	frame_bury 1 // bRatio: uint64

	// examples/amm/amm.algo.ts:56
	// ratio = aRatio < bRatio ? aRatio : bRatio
	frame_dig 0 // aRatio: uint64
	frame_dig 1 // bRatio: uint64
	<
	bz ternary1_false
	frame_dig 0 // aRatio: uint64
	b ternary1_end

ternary1_false:
	frame_dig 1 // bRatio: uint64

ternary1_end:
	frame_bury 2 // ratio: uint64

	// examples/amm/amm.algo.ts:58
	// return wideRatio([ratio, issued], [SCALE]);
	frame_dig 2 // ratio: uint64
	frame_dig -1 // issued: uint64
	mulw
	int 0
	int 1_000
	divmodw
	pop
	pop
	swap
	!
	assert

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// computeRatio()uint64
computeRatio:
	proto 0 1

	// examples/amm/amm.algo.ts:62
	// return wideRatio(
	//       [this.app.address.assetBalance(this.assetA.value), SCALE],
	//       [this.app.address.assetBalance(this.assetB.value)]
	//     );
	global CurrentApplicationAddress
	byte 0x61 // "a"
	app_global_get
	asset_holding_get AssetBalance
	assert
	int 1_000
	mulw
	int 0
	global CurrentApplicationAddress
	byte 0x62 // "b"
	app_global_get
	asset_holding_get AssetBalance
	assert
	divmodw
	pop
	pop
	swap
	!
	assert
	retsub

// tokensToBurn(uint64,uint64,uint64)uint64
tokensToBurn:
	proto 3 1

	// examples/amm/amm.algo.ts:69
	// return wideRatio([supply, amount], [issued]);
	frame_dig -2 // supply: uint64
	frame_dig -3 // amount: uint64
	mulw
	int 0
	frame_dig -1 // issued: uint64
	divmodw
	pop
	pop
	swap
	!
	assert
	retsub

// tokensToSwap(uint64,uint64,uint64)uint64
tokensToSwap:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// examples/amm/amm.algo.ts:73
	// factor = SCALE - FEE
	int 995
	frame_bury 0 // factor: uint64

	// examples/amm/amm.algo.ts:74
	// return wideRatio([inAmount, factor, outSupply], [inSupply * SCALE + inAmount * factor]);
	frame_dig -1 // inAmount: uint64
	frame_dig 0 // factor: uint64
	mulw
	frame_dig -3 // outSupply: uint64
	uncover 2
	dig 1
	*
	cover 2
	mulw
	cover 2
	+
	swap
	int 0
	frame_dig -2 // inSupply: uint64
	int 1_000
	*
	frame_dig -1 // inAmount: uint64
	frame_dig 0 // factor: uint64
	*
	+
	divmodw
	pop
	pop
	swap
	!
	assert

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_set_governor:
	// governor: account
	txna ApplicationArgs 1
	btoi
	txnas Accounts

	// execute set_governor(account)void
	callsub set_governor
	int 1
	return

// set_governor(account)void
set_governor:
	proto 1 0

	// examples/amm/amm.algo.ts:78
	// verifyAppCallTxn(this.txn, { sender: this.governor.value })
	// verify sender
	txn Sender
	byte 0x67 // "g"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:79
	// this.governor.value = governor
	byte 0x67 // "g"
	frame_dig -1 // governor: Account
	app_global_put
	retsub

abi_route_bootstrap:
	// The ABI return prefix
	byte 0x151f7c75

	// bAsset: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// aAsset: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// seed: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute bootstrap(asset,asset,pay)uint64
	callsub bootstrap
	itob
	concat
	log
	int 1
	return

// bootstrap(asset,asset,pay)uint64
bootstrap:
	proto 3 1

	// examples/amm/amm.algo.ts:83
	// verifyAppCallTxn(this.txn, { sender: this.governor.value })
	// verify sender
	txn Sender
	byte 0x67 // "g"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:85
	// assert(globals.groupSize === 2)
	global GroupSize
	int 2
	==
	assert

	// examples/amm/amm.algo.ts:87
	// verifyPayTxn(seed, { receiver: this.app.address, amount: { greaterThanEqualTo: 300_000 } })
	// verify receiver
	frame_dig -1 // seed: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // seed: PayTxn
	gtxns Amount
	int 300_000
	>=
	assert

	// examples/amm/amm.algo.ts:88
	// assert(aAsset < bAsset)
	frame_dig -2 // aAsset: Asset
	frame_dig -3 // bAsset: Asset
	<
	assert

	// examples/amm/amm.algo.ts:90
	// this.assetA.value = aAsset
	byte 0x61 // "a"
	frame_dig -2 // aAsset: Asset
	app_global_put

	// examples/amm/amm.algo.ts:91
	// this.assetB.value = bAsset
	byte 0x62 // "b"
	frame_dig -3 // bAsset: Asset
	app_global_put

	// examples/amm/amm.algo.ts:92
	// this.poolToken.value = this.doCreatePoolToken(aAsset, bAsset)
	byte 0x70 // "p"
	frame_dig -3 // bAsset: Asset
	frame_dig -2 // aAsset: Asset
	callsub doCreatePoolToken
	app_global_put

	// examples/amm/amm.algo.ts:94
	// this.doOptIn(aAsset)
	frame_dig -2 // aAsset: Asset
	callsub doOptIn

	// examples/amm/amm.algo.ts:95
	// this.doOptIn(bAsset)
	frame_dig -3 // bAsset: Asset
	callsub doOptIn

	// examples/amm/amm.algo.ts:97
	// return this.poolToken.value;
	byte 0x70 // "p"
	app_global_get
	retsub

abi_route_mint:
	// bAsset: asset
	txna ApplicationArgs 3
	btoi
	txnas Assets

	// aAsset: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// poolAsset: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// bXfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// aXfer: axfer
	txn GroupIndex
	int 2
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// execute mint(asset,asset,asset,axfer,axfer)void
	callsub mint
	int 1
	return

// mint(asset,asset,asset,axfer,axfer)void
mint:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// well formed mint
	// examples/amm/amm.algo.ts:102
	// assert(aAsset === this.assetA.value)
	frame_dig -4 // aAsset: Asset
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:103
	// assert(bAsset === this.assetB.value)
	frame_dig -5 // bAsset: Asset
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:104
	// assert(poolAsset === this.poolToken.value)
	frame_dig -3 // poolAsset: Asset
	byte 0x70 // "p"
	app_global_get
	==
	assert

	// valid asset A axfer
	// examples/amm/amm.algo.ts:107
	// verifyAssetTransferTxn(aXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: aAsset,
	//     })
	// verify sender
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==
	assert

	// verify assetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>
	assert

	// verify assetReceiver
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify xferAsset
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -4 // aAsset: Asset
	==
	assert

	// valid asset B axfer
	// examples/amm/amm.algo.ts:115
	// verifyAssetTransferTxn(bXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: bAsset,
	//     })
	// verify sender
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==
	assert

	// verify assetAmount
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>
	assert

	// verify assetReceiver
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify xferAsset
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -5 // bAsset: Asset
	==
	assert

	// if0_condition
	// examples/amm/amm.algo.ts:123
	// this.app.address.assetBalance(aAsset) === aXfer.assetAmount &&
	//       this.app.address.assetBalance(bAsset) === bXfer.assetAmount
	global CurrentApplicationAddress
	frame_dig -4 // aAsset: Asset
	asset_holding_get AssetBalance
	assert
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	==
	dup
	bz skip_and0
	global CurrentApplicationAddress
	frame_dig -5 // bAsset: Asset
	asset_holding_get AssetBalance
	assert
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	==
	&&

skip_and0:
	bz if0_else

	// if0_consequent
	// examples/amm/amm.algo.ts:126
	// this.tokensToMintIntial(aXfer.assetAmount, bXfer.assetAmount)
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	callsub tokensToMintIntial
	b if0_end

if0_else:
	// examples/amm/amm.algo.ts:128
	// toMint = this.tokensToMint(
	//         TOTAL_SUPPLY - this.app.address.assetBalance(poolAsset),
	//         this.app.address.assetBalance(aAsset) - aXfer.assetAmount,
	//         this.app.address.assetBalance(bAsset) - bXfer.assetAmount,
	//         aXfer.assetAmount,
	//         bXfer.assetAmount
	//       )
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -5 // bAsset: Asset
	asset_holding_get AssetBalance
	assert
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	global CurrentApplicationAddress
	frame_dig -4 // aAsset: Asset
	asset_holding_get AssetBalance
	assert
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	int 10_000_000_000
	global CurrentApplicationAddress
	frame_dig -3 // poolAsset: Asset
	asset_holding_get AssetBalance
	assert
	-
	callsub tokensToMint
	frame_bury 0 // toMint: uint64

	// examples/amm/amm.algo.ts:136
	// assert(toMint > 0)
	frame_dig 0 // toMint: uint64
	int 0
	>
	assert

	// examples/amm/amm.algo.ts:138
	// this.doAxfer(this.txn.sender, poolAsset, toMint)
	frame_dig 0 // toMint: uint64
	frame_dig -3 // poolAsset: Asset
	txn Sender
	callsub doAxfer

if0_end:
	retsub

abi_route_burn:
	// bAsset: asset
	txna ApplicationArgs 3
	btoi
	txnas Assets

	// aAsset: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// poolAsset: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// poolXfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// execute burn(asset,asset,asset,axfer)void
	callsub burn
	int 1
	return

// burn(asset,asset,asset,axfer)void
burn:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// well formed burn
	// examples/amm/amm.algo.ts:144
	// assert(poolAsset === this.poolToken.value)
	frame_dig -2 // poolAsset: Asset
	byte 0x70 // "p"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:145
	// assert(aAsset === this.assetA.value)
	frame_dig -3 // aAsset: Asset
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:146
	// assert(bAsset === this.assetB.value)
	frame_dig -4 // bAsset: Asset
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// valid pool axfer
	// examples/amm/amm.algo.ts:149
	// verifyAssetTransferTxn(poolXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: poolAsset,
	//     })
	// verify sender
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==
	assert

	// verify assetAmount
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>
	assert

	// verify assetReceiver
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify xferAsset
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // poolAsset: Asset
	==
	assert

	// examples/amm/amm.algo.ts:156
	// issued = TOTAL_SUPPLY - (this.app.address.assetBalance(poolAsset) - poolXfer.assetAmount)
	int 10_000_000_000
	global CurrentApplicationAddress
	frame_dig -2 // poolAsset: Asset
	asset_holding_get AssetBalance
	assert
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	-
	frame_bury 0 // issued: uint64

	// examples/amm/amm.algo.ts:158
	// aAmt = this.tokensToBurn(issued, this.app.address.assetBalance(aAsset), poolXfer.assetAmount)
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -3 // aAsset: Asset
	asset_holding_get AssetBalance
	assert
	frame_dig 0 // issued: uint64
	callsub tokensToBurn
	frame_bury 1 // aAmt: uint64

	// examples/amm/amm.algo.ts:160
	// bAmt = this.tokensToBurn(issued, this.app.address.assetBalance(bAsset), poolXfer.assetAmount)
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -4 // bAsset: Asset
	asset_holding_get AssetBalance
	assert
	frame_dig 0 // issued: uint64
	callsub tokensToBurn
	frame_bury 2 // bAmt: uint64

	// examples/amm/amm.algo.ts:162
	// this.doAxfer(this.txn.sender, aAsset, aAmt)
	frame_dig 1 // aAmt: uint64
	frame_dig -3 // aAsset: Asset
	txn Sender
	callsub doAxfer

	// examples/amm/amm.algo.ts:163
	// this.doAxfer(this.txn.sender, bAsset, bAmt)
	frame_dig 2 // bAmt: uint64
	frame_dig -4 // bAsset: Asset
	txn Sender
	callsub doAxfer

	// examples/amm/amm.algo.ts:165
	// this.ratio.value = this.computeRatio()
	byte 0x72 // "r"
	callsub computeRatio
	app_global_put
	retsub

abi_route_swap:
	// bAsset: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// aAsset: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// swapXfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// execute swap(asset,asset,axfer)void
	callsub swap
	int 1
	return

// swap(asset,asset,axfer)void
swap:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// well formed swap
	// examples/amm/amm.algo.ts:170
	// assert(aAsset === this.assetA.value)
	frame_dig -2 // aAsset: Asset
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:171
	// assert(bAsset === this.assetB.value)
	frame_dig -3 // bAsset: Asset
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:173
	// verifyAssetTransferTxn(swapXfer, {
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       sender: this.txn.sender,
	//       xferAsset: { includedIn: [aAsset, bAsset] },
	//     })
	// verify assetAmount
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>
	assert

	// verify assetReceiver
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// verify sender
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==
	assert

	// verify xferAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // aAsset: Asset
	==
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // bAsset: Asset
	==
	||
	assert

	// examples/amm/amm.algo.ts:180
	// outId = swapXfer.xferAsset === aAsset ? aAsset : bAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // aAsset: Asset
	==
	bz ternary3_false
	frame_dig -2 // aAsset: Asset
	b ternary3_end

ternary3_false:
	frame_dig -3 // bAsset: Asset

ternary3_end:
	frame_bury 0 // outId: asset

	// examples/amm/amm.algo.ts:182
	// inId = swapXfer.xferAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_bury 1 // inId: asset

	// examples/amm/amm.algo.ts:184
	// toSwap = this.tokensToSwap(
	//       swapXfer.assetAmount,
	//       this.app.address.assetBalance(inId) - swapXfer.assetAmount,
	//       this.app.address.assetBalance(outId)
	//     )
	global CurrentApplicationAddress
	frame_dig 0 // outId: asset
	asset_holding_get AssetBalance
	assert
	global CurrentApplicationAddress
	frame_dig 1 // inId: asset
	asset_holding_get AssetBalance
	assert
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	callsub tokensToSwap
	frame_bury 2 // toSwap: uint64

	// examples/amm/amm.algo.ts:190
	// assert(toSwap > 0)
	frame_dig 2 // toSwap: uint64
	int 0
	>
	assert

	// examples/amm/amm.algo.ts:192
	// this.doAxfer(this.txn.sender, outId, toSwap)
	frame_dig 2 // toSwap: uint64
	frame_dig 0 // outId: asset
	txn Sender
	callsub doAxfer

	// examples/amm/amm.algo.ts:194
	// this.ratio.value = this.computeRatio()
	byte 0x72 // "r"
	callsub computeRatio
	app_global_put
	retsub

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "set_governor(account)void"
	method "bootstrap(pay,asset,asset)uint64"
	method "mint(axfer,axfer,asset,asset,asset)void"
	method "burn(axfer,asset,asset,asset)void"
	method "swap(axfer,asset,asset)void"
	txna ApplicationArgs 0
	match abi_route_set_governor abi_route_bootstrap abi_route_mint abi_route_burn abi_route_swap
	err